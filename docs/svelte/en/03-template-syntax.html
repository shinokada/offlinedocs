<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Template syntax</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="template-syntax" class="level1">
      <h1>Template syntax</h1>
      <section id="tags" class="level2">
        <h2>Tags</h2>
        <p>A lowercase tag, like <code>&#x3C;div></code>, denotes a regular HTML element. A capitalised tag, such as <code>&#x3C;Widget></code> or <code>&#x3C;Namespace.Widget></code>, indicates a <em>component</em>.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;script>
	import Widget from './Widget.svelte';
&#x3C;/script>

&#x3C;div>
	&#x3C;Widget/>
&#x3C;/div></code></pre>
      </section>
      <section id="attributes-and-props" class="level2">
        <h2>Attributes and props</h2>
        <p>By default, attributes work exactly like their HTML counterparts.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;div class="foo">
	&#x3C;button disabled>can't touch this&#x3C;/button>
&#x3C;/div></code></pre>
        <p>As in HTML, values may be unquoted.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;input type=checkbox></code></pre>
        <p>Attribute values can contain JavaScript expressions.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;a href="page/{p}">page {p}&#x3C;/a></code></pre>
        <p>Or they can <em>be</em> JavaScript expressions.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;button disabled={!clickable}>...&#x3C;/button></code></pre>
        <p>Boolean attributes are included on the element if their value is <a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">truthy</a> and excluded if it's <a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">falsy</a>.</p>
        <p>All other attributes are included unless their value is <a href="https://developer.mozilla.org/en-US/docs/Glossary/Nullish">nullish</a> (<code>null</code> or <code>undefined</code>).</p>
        <pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>input</span> <span class="token attr-name">required</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>{false}</span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>This input field is not required<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>div</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>{null}</span><span class="token punctuation">></span></span>This div has no title attribute<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>div</span><span class="token punctuation">></span></span></code></pre>
        <p>An expression might include characters that would cause syntax highlighting to fail in regular HTML, so quoting the value is permitted. The quotes do not affect how the value is parsed:</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;button disabled="{number !== 42}">...&#x3C;/button></code></pre>
        <p>When the attribute name and value match (<code>name={name}</code>), they can be replaced with <code>{name}</code>.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;!-- These are equivalent -->
&#x3C;button disabled={disabled}>...&#x3C;/button>
&#x3C;button {disabled}>...&#x3C;/button></code></pre>
        <p>By convention, values passed to components are referred to as <em>properties</em> or <em>props</em> rather than <em>attributes</em>, which are a feature of the DOM.</p>
        <p>As with elements, <code>name={name}</code> can be replaced with the <code>{name}</code> shorthand.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;Widget foo={bar} answer={42} text="hello"/></code></pre>
        <p><em>Spread attributes</em> allow many attributes or properties to be passed to an element or component at once.</p>
        <p>An element or component can have multiple spread attributes, interspersed with regular ones.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;Widget {...things}/></code></pre>
        <p><em><code>$$props</code></em> references all props that are passed to a component, including ones that are not declared with <code>export</code>. It is not generally recommended, as it is difficult for Svelte to optimise. But it can be useful in rare cases – for example, when you don't know at compile time what props might be passed to a component.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;Widget {...$$props}/></code></pre>
        <p><em><code>$$restProps</code></em> contains only the props which are <em>not</em> declared with <code>export</code>. It can be used to pass down other unknown attributes to an element in a component. It shares the same optimisation problems as <em><code>$$props</code></em>, and is likewise not recommended.</p>
        <pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>input</span> <span class="token attr-name">{...$$restProps}</span><span class="token punctuation">></span></span></code></pre>
        <blockquote>
          <p>The <code>value</code> attribute of an <code>input</code> element or its children <code>option</code> elements must not be set with spread attributes when using <code>bind:group</code> or <code>bind:checked</code>. Svelte needs to be able to see the element's <code>value</code> directly in the markup in these cases so that it can link it to the bound variable.</p>
        </blockquote>
      </section>
      <section id="text-expressions" class="level2">
        <h2>Text expressions</h2>
        <pre class="language-sv"><code class="language-sv">{expression}</code></pre>
        <p>Text can also contain JavaScript expressions:</p>
        <blockquote>
          <p>If you're using a regular expression (<code>RegExp</code>) <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#literal_notation_and_constructor">literal notation</a>, you'll need to wrap it in parentheses.</p>
        </blockquote>
        <pre class="language-sv"><code class="language-sv">&#x3C;h1>Hello {name}!&#x3C;/h1>
&#x3C;p>{a} + {b} = {a + b}.&#x3C;/p>

&#x3C;div>{(/^[A-Za-z ]+$/).test(value) ? x : y}&#x3C;/div></code></pre>
      </section>
      <section id="comments" class="level2">
        <h2>Comments</h2>
        <p>You can use HTML comments inside components.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;!-- this is a comment! -->
&#x3C;h1>Hello world&#x3C;/h1></code></pre>
        <p>Comments beginning with <code>svelte-ignore</code> disable warnings for the next block of markup. Usually, these are accessibility warnings; make sure that you're disabling them for a good reason.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;!-- svelte-ignore a11y-autofocus -->
&#x3C;input bind:value={name} autofocus></code></pre>
      </section>
      <section id="if-" class="level2">
        <h2>{#if ...}</h2>
        <pre class="language-sv"><code class="language-sv">{#if expression}...{/if}</code></pre>
        <pre class="language-sv"><code class="language-sv">{#if expression}...{:else if expression}...{/if}</code></pre>
        <pre class="language-sv"><code class="language-sv">{#if expression}...{:else}...{/if}</code></pre>
        <p>Content that is conditionally rendered can be wrapped in an if block.</p>
        <pre class="language-sv"><code class="language-sv">{#if answer === 42}
	&#x3C;p>what was the question?&#x3C;/p>
{/if}</code></pre>
        <p>Additional conditions can be added with <code>{:else if expression}</code>, optionally ending in an <code>{:else}</code> clause.</p>
        <pre class="language-sv"><code class="language-sv">{#if porridge.temperature > 100}
	&#x3C;p>too hot!&#x3C;/p>
{:else if 80 > porridge.temperature}
	&#x3C;p>too cold!&#x3C;/p>
{:else}
	&#x3C;p>just right!&#x3C;/p>
{/if}</code></pre>
      </section>
      <section id="each-" class="level2">
        <h2>{#each ...}</h2>
        <pre class="language-sv"><code class="language-sv">{#each expression as name}...{/each}</code></pre>
        <pre class="language-sv"><code class="language-sv">{#each expression as name, index}...{/each}</code></pre>
        <pre class="language-sv"><code class="language-sv">{#each expression as name (key)}...{/each}</code></pre>
        <pre class="language-sv"><code class="language-sv">{#each expression as name, index (key)}...{/each}</code></pre>
        <pre class="language-sv"><code class="language-sv">{#each expression as name}...{:else}...{/each}</code></pre>
        <p>Iterating over lists of values can be done with an each block.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;h1>Shopping list&#x3C;/h1>
&#x3C;ul>
	{#each items as item}
		&#x3C;li>{item.name} x {item.qty}&#x3C;/li>
	{/each}
&#x3C;/ul></code></pre>
        <p>You can use each blocks to iterate over any array or array-like value — that is, any object with a <code>length</code> property.</p>
        <p>An each block can also specify an <em>index</em>, equivalent to the second argument in an <code>array.map(...)</code> callback:</p>
        <pre class="language-sv"><code class="language-sv">{#each items as item, i}
	&#x3C;li>{i + 1}: {item.name} x {item.qty}&#x3C;/li>
{/each}</code></pre>
        <p>If a <em>key</em> expression is provided — which must uniquely identify each list item — Svelte will use it to diff the list when data changes, rather than adding or removing items at the end. The key can be any object, but strings and numbers are recommended since they allow identity to persist when the objects themselves change.</p>
        <pre class="language-sv"><code class="language-sv">{#each items as item (item.id)}
	&#x3C;li>{item.name} x {item.qty}&#x3C;/li>
{/each}

&#x3C;!-- or with additional index value -->
{#each items as item, i (item.id)}
	&#x3C;li>{i + 1}: {item.name} x {item.qty}&#x3C;/li>
{/each}</code></pre>
        <p>You can freely use destructuring and rest patterns in each blocks.</p>
        <pre class="language-sv"><code class="language-sv">{#each items as { id, name, qty }, i (id)}
	&#x3C;li>{i + 1}: {name} x {qty}&#x3C;/li>
{/each}

{#each objects as { id, ...rest }}
	&#x3C;li>&#x3C;span>{id}&#x3C;/span>&#x3C;MyComponent {...rest}/>&#x3C;/li>
{/each}

{#each items as [id, ...rest]}
	&#x3C;li>&#x3C;span>{id}&#x3C;/span>&#x3C;MyComponent values={rest}/>&#x3C;/li>
{/each}</code></pre>
        <p>An each block can also have an <code>{:else}</code> clause, which is rendered if the list is empty.</p>
        <pre class="language-sv"><code class="language-sv">{#each todos as todo}
	&#x3C;p>{todo.text}&#x3C;/p>
{:else}
	&#x3C;p>No tasks today!&#x3C;/p>
{/each}</code></pre>
      </section>
      <section id="await-" class="level2">
        <h2>{#await ...}</h2>
        <pre class="language-sv"><code class="language-sv">{#await expression}...{:then name}...{:catch name}...{/await}</code></pre>
        <pre class="language-sv"><code class="language-sv">{#await expression}...{:then name}...{/await}</code></pre>
        <pre class="language-sv"><code class="language-sv">{#await expression then name}...{/await}</code></pre>
        <pre class="language-sv"><code class="language-sv">{#await expression catch name}...{/await}</code></pre>
        <p>Await blocks allow you to branch on the three possible states of a Promise — pending, fulfilled or rejected. In SSR mode, only the pending state will be rendered on the server.</p>
        <pre class="language-sv"><code class="language-sv">{#await promise}
	&#x3C;!-- promise is pending -->
	&#x3C;p>waiting for the promise to resolve...&#x3C;/p>
{:then value}
	&#x3C;!-- promise was fulfilled -->
	&#x3C;p>The value is {value}&#x3C;/p>
{:catch error}
	&#x3C;!-- promise was rejected -->
	&#x3C;p>Something went wrong: {error.message}&#x3C;/p>
{/await}</code></pre>
        <p>The <code>catch</code> block can be omitted if you don't need to render anything when the promise rejects (or no error is possible).</p>
        <pre class="language-sv"><code class="language-sv">{#await promise}
	&#x3C;!-- promise is pending -->
	&#x3C;p>waiting for the promise to resolve...&#x3C;/p>
{:then value}
	&#x3C;!-- promise was fulfilled -->
	&#x3C;p>The value is {value}&#x3C;/p>
{/await}</code></pre>
        <p>If you don't care about the pending state, you can also omit the initial block.</p>
        <pre class="language-sv"><code class="language-sv">{#await promise then value}
	&#x3C;p>The value is {value}&#x3C;/p>
{/await}</code></pre>
        <p>Similarly, if you only want to show the error state, you can omit the <code>then</code> block.</p>
        <pre class="language-sv"><code class="language-sv">{#await promise catch error}
	&#x3C;p>The error is {error}&#x3C;/p>
{/await}</code></pre>
      </section>
      <section id="key-" class="level2">
        <h2>{#key ...}</h2>
        <pre class="language-sv"><code class="language-sv">{#key expression}...{/key}</code></pre>
        <p>Key blocks destroy and recreate their contents when the value of an expression changes.</p>
        <p>This is useful if you want an element to play its transition whenever a value changes.</p>
        <pre class="language-sv"><code class="language-sv">{#key value}
	&#x3C;div transition:fade>{value}&#x3C;/div>
{/key}</code></pre>
        <p>When used around components, this will cause them to be reinstantiated and reinitialised.</p>
        <pre class="language-sv"><code class="language-sv">{#key value}
	&#x3C;Component />
{/key}</code></pre>
      </section>
      <section id="html-" class="level2">
        <h2>{@html ...}</h2>
        <pre class="language-sv"><code class="language-sv">{@html expression}</code></pre>
        <p>In a text expression, characters like <code>&#x3C;</code> and <code>></code> are escaped; however, with HTML expressions, they're not.</p>
        <p>The expression should be valid standalone HTML — <code>{@html "&#x3C;div>"}content{@html "&#x3C;/div>"}</code> will <em>not</em> work, because <code>&#x3C;/div></code> is not valid HTML. It also will <em>not</em> compile Svelte code.</p>
        <blockquote>
          <p>Svelte does not sanitize expressions before injecting HTML. If the data comes from an untrusted source, you must sanitize it, or you are exposing your users to an XSS vulnerability.</p>
        </blockquote>
        <pre class="language-sv"><code class="language-sv">&#x3C;div class="blog-post">
	&#x3C;h1>{post.title}&#x3C;/h1>
	{@html post.content}
&#x3C;/div></code></pre>
      </section>
      <section id="debug-" class="level2">
        <h2>{@debug ...}</h2>
        <pre class="language-sv"><code class="language-sv">{@debug}</code></pre>
        <pre class="language-sv"><code class="language-sv">{@debug var1, var2, ..., varN}</code></pre>
        <p>The <code>{@debug ...}</code> tag offers an alternative to <code>console.log(...)</code>. It logs the values of specific variables whenever they change, and pauses code execution if you have devtools open.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;script>
	let user = {
		firstname: 'Ada',
		lastname: 'Lovelace'
	};
&#x3C;/script>

{@debug user}

&#x3C;h1>Hello {user.firstname}!&#x3C;/h1></code></pre>
        <p><code>{@debug ...}</code> accepts a comma-separated list of variable names (not arbitrary expressions).</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;!-- Compiles -->
{@debug user}
{@debug user1, user2, user3}

&#x3C;!-- WON'T compile -->
{@debug user.firstname}
{@debug myArray[0]}
{@debug !isReady}
{@debug typeof user === 'object'}</code></pre>
        <p>The <code>{@debug}</code> tag without any arguments will insert a <code>debugger</code> statement that gets triggered when <em>any</em> state changes, as opposed to the specified variables.</p>
      </section>
      <section id="const-" class="level2">
        <h2>{@const ...}</h2>
        <pre class="language-sv"><code class="language-sv">{@const assignment}</code></pre>
        <p>The <code>{@const ...}</code> tag defines a local constant.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;script>
	export let boxes;
&#x3C;/script>

{#each boxes as box}
	{@const area = box.width * box.height}
	{box.width} * {box.height} = {area}
{/each}</code></pre>
        <p><code>{@const}</code> is only allowed as direct child of <code>{#if}</code>, <code>{:else if}</code>, <code>{:else}</code>, <code>{#each}</code>, <code>{:then}</code>, <code>{:catch}</code>, <code>&#x3C;Component /></code> or <code>&#x3C;svelte:fragment /></code>.</p>
      </section>
      <section id="element-directives" class="level2">
        <h2>Element directives</h2>
        <p>As well as attributes, elements can have <em>directives</em>, which control the element's behaviour in some way.</p>
        <section id="oneventname" class="level3">
          <h3>on:<em>eventname</em></h3>
          <pre class="language-sv"><code class="language-sv">on:eventname={handler}</code></pre>
          <pre class="language-sv"><code class="language-sv">on:eventname|modifiers={handler}</code></pre>
          <p>Use the <code>on:</code> directive to listen to DOM events.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;script>
	let count = 0;

	function handleClick(event) {
		count += 1;
	}
&#x3C;/script>

&#x3C;button on:click={handleClick}>
	count: {count}
&#x3C;/button></code></pre>
          <p>Handlers can be declared inline with no performance penalty. As with attributes, directive values may be quoted for the sake of syntax highlighters.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;button on:click="{() => count += 1}">
	count: {count}
&#x3C;/button></code></pre>
          <p>Add <em>modifiers</em> to DOM events with the <code>|</code> character.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;form on:submit|preventDefault={handleSubmit}>
	&#x3C;!-- the `submit` event's default is prevented,
	     so the page won't reload -->
&#x3C;/form></code></pre>
          <p>The following modifiers are available:</p>
          <ul>
            <li><code>preventDefault</code> — calls <code>event.preventDefault()</code> before running the handler</li>
            <li><code>stopPropagation</code> — calls <code>event.stopPropagation()</code>, preventing the event reaching the next element</li>
            <li><code>passive</code> — improves scrolling performance on touch/wheel events (Svelte will add it automatically where it's safe to do so)</li>
            <li><code>nonpassive</code> — explicitly set <code>passive: false</code></li>
            <li><code>capture</code> — fires the handler during the <em>capture</em> phase instead of the <em>bubbling</em> phase</li>
            <li><code>once</code> — remove the handler after the first time it runs</li>
            <li><code>self</code> — only trigger handler if <code>event.target</code> is the element itself</li>
            <li><code>trusted</code> — only trigger handler if <code>event.isTrusted</code> is <code>true</code>. I.e. if the event is triggered by a user action.</li>
          </ul>
          <p>Modifiers can be chained together, e.g. <code>on:click|once|capture={...}</code>.</p>
          <p>If the <code>on:</code> directive is used without a value, the component will <em>forward</em> the event, meaning that a consumer of the component can listen for it.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;button on:click>
	The component itself will emit the click event
&#x3C;/button></code></pre>
          <p>It's possible to have multiple event listeners for the same event:</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;script>
	let counter = 0;
	function increment() {
		counter = counter + 1;
	}

	function track(event) {
		trackEvent(event)
	}
&#x3C;/script>

&#x3C;button on:click={increment} on:click={track}>Click me!&#x3C;/button></code></pre>
        </section>
        <section id="bindproperty" class="level3">
          <h3>bind:<em>property</em></h3>
          <pre class="language-sv"><code class="language-sv">bind:property={variable}</code></pre>
          <p>Data ordinarily flows down, from parent to child. The <code>bind:</code> directive allows data to flow the other way, from child to parent. Most bindings are specific to particular elements.</p>
          <p>The simplest bindings reflect the value of a property, such as <code>input.value</code>.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;input bind:value={name}>
&#x3C;textarea bind:value={text}>&#x3C;/textarea>

&#x3C;input type="checkbox" bind:checked={yes}></code></pre>
          <p>If the name matches the value, you can use shorthand.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;!-- These are equivalent -->
&#x3C;input bind:value={value}>
&#x3C;input bind:value></code></pre>
          <p>Numeric input values are coerced; even though <code>input.value</code> is a string as far as the DOM is concerned, Svelte will treat it as a number. If the input is empty or invalid (in the case of <code>type="number"</code>), the value is <code>undefined</code>.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;input type="number" bind:value={num}>
&#x3C;input type="range" bind:value={num}></code></pre>
          <p>On <code>&#x3C;input></code> elements with <code>type="file"</code>, you can use <code>bind:files</code> to get the <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileList"><code>FileList</code> of selected files</a>. It is readonly.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;label for="avatar">Upload a picture:&#x3C;/label>
&#x3C;input
	accept="image/png, image/jpeg"
	bind:files
	id="avatar"
	name="avatar"
	type="file"
/></code></pre>
          <p>If you're using <code>bind:</code> directives together with <code>on:</code> directives, the order that they're defined in affects the value of the bound variable when the event handler is called.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;script>
	let value = 'Hello World';
&#x3C;/script>

&#x3C;input
	on:input="{() => console.log('Old value:', value)}"
	bind:value
	on:input="{() => console.log('New value:', value)}"
/></code></pre>
          <p>Here we were binding to the value of a text input, which uses the <code>input</code> event. Bindings on other elements may use different events such as <code>change</code>.</p>
          <section id="binding-select-value" class="level4">
            <h4>Binding <code>&#x3C;select></code> value</h4>
            <p>A <code>&#x3C;select></code> value binding corresponds to the <code>value</code> property on the selected <code>&#x3C;option></code>, which can be any value (not just strings, as is normally the case in the DOM).</p>
            <pre class="language-sv"><code class="language-sv">&#x3C;select bind:value={selected}>
	&#x3C;option value={a}>a&#x3C;/option>
	&#x3C;option value={b}>b&#x3C;/option>
	&#x3C;option value={c}>c&#x3C;/option>
&#x3C;/select></code></pre>
            <p>A <code>&#x3C;select multiple></code> element behaves similarly to a checkbox group.</p>
            <pre class="language-sv"><code class="language-sv">&#x3C;select multiple bind:value={fillings}>
	&#x3C;option value="Rice">Rice&#x3C;/option>
	&#x3C;option value="Beans">Beans&#x3C;/option>
	&#x3C;option value="Cheese">Cheese&#x3C;/option>
	&#x3C;option value="Guac (extra)">Guac (extra)&#x3C;/option>
&#x3C;/select></code></pre>
            <p>When the value of an <code>&#x3C;option></code> matches its text content, the attribute can be omitted.</p>
            <pre class="language-sv"><code class="language-sv">&#x3C;select multiple bind:value={fillings}>
	&#x3C;option>Rice&#x3C;/option>
	&#x3C;option>Beans&#x3C;/option>
	&#x3C;option>Cheese&#x3C;/option>
	&#x3C;option>Guac (extra)&#x3C;/option>
&#x3C;/select></code></pre>
            <p>Elements with the <code>contenteditable</code> attribute support <code>innerHTML</code> and <code>textContent</code> bindings.</p>
            <pre class="language-sv"><code class="language-sv">&#x3C;div contenteditable="true" bind:innerHTML={html}>&#x3C;/div></code></pre>
            <p><code>&#x3C;details></code> elements support binding to the <code>open</code> property.</p>
            <pre class="language-sv"><code class="language-sv">&#x3C;details bind:open={isOpen}>
	&#x3C;summary>Details&#x3C;/summary>
	&#x3C;p>
		Something small enough to escape casual notice.
	&#x3C;/p>
&#x3C;/details></code></pre>
          </section>
          <section id="media-element-bindings" class="level4">
            <h4>Media element bindings</h4>
            <p>Media elements (<code>&#x3C;audio></code> and <code>&#x3C;video></code>) have their own set of bindings — six <em>readonly</em> ones...</p>
            <ul>
              <li><code>duration</code> (readonly) — the total duration of the video, in seconds</li>
              <li><code>buffered</code> (readonly) — an array of <code>{start, end}</code> objects</li>
              <li><code>played</code> (readonly) — ditto</li>
              <li><code>seekable</code> (readonly) — ditto</li>
              <li><code>seeking</code> (readonly) — boolean</li>
              <li><code>ended</code> (readonly) — boolean</li>
            </ul>
            <p>...and five <em>two-way</em> bindings:</p>
            <ul>
              <li><code>currentTime</code> — the current playback time in the video, in seconds</li>
              <li><code>playbackRate</code> — how fast or slow to play the video, where 1 is 'normal'</li>
              <li><code>paused</code> — this one should be self-explanatory</li>
              <li><code>volume</code> — a value between 0 and 1</li>
              <li><code>muted</code> — a boolean value indicating whether the player is muted</li>
            </ul>
            <p>Videos additionally have readonly <code>videoWidth</code> and <code>videoHeight</code> bindings.</p>
            <pre class="language-sv"><code class="language-sv">&#x3C;video
	src={clip}
	bind:duration
	bind:buffered
	bind:played
	bind:seekable
	bind:seeking
	bind:ended
	bind:currentTime
	bind:playbackRate
	bind:paused
	bind:volume
	bind:muted
	bind:videoWidth
	bind:videoHeight
>&#x3C;/video></code></pre>
          </section>
          <section id="block-level-element-bindings" class="level4">
            <h4>Block-level element bindings</h4>
            <p>Block-level elements have 4 read-only bindings, measured using a technique similar to <a href="http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/">this one</a>:</p>
            <ul>
              <li><code>clientWidth</code></li>
              <li><code>clientHeight</code></li>
              <li><code>offsetWidth</code></li>
              <li><code>offsetHeight</code></li>
            </ul>
            <pre class="language-sv"><code class="language-sv">&#x3C;div
	bind:offsetWidth={width}
	bind:offsetHeight={height}
>
	&#x3C;Chart {width} {height}/>
&#x3C;/div></code></pre>
          </section>
        </section>
        <section id="bindgroup" class="level3">
          <h3>bind:group</h3>
          <pre class="language-sv"><code class="language-sv">bind:group={variable}</code></pre>
          <p>Inputs that work together can use <code>bind:group</code>.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;script>
	let tortilla = 'Plain';
	let fillings = [];
&#x3C;/script>

&#x3C;!-- grouped radio inputs are mutually exclusive -->
&#x3C;input type="radio" bind:group={tortilla} value="Plain">
&#x3C;input type="radio" bind:group={tortilla} value="Whole wheat">
&#x3C;input type="radio" bind:group={tortilla} value="Spinach">

&#x3C;!-- grouped checkbox inputs populate an array -->
&#x3C;input type="checkbox" bind:group={fillings} value="Rice">
&#x3C;input type="checkbox" bind:group={fillings} value="Beans">
&#x3C;input type="checkbox" bind:group={fillings} value="Cheese">
&#x3C;input type="checkbox" bind:group={fillings} value="Guac (extra)"></code></pre>
        </section>
        <section id="bindthis" class="level3">
          <h3>bind:this</h3>
          <pre class="language-sv"><code class="language-sv">bind:this={dom_node}</code></pre>
          <p>To get a reference to a DOM node, use <code>bind:this</code>.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;script>
	import { onMount } from 'svelte';

	let canvasElement;

	onMount(() => {
		const ctx = canvasElement.getContext('2d');
		drawStuff(ctx);
	});
&#x3C;/script>

&#x3C;canvas bind:this={canvasElement}>&#x3C;/canvas></code></pre>
        </section>
        <section id="classname" class="level3">
          <h3>class:<em>name</em></h3>
          <pre class="language-sv"><code class="language-sv">class:name={value}</code></pre>
          <pre class="language-sv"><code class="language-sv">class:name</code></pre>
          <p>A <code>class:</code> directive provides a shorter way of toggling a class on an element.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;!-- These are equivalent -->
&#x3C;div class="{active ? 'active' : ''}">...&#x3C;/div>
&#x3C;div class:active={active}>...&#x3C;/div>

&#x3C;!-- Shorthand, for when name and value match -->
&#x3C;div class:active>...&#x3C;/div>

&#x3C;!-- Multiple class toggles can be included -->
&#x3C;div class:active class:inactive={!active} class:isAdmin>...&#x3C;/div></code></pre>
        </section>
        <section id="styleproperty" class="level3">
          <h3>style:<em>property</em></h3>
          <pre class="language-sv"><code class="language-sv">style:property={value}</code></pre>
          <pre class="language-sv"><code class="language-sv">style:property="value"</code></pre>
          <pre class="language-sv"><code class="language-sv">style:property</code></pre>
          <p>The <code>style:</code> directive provides a shorthand for setting multiple styles on an element.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;!-- These are equivalent -->
&#x3C;div style:color="red">...&#x3C;/div>
&#x3C;div style="color: red;">...&#x3C;/div>

&#x3C;!-- Variables can be used -->
&#x3C;div style:color={myColor}>...&#x3C;/div>

&#x3C;!-- Shorthand, for when property and variable name match -->
&#x3C;div style:color>...&#x3C;/div>

&#x3C;!-- Multiple styles can be included -->
&#x3C;div style:color style:width="12rem" style:background-color={darkMode ? "black" : "white"}>...&#x3C;/div>

&#x3C;!-- Styles can be marked as important -->
&#x3C;div style:color|important="red">...&#x3C;/div></code></pre>
          <p>When <code>style:</code> directives are combined with <code>style</code> attributes, the directives will take precedence:</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;div style="color: blue;" style:color="red">This will be red&#x3C;/div></code></pre>
        </section>
        <section id="useaction" class="level3">
          <h3>use:<em>action</em></h3>
          <pre class="language-sv"><code class="language-sv">use:action</code></pre>
          <pre class="language-sv"><code class="language-sv">use:action={parameters}</code></pre>
          <pre class="language-js"><code class="language-js"><span class="token function-variable function">action</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">node</span><span class="token operator">:</span> <span class="token maybe-class-name">HTMLElement</span><span class="token punctuation">,</span> <span class="token literal-property property">parameters</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
	update<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">parameters</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">,</span>
	destroy<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span>
<span class="token punctuation">}</span></code></pre>
          <p>Actions are functions that are called when an element is created. They can return an object with a <code>destroy</code> method that is called after the element is unmounted:</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;script>
	function foo(node) {
		// the node has been mounted in the DOM

		return {
			destroy() {
				// the node has been removed from the DOM
			}
		};
	}
&#x3C;/script>

&#x3C;div use:foo>&#x3C;/div></code></pre>
          <p>An action can have a parameter. If the returned value has an <code>update</code> method, it will be called whenever that parameter changes, immediately after Svelte has applied updates to the markup.</p>
          <blockquote>
            <p>Don't worry about the fact that we're redeclaring the <code>foo</code> function for every component instance — Svelte will hoist any functions that don't depend on local state out of the component definition.</p>
          </blockquote>
          <pre class="language-sv"><code class="language-sv">&#x3C;script>
	export let bar;

	function foo(node, bar) {
		// the node has been mounted in the DOM

		return {
			update(bar) {
				// the value of `bar` has changed
			},

			destroy() {
				// the node has been removed from the DOM
			}
		};
	}
&#x3C;/script>

&#x3C;div use:foo={bar}>&#x3C;/div></code></pre>
        </section>
        <section id="transitionfn" class="level3">
          <h3>transition:<em>fn</em></h3>
          <pre class="language-sv"><code class="language-sv">transition:fn</code></pre>
          <pre class="language-sv"><code class="language-sv">transition:fn={params}</code></pre>
          <pre class="language-sv"><code class="language-sv">transition:fn|local</code></pre>
          <pre class="language-sv"><code class="language-sv">transition:fn|local={params}</code></pre>
          <pre class="language-js"><code class="language-js"><span class="token function-variable function">transition</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">node</span><span class="token operator">:</span> <span class="token maybe-class-name">HTMLElement</span><span class="token punctuation">,</span> <span class="token literal-property property">params</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
	delay<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	duration<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	easing<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">t</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> number<span class="token punctuation">,</span>
	css<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">t</span><span class="token operator">:</span> number<span class="token punctuation">,</span> <span class="token literal-property property">u</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> string<span class="token punctuation">,</span>
	tick<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">t</span><span class="token operator">:</span> number<span class="token punctuation">,</span> <span class="token literal-property property">u</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span>
<span class="token punctuation">}</span></code></pre>
          <p>A transition is triggered by an element entering or leaving the DOM as a result of a state change.</p>
          <p>When a block is transitioning out, all elements inside the block, including those that do not have their own transitions, are kept in the DOM until every transition in the block has been completed.</p>
          <p>The <code>transition:</code> directive indicates a <em>bidirectional</em> transition, which means it can be smoothly reversed while the transition is in progress.</p>
          <pre class="language-sv"><code class="language-sv">{#if visible}
	&#x3C;div transition:fade>
		fades in and out
	&#x3C;/div>
{/if}</code></pre>
          <blockquote>
            <p>By default intro transitions will not play on first render. You can modify this behaviour by setting <code>intro: true</code> when you <a href="04-run-time.html">create a component</a>.</p>
          </blockquote>
          <section id="transition-parameters" class="level4">
            <h4>Transition parameters</h4>
            <p>Like actions, transitions can have parameters.</p>
            <p>(The double <code>{{curlies}}</code> aren't a special syntax; this is an object literal inside an expression tag.)</p>
            <pre class="language-sv"><code class="language-sv">{#if visible}
	&#x3C;div transition:fade="{{ duration: 2000 }}">
		fades in and out over two seconds
	&#x3C;/div>
{/if}</code></pre>
          </section>
          <section id="custom-transition-functions" class="level4">
            <h4>Custom transition functions</h4>
            <p>Transitions can use custom functions. If the returned object has a <code>css</code> function, Svelte will create a CSS animation that plays on the element.</p>
            <p>The <code>t</code> argument passed to <code>css</code> is a value between <code>0</code> and <code>1</code> after the <code>easing</code> function has been applied. <em>In</em> transitions run from <code>0</code> to <code>1</code>, <em>out</em> transitions run from <code>1</code> to <code>0</code> — in other words <code>1</code> is the element's natural state, as though no transition had been applied. The <code>u</code> argument is equal to <code>1 - t</code>.</p>
            <p>The function is called repeatedly <em>before</em> the transition begins, with different <code>t</code> and <code>u</code> arguments.</p>
            <pre class="language-sv"><code class="language-sv">&#x3C;script>
	import { elasticOut } from 'svelte/easing';

	export let visible;

	function whoosh(node, params) {
		const existingTransform = getComputedStyle(node).transform.replace('none', '');

		return {
			delay: params.delay || 0,
			duration: params.duration || 400,
			easing: params.easing || elasticOut,
			css: (t, u) => `transform: ${existingTransform} scale(${t})`
		};
	}
&#x3C;/script>

{#if visible}
	&#x3C;div in:whoosh>
		whooshes in
	&#x3C;/div>
{/if}</code></pre>
            <p>A custom transition function can also return a <code>tick</code> function, which is called <em>during</em> the transition with the same <code>t</code> and <code>u</code> arguments.</p>
            <blockquote>
              <p>If it's possible to use <code>css</code> instead of <code>tick</code>, do so — CSS animations can run off the main thread, preventing jank on slower devices.</p>
            </blockquote>
            <pre class="language-sv"><code class="language-sv">&#x3C;script>
	export let visible = false;

	function typewriter(node, { speed = 1 }) {
		const valid = (
			node.childNodes.length === 1 &#x26;&#x26;
			node.childNodes[0].nodeType === Node.TEXT_NODE
		);

		if (!valid) {
			throw new Error(`This transition only works on elements with a single text node child`);
		}

		const text = node.textContent;
		const duration = text.length / (speed * 0.01);

		return {
			duration,
			tick: t => {
				const i = ~~(text.length * t);
				node.textContent = text.slice(0, i);
			}
		};
	}
&#x3C;/script>

{#if visible}
	&#x3C;p in:typewriter="{{ speed: 1 }}">
		The quick brown fox jumps over the lazy dog
	&#x3C;/p>
{/if}</code></pre>
            <p>If a transition returns a function instead of a transition object, the function will be called in the next microtask. This allows multiple transitions to coordinate, making <a href="/tutorial/deferred-transitions">crossfade effects</a> possible.</p>
          </section>
          <section id="transition-events" class="level4">
            <h4>Transition events</h4>
            <p>An element with transitions will dispatch the following events in addition to any standard DOM events:</p>
            <ul>
              <li><code>introstart</code></li>
              <li><code>introend</code></li>
              <li><code>outrostart</code></li>
              <li><code>outroend</code></li>
            </ul>
            <pre class="language-sv"><code class="language-sv">{#if visible}
	&#x3C;p
		transition:fly="{{ y: 200, duration: 2000 }}"
		on:introstart="{() => status = 'intro started'}"
		on:outrostart="{() => status = 'outro started'}"
		on:introend="{() => status = 'intro ended'}"
		on:outroend="{() => status = 'outro ended'}"
	>
		Flies in and out
	&#x3C;/p>
{/if}</code></pre>
            <p>Local transitions only play when the block they belong to is created or destroyed, <em>not</em> when parent blocks are created or destroyed.</p>
            <pre class="language-sv"><code class="language-sv">{#if x}
	{#if y}
		&#x3C;p transition:fade>
			fades in and out when x or y change
		&#x3C;/p>

		&#x3C;p transition:fade|local>
			fades in and out only when y changes
		&#x3C;/p>
	{/if}
{/if}</code></pre>
          </section>
        </section>
        <section id="infnoutfn" class="level3">
          <h3>in:<em>fn</em>/out:<em>fn</em></h3>
          <pre class="language-sv"><code class="language-sv">in:fn</code></pre>
          <pre class="language-sv"><code class="language-sv">in:fn={params}</code></pre>
          <pre class="language-sv"><code class="language-sv">in:fn|local</code></pre>
          <pre class="language-sv"><code class="language-sv">in:fn|local={params}</code></pre>
          <pre class="language-sv"><code class="language-sv">out:fn</code></pre>
          <pre class="language-sv"><code class="language-sv">out:fn={params}</code></pre>
          <pre class="language-sv"><code class="language-sv">out:fn|local</code></pre>
          <pre class="language-sv"><code class="language-sv">out:fn|local={params}</code></pre>
          <p>Similar to <code>transition:</code>, but only applies to elements entering (<code>in:</code>) or leaving (<code>out:</code>) the DOM.</p>
          <p>Unlike with <code>transition:</code>, transitions applied with <code>in:</code> and <code>out:</code> are not bidirectional — an in transition will continue to 'play' alongside the out transition, rather than reversing, if the block is outroed while the transition is in progress. If an out transition is aborted, transitions will restart from scratch.</p>
          <pre class="language-sv"><code class="language-sv">{#if visible}
	&#x3C;div in:fly out:fade>
		flies in, fades out
	&#x3C;/div>
{/if}</code></pre>
        </section>
        <section id="animatefn" class="level3">
          <h3>animate:<em>fn</em></h3>
          <pre class="language-sv"><code class="language-sv">animate:name</code></pre>
          <pre class="language-sv"><code class="language-sv">animate:name={params}</code></pre>
          <pre class="language-js"><code class="language-js"><span class="token function-variable function">animation</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">node</span><span class="token operator">:</span> <span class="token maybe-class-name">HTMLElement</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword module">from</span><span class="token operator">:</span> <span class="token maybe-class-name">DOMRect</span><span class="token punctuation">,</span> <span class="token literal-property property">to</span><span class="token operator">:</span> <span class="token maybe-class-name">DOMRect</span> <span class="token punctuation">}</span> <span class="token punctuation">,</span> <span class="token literal-property property">params</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
	delay<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	duration<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	easing<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">t</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> number<span class="token punctuation">,</span>
	css<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">t</span><span class="token operator">:</span> number<span class="token punctuation">,</span> <span class="token literal-property property">u</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> string<span class="token punctuation">,</span>
	tick<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">t</span><span class="token operator">:</span> number<span class="token punctuation">,</span> <span class="token literal-property property">u</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span>
<span class="token punctuation">}</span></code></pre>
          <pre class="language-js"><code class="language-js"><span class="token maybe-class-name">DOMRect</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">bottom</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	<span class="token literal-property property">height</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	<span class="token literal-property property">​​left</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	<span class="token literal-property property">right</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	<span class="token literal-property property">​top</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	<span class="token literal-property property">width</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	<span class="token literal-property property">x</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	<span class="token literal-property property">y</span><span class="token operator">:</span> number
<span class="token punctuation">}</span></code></pre>
          <p>An animation is triggered when the contents of a <a href="03-template-syntax.html">keyed each block</a> are re-ordered. Animations do not run when an element is added or removed, only when the index of an existing data item within the each block changes. Animate directives must be on an element that is an <em>immediate</em> child of a keyed each block.</p>
          <p>Animations can be used with Svelte's <a href="04-run-time.html">built-in animation functions</a> or <a href="03-template-syntax.html">custom animation functions</a>.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;!-- When `list` is reordered the animation will run-->
{#each list as item, index (item)}
	&#x3C;li animate:flip>{item}&#x3C;/li>
{/each}</code></pre>
          <section id="animation-parameters" class="level4">
            <h4>Animation Parameters</h4>
            <p>As with actions and transitions, animations can have parameters.</p>
            <p>(The double <code>{{curlies}}</code> aren't a special syntax; this is an object literal inside an expression tag.)</p>
            <pre class="language-sv"><code class="language-sv">{#each list as item, index (item)}
	&#x3C;li animate:flip="{{ delay: 500 }}">{item}&#x3C;/li>
{/each}</code></pre>
          </section>
          <section id="custom-animation-functions" class="level4">
            <h4>Custom animation functions</h4>
            <p>Animations can use custom functions that provide the <code>node</code>, an <code>animation</code> object and any <code>parameters</code> as arguments. The <code>animation</code> parameter is an object containing <code>from</code> and <code>to</code> properties each containing a <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMRect#Properties">DOMRect</a> describing the geometry of the element in its <code>start</code> and <code>end</code> positions. The <code>from</code> property is the DOMRect of the element in its starting position, and the <code>to</code> property is the DOMRect of the element in its final position after the list has been reordered and the DOM updated.</p>
            <p>If the returned object has a <code>css</code> method, Svelte will create a CSS animation that plays on the element.</p>
            <p>The <code>t</code> argument passed to <code>css</code> is a value that goes from <code>0</code> and <code>1</code> after the <code>easing</code> function has been applied. The <code>u</code> argument is equal to <code>1 - t</code>.</p>
            <p>The function is called repeatedly <em>before</em> the animation begins, with different <code>t</code> and <code>u</code> arguments.</p>
            <pre class="language-sv"><code class="language-sv">&#x3C;script>
	import { cubicOut } from 'svelte/easing';

	function whizz(node, { from, to }, params) {

		const dx = from.left - to.left;
		const dy = from.top - to.top;

		const d = Math.sqrt(dx * dx + dy * dy);

		return {
			delay: 0,
			duration: Math.sqrt(d) * 120,
			easing: cubicOut,
			css: (t, u) =>
				`transform: translate(${u * dx}px, ${u * dy}px) rotate(${t*360}deg);`
		};
	}
&#x3C;/script>

{#each list as item, index (item)}
	&#x3C;div animate:whizz>{item}&#x3C;/div>
{/each}</code></pre>
            <p>A custom animation function can also return a <code>tick</code> function, which is called <em>during</em> the animation with the same <code>t</code> and <code>u</code> arguments.</p>
            <blockquote>
              <p>If it's possible to use <code>css</code> instead of <code>tick</code>, do so — CSS animations can run off the main thread, preventing jank on slower devices.</p>
            </blockquote>
            <pre class="language-sv"><code class="language-sv">&#x3C;script>
	import { cubicOut } from 'svelte/easing';

	function whizz(node, { from, to }, params) {

		const dx = from.left - to.left;
		const dy = from.top - to.top;

		const d = Math.sqrt(dx * dx + dy * dy);

		return {
		delay: 0,
		duration: Math.sqrt(d) * 120,
		easing: cubicOut,
		tick: (t, u) =>
			Object.assign(node.style, {
				color: t > 0.5 ? 'Pink' : 'Blue'
			});
	};
	}
&#x3C;/script>

{#each list as item, index (item)}
	&#x3C;div animate:whizz>{item}&#x3C;/div>
{/each}</code></pre>
          </section>
        </section>
      </section>
      <section id="component-directives" class="level2">
        <h2>Component directives</h2>
        <section id="oneventname-1" class="level3">
          <h3>on:<em>eventname</em></h3>
          <pre class="language-sv"><code class="language-sv">on:eventname={handler}</code></pre>
          <p>Components can emit events using <a href="04-run-time.html">createEventDispatcher</a>, or by forwarding DOM events. Listening for component events looks the same as listening for DOM events:</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;SomeComponent on:whatever={handler}/></code></pre>
          <p>As with DOM events, if the <code>on:</code> directive is used without a value, the component will <em>forward</em> the event, meaning that a consumer of the component can listen for it.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;SomeComponent on:whatever/></code></pre>
        </section>
        <section id="--style-props" class="level3">
          <h3>--style-props</h3>
          <pre class="language-sv"><code class="language-sv">--style-props="anycssvalue"</code></pre>
          <p>You can also pass styles as props to components for the purposes of theming, using CSS custom properties.</p>
          <p>Svelte's implementation is essentially syntactic sugar for adding a wrapper element. This example:</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;Slider
  bind:value
  min={0}
  --rail-color="black"
  --track-color="rgb(0, 0, 255)"
/></code></pre>
          <p>Desugars to this:</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;div style="display: contents; --rail-color: black; --track-color: rgb(0, 0, 255)">
  &#x3C;Slider
    bind:value
    min={0}
    max={100}
  />
&#x3C;/div></code></pre>
          <p><strong>Note</strong>: Since this is an extra <code>&#x3C;div></code>, beware that your CSS structure might accidentally target this. Be mindful of this added wrapper element when using this feature.</p>
          <p>For SVG namespace, the example above desugars into using <code>&#x3C;g></code> instead:</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;g style="--rail-color: black; --track-color: rgb(0, 0, 255)">
  &#x3C;Slider
    bind:value
    min={0}
    max={100}
  />
&#x3C;/g></code></pre>
          <p><strong>Note</strong>: Since this is an extra <code>&#x3C;g></code>, beware that your CSS structure might accidentally target this. Be mindful of this added wrapper element when using this feature.</p>
          <p>Svelte's CSS Variables support allows for easily themeable components:</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;!-- Slider.svelte -->
&#x3C;style>
  .potato-slider-rail {
    background-color: var(--rail-color, var(--theme-color, 'purple'));
  }
&#x3C;/style></code></pre>
          <p>So you can set a high level theme color:</p>
          <pre class="language-css"><code class="language-css"><span class="token comment">/* global.css */</span>
<span class="token selector">html</span> <span class="token punctuation">{</span>
  <span class="token variable">--theme-color</span><span class="token punctuation">:</span> <span class="token color">black</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
          <p>Or override it at the consumer level:</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;Slider --rail-color="goldenrod"/></code></pre>
        </section>
        <section id="bindproperty-1" class="level3">
          <h3>bind:<em>property</em></h3>
          <pre class="language-sv"><code class="language-sv">bind:property={variable}</code></pre>
          <p>You can bind to component props using the same syntax as for elements.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;Keypad bind:value={pin}/></code></pre>
        </section>
        <section id="bindthis-1" class="level3">
          <h3>bind:this</h3>
          <pre class="language-sv"><code class="language-sv">bind:this={component_instance}</code></pre>
          <p>Components also support <code>bind:this</code>, allowing you to interact with component instances programmatically.</p>
          <blockquote>
            <p>Note that we can't do <code>{cart.empty}</code> since <code>cart</code> is <code>undefined</code> when the button is first rendered and throws an error.</p>
          </blockquote>
          <pre class="language-sv"><code class="language-sv">&#x3C;ShoppingCart bind:this={cart}/>

&#x3C;button on:click={() => cart.empty()}>
	Empty shopping cart
&#x3C;/button></code></pre>
        </section>
      </section>
      <section id="slot" class="level2">
        <h2><code>&#x3C;slot></code></h2>
        <pre class="language-sv"><code class="language-sv">&#x3C;slot>&#x3C;!-- optional fallback -->&#x3C;/slot></code></pre>
        <pre class="language-sv"><code class="language-sv">&#x3C;slot name="x">&#x3C;!-- optional fallback -->&#x3C;/slot></code></pre>
        <pre class="language-sv"><code class="language-sv">&#x3C;slot prop={value}>&#x3C;/slot></code></pre>
        <p>Components can have child content, in the same way that elements can.</p>
        <p>The content is exposed in the child component using the <code>&#x3C;slot></code> element, which can contain fallback content that is rendered if no children are provided.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;!-- Widget.svelte -->
&#x3C;div>
	&#x3C;slot>
		this fallback content will be rendered when no content is provided, like in the first example
	&#x3C;/slot>
&#x3C;/div>

&#x3C;!-- App.svelte -->
&#x3C;Widget>&#x3C;/Widget> &#x3C;!-- this component will render the default content -->

&#x3C;Widget>
	&#x3C;p>this is some child content that will overwrite the default slot content&#x3C;/p>
&#x3C;/Widget></code></pre>
        <section id="slot-namename" class="level3">
          <h3><code>&#x3C;slot name="</code><em>name</em><code>"></code></h3>
          <p>Named slots allow consumers to target specific areas. They can also have fallback content.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;!-- Widget.svelte -->
&#x3C;div>
	&#x3C;slot name="header">No header was provided&#x3C;/slot>
	&#x3C;p>Some content between header and footer&#x3C;/p>
	&#x3C;slot name="footer">&#x3C;/slot>
&#x3C;/div>

&#x3C;!-- App.svelte -->
&#x3C;Widget>
	&#x3C;h1 slot="header">Hello&#x3C;/h1>
	&#x3C;p slot="footer">Copyright (c) 2019 Svelte Industries&#x3C;/p>
&#x3C;/Widget></code></pre>
          <p>
            Components can be placed in a named slot using the syntax <code>&#x3C;Component slot="name" /></code>.
            In order to place content in a slot without using a wrapper element, you can use the special element <code>&#x3C;svelte:fragment></code>.
          </p>
          <pre class="language-sv"><code class="language-sv">&#x3C;!-- Widget.svelte -->
&#x3C;div>
	&#x3C;slot name="header">No header was provided&#x3C;/slot>
	&#x3C;p>Some content between header and footer&#x3C;/p>
	&#x3C;slot name="footer">&#x3C;/slot>
&#x3C;/div>

&#x3C;!-- App.svelte -->
&#x3C;Widget>
	&#x3C;HeaderComponent slot="header" />
	&#x3C;svelte:fragment slot="footer">
		&#x3C;p>All rights reserved.&#x3C;/p>
		&#x3C;p>Copyright (c) 2019 Svelte Industries&#x3C;/p>
	&#x3C;/svelte:fragment>
&#x3C;/Widget></code></pre>
        </section>
        <section id="slots" class="level3">
          <h3><code>$$slots</code></h3>
          <p><code>$$slots</code> is an object whose keys are the names of the slots passed into the component by the parent. If the parent does not pass in a slot with a particular name, that name will not be present in <code>$$slots</code>. This allows components to render a slot (and other elements, like wrappers for styling) only if the parent provides it.</p>
          <p>Note that explicitly passing in an empty named slot will add that slot's name to <code>$$slots</code>. For example, if a parent passes <code>&#x3C;div slot="title" /></code> to a child component, <code>$$slots.title</code> will be truthy within the child.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;!-- Card.svelte -->
&#x3C;div>
	&#x3C;slot name="title">&#x3C;/slot>
	{#if $$slots.description}
		&#x3C;!-- This &#x3C;hr> and slot will render only if a slot named "description" is provided. -->
		&#x3C;hr>
		&#x3C;slot name="description">&#x3C;/slot>
	{/if}
&#x3C;/div>

&#x3C;!-- App.svelte -->
&#x3C;Card>
	&#x3C;h1 slot="title">Blog Post Title&#x3C;/h1>
	&#x3C;!-- No slot named "description" was provided so the optional slot will not be rendered. -->
&#x3C;/Card></code></pre>
        </section>
        <section id="slot-keyvalue" class="level3">
          <h3><code>&#x3C;slot key={</code><em>value</em><code>}></code></h3>
          <p>Slots can be rendered zero or more times, and can pass values <em>back</em> to the parent using props. The parent exposes the values to the slot template using the <code>let:</code> directive.</p>
          <p>The usual shorthand rules apply — <code>let:item</code> is equivalent to <code>let:item={item}</code>, and <code>&#x3C;slot {item}></code> is equivalent to <code>&#x3C;slot item={item}></code>.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;!-- FancyList.svelte -->
&#x3C;ul>
	{#each items as item}
		&#x3C;li class="fancy">
			&#x3C;slot prop={item}>&#x3C;/slot>
		&#x3C;/li>
	{/each}
&#x3C;/ul>

&#x3C;!-- App.svelte -->
&#x3C;FancyList {items} let:prop={thing}>
	&#x3C;div>{thing.text}&#x3C;/div>
&#x3C;/FancyList></code></pre>
          <p>Named slots can also expose values. The <code>let:</code> directive goes on the element with the <code>slot</code> attribute.</p>
          <pre class="language-sv"><code class="language-sv">&#x3C;!-- FancyList.svelte -->
&#x3C;ul>
	{#each items as item}
		&#x3C;li class="fancy">
			&#x3C;slot name="item" {item}>&#x3C;/slot>
		&#x3C;/li>
	{/each}
&#x3C;/ul>

&#x3C;slot name="footer">&#x3C;/slot>

&#x3C;!-- App.svelte -->
&#x3C;FancyList {items}>
	&#x3C;div slot="item" let:item>{item.text}&#x3C;/div>
	&#x3C;p slot="footer">Copyright (c) 2019 Svelte Industries&#x3C;/p>
&#x3C;/FancyList></code></pre>
        </section>
      </section>
      <section id="svelteself" class="level2">
        <h2><code>&#x3C;svelte:self></code></h2>
        <p>The <code>&#x3C;svelte:self></code> element allows a component to include itself, recursively.</p>
        <p>It cannot appear at the top level of your markup; it must be inside an if or each block or passed to a component's slot to prevent an infinite loop.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;script>
	export let count;
&#x3C;/script>

{#if count > 0}
	&#x3C;p>counting down... {count}&#x3C;/p>
	&#x3C;svelte:self count="{count - 1}"/>
{:else}
	&#x3C;p>lift-off!&#x3C;/p>
{/if}</code></pre>
      </section>
      <section id="sveltecomponent" class="level2">
        <h2><code>&#x3C;svelte:component></code></h2>
        <pre class="language-sv"><code class="language-sv">&#x3C;svelte:component this={expression}/></code></pre>
        <p>The <code>&#x3C;svelte:component></code> element renders a component dynamically, using the component constructor specified as the <code>this</code> property. When the property changes, the component is destroyed and recreated.</p>
        <p>If <code>this</code> is falsy, no component is rendered.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;svelte:component this={currentSelection.component} foo={bar}/></code></pre>
      </section>
      <section id="svelteelement" class="level2">
        <h2><code>&#x3C;svelte:element></code></h2>
        <pre class="language-sv"><code class="language-sv">&#x3C;svelte:element this={expression}/></code></pre>
        <p>The <code>&#x3C;svelte:element></code> element lets you render an element of a dynamically specified type. This is useful for example when displaying rich text content from a CMS. Any properties and event listeners present will be applied to the element.</p>
        <p>The only supported binding is <code>bind:this</code>, since the element type specific bindings that Svelte does at build time (e.g. <code>bind:value</code> for input elements) do not work with a dynamic tag type.</p>
        <p>If <code>this</code> has a nullish value, the element and its children will not be rendered.</p>
        <p>If <code>this</code> is the name of a void tag (e.g., <code>br</code>) and <code>&#x3C;svelte:element></code> has child elements, a runtime error will be thrown in development mode.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;script>
	let tag = 'div';
	export let handler;
&#x3C;/script>

&#x3C;svelte:element this={tag} on:click={handler}>Foo&#x3C;/svelte:element></code></pre>
      </section>
      <section id="sveltewindow" class="level2">
        <h2><code>&#x3C;svelte:window></code></h2>
        <pre class="language-sv"><code class="language-sv">&#x3C;svelte:window on:event={handler}/></code></pre>
        <pre class="language-sv"><code class="language-sv">&#x3C;svelte:window bind:prop={value}/></code></pre>
        <p>The <code>&#x3C;svelte:window></code> element allows you to add event listeners to the <code>window</code> object without worrying about removing them when the component is destroyed, or checking for the existence of <code>window</code> when server-side rendering.</p>
        <p>Unlike <code>&#x3C;svelte:self></code>, this element may only appear at the top level of your component and must never be inside a block or element.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;script>
	function handleKeydown(event) {
		alert(`pressed the ${event.key} key`);
	}
&#x3C;/script>

&#x3C;svelte:window on:keydown={handleKeydown}/></code></pre>
        <p>You can also bind to the following properties:</p>
        <ul>
          <li><code>innerWidth</code></li>
          <li><code>innerHeight</code></li>
          <li><code>outerWidth</code></li>
          <li><code>outerHeight</code></li>
          <li><code>scrollX</code></li>
          <li><code>scrollY</code></li>
          <li><code>online</code> — an alias for window.navigator.onLine</li>
        </ul>
        <p>All except <code>scrollX</code> and <code>scrollY</code> are readonly.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;svelte:window bind:scrollY={y}/></code></pre>
        <blockquote>
          <p>Note that the page will not be scrolled to the initial value to avoid accessibility issues. Only subsequent changes to the bound variable of <code>scrollX</code> and <code>scrollY</code> will cause scrolling. However, if the scrolling behaviour is desired, call <code>scrollTo()</code> in <code>onMount()</code>.</p>
        </blockquote>
      </section>
      <section id="sveltebody" class="level2">
        <h2><code>&#x3C;svelte:body></code></h2>
        <pre class="language-sv"><code class="language-sv">&#x3C;svelte:body on:event={handler}/></code></pre>
        <p>Similarly to <code>&#x3C;svelte:window></code>, this element allows you to add listeners to events on <code>document.body</code>, such as <code>mouseenter</code> and <code>mouseleave</code>, which don't fire on <code>window</code>. It also lets you use <a href="03-template-syntax.html">actions</a> on the <code>&#x3C;body></code> element.</p>
        <p>As with <code>&#x3C;svelte:window></code>, this element may only appear the top level of your component and must never be inside a block or element.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;svelte:body
	on:mouseenter={handleMouseenter}
	on:mouseleave={handleMouseleave}
	use:someAction
/></code></pre>
      </section>
      <section id="sveltehead" class="level2">
        <h2><code>&#x3C;svelte:head></code></h2>
        <pre class="language-sv"><code class="language-sv">&#x3C;svelte:head>...&#x3C;/svelte:head></code></pre>
        <p>This element makes it possible to insert elements into <code>document.head</code>. During server-side rendering, <code>head</code> content is exposed separately to the main <code>html</code> content.</p>
        <p>As with <code>&#x3C;svelte:window></code> and <code>&#x3C;svelte:body></code>, this element may only appear at the top level of your component and must never be inside a block or element.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;svelte:head>
	&#x3C;link rel="stylesheet" href="/tutorial/dark-theme.css">
&#x3C;/svelte:head></code></pre>
      </section>
      <section id="svelteoptions" class="level2">
        <h2><code>&#x3C;svelte:options></code></h2>
        <pre class="language-sv"><code class="language-sv">&#x3C;svelte:options option={value}/></code></pre>
        <p>The <code>&#x3C;svelte:options></code> element provides a place to specify per-component compiler options, which are detailed in the <a href="05-compile-time.html">compiler section</a>. The possible options are:</p>
        <ul>
          <li><code>immutable={true}</code> — you never use mutable data, so the compiler can do simple referential equality checks to determine if values have changed</li>
          <li><code>immutable={false}</code> — the default. Svelte will be more conservative about whether or not mutable objects have changed</li>
          <li><code>accessors={true}</code> — adds getters and setters for the component's props</li>
          <li><code>accessors={false}</code> — the default</li>
          <li><code>namespace="..."</code> — the namespace where this component will be used, most commonly "svg"; use the "foreign" namespace to opt out of case-insensitive attribute names and HTML-specific warnings</li>
          <li><code>tag="..."</code> — the name to use when compiling this component as a custom element</li>
        </ul>
        <pre class="language-sv"><code class="language-sv">&#x3C;svelte:options tag="my-custom-element"/></code></pre>
      </section>
      <section id="sveltefragment" class="level2">
        <h2><code>&#x3C;svelte:fragment></code></h2>
        <p>The <code>&#x3C;svelte:fragment></code> element allows you to place content in a <a href="03-template-syntax.html">named slot</a> without wrapping it in a container DOM element. This keeps the flow layout of your document intact.</p>
        <pre class="language-sv"><code class="language-sv">&#x3C;!-- Widget.svelte -->
&#x3C;div>
	&#x3C;slot name="header">No header was provided&#x3C;/slot>
	&#x3C;p>Some content between header and footer&#x3C;/p>
	&#x3C;slot name="footer">&#x3C;/slot>
&#x3C;/div>

&#x3C;!-- App.svelte -->
&#x3C;Widget>
	&#x3C;h1 slot="header">Hello&#x3C;/h1>
	&#x3C;svelte:fragment slot="footer">
		&#x3C;p>All rights reserved.&#x3C;/p>
		&#x3C;p>Copyright (c) 2019 Svelte Industries&#x3C;/p>
	&#x3C;/svelte:fragment>
&#x3C;/Widget></code></pre>
        <p><span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span></p>
      </section>
    </section>
  </body>
</html>
