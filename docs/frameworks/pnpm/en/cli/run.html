<!doctype html><html lang="en"><meta charset="utf-8"><title>pnpm run</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="pnpm-run"><h1 id="pnpm-run">pnpm run</h1><p>Aliases: <code>run-script</code><p>Runs a script defined in the package's manifest file.<section class="level2"aria-labelledby="examples"><h2 id="examples">Examples</h2><p>Let's say you have a <code>watch</code> script configured in your <code>package.json</code>, like so:<pre class="language-json"><code class="language-json">scripts<span class="token operator">:</span> <span class="token punctuation">{</span>
    watch<span class="token operator">:</span> webpack --watch
<span class="token punctuation">}</span></code></pre><p>You can now run that script by using <code>pnpm run watch</code>! Simple, right? Another thing to note for those that like to save keystrokes and time is that<p>all scripts get aliased in as pnpm commands, so ultimately <code>pnpm watch</code> is just shorthand for <code>pnpm run watch</code> (ONLY for scripts that do not share the same name as already existing pnpm commands).</section><section class="level2"aria-labelledby="running-multiple-scripts"><h2 id="running-multiple-scripts">Running multiple scripts</h2><p>You may run multiple scripts at the same time by using a regex instead of the script name.<pre class="language-sh"><code class="language-sh">pnpm run /&#x3C;regex>/</code></pre><p>Run all scripts that start with <code>watch:</code>:<pre class="language-sh"><code class="language-sh">pnpm run /^watch:.*/</code></pre></section><section class="level2"aria-labelledby="details"><h2 id="details">Details</h2><p>In addition to the shellâ€™s pre-existing <code>PATH</code>, <code>pnpm run</code> includes <code>node_modules/.bin</code> in the <code>PATH</code> provided to <code>scripts</code>. This means that so long as you have a package installed, you can use it in a script like a regular command. For example, if you have <code>eslint</code> installed, you can write up a script like so:<pre class="language-json"><code class="language-json">lint<span class="token operator">:</span> eslint src --fix</code></pre><p>And even though <code>eslint</code> is not installed globally in your shell, it will run.<p>For workspaces, <code>&#x3C;workspace root>/node_modules/.bin</code> is also added to the <code>PATH</code>, so if a tool is installed in the workspace root, it may be called in any workspace package's <code>scripts</code>.</section><section class="level2"aria-labelledby="differences-with-npm-run"><h2 id="differences-with-npm-run">Differences with <code>npm run</code></h2><p>By default, pnpm doesn't run arbitrary <code>pre</code> and <code>post</code> hooks for user-defined scripts (such as <code>prestart</code>). This behavior, inherited from npm, caused scripts to be implicit rather than explicit, obfuscating the execution flow. It also led to surprising executions with <code>pnpm serve</code> also running <code>pnpm preserve</code>.<p>If for some reason you need the pre/post scripts behavior of npm, use the <code>enable-pre-post-scripts</code> option.</section><section class="level2"aria-labelledby="environment"><h2 id="environment">Environment</h2><p>There are some environment variables that pnpm automatically creates for the executed scripts. These environment variables may be used to get contextual information about the running process.<p>These are the environment variables created by pnpm:<ul><li><strong>npm_command</strong> - contains the name of the executed command. If the executed command is <code>pnpm run</code>, then the value of this variable will be run-script.</ul></section><section class="level2"aria-labelledby="options"><h2 id="options">Options</h2><p>Any options for the <code>run</code> command should be listed before the script's name. Options listed after the script's name are passed to the executed script.<p>All these will run pnpm CLI with the <code>--silent</code> option:<pre class="language-sh"><code class="language-sh">pnpm run --silent watch
pnpm --silent run watch
pnpm --silent watch</code></pre><p>Any arguments after the command's name are added to the executed script. So if <code>watch</code> runs <code>webpack --watch</code>, then this command:<pre class="language-sh"><code class="language-sh">pnpm run watch --no-color</code></pre><p>will run:<pre class="language-sh"><code class="language-sh">webpack --watch --no-color</code></pre><section class="level3"aria-labelledby="script-shell"><h3 id="script-shell">script-shell</h3><ul><li>Default: <strong>null</strong><li>Type: <strong>path</strong></ul><p>The shell to use for scripts run with the <code>pnpm run</code> command.<p>For instance, to force usage of Git Bash on Windows:<pre class="language-text"><code class="language-text">pnpm config set script-shell C:\\Program Files\\git\\bin\\bash.exe</code></pre></section><section class="level3"aria-labelledby="shell-emulator"><h3 id="shell-emulator">shell-emulator</h3><ul><li>Default: <strong>false</strong><li>Type: <strong>Boolean</strong></ul><p>When <code>true</code>, pnpm will use a JavaScript implementation of a [bash-like shell] to execute scripts.<p>This option simplifies cross-platform scripting. For instance, by default, the next script will fail on non-POSIX-compliant systems:<pre class="language-json"><code class="language-json">scripts<span class="token operator">:</span> <span class="token punctuation">{</span>
  test<span class="token operator">:</span> NODE_ENV=test node test.js
<span class="token punctuation">}</span></code></pre><p>But if the <code>shell-emulator</code> setting is set to <code>true</code>, it will work on all platforms.<p><a href="https://www.npmjs.com/package/@yarnpkg/shell">bash-like shell</a></section><section class="level3"aria-labelledby="--recursive--r"><h3 id="--recursive--r">--recursive, -r</h3><p>This runs an arbitrary command from each package's scripts object. If a package doesn't have the command, it is skipped. If none of the packages have the command, the command fails.</section><section class="level3"aria-labelledby="--if-present"><h3 id="--if-present">--if-present</h3><p>You can use the <code>--if-present</code> flag to avoid exiting with a non-zero exit code when the script is undefined. This lets you run potentially undefined scripts without breaking the execution chain.</section><section class="level3"aria-labelledby="--parallel"><h3 id="--parallel">--parallel</h3><p>Completely disregard concurrency and topological sorting, running a given script immediately in all matching packages with prefixed streaming output. This is the preferred flag for long-running processes over many packages, for instance, a lengthy build process.</section><section class="level3"aria-labelledby="--stream"><h3 id="--stream">--stream</h3><p>Stream output from child processes immediately, prefixed with the originating package directory. This allows output from different packages to be interleaved.</section><section class="level3"aria-labelledby="--aggregate-output"><h3 id="--aggregate-output">--aggregate-output</h3><p>Aggregate output from child processes that are run in parallel, and only print output when the child process is finished. It makes reading large logs after running <code>pnpm -r &#x3C;command></code> with <code>--parallel</code> or with <code>--workspace-concurrency=&#x3C;number></code> much easier (especially on CI). Only <code>--reporter=append-only</code> is supported.</section><section class="level3"aria-labelledby="enable-pre-post-scripts"><h3 id="enable-pre-post-scripts">enable-pre-post-scripts</h3><ul><li>Default: <strong>false</strong><li>Type: <strong>Boolean</strong></ul><p>When <code>true</code>, pnpm will run any pre/post scripts automatically. So running <code>pnpm foo</code> will be like running <code>pnpm prefoo &#x26;&#x26; pnpm foo &#x26;&#x26; pnpm postfoo</code>.</section><section class="level3"aria-labelledby="--resume-from-package_name"><h3 id="--resume-from-package_name">--resume-from &#x3C;package_name></h3><p>Resume execution from a particular project. This can be useful if you are working with a large workspace and you want to restart a build at a particular project without running through all of the projects that precede it in the build order.</section><section class="level3"aria-labelledby="--report-summary"><h3 id="--report-summary">--report-summary</h3><p>Record the result of the scripts executions into a <code>pnpm-exec-summary.json</code> file.<p>An example of a <code>pnpm-exec-summary.json</code> file:<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  executionStatus<span class="token operator">:</span> <span class="token punctuation">{</span>
    /Users/zoltan/src/pnpm/pnpm/cli/command<span class="token operator">:</span> <span class="token punctuation">{</span>
      status<span class="token operator">:</span> passed<span class="token punctuation">,</span>
      duration<span class="token operator">:</span> <span class="token number">1861.143042</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    /Users/zoltan/src/pnpm/pnpm/cli/common-cli-options-help<span class="token operator">:</span> <span class="token punctuation">{</span>
      status<span class="token operator">:</span> passed<span class="token punctuation">,</span>
      duration<span class="token operator">:</span> <span class="token number">1865.914958</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span></code></pre><p>Possible values of <code>status</code> are: 'passed', 'queued', 'running'.</section><section class="level3"aria-labelledby="--filter-package_selector"><h3 id="--filter-package_selector">--filter &#x3C;package_selector></h3><p><a href="../filtering.html">Read more about filtering.</a> <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section></section>