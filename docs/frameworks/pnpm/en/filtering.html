<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Filtering</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="filtering" class="level1">
      <h1>Filtering</h1>
      <p>Filtering allows you to restrict commands to specific subsets of packages.</p>
      <p>
        pnpm supports a rich selector syntax for picking packages by name or by
        relation.
      </p>
      <p>Selectors may be specified via the <code>--filter</code> (or <code>-F</code>) flag:</p>
      <pre class="language-sh"><code class="language-sh">pnpm --filter &#x3C;package_selector> &#x3C;command></code></pre>
      <section id="matching" class="level2">
        <h2>Matching</h2>
        <section id="--filter-package_name" class="level3">
          <h3>--filter &#x3C;package_name></h3>
          <p>
            To select an exact package, just specify its name (<code>@scope/pkg</code>) or use a
            pattern to select a set of packages (<code>@scope/*</code>).
          </p>
          <p>Examples:</p>
          <pre class="language-sh"><code class="language-sh">pnpm --filter @babel/core test
pnpm --filter @babel/* test
pnpm --filter *core test</code></pre>
          <p>
            Specifying the scope of the package is optional, so <code>--filter=core</code> will pick <code>@babel/core</code> if <code>core</code> is not found.
            However, if the workspace has multiple packages with the same name (for instance, <code>@babel/core</code> and <code>@types/core</code>),
            then filtering without scope will pick nothing.
          </p>
        </section>
        <section id="--filter-package_name-1" class="level3">
          <h3>--filter &#x3C;package_name>...</h3>
          <p>
            To select a package and its dependencies (direct and non-direct), suffix the
            package name with an ellipsis: <code>&#x3C;package_name>...</code>. For instance, the next
            command will run tests of <code>foo</code> and all of its dependencies:
          </p>
          <pre class="language-sh"><code class="language-sh">pnpm --filter foo... test</code></pre>
          <p>You may use a pattern to select a set of root packages:</p>
          <pre class="language-sh"><code class="language-sh">pnpm --filter @babel/preset-*... test</code></pre>
        </section>
        <section id="--filter-package_name-2" class="level3">
          <h3>--filter &#x3C;package_name>^...</h3>
          <p>
            To ONLY select the dependencies of a package (both direct and non-direct),
            suffix the name with the aforementioned ellipsis preceded by a chevron. For
            instance, the next command will run tests for all of <code>foo</code>'s
            dependencies:
          </p>
          <pre class="language-sh"><code class="language-sh">pnpm --filter foo^... test</code></pre>
        </section>
        <section id="--filter-package_name-3" class="level3">
          <h3>--filter ...&#x3C;package_name></h3>
          <p>
            To select a package and its dependent packages (direct and non-direct), prefix
            the package name with an ellipsis: <code>...&#x3C;package_name></code>. For instance, this will
            run the tests of <code>foo</code> and all packages dependent on it:
          </p>
          <pre class="language-sh"><code class="language-sh">pnpm --filter ...foo test</code></pre>
        </section>
        <section id="--filter-package_name-4" class="level3">
          <h3>--filter ...^&#x3C;package_name></h3>
          <p>
            To ONLY select a package's dependents (both direct and non-direct), prefix the
            package name with an ellipsis followed by a chevron. For instance, this will
            run tests for all packages dependent on <code>foo</code>:
          </p>
          <pre class="language-text"><code class="language-text">pnpm --filter ...^foo test</code></pre>
        </section>
        <section id="--filter-glob---filter-glob" class="level3">
          <h3>--filter ./&#x3C;glob>, --filter {&#x3C;glob>}</h3>
          <p>A glob pattern relative to the current working directory matching projects.</p>
          <pre class="language-sh"><code class="language-sh">pnpm --filter ./packages/** &#x3C;.html)</code></pre>
          <p>Includes all projects that are under the specified directory.</p>
          <p>
            It may be used with the ellipsis and chevron operators to select
            dependents/dependencies as well:
          </p>
          <pre class="language-sh"><code class="language-sh">pnpm --filter ...{&#x3C;directory>} &#x3C;.html)
pnpm --filter {&#x3C;directory>}... &#x3C;.html)
pnpm --filter ...{&#x3C;directory>}... &#x3C;.html)</code></pre>
          <p>
            It may also be combined with <code>[&#x3C;since>]</code>. For instance, to select all changed
            projects inside a directory:
          </p>
          <pre class="language-sh"><code class="language-sh">pnpm --filter {packages/**}[origin/master] &#x3C;.html)
pnpm --filter ...{packages/**}[origin/master] &#x3C;.html)
pnpm --filter {packages/**}[origin/master]... &#x3C;.html)
pnpm --filter ...{packages/**}[origin/master]... &#x3C;.html)</code></pre>
          <p>
            Or you may select all packages from a directory with names matching the given
            pattern:
          </p>
          <pre class="language-text"><code class="language-text">pnpm --filter @babel/*{components/**} &#x3C;.html)
pnpm --filter @babel/*{components/**}[origin/master] &#x3C;.html)
pnpm --filter ...@babel/*{components/**}[origin/master] &#x3C;.html)</code></pre>
        </section>
        <section id="--filter-since" class="level3">
          <h3>--filter [&#x3C;since>]</h3>
          <p>
            Selects all the packages changed since the specified commit/branch. May be
            suffixed or prefixed with <code>...</code> to include dependencies/dependents.
          </p>
          <p>
            For example, the next command will run tests in all changed packages since
            <code>master</code> and on any dependent packages:
          </p>
          <pre class="language-sh"><code class="language-sh">pnpm --filter ...[origin/master] test</code></pre>
        </section>
      </section>
      <section id="excluding" class="level2">
        <h2>Excluding</h2>
        <p>
          Any of the filter selectors may work as exclusion operators when they have a
          leading !. In zsh (and possibly other shells), ! should be escaped: <code>\!</code>.
        </p>
        <p>For instance, this will run a command in all projects except for <code>foo</code>:</p>
        <pre class="language-sh"><code class="language-sh">pnpm --filter=!foo &#x3C;.html)</code></pre>
        <p>
          And this will run a command in all projects that are not under the <code>lib</code>
          directory:
        </p>
        <pre class="language-sh"><code class="language-sh">pnpm --filter=!./lib &#x3C;.html)</code></pre>
      </section>
      <section id="multiplicity" class="level2">
        <h2>Multiplicity</h2>
        <p>
          When packages are filtered, every package is taken that matches at least one of
          the selectors. You can use as many filters as you want:
        </p>
        <pre class="language-sh"><code class="language-sh">pnpm --filter ...foo --filter bar --filter baz... test</code></pre>
      </section>
      <section id="--filter-prod-filtering_pattern" class="level2">
        <h2>--filter-prod &#x3C;filtering_pattern></h2>
        <p>
          Acts the same a <code>--filter</code> but omits <code>devDependencies</code> when selecting dependency projects
          from the workspace.
        </p>
      </section>
      <section id="--test-pattern-glob" class="level2">
        <h2>--test-pattern &#x3C;glob></h2>
        <p>
          <code>test-pattern</code> allows detecting whether the modified files are related to tests.
          If they are, the dependent packages of such modified packages are not included.
        </p>
        <p>
          This option is useful with the changed since filter. For instance, the next
          command will run tests in all changed packages, and if the changes are in the
          source code of the package, tests will run in the dependent packages as well:
        </p>
        <pre class="language-sh"><code class="language-sh">pnpm --filter=...[origin/master] --test-pattern=test/* test</code></pre>
      </section>
      <section id="--changed-files-ignore-pattern-glob" class="level2">
        <h2>--changed-files-ignore-pattern &#x3C;glob></h2>
        <p>Allows to ignore changed files by glob patterns when filtering for changed projects since the specified commit/branch.</p>
        <p>Usage example:</p>
        <pre class="language-sh"><code class="language-sh">pnpm --filter=...[origin/master] --changed-files-ignore-pattern=**/README.html) run build</code></pre>
        <p><span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span></p>
      </section>
    </section>
  </body>
</html>
