<!doctype html><html lang="en"><meta charset="utf-8"><title>Injection scopes</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="injection-scopes"class="level3"><h3>Injection scopes</h3><p>For people coming from different programming language backgrounds, it might be unexpected to learn that in Nest, almost everything is shared across incoming requests. We have a connection pool to the database, singleton services with global state, etc. Remember that Node.js doesn't follow the request/response Multi-Threaded Stateless Model in which every request is processed by a separate thread. Hence, using singleton instances is fully <strong>safe</strong> for our applications.<p>However, there are edge-cases when request-based lifetime may be the desired behavior, for instance per-request caching in GraphQL applications, request tracking, and multi-tenancy. Injection scopes provide a mechanism to obtain the desired provider lifetime behavior.<section id="provider-scope"class="level4"><h4>Provider scope</h4><p>A provider can have any of the following scopes:<table><tr><td><code>DEFAULT</code><td>A single instance of the provider is shared across the entire application. The instance lifetime is tied directly to the application lifecycle. Once the application has bootstrapped, all singleton providers have been instantiated. Singleton scope is used by default.<tr><td><code>REQUEST</code><td>A new instance of the provider is created exclusively for each incoming <strong>request</strong>. The instance is garbage-collected after the request has completed processing.<tr><td><code>TRANSIENT</code><td>Transient providers are not shared across consumers. Each consumer that injects a transient provider will receive a new, dedicated instance.</table><blockquote><p>info <strong>Hint</strong> Using singleton scope is <strong>recommended</strong> for most use cases. Sharing providers across consumers and across requests means that an instance can be cached and its initialization occurs only once, during application startup.</blockquote></section><section id="usage"class="level4"><h4>Usage</h4><p>Specify injection scope by passing the <code>scope</code> property to the <code>@Injectable()</code> decorator options object:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">Injectable</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Scope</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> scope<span class="token operator">:</span> <span class="token maybe-class-name">Scope</span><span class="token punctuation">.</span><span class="token constant">REQUEST</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">CatsService</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>Similarly, for <a href="/fundamentals/custom-providers">custom providers</a>, set the <code>scope</code> property in the long-hand form for a provider registration:<pre class="language-typescript"><code class="language-typescript"><span class="token punctuation">{</span>
  provide<span class="token operator">:</span> <span class="token string">'CACHE_MANAGER'</span><span class="token punctuation">,</span>
  useClass<span class="token operator">:</span> <span class="token maybe-class-name">CacheManager</span><span class="token punctuation">,</span>
  scope<span class="token operator">:</span> <span class="token maybe-class-name">Scope</span><span class="token punctuation">.</span><span class="token constant">TRANSIENT</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></code></pre><blockquote><p>info <strong>Hint</strong> Import the <code>Scope</code> enum from <code>@nestjs/common</code></blockquote><p>Singleton scope is used by default, and need not be declared. If you do want to declare a provider as singleton scoped, use the <code>Scope.DEFAULT</code> value for the <code>scope</code> property.<blockquote><p>warning <strong>Notice</strong> Websocket Gateways should not use request-scoped providers because they must act as singletons. Each gateway encapsulates a real socket and cannot be instantiated multiple times. The limitation also applies to some other providers, like <a href="../security/authentication#request-scoped-strategies"><em>Passport strategies</em></a> or <em>Cron controllers</em>.</blockquote></section><section id="controller-scope"class="level4"><h4>Controller scope</h4><p>Controllers can also have scope, which applies to all request method handlers declared in that controller. Like provider scope, the scope of a controller declares its lifetime. For a request-scoped controller, a new instance is created for each inbound request, and garbage-collected when the request has completed processing.<p>Declare controller scope with the <code>scope</code> property of the <code>ControllerOptions</code> object:<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Controller</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  path<span class="token operator">:</span> <span class="token string">'cats'</span><span class="token punctuation">,</span>
  scope<span class="token operator">:</span> <span class="token maybe-class-name">Scope</span><span class="token punctuation">.</span><span class="token constant">REQUEST</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">CatsController</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></section><section id="scope-hierarchy"class="level4"><h4>Scope hierarchy</h4><p>The <code>REQUEST</code> scope bubbles up the injection chain. A controller that depends on a request-scoped provider will, itself, be request-scoped.<p>Imagine the following dependency graph: <code>CatsController &#x3C;- CatsService &#x3C;- CatsRepository</code>. If <code>CatsService</code> is request-scoped (and the others are default singletons), the <code>CatsController</code> will become request-scoped as it is dependent on the injected service. The <code>CatsRepository</code>, which is not dependent, would remain singleton-scoped.<p>Transient-scoped dependencies don't follow that pattern. If a singleton-scoped <code>DogsService</code> injects a transient <code>LoggerService</code> provider, it will receive a fresh instance of it. However, <code>DogsService</code> will stay singleton-scoped, so injecting it anywhere would <em>not</em> resolve to a new instance of <code>DogsService</code>. In case it's desired behavior, <code>DogsService</code> must be explicitly marked as <code>TRANSIENT</code> as well.<p><app-banner-courses></app-banner-courses></section><section id="request-provider"class="level4"><h4>Request provider</h4><p>In an HTTP server-based application (e.g., using <code>@nestjs/platform-express</code> or <code>@nestjs/platform-fastify</code>), you may want to access a reference to the original request object when using request-scoped providers. You can do this by injecting the <code>REQUEST</code> object.<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">Injectable</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Scope</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Inject</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token punctuation">{</span> <span class="token constant">REQUEST</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/core'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">Request</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'express'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> scope<span class="token operator">:</span> <span class="token maybe-class-name">Scope</span><span class="token punctuation">.</span><span class="token constant">REQUEST</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">CatsService</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token constant">REQUEST</span><span class="token punctuation">)</span> <span class="token keyword">private</span> request<span class="token operator">:</span> <span class="token maybe-class-name">Request</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Because of underlying platform/protocol differences, you access the inbound request slightly differently for Microservice or GraphQL applications. In <a href="/graphql/quick-start">GraphQL</a> applications, you inject <code>CONTEXT</code> instead of <code>REQUEST</code>:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">Injectable</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Scope</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Inject</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token punctuation">{</span> <span class="token constant">CONTEXT</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/graphql'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> scope<span class="token operator">:</span> <span class="token maybe-class-name">Scope</span><span class="token punctuation">.</span><span class="token constant">REQUEST</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">CatsService</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token constant">CONTEXT</span><span class="token punctuation">)</span> <span class="token keyword">private</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>You then configure your <code>context</code> value (in the <code>GraphQLModule</code>) to contain <code>request</code> as its property.</section><section id="inquirer-provider"class="level4"><h4>Inquirer provider</h4><p>If you want to get the class where a provider was constructed, for instance in logging or metrics providers, you can inject the <code>INQUIRER</code> token.<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">Inject</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Injectable</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Scope</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token punctuation">{</span> <span class="token constant">INQUIRER</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/core'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> scope<span class="token operator">:</span> <span class="token maybe-class-name">Scope</span><span class="token punctuation">.</span><span class="token constant">TRANSIENT</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">HelloService</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token constant">INQUIRER</span><span class="token punctuation">)</span> <span class="token keyword">private</span> parentClass<span class="token operator">:</span> object<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token function">sayHello</span><span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">parentClass</span><span class="token operator">?.</span>constructor<span class="token operator">?.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>message<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>And then use it as follows:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">Injectable</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">HelloService</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./hello.service'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">AppService</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> helloService<span class="token operator">:</span> <span class="token maybe-class-name">HelloService</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token function">getRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">helloService</span><span class="token punctuation">.</span><span class="token method function property-access">sayHello</span><span class="token punctuation">(</span><span class="token string">'My name is getRoot'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword control-flow">return</span> <span class="token string">'Hello world!'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>In the example above when <code>AppService#getRoot</code> is called, <code>"AppService: My name is getRoot"</code> will be logged to the console.</section><section id="performance"class="level4"><h4>Performance</h4><p>Using request-scoped providers will have an impact on application performance. While Nest tries to cache as much metadata as possible, it will still have to create an instance of your class on each request. Hence, it will slow down your average response time and overall benchmarking result. Unless a provider must be request-scoped, it is strongly recommended that you use the default singleton scope.<blockquote><p>info <strong>Hint</strong> Although it all sounds quite intimidating, a properly designed application that leverages request-scoped providers should not slow down by more than ~5% latency-wise.</blockquote></section><section id="durable-providers"class="level4"><h4>Durable providers</h4><p>Request-scoped providers, as mentioned in the section above, may lead to increased latency since having at least 1 request-scoped provider (injected into the controller instance, or deeper - injected into one of its providers) makes the controller request-scoped as well. That means, it must be recreated (instantiated) per each individual request (and garbage collected afterwards). Now, that also means, that for let's say 30k requests in parallel, there will be 30k ephemeral instances of the controller (and its request-scoped providers).<p>Having a common provider that most providers depend on (think of a database connection, or a logger service), automatically converts all those providers to request-scoped providers as well. This can pose a challenge in <strong>multi-tenant applications</strong>, especially for those that have a central request-scoped "data source" provider that grabs headers/token from the request object and based on its values, retrieves the corresponding database connection/schema (specific to that tenant).<p>For instance, let's say you have an application alternately used by 10 different customers. Each customer has its <strong>own dedicated data source</strong>, and you want to make sure customer A will never be able to reach customer's B database. One way to achieve this could be to declare a request-scoped "data source" provider that - based on the request object - determines what's the "current customer" and retrieves its corresponding database. With this approach, you can turn your application into a multi-tenant application in just a few minutes. But, a major downside to this approach is that since most likely a large chunk of your application' components rely on the "data source" provider, they will implicitly become "request-scoped", and therefore you will undoubtedly see an impact in your apps performance.<p>But what if we had a better solution? Since we only have 10 customers, couldn't we have 10 individual <a href="/fundamentals/module-ref#resolving-scoped-providers">DI sub-trees</a> per customer (instead of recreating each tree per request)? If your providers don't rely on any property that's truly unique for each consecutive request (e.g., request UUID) but instead there're some specific attributes that let us aggregate (classify) them, there's no reason to <em>recreate DI sub-tree</em> on every incoming request.<p>And that's exactly when the <strong>durable providers</strong> come in handy.<p>Before we start flagging providers as durable, we must first register a <strong>strategy</strong> that instructs Nest what are those "common request attributes", provide logic that groups requests - associates them with their corresponding DI sub-trees.<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>
  <span class="token maybe-class-name">HostComponentInfo</span><span class="token punctuation">,</span>
  <span class="token maybe-class-name">ContextId</span><span class="token punctuation">,</span>
  <span class="token maybe-class-name">ContextIdFactory</span><span class="token punctuation">,</span>
  <span class="token maybe-class-name">ContextIdStrategy</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/core'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">Request</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'express'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> tenants <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token maybe-class-name">ContextId</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">AggregateByTenantContextIdStrategy</span></span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token maybe-class-name">ContextIdStrategy</span></span> <span class="token punctuation">{</span>
  <span class="token function">attach</span><span class="token punctuation">(</span>contextId<span class="token operator">:</span> <span class="token maybe-class-name">ContextId</span><span class="token punctuation">,</span> request<span class="token operator">:</span> <span class="token maybe-class-name">Request</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> tenantId <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token property-access">headers</span><span class="token punctuation">[</span><span class="token string">'x-tenant-id'</span><span class="token punctuation">]</span> <span class="token keyword module">as</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> tenantSubTreeId<span class="token operator">:</span> <span class="token maybe-class-name">ContextId</span><span class="token punctuation">;</span>

    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>tenants<span class="token punctuation">.</span><span class="token method function property-access">has</span><span class="token punctuation">(</span>tenantId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      tenantSubTreeId <span class="token operator">=</span> tenants<span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span>tenantId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
      tenantSubTreeId <span class="token operator">=</span> <span class="token maybe-class-name">ContextIdFactory</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      tenants<span class="token punctuation">.</span><span class="token method function property-access">set</span><span class="token punctuation">(</span>tenantId<span class="token punctuation">,</span> tenantSubTreeId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// If tree is not durable, return the original "contextId" object</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>info<span class="token operator">:</span> <span class="token maybe-class-name">HostComponentInfo</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span>
      info<span class="token punctuation">.</span><span class="token property-access">isTreeDurable</span> <span class="token operator">?</span> tenantSubTreeId <span class="token operator">:</span> contextId<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><blockquote><p>info <strong>Hint</strong> Similar to the request scope, durability bubbles up the injection chain. That means if A depends on B which is flagged as <code>durable</code>, A implicitly becomes durable too (unless <code>durable</code> is explicitly set to <code>false</code> for A provider).</blockquote><blockquote><p>warning <strong>Warning</strong> Note this strategy is not ideal for applications operating with a large number of tenants.</blockquote><p>The value returned from the <code>attach</code> method instructs Nest what context identifier should be used for a given host. In this case, we specified that the <code>tenantSubTreeId</code> should be used instead of the original, auto-generated <code>contextId</code> object, when the host component (e.g., request-scoped controller) is flagged as durable (you can learn how to mark providers as durable below). Also, in this example, no payload would be registered (where payload = <code>REQUEST</code>/<code>CONTEXT</code> provider that represents the "root" - parent of the sub-tree).<p>If you want to register the payload for a durable tree, use the following construction instead:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">resolve</span><span class="token operator">:</span> <span class="token punctuation">(</span>info<span class="token operator">:</span> <span class="token maybe-class-name">HostComponentInfo</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> context <span class="token operator">=</span> info<span class="token punctuation">.</span><span class="token property-access">isTreeDurable</span> <span class="token operator">?</span> tenantSubTreeId <span class="token operator">:</span> contextId<span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> context<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  payload<span class="token operator">:</span> <span class="token punctuation">{</span> tenantId <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></code></pre><p>Now whenever you inject the <code>REQUEST</code> provider (or <code>CONTEXT</code> for GraphQL applications) using the <code>@Inject(REQUEST)</code>, the <code>payload</code> object would be injected (consisting of a single property - <code>tenantId</code> in this case).<p>Alright so with this strategy in place, you can register it somewhere in your code (as it applies globally anyway), so for example, you could place it in the <code>main.ts</code> file:<pre class="language-typescript"><code class="language-typescript"><span class="token maybe-class-name">ContextIdFactory</span><span class="token punctuation">.</span><span class="token method function property-access">apply</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">AggregateByTenantContextIdStrategy</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>info <strong>Hint</strong> The <code>ContextIdFactory</code> class is imported from the <code>@nestjs/core</code> package.</blockquote><p>As long as the registration occurs before any request hits your application, everything will work as intended.<p>Lastly, to turn a regular provider into a durable provider, simply set the <code>durable</code> flag to <code>true</code>:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">Injectable</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Scope</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> scope<span class="token operator">:</span> <span class="token maybe-class-name">Scope</span><span class="token punctuation">.</span><span class="token constant">REQUEST</span><span class="token punctuation">,</span> durable<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">CatsService</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>Similarly, for <a href="/fundamentals/custom-providers">custom providers</a>, set the <code>durable</code> property in the long-hand form for a provider registration:<pre class="language-typescript"><code class="language-typescript"><span class="token punctuation">{</span>
  provide<span class="token operator">:</span> <span class="token string">'CONNECTION_POOL'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">useFactory</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  scope<span class="token operator">:</span> <span class="token maybe-class-name">Scope</span><span class="token punctuation">.</span><span class="token constant">REQUEST</span><span class="token punctuation">,</span>
  durable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></code></pre><p><span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>