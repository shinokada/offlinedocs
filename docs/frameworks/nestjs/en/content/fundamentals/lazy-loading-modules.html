<!doctype html><html lang="en"><meta charset="utf-8"><title>Lazy-loading modules</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="lazy-loading-modules"class="level3"><h3>Lazy-loading modules</h3><p>By default, modules are eagerly loaded, which means that as soon as the application loads, so do all the modules, whether or not they are immediately necessary. While this is fine for most applications, it may become a bottleneck for apps/workers running in the <strong>serverless environment</strong>, where the startup latency ("cold start") is crucial.<p>Lazy loading can help decrease bootstrap time by loading only modules required by the specific serverless function invocation. In addition, you could also load other modules asynchronously once the serverless function is "warm" to speed-up the bootstrap time for subsequent calls even further (deferred modules registration).<blockquote><p>info <strong>Hint</strong> If you're familiar with the <strong>Angular</strong> framework, you might have seen the "lazy-loading modules" term before. Be aware that this technique is <strong>functionally different</strong> in Nest and so think about this as an entirely different feature that shares similar naming conventions.</blockquote><blockquote><p>warning <strong>Warning</strong> Do note that <a href="https://docs.nestjs.com/fundamentals/lifecycle-events">lifecycle hooks methods</a> are not invoked in lazy loaded modules and services.</blockquote><section id="getting-started"class="level4"><h4>Getting started</h4><p>To load modules on-demand, Nest provides the <code>LazyModuleLoader</code> class that can be injected into a class in the normal way:<pre class="language-typescript"><code class="language-typescript">@<span class="token decorator"><span class="token at operator">@</span><span class="token function">filename</span></span><span class="token punctuation">(</span>cats<span class="token punctuation">.</span><span class="token property-access">service</span><span class="token punctuation">)</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">CatsService</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> lazyModuleLoader<span class="token operator">:</span> <span class="token maybe-class-name">LazyModuleLoader</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
@@<span class="token keyword control-flow">switch</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Dependencies</span></span><span class="token punctuation">(</span><span class="token maybe-class-name">LazyModuleLoader</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">CatsService</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>lazyModuleLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">lazyModuleLoader</span> <span class="token operator">=</span> lazyModuleLoader<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><blockquote><p>info <strong>Hint</strong> The <code>LazyModuleLoader</code> class is imported from the <code>@nestjs/core</code> package.</blockquote><p>Alternatively, you can obtain a reference to the <code>LazyModuleLoader</code> provider from within your application bootstrap file (<code>main.ts</code>), as follows:<pre class="language-typescript"><code class="language-typescript"><span class="token comment">// "app" represents a Nest application instance</span>
<span class="token keyword">const</span> lazyModuleLoader <span class="token operator">=</span> app<span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token maybe-class-name">LazyModuleLoader</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>With this in place, you can now load any module using the following construction:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">LazyModule</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./lazy.module'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> moduleRef <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">lazyModuleLoader</span><span class="token punctuation">.</span><span class="token method function property-access">load</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">LazyModule</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>info <strong>Hint</strong> "Lazy-loaded" modules are <strong>cached</strong> upon the first <code>LazyModuleLoader#load</code> method invocation. That means, each consecutive attempt to load <code>LazyModule</code> will be <strong>very fast</strong> and will return a cached instance, instead of loading the module again.<pre class="language-bash"><code class="language-bash">Load <span class="token string">"LazyModule"</span> attempt: <span class="token number">1</span>
time: <span class="token number">2</span>.379ms
Load <span class="token string">"LazyModule"</span> attempt: <span class="token number">2</span>
time: <span class="token number">0</span>.294ms
Load <span class="token string">"LazyModule"</span> attempt: <span class="token number">3</span>
time: <span class="token number">0</span>.303ms</code></pre><p>Also, "lazy-loaded" modules share the same modules graph as those eagerly loaded on the application bootstrap as well as any other lazy modules registered later in your app.</blockquote><p>Where <code>lazy.module.ts</code> is a TypeScript file that exports a <strong>regular Nest module</strong> (no extra changes are required).<p>The <code>LazyModuleLoader#load</code> method returns the <a href="/fundamentals/module-ref">module reference</a> (of <code>LazyModule</code>) that lets you navigate the internal list of providers and obtain a reference to any provider using its injection token as a lookup key.<p>For example, let's say we have a <code>LazyModule</code> with the following definition:<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token maybe-class-name">LazyService</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  exports<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token maybe-class-name">LazyService</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">LazyModule</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><blockquote><p>info <strong>Hint</strong> Lazy-loaded modules cannot be registered as <strong>global modules</strong> as it simply makes no sense (since they are registered lazily, on-demand when all the statically registered modules have been already instantiated). Likewise, registered <strong>global enhancers</strong> (guards/interceptors/etc.) <strong>will not work</strong> properly either.</blockquote><p>With this, we could obtain a reference to the <code>LazyService</code> provider, as follows:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">LazyModule</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./lazy.module'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> moduleRef <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">lazyModuleLoader</span><span class="token punctuation">.</span><span class="token method function property-access">load</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">LazyModule</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">LazyService</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./lazy.service'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> lazyService <span class="token operator">=</span> moduleRef<span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token maybe-class-name">LazyService</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>warning <strong>Warning</strong> If you use <strong>Webpack</strong>, make sure to update your <code>tsconfig.json</code> file - setting <code>compilerOptions.module</code> to <code>"esnext"</code> and adding <code>compilerOptions.moduleResolution</code> property with <code>"node"</code> as a value:<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"module"</span><span class="token operator">:</span> <span class="token string">"esnext"</span><span class="token punctuation">,</span>
    <span class="token property">"moduleResolution"</span><span class="token operator">:</span> <span class="token string">"node"</span><span class="token punctuation">,</span>
    ...
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>With these options set up, you'll be able to leverage the <a href="https://webpack.js.org/guides/code-splitting/">code splitting</a> feature.</blockquote></section><section id="lazy-loading-controllers-gateways-and-resolvers"class="level4"><h4>Lazy-loading controllers, gateways, and resolvers</h4><p>Since controllers (or resolvers in GraphQL applications) in Nest represent sets of routes/paths/topics (or queries/mutations), you <strong>cannot lazy load them</strong> using the <code>LazyModuleLoader</code> class.<blockquote><p>error <strong>Warning</strong> Controllers, <a href="/graphql/resolvers">resolvers</a>, and <a href="/websockets/gateways">gateways</a> registered inside lazy-loaded modules will not behave as expected. Similarly, you cannot register middleware functions (by implementing the <code>MiddlewareConsumer</code> interface) on-demand.</blockquote><p>For example, let's say you're building a REST API (HTTP application) with a Fastify driver under the hood (using the <code>@nestjs/platform-fastify</code> package). Fastify does not let you register routes after the application is ready/successfully listening to messages. That means even if we analyzed route mappings registered in the module's controllers, all lazy-loaded routes wouldn't be accessible since there is no way to register them at runtime.<p>Likewise, some transport strategies we provide as part of the <code>@nestjs/microservices</code> package (including Kafka, gRPC, or RabbitMQ) require to subscribe/listen to specific topics/channels before the connection is established. Once your application starts listening to messages, the framework would not be able to subscribe/listen to new topics.<p>Lastly, the <code>@nestjs/graphql</code> package with the code first approach enabled automatically generates the GraphQL schema on-the-fly based on the metadata. That means, it requires all classes to be loaded beforehand. Otherwise, it would not be doable to create the appropriate, valid schema.</section><section id="common-use-cases"class="level4"><h4>Common use-cases</h4><p>Most commonly, you will see lazy loaded modules in situations when your worker/cron job/lambda &#x26; serverless function/webhook must trigger different services (different logic) based on the input arguments (route path/date/query parameters, etc.). On the other hand, lazy-loading modules may not make too much sense for monolithic applications, where the startup time is rather irrelevant. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>