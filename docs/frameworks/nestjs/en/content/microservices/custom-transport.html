<!doctype html><html lang="en"><meta charset="utf-8"><title>Custom transporters</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="custom-transporters"class="level3"><h3>Custom transporters</h3><p>Nest provides a variety of <strong>transporters</strong> out-of-the-box, as well as an API allowing developers to build new custom transport strategies. Transporters enable you to connect components over a network using a pluggable communications layer and a very simple application-level message protocol (read full <a href="https://dev.to/nestjs/integrate-nestjs-with-external-services-using-microservice-transporters-part-1-p3">article</a>).<blockquote><p>info <strong>Hint</strong> Building a microservice with Nest does not necessarily mean you must use the <code>@nestjs/microservices</code> package. For example, if you want to communicate with external services (let's say other microservices written in different languages), you may not need all the features provided by <code>@nestjs/microservice</code> library. In fact, if you don't need decorators (<code>@EventPattern</code> or <code>@MessagePattern</code>) that let you declaratively define subscribers, running a <a href="/application-context">Standalone Application</a> and manually maintaining connection/subscribing to channels should be enough for most use-cases and will provide you with more flexibility.</blockquote><p>With a custom transporter, you can integrate any messaging system/protocol (including Google Cloud Pub/Sub, Amazon Kinesis, and others) or extend the existing one, adding extra features on top (for example, <a href="https://github.com/mqttjs/MQTT.js/blob/master/README.md#qos">QoS</a> for MQTT).<blockquote><p>info <strong>Hint</strong> To better understand how Nest microservices work and how you can extend the capabilities of existing transporters, we recommend reading the <a href="https://dev.to/johnbiundo/series/4724">NestJS Microservices in Action</a> and <a href="https://dev.to/nestjs/part-1-introduction-and-setup-1a2l">Advanced NestJS Microservices</a> article series.</blockquote><section id="creating-a-strategy"class="level4"><h4>Creating a strategy</h4><p>First, let's define a class representing our custom transporter.<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">CustomTransportStrategy</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Server</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/microservices'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">GoogleCloudPubSubServer</span></span>
  <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">Server</span></span>
  <span class="token keyword">implements</span> <span class="token class-name"><span class="token maybe-class-name">CustomTransportStrategy</span></span> <span class="token punctuation">{</span>
  <span class="token doc-comment comment">/**
   * This method is triggered when you run "app.listen()".
   */</span>
  <span class="token function">listen</span><span class="token punctuation">(</span><span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token doc-comment comment">/**
   * This method is triggered on application shutdown.
   */</span>
  <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><blockquote><p>warning <strong>Warning</strong> Please, note we won't be implementing a fully-featured Google Cloud Pub/Sub server in this chapter as this would require diving into transporter specific technical details.</blockquote><p>In our example above, we declared the <code>GoogleCloudPubSubServer</code> class and provided <code>listen()</code> and <code>close()</code> methods enforced by the <code>CustomTransportStrategy</code> interface. Also, our class extends the <code>Server</code> class imported from the <code>@nestjs/microservices</code> package that provides a few useful methods, for example, methods used by Nest runtime to register message handlers. Alternatively, in case you want to extend the capabilities of an existing transport strategy, you could extend the corresponding server class, for example, <code>ServerRedis</code>. Conventionally, we added the <code>"Server"</code> suffix to our class as it will be responsible for subscribing to messages/events (and responding to them, if necessary).<p>With this in place, we can now use our custom strategy instead of using a built-in transporter, as follows:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token maybe-class-name">NestFactory</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">createMicroservice</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">MicroserviceOptions</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
  <span class="token maybe-class-name">AppModule</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    strategy<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">GoogleCloudPubSubServer</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Basically, instead of passing the normal transporter options object with <code>transport</code> and <code>options</code> properties, we pass a single property, <code>strategy</code>, whose value is an instance of our custom transporter class.<p>Back to our <code>GoogleCloudPubSubServer</code> class, in a real-world application, we would be establishing a connection to our message broker/external service and registering subscribers/listening to specific channels in <code>listen()</code> method (and then removing subscriptions &#x26; closing the connection in the <code>close()</code> teardown method), but since this requires a good understanding of how Nest microservices communicate with each other, we recommend reading this <a href="https://dev.to/nestjs/part-1-introduction-and-setup-1a2l">article series</a>. In this chapter instead, we'll focus on the capabilities the <code>Server</code> class provides and how you can leverage them to build custom strategies.<p>For example, let's say that somewhere in our application, the following message handler is defined:<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">MessagePattern</span></span><span class="token punctuation">(</span><span class="token string">'echo'</span><span class="token punctuation">)</span>
<span class="token function">echo</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Payload</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> data<span class="token operator">:</span> object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> data<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>This message handler will be automatically registered by Nest runtime. With <code>Server</code> class, you can see what message patterns have been registered and also, access and execute the actual methods that were assigned to them. To test this out, let's add a simple <code>console.log</code> inside <code>listen()</code> method before <code>callback</code> function is called:<pre class="language-typescript"><code class="language-typescript"><span class="token function">listen</span><span class="token punctuation">(</span><span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">messageHandlers</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>After your application restarts, you'll see the following log in your terminal:<pre class="language-typescript"><code class="language-typescript"><span class="token known-class-name class-name">Map</span> <span class="token punctuation">{</span> <span class="token string">'echo'</span> <span class="token arrow operator">=></span> <span class="token punctuation">[</span><span class="token maybe-class-name">AsyncFunction</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> isEventHandler<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><blockquote><p>info <strong>Hint</strong> If we used the <code>@EventPattern</code> decorator, you would see the same output, but with the <code>isEventHandler</code> property set to <code>true</code>.</blockquote><p>As you can see, the <code>messageHandlers</code> property is a <code>Map</code> collection of all message (and event) handlers, in which patterns are being used as keys. Now, you can use a key (for example, <code>"echo"</code>) to receive a reference to the message handler:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">async</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> echoHandler <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">messageHandlers</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token string">'echo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword control-flow">await</span> <span class="token function">echoHandler</span><span class="token punctuation">(</span><span class="token string">'Hello world!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Once we execute the <code>echoHandler</code> passing an arbitrary string as an argument (<code>"Hello world!"</code> here), we should see it in the console:<pre class="language-json"><code class="language-json">Hello world!</code></pre><p>Which means that our method handler was properly executed.</section><section id="client-proxy"class="level4"><h4>Client proxy</h4><p>As we mentioned in the first section, you don't necessarily need to use the <code>@nestjs/microservices</code> package to create microservices, but if you decide to do so and you need to integrate a custom strategy, you will need to provide a "client" class too.<blockquote><p>info <strong>Hint</strong> Again, implementing a fully-featured client class compatible with all <code>@nestjs/microservices</code> features (e.g., streaming) requires a good understading of communication techniques used by the framework. To learn more, check out this <a href="https://dev.to/nestjs/part-4-basic-client-component-16f9">article</a>.</blockquote><p>To communicate with an external service/emit &#x26; publish messages (or events) you can either use a library-specific SDK package, or implement a custom client class that extends the <code>ClientProxy</code>, as follows:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">ClientProxy</span><span class="token punctuation">,</span> <span class="token maybe-class-name">ReadPacket</span><span class="token punctuation">,</span> <span class="token maybe-class-name">WritePacket</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/microservices'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">GoogleCloudPubSubClient</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">ClientProxy</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">async</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">async</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">async</span> <span class="token function">dispatchEvent</span><span class="token punctuation">(</span>packet<span class="token operator">:</span> <span class="token maybe-class-name">ReadPacket</span><span class="token operator">&#x3C;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">publish</span><span class="token punctuation">(</span>
    packet<span class="token operator">:</span> <span class="token maybe-class-name">ReadPacket</span><span class="token operator">&#x3C;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">,</span>
    <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>packet<span class="token operator">:</span> <span class="token maybe-class-name">WritePacket</span><span class="token operator">&#x3C;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Function</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><blockquote><p>warning <strong>Warning</strong> Please, note we won't be implementing a fully-featured Google Cloud Pub/Sub client in this chapter as this would require diving into transporter specific technical details.</blockquote><p>As you can see, <code>ClientProxy</code> class requires us to provide several methods for establishing &#x26; closing the connection and publishing messages (<code>publish</code>) and events (<code>dispatchEvent</code>). Note, if you don't need a request-response communication style support, you can leave the <code>publish()</code> method empty. Likewise, if you don't need to support event-based communication, skip the <code>dispatchEvent()</code> method.<p>To observe what and when those methods are executed, let's add multiple <code>console.log</code> calls, as follows:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">GoogleCloudPubSubClient</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">ClientProxy</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">async</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'connect'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">async</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">async</span> <span class="token function">dispatchEvent</span><span class="token punctuation">(</span>packet<span class="token operator">:</span> <span class="token maybe-class-name">ReadPacket</span><span class="token operator">&#x3C;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'event to dispatch: '</span><span class="token punctuation">,</span> packet<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">publish</span><span class="token punctuation">(</span>
    packet<span class="token operator">:</span> <span class="token maybe-class-name">ReadPacket</span><span class="token operator">&#x3C;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">,</span>
    <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>packet<span class="token operator">:</span> <span class="token maybe-class-name">WritePacket</span><span class="token operator">&#x3C;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Function</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'message:'</span><span class="token punctuation">,</span> packet<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// In a real-world application, the "callback" function should be executed</span>
    <span class="token comment">// with payload sent back from the responder. Here, we'll simply simulate (5 seconds delay)</span>
    <span class="token comment">// that response came through by passing the same "data" as we've originally passed in.</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">{</span> response<span class="token operator">:</span> packet<span class="token punctuation">.</span><span class="token property-access">data</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'teardown'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>With this in place, let's create an instance of <code>GoogleCloudPubSubClient</code> class and run the <code>send()</code> method (which you might have seen in earlier chapters), subscribing to the returned observable stream.<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> googlePubSubClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">GoogleCloudPubSubClient</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
googlePubSubClient
  <span class="token punctuation">.</span><span class="token method function property-access">send</span><span class="token punctuation">(</span><span class="token string">'pattern'</span><span class="token punctuation">,</span> <span class="token string">'Hello world!'</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token method function property-access">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Now, you should see the following output in your terminal:<pre class="language-typescript"><code class="language-typescript">connect
message<span class="token operator">:</span> <span class="token punctuation">{</span> pattern<span class="token operator">:</span> <span class="token string">'pattern'</span><span class="token punctuation">,</span> data<span class="token operator">:</span> <span class="token string">'Hello world!'</span> <span class="token punctuation">}</span>
<span class="token maybe-class-name">Hello</span> world<span class="token operator">!</span> <span class="token comment">// &#x3C;-- after 5 seconds</span></code></pre><p>To test if our "teardown" method (which our <code>publish()</code> method returns) is properly executed, let's apply a timeout operator to our stream, setting it to 2 seconds to make sure it throws earlier then our <code>setTimeout</code> calls the <code>callback</code> function.<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> googlePubSubClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">GoogleCloudPubSubClient</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
googlePubSubClient
  <span class="token punctuation">.</span><span class="token method function property-access">send</span><span class="token punctuation">(</span><span class="token string">'pattern'</span><span class="token punctuation">,</span> <span class="token string">'Hello world!'</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token method function property-access">pipe</span><span class="token punctuation">(</span><span class="token function">timeout</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token method function property-access">subscribe</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">error</span><span class="token punctuation">(</span>error<span class="token punctuation">.</span><span class="token property-access">message</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>info <strong>Hint</strong> The <code>timeout</code> operator is imported from the <code>rxjs/operators</code> package.</blockquote><p>With <code>timeout</code> operator applied, your terminal output should look as follows:<pre class="language-typescript"><code class="language-typescript">connect
message<span class="token operator">:</span> <span class="token punctuation">{</span> pattern<span class="token operator">:</span> <span class="token string">'pattern'</span><span class="token punctuation">,</span> data<span class="token operator">:</span> <span class="token string">'Hello world!'</span> <span class="token punctuation">}</span>
teardown <span class="token comment">// &#x3C;-- teardown</span>
<span class="token maybe-class-name">Timeout</span> has occurred</code></pre><p>To dispatch an event (instead of sending a message), use the <code>emit()</code> method:<pre class="language-typescript"><code class="language-typescript">googlePubSubClient<span class="token punctuation">.</span><span class="token method function property-access">emit</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">,</span> <span class="token string">'Hello world!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>And that's what you should see in the console:<pre class="language-typescript"><code class="language-typescript">connect
event to dispatch<span class="token operator">:</span>  <span class="token punctuation">{</span> pattern<span class="token operator">:</span> <span class="token string">'event'</span><span class="token punctuation">,</span> data<span class="token operator">:</span> <span class="token string">'Hello world!'</span> <span class="token punctuation">}</span></code></pre></section><section id="message-serialization"class="level4"><h4>Message serialization</h4><p>If you need to add some custom logic around the serialization of responses on the client side, you can use a custom class that extends the <code>ClientProxy</code> class or one of its child classes. For modifying successful requests you can override the <code>serializeResponse</code> method, and for modifying any errors that go through this client you can override the <code>serializeError</code> method. To make use of this custom class, you can pass the class itself to the <code>ClientsModule.register()</code> method using the <code>customClass</code> property. Below is an example of a custom <code>ClientProxy</code> that serializes each error into an <code>RpcException</code>.<pre class="language-typescript"><code class="language-typescript">@<span class="token decorator"><span class="token at operator">@</span><span class="token function">filename</span></span><span class="token punctuation">(</span>error<span class="token operator">-</span>handling<span class="token punctuation">.</span><span class="token property-access">proxy</span><span class="token punctuation">)</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">ClientTcp</span><span class="token punctuation">,</span> <span class="token maybe-class-name">RpcException</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/microservices'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">ErrorHandlingProxy</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">ClientTCP</span></span> <span class="token punctuation">{</span>
  <span class="token function">serializeError</span><span class="token punctuation">(</span>err<span class="token operator">:</span> <span class="token known-class-name class-name">Error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">RpcException</span></span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>and then use it in the <code>ClientsModule</code> like so:<pre class="language-typescript"><code class="language-typescript">@<span class="token decorator"><span class="token at operator">@</span><span class="token function">filename</span></span><span class="token punctuation">(</span>app<span class="token punctuation">.</span><span class="token property-access">module</span><span class="token punctuation">)</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  imports<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token maybe-class-name">ClientsModule</span><span class="token punctuation">.</span><span class="token method function property-access">register</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      name<span class="token operator">:</span> <span class="token string">'CustomProxy'</span><span class="token punctuation">,</span>
      customClass<span class="token operator">:</span> <span class="token maybe-class-name">ErrorHandlingProxy</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">AppModule</span></span></code></pre><blockquote><p>info <strong>hint</strong> This is the class itself being passed to <code>customClass</code>, not an instance of the class. Nest will create the instance under the hood for you, and will pass any options given to the <code>options</code> property to the new <code>ClientProxy</code>. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></blockquote></section></section>