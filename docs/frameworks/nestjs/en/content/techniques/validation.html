<!doctype html><html lang="en"><meta charset="utf-8"><title>Validation</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="validation"class="level3"><h3>Validation</h3><p>It is best practice to validate the correctness of any data sent into a web application. To automatically validate incoming requests, Nest provides several pipes available right out-of-the-box:<ul><li><code>ValidationPipe</code><li><code>ParseIntPipe</code><li><code>ParseBoolPipe</code><li><code>ParseArrayPipe</code><li><code>ParseUUIDPipe</code></ul><p>The <code>ValidationPipe</code> makes use of the powerful <a href="https://github.com/typestack/class-validator">class-validator</a> package and its declarative validation decorators. The <code>ValidationPipe</code> provides a convenient approach to enforce validation rules for all incoming client payloads, where the specific rules are declared with simple annotations in local class/DTO declarations in each module.<section id="overview"class="level4"><h4>Overview</h4><p>In the <a href="/pipes">Pipes</a> chapter, we went through the process of building simple pipes and binding them to controllers, methods or to the global app to demonstrate how the process works. Be sure to review that chapter to best understand the topics of this chapter. Here, we'll focus on various <strong>real world</strong> use cases of the <code>ValidationPipe</code>, and show how to use some of its advanced customization features.</section><section id="using-the-built-in-validationpipe"class="level4"><h4>Using the built-in ValidationPipe</h4><p>To begin using it, we first install the required dependency.<pre class="language-bash"><code class="language-bash">$ <span class="token function">npm</span> i --save class-validator class-transformer</code></pre><blockquote><p>info <strong>Hint</strong> The <code>ValidationPipe</code> is exported from the <code>@nestjs/common</code> package.</blockquote><p>Because this pipe uses the <a href="https://github.com/typestack/class-validator"><code>class-validator</code></a> and <a href="https://github.com/typestack/class-transformer"><code>class-transformer</code></a> libraries, there are many options available. You configure these settings via a configuration object passed to the pipe. Following are the built-in options:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">export</span> <span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">ValidationPipeOptions</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">ValidatorOptions</span></span> <span class="token punctuation">{</span>
  transform<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  disableErrorMessages<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  exceptionFactory<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span>errors<span class="token operator">:</span> <span class="token known-class-name class-name">ValidationError</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>In addition to these, all <code>class-validator</code> options (inherited from the <code>ValidatorOptions</code> interface) are available:<table><tr><th>Option<th>Type<th>Description<tr><td><code>enableDebugMessages</code><td><code>boolean</code><td>If set to true, validator will print extra warning messages to the console when something is not right.<tr><td><code>skipUndefinedProperties</code><td><code>boolean</code><td>If set to true then validator will skip validation of all properties that are undefined in the validating object.<tr><td><code>skipNullProperties</code><td><code>boolean</code><td>If set to true then validator will skip validation of all properties that are null in the validating object.<tr><td><code>skipMissingProperties</code><td><code>boolean</code><td>If set to true then validator will skip validation of all properties that are null or undefined in the validating object.<tr><td><code>whitelist</code><td><code>boolean</code><td>If set to true, validator will strip validated (returned) object of any properties that do not use any validation decorators.<tr><td><code>forbidNonWhitelisted</code><td><code>boolean</code><td>If set to true, instead of stripping non-whitelisted properties validator will throw an exception.<tr><td><code>forbidUnknownValues</code><td><code>boolean</code><td>If set to true, attempts to validate unknown objects fail immediately.<tr><td><code>disableErrorMessages</code><td><code>boolean</code><td>If set to true, validation errors will not be returned to the client.<tr><td><code>errorHttpStatusCode</code><td><code>number</code><td>This setting allows you to specify which exception type will be used in case of an error. By default it throws <code>BadRequestException</code>.<tr><td><code>exceptionFactory</code><td><code>Function</code><td>Takes an array of the validation errors and returns an exception object to be thrown.<tr><td><code>groups</code><td><code>string[]</code><td>Groups to be used during validation of the object.<tr><td><code>always</code><td><code>boolean</code><td>Set default for <code>always</code> option of decorators. Default can be overridden in decorator options<tr><td><code>strictGroups</code><td><code>boolean</code><td>If <code>groups</code> is not given or is empty, ignore decorators with at least one group.<tr><td><code>dismissDefaultMessages</code><td><code>boolean</code><td>If set to true, the validation will not use default messages. Error message always will be <code>undefined</code> if its not explicitly set.<tr><td><code>validationError.target</code><td><code>boolean</code><td>Indicates if target should be exposed in <code>ValidationError</code>.<tr><td><code>validationError.value</code><td><code>boolean</code><td>Indicates if validated value should be exposed in <code>ValidationError</code>.<tr><td><code>stopAtFirstError</code><td><code>boolean</code><td>When set to true, validation of the given property will stop after encountering the first error. Defaults to false.</table><blockquote><p>info <strong>Notice</strong> Find more information about the <code>class-validator</code> package in its <a href="https://github.com/typestack/class-validator">repository</a>.</blockquote></section><section id="auto-validation"class="level4"><h4>Auto-validation</h4><p>We'll start by binding <code>ValidationPipe</code> at the application level, thus ensuring all endpoints are protected from receiving incorrect data.<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">bootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token maybe-class-name">NestFactory</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span><span class="token maybe-class-name">AppModule</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  app<span class="token punctuation">.</span><span class="token method function property-access">useGlobalPipes</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">ValidationPipe</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">await</span> app<span class="token punctuation">.</span><span class="token method function property-access">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">bootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>To test our pipe, let's create a basic endpoint.<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Post</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">create</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Body</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> createUserDto<span class="token operator">:</span> <span class="token maybe-class-name">CreateUserDto</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token string">'This action adds a new user'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><blockquote><p>info <strong>Hint</strong> Since TypeScript does not store metadata about <strong>generics or interfaces</strong>, when you use them in your DTOs, <code>ValidationPipe</code> may not be able to properly validate incoming data. For this reason, consider using concrete classes in your DTOs.</blockquote><blockquote><p>info <strong>Hint</strong> When importing your DTOs, you can't use a type-only import as that would be erased at runtime, i.e. remember to <code>import {{ '{' }} CreateUserDto {{ '}' }}</code> instead of <code>import type {{ '{' }} CreateUserDto {{ '}' }}</code>.</blockquote><p>Now we can add a few validation rules in our <code>CreateUserDto</code>. We do this using decorators provided by the <code>class-validator</code> package, described in detail <a href="https://github.com/typestack/class-validator#validation-decorators">here</a>. In this fashion, any route that uses the <code>CreateUserDto</code> will automatically enforce these validation rules.<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">IsEmail</span><span class="token punctuation">,</span> <span class="token maybe-class-name">IsNotEmpty</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'class-validator'</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">CreateUserDto</span></span> <span class="token punctuation">{</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">IsEmail</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  email<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

  <span class="token decorator"><span class="token at operator">@</span><span class="token function">IsNotEmpty</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  password<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>With these rules in place, if a request hits our endpoint with an invalid <code>email</code> property in the request body, the application will automatically respond with a <code>400 Bad Request</code> code, along with the following response body:<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"statusCode"</span><span class="token operator">:</span> <span class="token number">400</span><span class="token punctuation">,</span>
  <span class="token property">"error"</span><span class="token operator">:</span> <span class="token string">"Bad Request"</span><span class="token punctuation">,</span>
  <span class="token property">"message"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"email must be an email"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre><p>In addition to validating request bodies, the <code>ValidationPipe</code> can be used with other request object properties as well. Imagine that we would like to accept <code>:id</code> in the endpoint path. To ensure that only numbers are accepted for this request parameter, we can use the following construct:<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token string">':id'</span><span class="token punctuation">)</span>
<span class="token function">findOne</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Param</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> params<span class="token operator">:</span> <span class="token maybe-class-name">FindOneParams</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token string">'This action returns a user'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><code>FindOneParams</code>, like a DTO, is simply a class that defines validation rules using <code>class-validator</code>. It would look like this:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">IsNumberString</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'class-validator'</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">FindOneParams</span></span> <span class="token punctuation">{</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">IsNumberString</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></section><section id="disable-detailed-errors"class="level4"><h4>Disable detailed errors</h4><p>Error messages can be helpful to explain what was incorrect in a request. However, some production environments prefer to disable detailed errors. Do this by passing an options object to the <code>ValidationPipe</code>:<pre class="language-typescript"><code class="language-typescript">app<span class="token punctuation">.</span><span class="token method function property-access">useGlobalPipes</span><span class="token punctuation">(</span>
  <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">ValidationPipe</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    disableErrorMessages<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>As a result, detailed error messages won't be displayed in the response body.</section><section id="stripping-properties"class="level4"><h4>Stripping properties</h4><p>Our <code>ValidationPipe</code> can also filter out properties that should not be received by the method handler. In this case, we can <strong>whitelist</strong> the acceptable properties, and any property not included in the whitelist is automatically stripped from the resulting object. For example, if our handler expects <code>email</code> and <code>password</code> properties, but a request also includes an <code>age</code> property, this property can be automatically removed from the resulting DTO. To enable such behavior, set <code>whitelist</code> to <code>true</code>.<pre class="language-typescript"><code class="language-typescript">app<span class="token punctuation">.</span><span class="token method function property-access">useGlobalPipes</span><span class="token punctuation">(</span>
  <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">ValidationPipe</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    whitelist<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>When set to true, this will automatically remove non-whitelisted properties (those without any decorator in the validation class).<p>Alternatively, you can stop the request from processing when non-whitelisted properties are present, and return an error response to the user. To enable this, set the <code>forbidNonWhitelisted</code> option property to <code>true</code>, in combination with setting <code>whitelist</code> to <code>true</code>.<p><app-banner-courses></app-banner-courses></section><section id="transform-payload-objects"class="level4"><h4>Transform payload objects</h4><p>Payloads coming in over the network are plain JavaScript objects. The <code>ValidationPipe</code> can automatically transform payloads to be objects typed according to their DTO classes. To enable auto-transformation, set <code>transform</code> to <code>true</code>. This can be done at a method level:<pre class="language-typescript"><code class="language-typescript">@<span class="token decorator"><span class="token at operator">@</span><span class="token function">filename</span></span><span class="token punctuation">(</span>cats<span class="token punctuation">.</span><span class="token property-access">controller</span><span class="token punctuation">)</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Post</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">UsePipes</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">ValidationPipe</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> transform<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Body</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> createCatDto<span class="token operator">:</span> <span class="token maybe-class-name">CreateCatDto</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">catsService</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>createCatDto<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>To enable this behavior globally, set the option on a global pipe:<pre class="language-typescript"><code class="language-typescript">app<span class="token punctuation">.</span><span class="token method function property-access">useGlobalPipes</span><span class="token punctuation">(</span>
  <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">ValidationPipe</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    transform<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>With the auto-transformation option enabled, the <code>ValidationPipe</code> will also perform conversion of primitive types. In the following example, the <code>findOne()</code> method takes one argument which represents an extracted <code>id</code> path parameter:<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token string">':id'</span><span class="token punctuation">)</span>
<span class="token function">findOne</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Param</span></span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> id <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
  <span class="token keyword control-flow">return</span> <span class="token string">'This action returns a user'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>By default, every path parameter and query parameter comes over the network as a <code>string</code>. In the above example, we specified the <code>id</code> type as a <code>number</code> (in the method signature). Therefore, the <code>ValidationPipe</code> will try to automatically convert a string identifier to a number.</section><section id="explicit-conversion"class="level4"><h4>Explicit conversion</h4><p>In the above section, we showed how the <code>ValidationPipe</code> can implicitly transform query and path parameters based on the expected type. However, this feature requires having auto-transformation enabled.<p>Alternatively (with auto-transformation disabled), you can explicitly cast values using the <code>ParseIntPipe</code> or <code>ParseBoolPipe</code> (note that <code>ParseStringPipe</code> is not needed because, as mentioned earlier, every path parameter and query parameter comes over the network as a <code>string</code> by default).<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token string">':id'</span><span class="token punctuation">)</span>
<span class="token function">findOne</span><span class="token punctuation">(</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Param</span></span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token maybe-class-name">ParseIntPipe</span><span class="token punctuation">)</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Query</span></span><span class="token punctuation">(</span><span class="token string">'sort'</span><span class="token punctuation">,</span> <span class="token maybe-class-name">ParseBoolPipe</span><span class="token punctuation">)</span> sort<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> id <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> sort <span class="token operator">===</span> <span class="token string">'boolean'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
  <span class="token keyword control-flow">return</span> <span class="token string">'This action returns a user'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><blockquote><p>info <strong>Hint</strong> The <code>ParseIntPipe</code> and <code>ParseBoolPipe</code> are exported from the <code>@nestjs/common</code> package.</blockquote></section><section id="mapped-types"class="level4"><h4>Mapped types</h4><p>As you build out features like <strong>CRUD</strong> (Create/Read/Update/Delete) it's often useful to construct variants on a base entity type. Nest provides several utility functions that perform type transformations to make this task more convenient.<blockquote><p><strong>Warning</strong> If your application uses the <code>@nestjs/swagger</code> package, see <a href="/openapi/mapped-types">this chapter</a> for more information about Mapped Types. Likewise, if you use the <code>@nestjs/graphql</code> package see <a href="/graphql/mapped-types">this chapter</a>. Both packages heavily rely on types and so they require a different import to be used. Therefore, if you used <code>@nestjs/mapped-types</code> (instead of an appropriate one, either <code>@nestjs/swagger</code> or <code>@nestjs/graphql</code> depending on the type of your app), you may face various, undocumented side-effects.</blockquote><p>When building input validation types (also called DTOs), it's often useful to build <strong>create</strong> and <strong>update</strong> variations on the same type. For example, the <strong>create</strong> variant may require all fields, while the <strong>update</strong> variant may make all fields optional.<p>Nest provides the <code>PartialType()</code> utility function to make this task easier and minimize boilerplate.<p>The <code>PartialType()</code> function returns a type (class) with all the properties of the input type set to optional. For example, suppose we have a <strong>create</strong> type as follows:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">CreateCatDto</span></span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  breed<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>By default, all of these fields are required. To create a type with the same fields, but with each one optional, use <code>PartialType()</code> passing the class reference (<code>CreateCatDto</code>) as an argument:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">UpdateCatDto</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">PartialType</span></span><span class="token punctuation">(</span><span class="token maybe-class-name">CreateCatDto</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><blockquote><p>info <strong>Hint</strong> The <code>PartialType()</code> function is imported from the <code>@nestjs/mapped-types</code> package.</blockquote><p>The <code>PickType()</code> function constructs a new type (class) by picking a set of properties from an input type. For example, suppose we start with a type like:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">CreateCatDto</span></span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  breed<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>We can pick a set of properties from this class using the <code>PickType()</code> utility function:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">UpdateCatAgeDto</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">PickType</span></span><span class="token punctuation">(</span><span class="token maybe-class-name">CreateCatDto</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">]</span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><blockquote><p>info <strong>Hint</strong> The <code>PickType()</code> function is imported from the <code>@nestjs/mapped-types</code> package.</blockquote><p>The <code>OmitType()</code> function constructs a type by picking all properties from an input type and then removing a particular set of keys. For example, suppose we start with a type like:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">CreateCatDto</span></span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  breed<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>We can generate a derived type that has every property <strong>except</strong> <code>name</code> as shown below. In this construct, the second argument to <code>OmitType</code> is an array of property names.<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">UpdateCatDto</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">OmitType</span></span><span class="token punctuation">(</span><span class="token maybe-class-name">CreateCatDto</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><blockquote><p>info <strong>Hint</strong> The <code>OmitType()</code> function is imported from the <code>@nestjs/mapped-types</code> package.</blockquote><p>The <code>IntersectionType()</code> function combines two types into one new type (class). For example, suppose we start with two types like:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">CreateCatDto</span></span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  breed<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">AdditionalCatInfo</span></span> <span class="token punctuation">{</span>
  color<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>We can generate a new type that combines all properties in both types.<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">UpdateCatDto</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">IntersectionType</span></span><span class="token punctuation">(</span>
  <span class="token maybe-class-name">CreateCatDto</span><span class="token punctuation">,</span>
  <span class="token maybe-class-name">AdditionalCatInfo</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><blockquote><p>info <strong>Hint</strong> The <code>IntersectionType()</code> function is imported from the <code>@nestjs/mapped-types</code> package.</blockquote><p>The type mapping utility functions are composable. For example, the following will produce a type (class) that has all of the properties of the <code>CreateCatDto</code> type except for <code>name</code>, and those properties will be set to optional:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">UpdateCatDto</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">PartialType</span></span><span class="token punctuation">(</span>
  <span class="token function"><span class="token maybe-class-name">OmitType</span></span><span class="token punctuation">(</span><span class="token maybe-class-name">CreateCatDto</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></section><section id="parsing-and-validating-arrays"class="level4"><h4>Parsing and validating arrays</h4><p>TypeScript does not store metadata about generics or interfaces, so when you use them in your DTOs, <code>ValidationPipe</code> may not be able to properly validate incoming data. For instance, in the following code, <code>createUserDtos</code> won't be correctly validated:<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Post</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">createBulk</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Body</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> createUserDtos<span class="token operator">:</span> <span class="token maybe-class-name">CreateUserDto</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token string">'This action adds new users'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>To validate the array, create a dedicated class which contains a property that wraps the array, or use the <code>ParseArrayPipe</code>.<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Post</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">createBulk</span><span class="token punctuation">(</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Body</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">ParseArrayPipe</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> items<span class="token operator">:</span> <span class="token maybe-class-name">CreateUserDto</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  createUserDtos<span class="token operator">:</span> <span class="token maybe-class-name">CreateUserDto</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token string">'This action adds new users'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>In addition, the <code>ParseArrayPipe</code> may come in handy when parsing query parameters. Let's consider a <code>findByIds()</code> method that returns users based on identifiers passed as query parameters.<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">findByIds</span><span class="token punctuation">(</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Query</span></span><span class="token punctuation">(</span><span class="token string">'ids'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">ParseArrayPipe</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> items<span class="token operator">:</span> <span class="token known-class-name class-name">Number</span><span class="token punctuation">,</span> separator<span class="token operator">:</span> <span class="token string">','</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  ids<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token string">'This action returns users by ids'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>This construction validates the incoming query parameters from an HTTP <code>GET</code> request like the following:<pre class="language-bash"><code class="language-bash">GET /?ids<span class="token operator">=</span><span class="token number">1,2</span>,3</code></pre></section><section id="websockets-and-microservices"class="level4"><h4>WebSockets and Microservices</h4><p>While this chapter shows examples using HTTP style applications (e.g., Express or Fastify), the <code>ValidationPipe</code> works the same for WebSockets and microservices, regardless of the transport method that is used.</section><section id="learn-more"class="level4"><h4>Learn more</h4><p>Read more about custom validators, error messages, and available decorators as provided by the <code>class-validator</code> package <a href="https://github.com/typestack/class-validator">here</a>. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>