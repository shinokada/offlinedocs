<!doctype html><html lang="en"><meta charset="utf-8"><title>Router module</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="router-module"class="level3"><h3>Router module</h3><blockquote><p>info <strong>Hint</strong> This chapter is only relevant to HTTP-based applications.</blockquote><p>In an HTTP application (for example, REST API), the route path for a handler is determined by concatenating the (optional) prefix declared for the controller (inside the <code>@Controller</code> decorator), and any path specified in the method's decorator (e.g, <code>@Get('users')</code>). You can learn more about that in <a href="/controllers#routing">this section</a>. Additionally, you can define a <a href="/faq/global-prefix">global prefix</a> for all routes registered in your application, or enable <a href="/techniques/versioning">versioning</a>.<p>Also, there are edge-cases when defining a prefix at a module-level (and so for all controllers registered inside that module) may come in handy. For example, imagine a REST application that exposes several different endpoints being used by a specific portion of your application called "Dashboard". In such a case, instead of repeating the <code>/dashboard</code> prefix within each controller, you could use a utility <code>RouterModule</code> module, as follows:<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  imports<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token maybe-class-name">DashboardModule</span><span class="token punctuation">,</span>
    <span class="token maybe-class-name">RouterModule</span><span class="token punctuation">.</span><span class="token method function property-access">register</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        path<span class="token operator">:</span> <span class="token string">'dashboard'</span><span class="token punctuation">,</span>
        module<span class="token operator">:</span> <span class="token maybe-class-name">DashboardModule</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">AppModule</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><blockquote><p>info <strong>Hint</strong> The <code>RouterModule</code> class is exported from the <code>@nestjs/core</code> package.</blockquote><p>In addition, you can define hierarchical structures. This means each module can have <code>children</code> modules. The children modules will inherit their parent's prefix. In the following example, we'll register the <code>AdminModule</code> as a parent module of <code>DashboardModule</code> and <code>MetricsModule</code>.<pre class="language-typescript"><code class="language-typescript"><span class="token maybe-class-name">RouterModule</span><span class="token punctuation">.</span><span class="token method function property-access">register</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    path<span class="token operator">:</span> <span class="token string">'admin'</span><span class="token punctuation">,</span>
    module<span class="token operator">:</span> <span class="token maybe-class-name">AdminModule</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        path<span class="token operator">:</span> <span class="token string">'dashboard'</span><span class="token punctuation">,</span>
        module<span class="token operator">:</span> <span class="token maybe-class-name">DashboardModule</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        path<span class="token operator">:</span> <span class="token string">'metrics'</span><span class="token punctuation">,</span>
        module<span class="token operator">:</span> <span class="token maybe-class-name">MetricsModule</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>info <strong>Hint</strong> This feature should be used very carefully, as overusing it can make code difficult to maintain over time.</blockquote><p>In the example above, any controller registered inside the <code>DashboardModule</code> will have an extra <code>/admin/dashboard</code> prefix (as the module concatenates paths from top to bottom - recursively - parent to children). Likewise, each controller defined inside the <code>MetricsModule</code> will have an additional module-level prefix <code>/admin/metrics</code>. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section>