<!doctype html><html lang="en"><meta charset="utf-8"><title>Request lifecycle</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="request-lifecycle"class="level3"><h3>Request lifecycle</h3><p>Nest applications handle requests and produce responses in a sequence we refer to as the <strong>request lifecycle</strong>. With the use of middleware, pipes, guards, and interceptors, it can be challenging to track down where a particular piece of code executes during the request lifecycle, especially as global, controller level, and route level components come into play. In general, a request flows through middleware to guards, then to interceptors, then to pipes and finally back to interceptors on the return path (as the response is generated).<section id="middleware"class="level4"><h4>Middleware</h4><p>Middleware is executed in a particular sequence. First, Nest runs globally bound middleware (such as middleware bound with <code>app.use</code>) and then it runs <a href="/middleware">module bound middleware</a>, which are determined on paths. Middleware are run sequentially in the order they are bound, similar to the way middleware in Express works. In the case of middleware bound across different modules, the middleware bound to the root module will run first, and then middleware will run in the order that the modules are added to the imports array.</section><section id="guards"class="level4"><h4>Guards</h4><p>Guard execution starts with global guards, then proceeds to controller guards, and finally to route guards. As with middleware, guards run in the order in which they are bound. For example:<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">UseGuards</span></span><span class="token punctuation">(</span><span class="token maybe-class-name">Guard1</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Guard2</span><span class="token punctuation">)</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Controller</span></span><span class="token punctuation">(</span><span class="token string">'cats'</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">CatsController</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> catsService<span class="token operator">:</span> <span class="token maybe-class-name">CatsService</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token decorator"><span class="token at operator">@</span><span class="token function">UseGuards</span></span><span class="token punctuation">(</span><span class="token maybe-class-name">Guard3</span><span class="token punctuation">)</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">getCats</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Cats</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">catsService</span><span class="token punctuation">.</span><span class="token method function property-access">getCats</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p><code>Guard1</code> will execute before <code>Guard2</code> and both will execute before <code>Guard3</code>.<blockquote><p>info <strong>Hint</strong> When speaking about globally bound vs controller or locally bound, the difference is where the guard (or other component is bound). If you are using <code>app.useGlobalGuard()</code> or providing the component via a module, it is globally bound. Otherwise, it is bound to a controller if the decorator precedes a controller class, or to a route if the decorator proceeds a route declaration.</blockquote></section><section id="interceptors"class="level4"><h4>Interceptors</h4><p>Interceptors, for the most part, follow the same pattern as guards, with one catch: as interceptors return <a href="https://github.com/ReactiveX/rxjs">RxJS Observables</a>, the observables will be resolved in a first in last out manner. So inbound requests will go through the standard global, controller, route level resolution, but the response side of the request (i.e., after returning from the controller method handler) will be resolved from route to controller to global. Also, any errors thrown by pipes, controllers, or services can be read in the <code>catchError</code> operator of an interceptor.</section><section id="pipes"class="level4"><h4>Pipes</h4><p>Pipes follow the standard global to controller to route bound sequence, with the same first in first out in regards to the <code>@usePipes()</code> parameters. However, at a route parameter level, if you have multiple pipes running, they will run in the order of the last parameter with a pipe to the first. This also applies to the route level and controller level pipes. For example, if we have the following controller:<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">UsePipes</span></span><span class="token punctuation">(</span><span class="token maybe-class-name">GeneralValidationPipe</span><span class="token punctuation">)</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Controller</span></span><span class="token punctuation">(</span><span class="token string">'cats'</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">CatsController</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> catsService<span class="token operator">:</span> <span class="token maybe-class-name">CatsService</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token decorator"><span class="token at operator">@</span><span class="token function">UsePipes</span></span><span class="token punctuation">(</span><span class="token maybe-class-name">RouteSpecificPipe</span><span class="token punctuation">)</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Patch</span></span><span class="token punctuation">(</span><span class="token string">':id'</span><span class="token punctuation">)</span>
  <span class="token function">updateCat</span><span class="token punctuation">(</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">Body</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> body<span class="token operator">:</span> <span class="token maybe-class-name">UpdateCatDTO</span><span class="token punctuation">,</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">Param</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> params<span class="token operator">:</span> <span class="token maybe-class-name">UpdateCatParams</span><span class="token punctuation">,</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">Query</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> query<span class="token operator">:</span> <span class="token maybe-class-name">UpdateCatQuery</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">catsService</span><span class="token punctuation">.</span><span class="token method function property-access">updateCat</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> params<span class="token punctuation">,</span> query<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>then the <code>GeneralValidationPipe</code> will run for the <code>query</code>, then the <code>params</code>, and then the <code>body</code> objects before moving on to the <code>RouteSpecificPipe</code>, which follows the same order. If any parameter-specific pipes were in place, they would run (again, from the last to first parameter) after the controller and route level pipes.</section><section id="filters"class="level4"><h4>Filters</h4><p>Filters are the only component that do not resolve global first. Instead, filters resolve from the lowest level possible, meaning execution starts with any route bound filters and proceeding next to controller level, and finally to global filters. Note that exceptions cannot be passed from filter to filter; if a route level filter catches the exception, a controller or global level filter cannot catch the same exception. The only way to achieve an effect like this is to use inheritance between the filters.<blockquote><p>info <strong>Hint</strong> Filters are only executed if any uncaught exception occurs during the request process. Caught exceptions, such as those caught with a <code>try/catch</code> will not trigger Exception Filters to fire. As soon as an uncaught exception is encountered, the rest of the lifecycle is ignored and the request skips straight to the filter.</blockquote></section><section id="summary"class="level4"><h4>Summary</h4><p>In general, the request lifecycle looks like the following:<ol><li>Incoming request<li>Globally bound middleware<li>Module bound middleware<li>Global guards<li>Controller guards<li>Route guards<li>Global interceptors (pre-controller)<li>Controller interceptors (pre-controller)<li>Route interceptors (pre-controller)<li>Global pipes<li>Controller pipes<li>Route pipes<li>Route parameter pipes<li>Controller (method handler)<li>Service (if exists)<li>Route interceptor (post-request)<li>Controller interceptor (post-request)<li>Global interceptor (post-request)<li>Exception filters (route, then controller, then global)<li>Server response <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></ol></section></section>