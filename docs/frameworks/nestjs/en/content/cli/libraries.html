<!doctype html><html lang="en"><meta charset="utf-8"><title>Libraries</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="libraries"class="level3"><h3>Libraries</h3><p>Many applications need to solve the same general problems, or re-use a modular component in several different contexts. Nest has a few ways of addressing this, but each works at a different level to solve the problem in a way that helps meet different architectural and organizational objectives.<p>Nest <a href="/modules">modules</a> are useful for providing an execution context that enables sharing components within a single application. Modules can also be packaged with <a href="https://npmjs.com">npm</a> to create a reusable library that can be installed in different projects. This can be an effective way to distribute configurable, re-usable libraries that can be used by different, loosely connected or unaffiliated organizations (e.g., by distributing/installing 3rd party libraries).<p>For sharing code within closely organized groups (e.g., within company/project boundaries), it can be useful to have a more lightweight approach to sharing components. Monorepos have arisen as a construct to enable that, and within a monorepo, a <strong>library</strong> provides a way to share code in an easy, lightweight fashion. In a Nest monorepo, using libraries enables easy assembly of applications that share components. In fact, this encourages decomposition of monolithic applications and development processes to focus on building and composing modular components.<section id="nest-libraries"class="level4"><h4>Nest libraries</h4><p>A Nest library is a Nest project that differs from an application in that it cannot run on its own. A library must be imported into a containing application in order for its code to execute. The built-in support for libraries described in this section is only available for <strong>monorepos</strong> (standard mode projects can achieve similar functionality using npm packages).<p>For example, an organization may develop an <code>AuthModule</code> that manages authentication by implementing company policies that govern all internal applications. Rather than build that module separately for each application, or physically packaging the code with npm and requiring each project to install it, a monorepo can define this module as a library. When organized this way, all consumers of the library module can see an up-to-date version of the <code>AuthModule</code> as it is committed. This can have significant benefits for coordinating component development and assembly, and simplifying end-to-end testing.</section><section id="creating-libraries"class="level4"><h4>Creating libraries</h4><p>Any functionality that is suitable for re-use is a candidate for being managed as a library. Deciding what should be a library, and what should be part of an application, is an architectural design decision. Creating libraries involves more than simply copying code from an existing application to a new library. When packaged as a library, the library code must be decoupled from the application. This may require <strong>more</strong> time up front and force some design decisions that you may not face with more tightly coupled code. But this additional effort can pay off when the library can be used to enable more rapid application assembly across multiple applications.<p>To get started with creating a library, run the following command:<pre class="language-bash"><code class="language-bash">nest g library my-library</code></pre><p>When you run the command, the <code>library</code> schematic prompts you for a prefix (AKA alias) for the library:<pre class="language-bash"><code class="language-bash">What prefix would you like to use <span class="token keyword">for</span> the library <span class="token punctuation">(</span>default: @app<span class="token punctuation">)</span>?</code></pre><p>This creates a new project in your workspace called <code>my-library</code>. A library-type project, like an application-type project, is generated into a named folder using a schematic. Libraries are managed under the <code>libs</code> folder of the monorepo root. Nest creates the <code>libs</code> folder the first time a library is created.<p>The files generated for a library are slightly different from those generated for an application. Here is the contents of the <code>libs</code> folder after executing the command above:<div class="file-tree"><div class="item">libs</div><div class="children"><div class="item">my-library</div><div class="children"><div class="item">src</div><div class="children"><div class="item">index.ts</div><div class="item">my-library.module.ts</div><div class="item">my-library.service.ts</div></div><div class="item">tsconfig.lib.json</div></div></div></div><p>The <code>nest-cli.json</code> file will have a new entry for the library under the <code>"projects"</code> key:<pre class="language-javascript"><code class="language-javascript"><span class="token spread operator">...</span>
<span class="token punctuation">{</span>
    <span class="token string-property property">"my-library"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"library"</span><span class="token punctuation">,</span>
      <span class="token string-property property">"root"</span><span class="token operator">:</span> <span class="token string">"libs/my-library"</span><span class="token punctuation">,</span>
      <span class="token string-property property">"entryFile"</span><span class="token operator">:</span> <span class="token string">"index"</span><span class="token punctuation">,</span>
      <span class="token string-property property">"sourceRoot"</span><span class="token operator">:</span> <span class="token string">"libs/my-library/src"</span><span class="token punctuation">,</span>
      <span class="token string-property property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token string-property property">"tsConfigPath"</span><span class="token operator">:</span> <span class="token string">"libs/my-library/tsconfig.lib.json"</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token spread operator">...</span></code></pre><p>There are two differences in <code>nest-cli.json</code> metadata between libraries and applications:<ul><li>the <code>"type"</code> property is set to <code>"library"</code> instead of <code>"application"</code><li>the <code>"entryFile"</code> property is set to <code>"index"</code> instead of <code>"main"</code></ul><p>These differences key the build process to handle libraries appropriately. For example, a library exports its functions through the <code>index.js</code> file.<p>As with application-type projects, libraries each have their own <code>tsconfig.lib.json</code> file that extends the root (monorepo-wide) <code>tsconfig.json</code> file. You can modify this file, if necessary, to provide library-specific compiler options.<p>You can build the library with the CLI command:<pre class="language-bash"><code class="language-bash">nest build my-library</code></pre></section><section id="using-libraries"class="level4"><h4>Using libraries</h4><p>With the automatically generated configuration files in place, using libraries is straightforward. How would we import <code>MyLibraryService</code> from the <code>my-library</code> library into the <code>my-project</code> application?<p>First, note that using library modules is the same as using any other Nest module. What the monorepo does is manage paths in a way that importing libraries and generating builds is now transparent. To use <code>MyLibraryService</code>, we need to import its declaring module. We can modify <code>my-project/src/app.module.ts</code> as follows to import <code>MyLibraryModule</code>.<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">Module</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">AppController</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./app.controller'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">AppService</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./app.service'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">MyLibraryModule</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@app/my-library'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  imports<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token maybe-class-name">MyLibraryModule</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  controllers<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token maybe-class-name">AppController</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token maybe-class-name">AppService</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">AppModule</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>Notice above that we've used a path alias of <code>@app</code> in the ES module <code>import</code> line, which was the <code>prefix</code> we supplied with the <code>nest g library</code> command above. Under the covers, Nest handles this through tsconfig path mapping. When adding a library, Nest updates the global (monorepo) <code>tsconfig.json</code> file's <code>"paths"</code> key like this:<pre class="language-javascript"><code class="language-javascript"><span class="token string-property property">"paths"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string-property property">"@app/my-library"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token string">"libs/my-library/src"</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token string-property property">"@app/my-library/*"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token string">"libs/my-library/src/*"</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre><p>So, in a nutshell, the combination of the monorepo and library features has made it easy and intuitive to include library modules into applications.<p>This same mechanism enables building and deploying applications that compose libraries. Once you've imported the <code>MyLibraryModule</code>, running <code>nest build</code> handles all the module resolution automatically and bundles the app along with any library dependencies, for deployment. The default compiler for a monorepo is <strong>webpack</strong>, so the resulting distribution file is a single file that bundles all of the transpiled JavaScript files into a single file. You can also switch to <code>tsc</code> as described <a href="https://docs.nestjs.com/cli/monorepo#global-compiler-options">here</a>. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>