<!doctype html><html lang="en"><meta charset="utf-8"><title>Other features</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="other-features"class="level3"><h3>Other features</h3><p>In the GraphQL world, there is a lot of debate about handling issues like <strong>authentication</strong>, or <strong>side-effects</strong> of operations. Should we handle things inside the business logic? Should we use a higher-order function to enhance queries and mutations with authorization logic? Or should we use <a href="https://www.apollographql.com/docs/apollo-server/schema/directives/">schema directives</a>? There is no single one-size-fits-all answer to these questions.<p>Nest helps address these issues with its cross-platform features like <a href="/guards">guards</a> and <a href="/interceptors">interceptors</a>. The philosophy is to reduce redundancy and provide tooling that helps create well-structured, readable, and consistent applications.<section id="overview"class="level4"><h4>Overview</h4><p>You can use standard <a href="/guards">guards</a>, <a href="/interceptors">interceptors</a>, <a href="/exception-filters">filters</a> and <a href="/pipes">pipes</a> in the same fashion with GraphQL as with any RESTful application. Additionally, you can easily create your own decorators by leveraging the <a href="/custom-decorators">custom decorators</a> feature. Let's take a look at a sample GraphQL query handler.<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Query</span></span><span class="token punctuation">(</span><span class="token string">'author'</span><span class="token punctuation">)</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">UseGuards</span></span><span class="token punctuation">(</span><span class="token maybe-class-name">AuthGuard</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">getAuthor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Args</span></span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token maybe-class-name">ParseIntPipe</span><span class="token punctuation">)</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">authorsService</span><span class="token punctuation">.</span><span class="token method function property-access">findOneById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>As you can see, GraphQL works with both guards and pipes in the same way as HTTP REST handlers. Because of this, you can move your authentication logic to a guard; you can even reuse the same guard class across both a REST and GraphQL API interface. Similarly, interceptors work across both types of applications in the same way:<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Mutation</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">UseInterceptors</span></span><span class="token punctuation">(</span><span class="token maybe-class-name">EventsInterceptor</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">upvotePost</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Args</span></span><span class="token punctuation">(</span><span class="token string">'postId'</span><span class="token punctuation">)</span> postId<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">postsService</span><span class="token punctuation">.</span><span class="token method function property-access">upvoteById</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token operator">:</span> postId <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></section><section id="execution-context"class="level4"><h4>Execution context</h4><p>Since GraphQL receives a different type of data in the incoming request, the <a href="https://docs.nestjs.com/fundamentals/execution-context">execution context</a> received by both guards and interceptors is somewhat different with GraphQL vs. REST. GraphQL resolvers have a distinct set of arguments: <code>root</code>, <code>args</code>, <code>context</code>, and <code>info</code>. Thus guards and interceptors must transform the generic <code>ExecutionContext</code> to a <code>GqlExecutionContext</code>. This is straightforward:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">CanActivate</span><span class="token punctuation">,</span> <span class="token maybe-class-name">ExecutionContext</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Injectable</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">GqlExecutionContext</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/graphql'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">AuthGuard</span></span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token maybe-class-name">CanActivate</span></span> <span class="token punctuation">{</span>
  <span class="token function">canActivate</span><span class="token punctuation">(</span>context<span class="token operator">:</span> <span class="token maybe-class-name">ExecutionContext</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> ctx <span class="token operator">=</span> <span class="token maybe-class-name">GqlExecutionContext</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>The GraphQL context object returned by <code>GqlExecutionContext.create()</code> exposes a <strong>get</strong> method for each GraphQL resolver argument (e.g., <code>getArgs()</code>, <code>getContext()</code>, etc). Once transformed, we can easily pick out any GraphQL argument for the current request.</section><section id="exception-filters"class="level4"><h4>Exception filters</h4><p>Nest standard <a href="/exception-filters">exception filters</a> are compatible with GraphQL applications as well. As with <code>ExecutionContext</code>, GraphQL apps should transform the <code>ArgumentsHost</code> object to a <code>GqlArgumentsHost</code> object.<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Catch</span></span><span class="token punctuation">(</span><span class="token maybe-class-name">HttpException</span><span class="token punctuation">)</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">HttpExceptionFilter</span></span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token maybe-class-name">GqlExceptionFilter</span></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">catch</span><span class="token punctuation">(</span>exception<span class="token operator">:</span> <span class="token maybe-class-name">HttpException</span><span class="token punctuation">,</span> host<span class="token operator">:</span> <span class="token maybe-class-name">ArgumentsHost</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> gqlHost <span class="token operator">=</span> <span class="token maybe-class-name">GqlArgumentsHost</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> exception<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><blockquote><p>info <strong>Hint</strong> Both <code>GqlExceptionFilter</code> and <code>GqlArgumentsHost</code> are imported from the <code>@nestjs/graphql</code> package.</blockquote><p>Note that unlike the REST case, you don't use the native <code>response</code> object to generate a response.</section><section id="custom-decorators"class="level4"><h4>Custom decorators</h4><p>As mentioned, the <a href="/custom-decorators">custom decorators</a> feature works as expected with GraphQL resolvers.<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">export</span> <span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token function">createParamDecorator</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span>data<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">,</span> ctx<span class="token operator">:</span> <span class="token maybe-class-name">ExecutionContext</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span>
    <span class="token maybe-class-name">GqlExecutionContext</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">user</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Use the <code>@User()</code> custom decorator as follows:<pre class="language-typescript"><code class="language-typescript"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Mutation</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">upvotePost</span><span class="token punctuation">(</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">User</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> user<span class="token operator">:</span> <span class="token maybe-class-name">UserEntity</span><span class="token punctuation">,</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Args</span></span><span class="token punctuation">(</span><span class="token string">'postId'</span><span class="token punctuation">)</span> postId<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><blockquote><p>info <strong>Hint</strong> In the above example, we have assumed that the <code>user</code> object is assigned to the context of your GraphQL application.</blockquote></section><section id="execute-enhancers-at-the-field-resolver-level"class="level4"><h4>Execute enhancers at the field resolver level</h4><p>In the GraphQL context, Nest does not run <strong>enhancers</strong> (the generic name for interceptors, guards and filters) at the field level <a href="https://github.com/nestjs/graphql/issues/320#issuecomment-511193229">see this issue</a>: they only run for the top level <code>@Query()</code>/<code>@Mutation()</code> method. You can tell Nest to execute interceptors, guards or filters for methods annotated with <code>@ResolveField()</code> by setting the <code>fieldResolverEnhancers</code> option in <code>GqlModuleOptions</code>. Pass it a list of <code>'interceptors'</code>, <code>'guards'</code>, and/or <code>'filters'</code> as appropriate:<pre class="language-typescript"><code class="language-typescript"><span class="token maybe-class-name">GraphQLModule</span><span class="token punctuation">.</span><span class="token method function property-access">forRoot</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  fieldResolverEnhancers<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'interceptors'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre><blockquote><p><strong>Warning</strong> Enabling enhancers for field resolvers can cause performance issues when you are returning lots of records and your field resolver is executed thousands of times. For this reason, when you enable <code>fieldResolverEnhancers</code>, we advise you to skip execution of enhancers that are not strictly necessary for your field resolvers. You can do this using the following helper function:</blockquote><pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">isResolvingGraphQLField</span><span class="token punctuation">(</span>context<span class="token operator">:</span> <span class="token maybe-class-name">ExecutionContext</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">getType</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">GqlContextType</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'graphql'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> gqlContext <span class="token operator">=</span> <span class="token maybe-class-name">GqlExecutionContext</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> info <span class="token operator">=</span> gqlContext<span class="token punctuation">.</span><span class="token method function property-access">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> parentType <span class="token operator">=</span> info<span class="token punctuation">.</span><span class="token property-access">parentType</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> parentType <span class="token operator">!==</span> <span class="token string">'Query'</span> <span class="token operator">&#x26;&#x26;</span> parentType <span class="token operator">!==</span> <span class="token string">'Mutation'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></section><section id="creating-a-custom-driver"class="level4"><h4>Creating a custom driver</h4><p>Nest provides two official drivers out-of-the-box: <code>@nestjs/apollo</code> and <code>@nestjs/mercurius</code>, as well as an API allowing developers to build new <strong>custom drivers</strong>. With a custom driver, you can integrate any GraphQL library or extend the existing integration, adding extra features on top.<p>For example, to integrate the <code>express-graphql</code> package, you could create the following driver class:<pre class="language-typescript"><code class="language-typescript"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">AbstractGraphQLDriver</span><span class="token punctuation">,</span> <span class="token maybe-class-name">GqlModuleOptions</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@nestjs/graphql'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> graphqlHTTP <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'express-graphql'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">ExpressGraphQLDriver</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">AbstractGraphQLDriver</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">async</span> <span class="token function">start</span><span class="token punctuation">(</span>options<span class="token operator">:</span> <span class="token maybe-class-name">GqlModuleOptions</span><span class="token operator">&#x3C;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token keyword">void</span><span class="token operator">></span> <span class="token punctuation">{</span>
    options <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">graphQlFactory</span><span class="token punctuation">.</span><span class="token method function property-access">mergeWithSchema</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token punctuation">{</span> httpAdapter <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">httpAdapterHost</span><span class="token punctuation">;</span>
    httpAdapter<span class="token punctuation">.</span><span class="token method function property-access">use</span><span class="token punctuation">(</span>
      <span class="token string">'/graphql'</span><span class="token punctuation">,</span>
      <span class="token function">graphqlHTTP</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        schema<span class="token operator">:</span> options<span class="token punctuation">.</span><span class="token property-access">schema</span><span class="token punctuation">,</span>
        graphiql<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">async</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>And then use it as follows:<pre class="language-typescript"><code class="language-typescript"><span class="token maybe-class-name">GraphQLModule</span><span class="token punctuation">.</span><span class="token method function property-access">forRoot</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  driver<span class="token operator">:</span> <span class="token maybe-class-name">ExpressGraphQLDriver</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>