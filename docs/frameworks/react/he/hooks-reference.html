<!doctypehtml><html lang="he"><meta charset="utf-8"><title>עיון ב-Hooks API</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="עיון-ב-hooks-api"class="level1"><h1>עיון ב-Hooks API</h1><p><em>Hooks</em> הם תוספת חדשה ב-React 16.8. הם נותנים לנו להשתמש ב-state ופיצ'רים אחרים של React מבלי לכתוב מחלקה.<p>עמוד זה מתאר את ה-APIs של ה-Hooks המובנים בתוך React.<p>אם הנושא של Hooks חדש לך, יכול להיות שתרצה לקרוא את <a href="./hooks-overview.html">הסקירה הכללית</a> קודם. יכול להיות שתמצא מידע שימושי <a href="./hooks-faq.html">בסעיף שאלות נפוצות</a>.<ul><li><a href="#basic-hooks">Hooks בסיסיים</a><ul><li><a href="#usestate"><code>useState</code></a><li><a href="#useeffect"><code>useEffect</code></a><li><a href="#usecontext"><code>useContext</code></a></ul><li><a href="#additional-hooks">Hooks נוספים</a><ul><li><a href="#usereducer"><code>useReducer</code></a><li><a href="#usecallback"><code>useCallback</code></a><li><a href="#usememo"><code>useMemo</code></a><li><a href="#useref"><code>useRef</code></a><li><a href="#useimperativehandle"><code>useImperativeHandle</code></a><li><a href="#uselayouteffect"><code>useLayoutEffect</code></a><li><a href="#usedebugvalue"><code>useDebugValue</code></a><li><a href="#usedeferredvalue"><code>useDeferredValue</code></a><li><a href="#usetransition"><code>useTransition</code></a><li><a href="#useid"><code>useId</code></a></ul><li><a href="#library-hooks">Library Hooks</a><ul><li><a href="#usesyncexternalstore"><code>useSyncExternalStore</code></a><li><a href="#useinsertioneffect"><code>useInsertionEffect</code></a></ul></ul><section id="basic-hooks"class="level2"><h2>Hooks בסיסיים</h2><section id="usestate-usestate"class="level3"><h3><code>useState</code> {#usestate}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>initialState<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>מחזיר ערך stateful, ופונקציה על מנת לעדכן אותו.<p>בזמן הרינדור הראשוני, ה-state המוחזר (<code>state</code>) הוא שווה ערך לערך המועבר כארגומנט הראשון (<code>initialState</code>).<p>פונקציית ה-<code>setState</code> משמשת לעדכון ה-state. היא מקבלת ערך state חדש וקובעת רינדור מחדש של הקומפוננטה.<pre class="language-js"><code class="language-js"><span class="token function">setState</span><span class="token punctuation">(</span>newState<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>בזמן הרינדורים העוקבים, הערך הראשון שמוחזר על ידי <code>useState</code> תמיד יהיה ה-state האחרון לאחר יישום העדכונים.<blockquote><p>הערה<p>React מבטיח שזהות פונקציית ה-<code>setState</code> יציבה ולא תשתנה בין רינדורים. זאת הסיבה שזה בטוח להשמיט</blockquote><section id="functional-updates"class="level4"><h4>עדכונים פונקציונליים</h4><p>אם ה-state החדש חושב באמצעות ה-state הקודם, ניתן להעביר פונקציה ל-<code>setState</code>. הפונקציה תקבל את הערך הקודם, ותחזיר ערך מעודכן. הנה דוגמה של קומפוננטת counter שמשתמשת בשתי הצורות של <code>setState</code>:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Counter</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>initialCount<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>initialCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token literal-property property">Count</span><span class="token operator">:</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>initialCount<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token maybe-class-name">Reset</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token parameter">prevCount</span> <span class="token arrow operator">=></span> prevCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">-</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token parameter">prevCount</span> <span class="token arrow operator">=></span> prevCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">+</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>כפתורי ה-"+" וה-"-" משתמשים בצורה הפונקציונלית, בגלל שהערך המעודכן מבוסס על הערך הקודם. אבל כפתור ה"Reset" משתמש בצורה הרגילה, בגלל שהוא תמיד מעדכן את הספירה חזרה לערך ההתחלתי.<blockquote><p>הערה אם הפונקציה מחזירה ערך שווה לזה שקיים ב-state הנוכחי, הרינדור הבא ידולג לגמרי.<p>בשונה ממתודת ה-<code>setState</code> שנמצאת בקומפוננטות מחלקה, <code>useState</code> לא ממזגת עדכוני אובייקטים באופן אוטומטי. ניתן לחקות התנהגות זו על ידי שילוב של מעדכן פונקציה עם אופן הכתיבה של object spread(שלוש נקודות '...'):<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setState</span><span class="token punctuation">(</span><span class="token parameter">prevState</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// Object.assign גם יעבוד</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>prevState<span class="token punctuation">,</span> <span class="token spread operator">...</span>updatedValues<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>אופציה נוספת היא <code>useReducer</code>, שמתאים יותר לניהול אובייקטי(objects) state שמכילים מספר רב של תת-ערכים.</blockquote></section><section id="lazy-initial-state"class="level4"><h4>Initial state עצלן</h4><p>הארגומנט <code>initialState</code> הוא ה-state שהשתמשנו בו ברינדור הראשון. ברינדורים עוקבים, מתעלמים ממנו. אם ה-state ההתחלתי הוא התוצאה של חישוב יקר, ניתן לספק פונקציה במקום, שתרוץ רק ברינדור ההתחלתי:<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> initialState <span class="token operator">=</span> <span class="token function">someExpensiveComputation</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> initialState<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section><section id="bailing-out-of-a-state-update"class="level4"><h4>יציאה מעדכון state</h4><p>אם אתה מעדכן State Hook לערך ששווה לערך הנוכחי, React יצא מהפעולה מבלי רינדור הילדים או יריית אפקטים. (React משתמש <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description">באלגוריתם ההשוואה <code>Object.is</code></a>.)<p>שים לב שיכול להיות ש-React יצטרך לרנדר את הקומפוננטה הספציפית הזו לפני יציאה מהפעולה. זה לא אמור להיות מדאיג בגלל ש-React לא ילך שלא כצורך "עמוק" לתוך העץ. אם אתה מבצע חישובים יקרים בזמן רינדור, ניתן למטב אותם עם <code>useMemo</code>.</section><section id="batching-of-state-updates"class="level4"><h4>Batching of state updates</h4><p>React may group several state updates into a single re-render to improve performance. Normally, this improves performance and shouldn't affect your application's behavior.<p>Before React 18, only updates inside React event handlers were batched. Starting with React 18, <a href="/blog/2022/03/08/react-18-upgrade-guide.html#automatic-batching">batching is enabled for all updates by default</a>. Note that React makes sure that updates from several <em>different</em> user-initiated events -- for example, clicking a button twice -- are always processed separately and do not get batched. This prevents logical mistakes.<p>In the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in <a href="./react-dom.html#flushsync"><code>flushSync</code></a>. However, this can hurt performance so do this only where needed.</section></section><section id="useeffect-useeffect"class="level3"><h3><code>useEffect</code> {#useeffect}</h3><pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span>didUpdate<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>מקבלת פונקציה שמכילה קוד חיוני, שכנראה גורם לאפקט כלשהו.<p>Mutations, subscriptions, טיימרים, לוגים, ותופעות לוואי אחרים לא מורשים בתוך ה-main body של קומפוננטת פונקציה (המכונה <em>שלב הרינדור</em> של React). אי ציות לכך יגרום לבאגים מבלבלים ואי עקביות בממשק המשתמש.<p>במקום זאת, השתמש ב-<code>useEffect</code>. הפונקציה המועברת ל-<code>useEffect</code> תרוץ אחרי שהרינדור מופיע על המסך. ניתן לחשוב על אפקטים כפתח מילוט מהעולם הפונקציונלי של React לתוך העולם האימפרטיבי.<p>כברירת מחדל, אפקטים רצים אחרי כל רינדור שמסתיים, אבל ניתן לבחור להריץ אותם <a href="#conditionally-firing-an-effect">רק כשערכים מסוימים שונו</a>.<section id="cleaning-up-an-effect"class="level4"><h4>ניקוי אפקט</h4><p>לעיתים קרובות, אפקטים יוצרים משאבים שדורשים ניקוי לפני שהקומפוננטה עוזבת את המסך, כמו subscription או timer ID. על מנת לעשות זאת, הפונקציה המועברת ל-<code>useEffect</code> תחזיר פונקציית נקיון. לדוגמה, על מנת ליצור subscription:<pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> subscription <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">source</span><span class="token punctuation">.</span><span class="token method function property-access">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// ניקוי ה-subscription</span>
    subscription<span class="token punctuation">.</span><span class="token method function property-access">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>פונקציית הנקיון רצה לפני הסרת הקומפוננטה מממשק המשתמש על מנת למנוע דליפות זיכרון. בנוסף לכך, אם קומפוננטה מתרנדרת מספר רב של פעמים (כמו שבדרך כלל קורה), <strong>האפקט הקודם מנוקה לפני הרצת האפקט הבא</strong>. בדוגמה שלנו, זה אומר ש-subscription חדש נוצר בכל עדכון. על מנת להימנע מיריית אפקט על כל עדכון, קרא את החלק הבא.</section><section id="timing-of-effects"class="level4"><h4>תזמון אפקטים</h4><p>בשונה מ-<code>componentDidMount</code> ו-<code>componentDidUpdate</code>, הפונקציה שמועברת ל-<code>useEffect</code> נורה <strong>לאחר</strong> פריסה וצביעה(layout and paint), בזמן אירוע נדחה. זה עושה את זה מתאים להרבה תופעות לוואי, כמו הכנת subscriptions ו- event handlers, בגלל שרוב סוגי העבודה לא חוסמים את הדפדפן מלעדכן את המסך.<p>למרות זאת, לא ניתן לעכב את כל האפקטים. לדוגמה, מוטציית DOM שגלויה למשתמש צריכה להיות נורה באופן סינכרוני לפני הצבע הבא כך שהמשתמש לא יבחין בחוסר עקביות חזותי. (ההבחנה דומה מבחינה קונספטואלית למאזינים לאירועים פסיביים לעומת פעילים). בשביל סוגי האפקטים האלה, React מספק Hook נוסף שנקרא <a href="#uselayouteffect"><code>useLayoutEffect</code></a>. יש לו את אותה חתימה כ-<code>useEffect</code>, ושונה ממנו כשהוא נורה.<p>&#x3C;&#x3C;&#x3C;&#x3C;&#x3C;&#x3C;&#x3C; HEAD אף על פי ש-<code>useEffect</code> מתעכב על שהדפדפן נצבע, זה מובטח שהוא נורה לפני רינדורים חדשים. React תמיד ינקה אפקטים של רינדורים קודמים לפני החלת עדכון חדש. ======= Additionally, starting in React 18, the function passed to <code>useEffect</code> will fire synchronously <strong>before</strong> layout and paint when it's the result of a discrete user input such as a click, or when it's the result of an update wrapped in <a href="./react-dom.html#flushsync"><code>flushSync</code></a>. This behavior allows the result of the effect to be observed by the event system, or by the caller of <a href="./react-dom.html#flushsync"><code>flushSync</code></a>.<blockquote><p>Note<p>This only affects the timing of when the function passed to <code>useEffect</code> is called - updates scheduled inside these effects are still deferred. This is different than <a href="#uselayouteffect"><code>useLayoutEffect</code></a>, which fires the function and processes the updates inside of it immediately.</blockquote><p>Even in cases where <code>useEffect</code> is deferred until after the browser has painted, it's guaranteed to fire before any new renders. React will always flush a previous render's effects before starting a new update.<blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>84ad3308338e2bb819f4f24fa8e9dfeeffaa970b</blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></section><section id="conditionally-firing-an-effect"class="level4"><h4>יריית אפקט לפי תנאי</h4><p>ההתנהגות הרגילה של אפקטים היא לירות את האפקט לאחר כל רינדור שהושלם. בדרך זו אפקט תמיד נוצר מחדש אם אחד מה-dependencies שלו משתנה.<p>למרות זאת, זה יכול להיות יותר מדי במקרים מסוימים, כמו דוגמת ה-subscription מהקטע הקודם. אנחנו לא צריכים ליצור subscription חדש על כל עדכון, רק אם ה-prop <code>source</code> שונה.<p>על מנת ליישם זאת, העבר ארגומנט שני ל-<code>useEffect</code> שהוא מערך של ערכים שהאפקט תלוי בהם. הדוגמה המעודכנת שלנו נראית כמו זה:<pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> subscription <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">source</span><span class="token punctuation">.</span><span class="token method function property-access">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      subscription<span class="token punctuation">.</span><span class="token method function property-access">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>props<span class="token punctuation">.</span><span class="token property-access">source</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>עכשיו ה-subscription ייווצר מחדש רק כש-<code>props.source</code> משתנה.<blockquote><p>הערה<p>אם אתה משתמש באופטימיזציה זו, וודא כי המערך מכיל <strong>את כל הערכים מ-scope הקומפוננטה (כמו props ו-state) שמשתנים לאורך זמן ושהאפקט משתמש בהם</strong>. אחרת, הקוד שלך יתייחס לערכים ישנים מרינדורים קודמים. למד עוד על <a href="./hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">על איך לטפל בפונקציות</a> ומה לעשות <a href="./hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often">כשערכי המערך משתנים בתדירות גבוהה מדי</a>.<p>אם אתה רוצה להריץ אפקט ולנקות אותו רק פעם אחת (ב-mount ו-unmount), תוכל להעביר מערך ריק ( [] ) כארגומנט שני. זה אומר ל-React שהאפקט שלך לא תלוי <em>בשום</em> ערך מה-props או state, כך שהוא לא צריך לרוץ מחדש. זה לא מטופל כמקרה מיוחד – זה עובד כמו שמערך ה-dependencies תמיד עובד.<p>אם אתה מעביר מערך ריק ( [] ), ה-props ו-state בתוך האפקט תמיד יכילו את הערכים ההתחלתיים שלהם. בזמן שהעברת <code>[]</code> כארגומנט שני יותר קרוב ל-<code>componentDidMount</code> ו-<code>componentWillUnmount</code> כמודל מנטלי, יש פתרונות <a href="./hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">טובים</a> <a href="./hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often">יותר</a> שעוזרים להימנע מהרצה מחדש של אפקטים בתדירות גבוהה מדי. בנוסף, אסור לשכוח ש-React מעכב הרצה של <code>useEffect</code> עד לאחר שהדפדפן נצבע, אז עשיית עבודה נוספת היא פחות בעיה.<p>אנו ממליצים על שימוש בחוק <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> כחלק מחבילת ה- <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> שלנו. הוא מזהיר מפני dependencies שמוגדרים לא נכון ומציע תיקון.</blockquote><p>מערך ה-dependencies לא מועבר כארגומנטים לפונקציית האפקט. אבל באופן עקרוני, זה מה שהם מייצגים: כל ערך שמצוין בתוך פונקציית האפקט צריך להופיע במערך ה-dependencies. בעתיד, קומפיילר מתקדם יוכל ליצור את המערך באופן אוטומטי.</section></section><section id="usecontext-usecontext"class="level3"><h3><code>useContext</code> {#usecontext}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span><span class="token maybe-class-name">MyContext</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>מקבל אובייקט context (הערך המוחזר מ-<code>React.createContext</code>) ומחזיר את ערך ה-context הנוכחי לאותו context. ערך ה-context הנוכחי נקבע על ידי ה-prop <code>value</code> של <code>&#x3C;MyContext.Provider</code> מעל הקומפוננטה הקוראת בעץ.<p>כש-<code>&#x3C;MyContext.Provider></code> מעל הקומפוננטה מתעדכן, ה-Hook מפעיל מרנדר עם <code>value</code> האחרון של ה-context, ואותו ערך מועבר ל- <code>MyContext</code> Provider.<p>אל תשכח שהארגומנט של <code>useContext</code> צריך להיות <em>אובייקט ה-context עצמו</em>:<p><strong>נכון:</strong> <code>useContext(MyContext)</code> <strong>לא נכון:</strong> <code>useContext(MyContext.Consumer)</code> <strong>לא נכון:</strong> <code>useContext(MyContext.Provider)</code><p>קומפוננטה שקוראת ל-<code>useContext</code> תמיד תתרנדר מחדש כשערך ה-context ישתנה. אם רינדור מחדש של הקומפוננטה הוא יקר, ניתן <a href="https://github.com/facebook/react/issues/15156#issuecomment-474590693">למטב אותו על ידי שימוש ב-memoization</a>.<blockquote><p>טיפ<p>אם אתה מכיר את ה-context API לפני Hooks, <code>useContext(MyContext)</code> הוא שווה ל-<code>static contextType = MyContext</code> במחלקה, או ל-<code>&#x3C;MyContext.Consumer></code>.<p><code>useContext(MyContext)</code> נותן לנו רק <em>לקרוא</em> את ה-context ולעשות subscribe לשינויים שלו. נצטרך עדיין <code>&#x3C;MyContext.Provider></code> מעל בעץ על מנת <em>לספק</em> את הערך ל-context זה.</blockquote></section></section><section id="additional-hooks"class="level2"><h2>Hooks נוספים</h2><p>ה-Hooks הבאים הם או צורות אחרות של הבסיסיים מהסעיף הקודם, או כאלה שנצטרך רק במקרי קצה ספציפיים. לא צריך להילחץ מללמוד אותם בהתחלה.<section id="usereducer-usereducer"class="level3"><h3><code>useReducer</code> {#usereducer}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> initialArg<span class="token punctuation">,</span> init<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>אלטרנטיבה ל-<a href="#usestate"><code>useState</code></a>. מקבל reducer מסוג <code>(state, action) => newState</code>, ומחזיר את ה-state הנוכחי ביחד עם מתודת <code>dispatch</code>. (אם התעסקת בעבר עם Redux, זה כבר מוכר לך).<p>בדרך כלל <code>useReducer</code> עדיף על <code>useState</code> כשיש לך לוגיקת state מורכבת שמערבת מספר רב של תת-ערכים או כשה-state הבא תלוי ב-state הקודם. <code>useReducer</code> גם נותן לנו למטב ביצועים לקומפוננטות שמפעילות עדכונים עמוקים בגלל שניתן <a href="./hooks-faq.html#how-to-avoid-passing-callbacks-down">להעביר את dispatch מטה במקום callbacks</a>.<p>הנה דוגמת ה-counter מהקטע הקודם על <a href="#usestate"><code>useState</code></a>, נכתב מחדש עם שימוש ב-reducer:<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> initialState <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">reducer</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'increment'</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">'decrement'</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword module">default</span><span class="token operator">:</span>
      <span class="token keyword control-flow">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Counter</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> initialState<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token literal-property property">Count</span><span class="token operator">:</span> <span class="token punctuation">{</span>state<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'decrement'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">-</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'increment'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">+</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><blockquote><p>הערה<p>React מבטיח שזהות פונקציית <code>dispatch</code> היא קבועה ולא תשתנה ברינדורים חוזרים. זאת הסיבה שזה בטוח להשמיט מרשימת ה-dependency של <code>useEffect</code> או <code>useCallback</code>.</blockquote><section id="specifying-the-initial-state"class="level4"><h4>ציון ה-state ההתחלתי</h4><p>ישנם שתי דרכים שונות לאתחל <code>useReducer</code> state. ניתן לבחור אחד מהם תלוי בשימוש. הדרך הפשוטה ביותר היא להעביר את ה-state ההתחלתי כארגומנט שני:<pre class="language-js{3}"><code class="language-js{3}">  const [state, dispatch] = useReducer(
    reducer,
    {count: initialCount}
  );</code></pre><blockquote><p>הערה<p>React לא משתמש במוסכמת הארגומנט <code>state = intialState</code> בניגוד ל-Redux. הערך ההתחלתי לפעמים תלוי ב-props ומכאן שהוא מוגדר בקריאת ה-Hook. אם זה לא לטעמך, ניתן לקרוא ל-<code>useReducer(reducer, undefined, reducer)</code> על מנת לחקות את התנהגות Redux, אבל זה לא מומלץ.</blockquote></section><section id="lazy-initialization"class="level4"><h4>אתחול עצלן</h4><p>ניתן גם ליצור state התחלתי בעצלתיים. על מנת לעשות זאת, ניתן להעביר פונקציית <code>init</code> כארגומנט שלישי. ה-state ההתחלתי ייקבע ל-<code>init(initialArg)</code>.<p>זה נותן לנו לחלץ את הלוגיקה לחישוב ה-state ההתחלתי מחוץ ל-reducer. זה גם שימושי לאיפוס ה-state לאחר מכן כתגובה לפעולה(action):<pre class="language-js{1-3,11-12,19,24}"><code class="language-js{1-3,11-12,19,24}">function init(initialCount) {
  return {count: initialCount};
}

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    case 'reset':
      return init(action.payload);
    default:
      throw new Error();
  }
}

function Counter({initialCount}) {
  const [state, dispatch] = useReducer(reducer, initialCount, init);
  return (
    &#x3C;>
      Count: {state.count}
      &#x3C;button
        onClick={() => dispatch({type: 'reset', payload: initialCount})}>
        Reset
      &#x3C;/button>
      &#x3C;button onClick={() => dispatch({type: 'decrement'})}>-&#x3C;/button>
      &#x3C;button onClick={() => dispatch({type: 'increment'})}>+&#x3C;/button>
    &#x3C;/>
  );
}</code></pre></section><section id="bailing-out-of-a-dispatch"class="level4"><h4>יציאה מ-dispatch</h4><p>אם אתה מעדכן State Hook לערך ששווה לערך הנוכחי, React יצא מהפעולה מבלי רינדור הילדים או יריית אפקטים. (React משתמש <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description">באלגוריתם ההשוואה <code>Object.is</code></a>.)<p>שים לב שיכול להיות ש-React יצטרך לרנדר את הקומפוננטה הספציפית הזו לפני יציאה מהפעולה. זה לא אמור להיות מדאיג בגלל ש-React לא ילך שלא כצורך "עמוק" לתוך העץ. אם אתה מבצע חישובים יקרים בזמן רינדור, ניתן למטב אותם עם <code>useMemo</code>.</section></section><section id="usecallback-usecallback"class="level3"><h3><code>useCallback</code> {#usecallback}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> memoizedCallback <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">doSomething</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>מחזיר <a href="https://en.wikipedia.org/wiki/Memoization">memoized callback</a>.<p>העבר callback ומערך של dependencies. <code>useCallback</code> תחזיר גרסה memorized של ה-callback שמשתנה רק אם אחד מה-dependencies משתנה. זה שימושי כשמעבירים callbacks לקומפוננטות ילדים ממוטבות שמסתמכות על השוואה לפי אזכור על מנת למנוע רינדורים מיותרים (לדוגמה <code>shouldComponentUpdate</code>).<p><code>useCallback(fn, deps)</code> שווה ל-<code>useMemo(() => fn, deps)</code>.<blockquote><p>הערה<p>מערך ה-dependencies לא מועבר כארגומנטים לפונקציית האפקט. אבל באופן עקרוני, זה מה שהם מייצגים: כל ערך שמצוין בתוך פונקציית האפקט צריך להופיע במערך ה-dependencies. בעתיד, קומפיילר מתקדם יוכל ליצור את המערך באופן אוטומטי.<p>אנו ממליצים על שימוש בחוק <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> כחלק מחבילת ה- <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> שלנו. הוא מזהיר מפני dependencies שמוגדרים לא נכון ומציע תיקון.</blockquote></section><section id="usememo-usememo"class="level3"><h3><code>useMemo</code> {#usememo}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">computeExpensiveValue</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>מחזיר <a href="https://en.wikipedia.org/wiki/Memoization">ערך memoized</a>.<p>העבר פונקציית "create" ומערך של dependencies. <code>useMemo</code> תחשב מחדש רק את הערך ה-memoized כשאחד מה-dependencies שונה. מיטוב זה עוזר להימנע מחישובים יקרים בכל רינדור.<p>זכור כי הפונקציה שמועברת ל-<code>useMemo</code> רצה בזמן רינדור. אל תעשה דברים בתוכה שלא היית עושה בדרך כלל בזמן רינדור. לדוגמה, side effects שייכים ל-<code>useEffect</code>, לא <code>useMemo</code>.<p>אם סופק מערך כלשהו, ערך חדש יחושב בכל רינדור.<p><strong>ניתן להסתמך על <code>useMemo</code> כמיטוב ביצועים, לא כערבות סמנטית.</strong> בעתיד, יכול להיות ש-React יבחר "לשכוח" חלק מהערכים ה-memoized ויחשב אותם מחדש ברינדור הבא, לדוגמה, על מנת לשחרר זיכרון לקומפוננטות offscreen. כתוב את הקוד שלך כך שהוא יעבוד בלי <code>useMemo</code> -- ואז תוסיף אותו על מנת למטב ביצועים.<blockquote><p>הערה<p>מערך ה-dependencies לא מועבר כארגומנטים לפונקציית האפקט. אבל באופן עקרוני, זה מה שהם מייצגים: כל ערך שמצוין בתוך פונקציית האפקט צריך להופיע במערך ה-dependencies. בעתיד, קומפיילר מתקדם יוכל ליצור את המערך באופן אוטומטי.<p>אנו ממליצים על שימוש בחוק <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> כחלק מחבילת ה- <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> שלנו. הוא מזהיר מפני dependencies שמוגדרים לא נכון ומציע תיקון.</blockquote></section><section id="useref-useref"class="level3"><h3><code>useRef</code> {#useref}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> refContainer <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>initialValue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>useRef</code> מחזיר אובייקט ref שניתן לשינוי שמאפיין ה-<code>.current</code> שלו מאותחל לארגומנט המועבר (<code>intialValue</code>). האובייקט המוחזר יתמיד לכל מחזור החיים של הקומפוננטה.<p>מקרה שימוש נפוץ הוא לגשת לילד כשרוצים:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">TextInputWithFocusButton</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> inputEl <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">onButtonClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// `current` מצביע על אלמנט ה-text input </span>
    inputEl<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">.</span><span class="token method function property-access">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span>inputEl<span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">"text"</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onButtonClick<span class="token punctuation">}</span><span class="token operator">></span><span class="token maybe-class-name">Focus</span> the input<span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>במהותו, <code>useRef</code> הוא כמו "קופסה" שיכולה להחזיק ערך שניתן לשינוי בתוך מאפיין ה-<code>.current</code>.<p>אולי אתה מכיר refs בעיקר כדרך <a href="./refs-and-the-dom.html">לגשת ל-DOM</a>. אם אתה מעביר אובייקט ref ל-React עם <code>&#x3C;div ref={myRef}</code>, React יקבע את מאפיין ה-<code>.current</code> ל-DOM node המקביל כשאותו node משתנה.<p>למרות זאת, <code>useRef()</code> שימושי ליותר מתכונת ה-<code>ref</code>. הוא <a href="./hooks-faq.html#is-there-something-like-instance-variables">שימושי לשמירת כל ערך שניתן לשינוי</a> בדומה לדרך שהיית משתמש ב-instance fields במחלקות.<p>זה עובד בגלל ש<code>useRef()</code> יוצר אובייקט JavaScript פשוט. ההבדל היחיד בין <code>useRef()</code> ויצירת אובייקט <code>{current: …}</code> בעצמך היא ש-<code>useRef()</code> ייתן לך את אותו אובייקט ref בכל רינדור.<p>זכור ש-<code>useRef()</code> <em>לא</em> מודיע לך כשהתוכן שלו משתנה. שינוי של המאפיין <code>.current</code> לא גורם לרינדור מחדש. אם אתה רוצה להריץ קוד כש-React מצרף או מנתק ref מ-DOM node, אולי תרצה להשתמש ב-<a href="./hooks-faq.html#how-can-i-measure-a-dom-node">callback ref</a> במקום.</section><section id="useimperativehandle-useimperativehandle"class="level3"><h3><code>useImperativeHandle</code> {#useimperativehandle}</h3><pre class="language-js"><code class="language-js"><span class="token function">useImperativeHandle</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> createHandle<span class="token punctuation">,</span> <span class="token punctuation">[</span>deps<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><code>useImperativeHandle</code> מתאים אישית את הערך ה-instance שנחשף לקומפוננטות הורה בשימוש <code>ref</code>. כמו תמיד, כדאי להימנע מקוד אימפרטיבי בשימוש refs ברוב המקרים. כדאי להשתמש ב-<code>useImperativeHandle</code> עם <code>forwardRef</code>:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">FancyInput</span></span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> inputRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useImperativeHandle</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">focus</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      inputRef<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">.</span><span class="token method function property-access">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span>inputRef<span class="token punctuation">}</span> <span class="token spread operator">...</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token maybe-class-name">FancyInput</span> <span class="token operator">=</span> <span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token maybe-class-name">FancyInput</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>בדוגמה זו, קומפוננטת הורה שמרנדרת <code>&#x3C;FancyInput ref={fancyInputRef} /></code> צריכה להיות מסוגלת לקרוא ל-<code>fancyInputRef.current.focus()</code>.</section><section id="uselayouteffect-uselayouteffect"class="level3"><h3><code>useLayoutEffect</code> {#uselayouteffect}</h3><p>מאפיין זה זהה ל-<code>useEffect</code>, אבל הוא יורה באופן סינכרוני לאחר כל שינויי DOM. השתמש בזה על מנת לקרוא layout מתוך ה-DOM ולרנדר מחדש באופן סינכרוני. עדכונים מתוזמנים בתוך <code>useLayoutEffect</code> ישטפו באופן סינכרוני, לפני שלדפדפן יש הזדמנות לצבוע.<p>העדף את <code>useEffect</code> הסטנדרטי מתי שאפשר על מנת להימנע מחסימת עדכונים ויזואליים.<blockquote><p>טיפ<p>אם אתה מזיז קוד מקומפוננטת מחלקה, שים לב ש-<code>useLayoutEffect</code> יורה באותו קצב כמו <code>componentDidMount</code> ו-<code>componentDidUpdate</code>. לעומת זאת, <strong>אנו ממליצים להתחיל עם <code>useEffect</code> קודם</strong> ולנסות את <code>useLayoutEffect</code> רק אם זה יוצר בעיה.<p>אם אתה משתמש ב-server rendering, שים לב <em>שגם</em> <code>useLayoutEffect</code> וגם <code>useEffect</code> יכולים לרוץ עד שה-Javascript הורד. זאת הסיבה ש-React מזהיר כשקומפוננטה שהיא server-rendered מכילה <code>useLayoutEffect</code>. על מנת לתקן זאת, או שתעביר את הלוגיקה ל-<code>useEffect</code> (אם זה לא נחוץ לרינדור הראשון), או המתן עם הצגת הקומפוננטה עד לאחר רינדור הקליינט (אם ה-HTML נראה שבור עד ש-<code>useLayoutEffect</code> רץ).<p>על מנת להדיר קומפוננטה שצריכה layout effects מ-server-rendered HTML, רנדר אותה בתנאי עם <code>showChild &#x26;&#x26; &#x3C;Child /></code> ועכב את הצגתה עם <code>useEffect(() => { setShowChild(true); }, [])</code>. בדרך זו, ממשק המשתמש לא מופיע שבור לפני הידרציה.</blockquote></section><section id="usedebugvalue-usedebugvalue"class="level3"><h3><code>useDebugValue</code> {#usedebugvalue}</h3><pre class="language-js"><code class="language-js"><span class="token function">useDebugValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span></code></pre><p>ניתן להשתמש ב-<code>useDebugValue</code> על מנת להציג label ל-hooks מותאמים אישית ב-React DevTools.<p>לדוגמה, שקול את ה-hook <code>useFriendStatus</code> שמתואר <a href="./hooks-custom.html">ב"בניית Hooks משלך"</a>:<pre class="language-js{6-8}"><code class="language-js{6-8}">function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  // ...

  // הראה label ב-DevTools ליד ה-Hook הזה
  // לדוגמה "FriendStatus: Online"
  useDebugValue(isOnline ? 'Online' : 'Offline');

  return isOnline;
}</code></pre><blockquote><p>טיפ<p>אנו לא ממליצים להוסיף ערכי debug לכל Hook מותאם אישית. זה נחוץ במיוחד ל-Hooks מותאמים אישית שחלק מספריות משותפות.</blockquote><section id="defer-formatting-debug-values"class="level4"><h4>דחה formatting של ערכי debug</h4><p>במקרים מסוימים לבצע formatting לערך יכול להיות פעולה יקרה. זה גם לא נחוץ אלא אם ה-Hook נבדק.<p>מסיבה זו <code>useDebugValue</code> מקבל פונקציית formatting כפרמטר שני אופציונלי. קוראים לפונקציה זו רק אם ה-Hooks נבדקים. היא מקבלת את ערך ה-debug כפרמטר וצריכה להחזיר ערך הצגה שעבר formatting.<p>לדוגמה Hook מותאם אישית שמחזיר ערך <code>Date</code> יוכל להימנע מלקרוא לפונקציית <code>toDateString</code> באופן לא נחוץ על ידי העברת ה-formatter הבא:<pre class="language-js"><code class="language-js"><span class="token function">useDebugValue</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> <span class="token parameter">date</span> <span class="token arrow operator">=></span> date<span class="token punctuation">.</span><span class="token method function property-access">toDateString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section></section><section id="usedeferredvalue-usedeferredvalue"class="level3"><h3><code>useDeferredValue</code> {#usedeferredvalue}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> deferredValue <span class="token operator">=</span> <span class="token function">useDeferredValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>useDeferredValue</code> accepts a value and returns a new copy of the value that will defer to more urgent updates. If the current render is the result of an urgent update, like user input, React will return the previous value and then render the new value after the urgent render has completed.<p>This hook is similar to user-space hooks which use debouncing or throttling to defer updates. The benefits to using <code>useDeferredValue</code> is that React will work on the update as soon as other work finishes (instead of waiting for an arbitrary amount of time), and like <a href="./react-api.html#starttransition"><code>startTransition</code></a>, deferred values can suspend without triggering an unexpected fallback for existing content.<section id="memoizing-deferred-children"class="level4"><h4>Memoizing deferred children</h4><p><code>useDeferredValue</code> only defers the value that you pass to it. If you want to prevent a child component from re-rendering during an urgent update, you must also memoize that component with <a href="./react-api.html#reactmemo"><code>React.memo</code></a> or <a href="./hooks-reference.html#usememo"><code>React.useMemo</code></a>:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Typeahead</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> query <span class="token operator">=</span> <span class="token function">useSearchQuery</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> deferredQuery <span class="token operator">=</span> <span class="token function">useDeferredValue</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Memoizing tells React to only re-render when deferredQuery changes,</span>
  <span class="token comment">// not when query changes.</span>
  <span class="token keyword">const</span> suggestions <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">SearchSuggestions</span> query<span class="token operator">=</span><span class="token punctuation">{</span>deferredQuery<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>deferredQuery<span class="token punctuation">]</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">SearchInput</span> query<span class="token operator">=</span><span class="token punctuation">{</span>query<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Suspense</span> fallback<span class="token operator">=</span><span class="token string">"Loading results..."</span><span class="token operator">></span>
        <span class="token punctuation">{</span>suggestions<span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Suspense</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Memoizing the children tells React that it only needs to re-render them when <code>deferredQuery</code> changes and not when <code>query</code> changes. This caveat is not unique to <code>useDeferredValue</code>, and it's the same pattern you would use with similar hooks that use debouncing or throttling.</section></section><section id="usetransition-usetransition"class="level3"><h3><code>useTransition</code> {#usetransition}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>isPending<span class="token punctuation">,</span> startTransition<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Returns a stateful value for the pending state of the transition, and a function to start it.<p><code>startTransition</code> lets you mark updates in the provided callback as transitions:<pre class="language-js"><code class="language-js"><span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>isPending</code> indicates when a transition is active to show a pending state:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">App</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isPending<span class="token punctuation">,</span> startTransition<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token arrow operator">=></span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token punctuation">{</span>isPending <span class="token operator">&#x26;&#x26;</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Spinner</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><blockquote><p>Note:<p>Updates in a transition yield to more urgent updates such as clicks.<p>Updates in a transitions will not show a fallback for re-suspended content. This allows the user to continue interacting with the current content while rendering the update.</blockquote></section><section id="useid-useid"class="level3"><h3><code>useId</code> {#useid}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">useId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>useId</code> is a hook for generating unique IDs that are stable across the server and client, while avoiding hydration mismatches.<blockquote><p>Note<p><code>useId</code> is <strong>not</strong> for generating <a href="./lists-and-keys.html#keys">keys in a list</a>. Keys should be generated from your data.</blockquote><p>For a basic example, pass the <code>id</code> directly to the elements that need it:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Checkbox</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">useId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>label htmlFor<span class="token operator">=</span><span class="token punctuation">{</span>id<span class="token punctuation">}</span><span class="token operator">></span><span class="token maybe-class-name">Do</span> you like <span class="token maybe-class-name">React</span><span class="token operator">?</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>label<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>input id<span class="token operator">=</span><span class="token punctuation">{</span>id<span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">"checkbox"</span> name<span class="token operator">=</span><span class="token string">"react"</span><span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>For multiple IDs in the same component, append a suffix using the same <code>id</code>:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">NameFields</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">useId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>label htmlFor<span class="token operator">=</span><span class="token punctuation">{</span>id <span class="token operator">+</span> <span class="token string">'-firstName'</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token maybe-class-name">First</span> <span class="token maybe-class-name">Name</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>label<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
        <span class="token operator">&#x3C;</span>input id<span class="token operator">=</span><span class="token punctuation">{</span>id <span class="token operator">+</span> <span class="token string">'-firstName'</span><span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">"text"</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>label htmlFor<span class="token operator">=</span><span class="token punctuation">{</span>id <span class="token operator">+</span> <span class="token string">'-lastName'</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token maybe-class-name">Last</span> <span class="token maybe-class-name">Name</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>label<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
        <span class="token operator">&#x3C;</span>input id<span class="token operator">=</span><span class="token punctuation">{</span>id <span class="token operator">+</span> <span class="token string">'-lastName'</span><span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">"text"</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><blockquote><p>Note:<p><code>useId</code> generates a string that includes the <code>:</code> token. This helps ensure that the token is unique, but is not supported in CSS selectors or APIs like <code>querySelectorAll</code>.<p><code>useId</code> supports an <code>identifierPrefix</code> to prevent collisions in multi-root apps. To configure, see the options for <a href="./react-dom-client.html#hydrateroot"><code>hydrateRoot</code></a> and <a href="./react-dom-server.html"><code>ReactDOMServer</code></a>.</blockquote></section></section><section id="library-hooks"class="level2"><h2>Library Hooks</h2><p>The following Hooks are provided for library authors to integrate libraries deeply into the React model, and are not typically used in application code.<section id="usesyncexternalstore-usesyncexternalstore"class="level3"><h3><code>useSyncExternalStore</code> {#usesyncexternalstore}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">useSyncExternalStore</span><span class="token punctuation">(</span>subscribe<span class="token punctuation">,</span> getSnapshot<span class="token punctuation">[</span><span class="token punctuation">,</span> getServerSnapshot<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>useSyncExternalStore</code> is a hook recommended for reading and subscribing from external data sources in a way that's compatible with concurrent rendering features like selective hydration and time slicing.<p>This method returns the value of the store and accepts three arguments:<ul><li><code>subscribe</code>: function to register a callback that is called whenever the store changes.<li><code>getSnapshot</code>: function that returns the current value of the store.<li><code>getServerSnapshot</code>: function that returns the snapshot used during server rendering.</ul><p>The most basic example simply subscribes to the entire store:<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">useSyncExternalStore</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span><span class="token property-access">subscribe</span><span class="token punctuation">,</span> store<span class="token punctuation">.</span><span class="token property-access">getSnapshot</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>However, you can also subscribe to a specific field:<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> selectedField <span class="token operator">=</span> <span class="token function">useSyncExternalStore</span><span class="token punctuation">(</span>
  store<span class="token punctuation">.</span><span class="token property-access">subscribe</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> store<span class="token punctuation">.</span><span class="token method function property-access">getSnapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">selectedField</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>When server rendering, you must serialize the store value used on the server, and provide it to <code>useSyncExternalStore</code>. React will use this snapshot during hydration to prevent server mismatches:<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> selectedField <span class="token operator">=</span> <span class="token function">useSyncExternalStore</span><span class="token punctuation">(</span>
  store<span class="token punctuation">.</span><span class="token property-access">subscribe</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> store<span class="token punctuation">.</span><span class="token method function property-access">getSnapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">selectedField</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">INITIAL_SERVER_SNAPSHOT</span><span class="token punctuation">.</span><span class="token property-access">selectedField</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>Note:<p><code>getSnapshot</code> must return a cached value. If getSnapshot is called multiple times in a row, it must return the same exact value unless there was a store update in between.<p>A shim is provided for supporting multiple React versions published as <code>use-sync-external-store/shim</code>. This shim will prefer <code>useSyncExternalStore</code> when available, and fallback to a user-space implementation when it's not.<p>As a convenience, we also provide a version of the API with automatic support for memoizing the result of getSnapshot published as <code>use-sync-external-store/with-selector</code>.</blockquote></section><section id="useinsertioneffect-useinsertioneffect"class="level3"><h3><code>useInsertionEffect</code> {#useinsertioneffect}</h3><pre class="language-js"><code class="language-js"><span class="token function">useInsertionEffect</span><span class="token punctuation">(</span>didUpdate<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The signature is identical to <code>useEffect</code>, but it fires synchronously <em>before</em> all DOM mutations. Use this to inject styles into the DOM before reading layout in <a href="#uselayouteffect"><code>useLayoutEffect</code></a>. Since this hook is limited in scope, this hook does not have access to refs and cannot schedule updates.<blockquote><p>Note:<p><code>useInsertionEffect</code> should be limited to css-in-js library authors. Prefer <a href="#useeffect"><code>useEffect</code></a> or <a href="#uselayouteffect"><code>useLayoutEffect</code></a> instead. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></blockquote></section></section></section>