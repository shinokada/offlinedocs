<!doctypehtml><html lang="he"><meta charset="utf-8"><title>קונטקסט</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="קונטקסט"class="level1"><h1>קונטקסט</h1><p>קונטקסט מספק דרך להעביר מידע דרך עץ הקומפוננטות בלי להשתמש ב-props באופן ידני לכל קומפוננטה.<p>באפליקציית React טיפוסית, המידע מועבר למטה (מקומפוננטת אב לקומפוננטת ילד) דרך props, אבל עבור מידע שנדרש בהרבה קומפוננטות באפליקציה (כמו לדוגמא העדפות שפה או ערכת נושא של ממשק המשתמש) השימוש ב-props יכול להיות מסורבל. קונטקסט מספק דרך לשתף מידע כזה בין קומפוננטות בלי להעביר אותו באופן מפורש לכל קומפוננטה.<ul><li><a href="#when-to-use-context">מתי להשתמש בקונטקסט</a><li><a href="#before-you-use-context">לפני השימוש בקונטקסט</a><li><a href="#api">ממשק תכנות</a><ul><li><a href="#reactcreatecontext">React.createContext</a><li><a href="#contextprovider">Context.Provider</a><li><a href="#classcontexttype">Class.contextType</a><li><a href="#contextconsumer">Context.Consumer</a><li><a href="#contextdisplayname">Context.displayName</a></ul><li><a href="#examples">דוגמאות</a><ul><li><a href="#dynamic-context">קונטקסט דינאמי</a><li><a href="#updating-context-from-a-nested-component">עדכון הקונטקסט מתוך קומפוננטה מקוננת</a><li><a href="#consuming-multiple-contexts">שימוש ביותר מקונטקסט אחד</a></ul><li><a href="#caveats">הסתיגויות</a><li><a href="#legacy-api">ממשק תכנות מדור קודם</a></ul><section id="when-to-use-context"class="level2"><h2>מתי להשתמש בקונטקסט</h2><p>הקונטקסט נועד לשתף מידע שנחשב ״גלובאלי״ לכל הקומפוננטות בעץ, כמו מידע על המשתמש המאומת, ערכת הנושא או השפה המועדפת. בקוד הנ״ל אנחנו מעבירים את ה-prop של ״ערכת הנושא״ בשביל לעצב את קומפוננטת הכפתור:<p><code>embed:context/motivation-problem.js</code><p>בעזרת הקונטקסט, אפשר להמנע מלהעביר את ה-prop דרך רכיבי ביניים:<p><code>embed:context/motivation-solution.js</code></section><section id="before-you-use-context"class="level2"><h2>לפני השימוש בקונטקסט</h2><p>השימוש בקונטקסט נועד בעיקר למצב שבו חלק מהמידע צריך להיות נגיש ל<em>הרבה</em> קומפוננטות בעומקים שונים. עדיף להשתמש בקונטקסט בחסכנות כי הוא יכול להקשות על שימוש חוזר בקומפוננטות.<p><strong>אם המטרה היחידה שלך בשימוש בקונטקסט היא להמנע מהעברת props להרבה קומפוננטות, <a href="./composition-vs-inheritance.html">הכלת קומפוננטות</a> היא בדרך כלל פתרון פשוט יותר.</strong><p>לדוגמא, קומפוננטת <code>Page</code> שמעבירה את ה-props <code>user</code> ו- <code>avatarSize</code> לכמה רמות עומק, כדי שקומפוננטות ילד כמו <code>Link</code> ו- <code>Avatar</code> יוכלו להשתמש בהם:<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Page</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> avatarSize<span class="token operator">=</span><span class="token punctuation">{</span>avatarSize<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token comment">// ... שמרנדרת ...</span>
<span class="token operator">&#x3C;</span><span class="token maybe-class-name">PageLayout</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> avatarSize<span class="token operator">=</span><span class="token punctuation">{</span>avatarSize<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token comment">// ... שמרנדרת ...</span>
<span class="token operator">&#x3C;</span><span class="token maybe-class-name">NavigationBar</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> avatarSize<span class="token operator">=</span><span class="token punctuation">{</span>avatarSize<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token comment">// ... שמרנדרת ...</span>
<span class="token operator">&#x3C;</span><span class="token maybe-class-name">Link</span> href<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">.</span><span class="token property-access">permalink</span><span class="token punctuation">}</span><span class="token operator">></span>
  <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Avatar</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> size<span class="token operator">=</span><span class="token punctuation">{</span>avatarSize<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Link</span><span class="token operator">></span></code></pre><p>יכול להיות שהעברת ה-props <code>user</code> ו- <code>avatarSize</code> דרך כל כך הרבה רמות עומק תרגיש מיותר, בעיקר כי בסוף רק קומפוננטת ה- <code>Avatar</code> באמת משתמשת בהם. זה גם מעצבן שכל פעם שקומפוננטת ה- <code>Avatar</code> צריכה עוד props, צריך להעביר אותם דרך כל רכיבי הביניים.<p>דרך אחת לפתור את הבעיה <strong>ללא שימוש בקונטקסט</strong> היא <a href="./composition-vs-inheritance.html#containment">להעביר את קומפוננטת ה-<code>Avatar</code> עצמה</a> כדי שקומפוננטות הביניים לא יצטרכו לדעת על ה-props <code>user</code> או <code>avatarSize</code>:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Page</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">user</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> userLink <span class="token operator">=</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Link</span> href<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">.</span><span class="token property-access">permalink</span><span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Avatar</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> size<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span><span class="token property-access">avatarSize</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Link</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">PageLayout</span> userLink<span class="token operator">=</span><span class="token punctuation">{</span>userLink<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// :עכשיו, יש לנו</span>
<span class="token operator">&#x3C;</span><span class="token maybe-class-name">Page</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> avatarSize<span class="token operator">=</span><span class="token punctuation">{</span>avatarSize<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token comment">// ... שמרנדרת ...</span>
<span class="token operator">&#x3C;</span><span class="token maybe-class-name">PageLayout</span> userLink<span class="token operator">=</span><span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token comment">// ... שמרנדרת ...</span>
<span class="token operator">&#x3C;</span><span class="token maybe-class-name">NavigationBar</span> userLink<span class="token operator">=</span><span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token comment">// ... שמרנדרת ...</span>
<span class="token punctuation">{</span>props<span class="token punctuation">.</span><span class="token property-access">userLink</span><span class="token punctuation">}</span></code></pre><p>עם השינוי הזה, רק הקומפוננטה העליונה <code>Page</code> צריכה לדעת על קומפוננטות ה- <code>Link</code> וה- <code>Avatar</code> ועל ה-props שהן דורשות.<p>תבנית העיצוב הזו נקראת <em>היפוך שליטה</em> והיא מאפשרת לכתוב קוד נקי יותר במקרים רבים, להפחית את מספר ה- props שצריך להעביר באפליקציה, ולהחזיר שליטה לקומפוננטה העליונה. היפוך שליטה זה, עם זאת, הוא לא תמיד הדרך הנכונה בכל מצב: העברת קוד מסובך למעלה בעץ הקומפוננטה יגרום לקומפוננטת השורש להיות יותר מסובכת ויכריח את קומפוננטות הילד להיות יותר מדי גמישות.<p>אין הגבלה של ילד יחיד לכל קומפוננטה. אפשר להעביר ילדים מרובים, ואפילו ״משבצות״ ("slots") מרובות לילדים, <a href="./composition-vs-inheritance.html#containment">כמתועד כאן</a>:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Page</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">user</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> content <span class="token operator">=</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Feed</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> topBar <span class="token operator">=</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">NavigationBar</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Link</span> href<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">.</span><span class="token property-access">permalink</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Avatar</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> size<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span><span class="token property-access">avatarSize</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Link</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">NavigationBar</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">PageLayout</span>
      topBar<span class="token operator">=</span><span class="token punctuation">{</span>topBar<span class="token punctuation">}</span>
      content<span class="token operator">=</span><span class="token punctuation">{</span>content<span class="token punctuation">}</span>
    <span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>תבנית העיצוב הזאת מספיקה במקרים רבים כשרוצים להפריד קומפוננטת ילד מקומפוננטת האב שלה. אפשר להרחיב את הפתרון עוד יותר עם <a href="./render-props.html">render props</a> במקרים שקומפוננטת הילד צריכה לתקשר עם קומפוננטת האב לפני הרינדור.<p>למרות זאת, לפעמים אותו המידע צריך להיות נגיש ע״י מספר קומפוננטות בעץ, ובעומקים שונים. במקרים כאלה, הקונטקסט מאפשר ״לשדר״ את המידע, ושינויים במידע, לכל הקומפוננטות בעץ. דוגמאות שכיחות שבן שימוש בקונטקסט פשוט יותר מהאלטרנטיבות הן כמתואר קודם - ערכות נושא, העדפות שפה או זכרון מטמון.</section><section id="api"class="level2"><h2>ממשק תכנות</h2><section id="reactcreatecontext-reactcreatecontext"class="level3"><h3><code>React.createContext</code> {#reactcreatecontext}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">MyContext</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">createContext</span><span class="token punctuation">(</span>defaultValue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>הקוד הזה יוצר אובייקט קונטקסט. כש- React מרנדר את הקומפוננטות שמאזינות לקונטקסט, הוא קורא את ערך הקונטקסט מהספק ("Provider") הקרוב ביותר מעליו בעץ.<p>ערך ברירת המחדל נקרא <strong>רק</strong> כשאין לקומפוננטה מעליה בעץ ספק תואם. ערך ברירת מחדל זה יכול להיות שימושי בבדיקות אוטומטיות לקומפוננטות מבודדות - בלי צורך לעטוף אותן. הערה: העברת הערך <code>undefined</code> כערך הספק לא יגרום לקומפוננטות תחתיו לצרוך את ערך ברירת המחדל.</section><section id="contextprovider-contextprovider"class="level3"><h3><code>Context.Provider</code> {#contextprovider}</h3><pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">MyContext</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Provider</span></span> value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token comment">/* some value */</span><span class="token punctuation">}</span><span class="token operator">></span></code></pre><p>כל עצם קונטקסט מגיע עם קומפוננטת ספק (Provider) שנותנת לקומפוננטות שצורכות אותו להקשיב לשינויים בקונטקסט. הספק מקבל prop <code>value</code> שיועבר לקומפוננטות ילד שצורכות את הספק בכל רמות העומק של העץ. ספק אחד יכול להתחבר לצרכנים רבים. אפשר להגדיר ספקים ברמות שונות של אותו העץ כדי לעקוף את הערכים המוגדרים בהם בעומקים שונים של עץ הקומפוננטות.<p>קומפוננטת הספק מקבלת prop <code>value</code> אשר יועבר לקומפוננטות צאצאיות הצורכות מספק זה. ספק אחד יכול להיות מחובר להרבה צרכנים. ספקים יכולים להיות מקוננים כדי לדרוס ערכים עמוק יותר בתוך העץ.<p>כל הצרכנים שהם צאצאים של ספק, ירונדרו בכל שינוי ב-prop <code>value</code>. ההפצה מהספק לצאצאיו הצרכנים (כולל <a href="./context.html#classcontexttype">.contextType</a> ו-<a href="./hooks-reference.html#usecontext">useContext</a>) אינה כפופה למתודה <code>shouldComponentUpdate</code>, כך שהצרכן מתעדכן אפילו כשקומפוננטה מעליו מדלגת על העדכון.<p>שינויים נקבעים ע״י השוואת הערכים החדשים מול הישנים בעזרת אותו האלגוריתם כמו <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"><code>Object.is</code></a>.<blockquote><p>הערה<p>הדרך שבה שינויים נקבעים יכולה ליצור בעיות כשמעבירים עצמים כערכים: ראה <a href="#caveats">הסתיגויות</a>.</blockquote></section><section id="classcontexttype-classcontexttype"class="level3"><h3><code>Class.contextType</code> {#classcontexttype}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">context</span><span class="token punctuation">;</span>
    <span class="token comment">/* MyContext-בשימוש בערך ה mount-יגרום לתופעת לואי בזמן ה */</span>
  <span class="token punctuation">}</span>
  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">context</span><span class="token punctuation">;</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">context</span><span class="token punctuation">;</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">context</span><span class="token punctuation">;</span>
    <span class="token comment">/*MyContext-ירנדר משהו שמבוסס על ערך ה */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token maybe-class-name">MyClass</span><span class="token punctuation">.</span><span class="token property-access">contextType</span> <span class="token operator">=</span> <span class="token maybe-class-name">MyContext</span><span class="token punctuation">;</span></code></pre><p>מאפיין ה-<code>contextType</code> במחלקה מוקצה בעצם קונטקסט שנוצר על ידי המתודה <a href="#reactcreatecontext"><code>React.createContext()</code></a>. שימוש במאפיין זה נותן לנו לצרוך את ערך הקונטקסט הנוכחי הקרוב ביותר בעזרת <code>this.context</code>. אפשר להשתמש בהפניה זו בכל אחת ממתודות מחזור החיים כולל מתודת הרינדור.<blockquote><p>הערה:<p>אפשר לצרוך רק קונטקסט אחד בעזרת ממשק זה. על מנת לצרוך יותר מאחד, ראו <a href="#consuming-multiple-contexts">שימוש ביותר מקונטקסט אחד</a>.<p>אם אתם משתמשים בסינטקסט הנסיוני של <a href="https://babeljs.io/docs/plugins/transform-class-properties/">מאפייני מחלקה ציבורית</a>, תוכלו להשתמש במאפיין מחלקה <strong>סטטי</strong> על מנת לאתחל את ה- <code>contextType</code>.</blockquote><pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> contextType <span class="token operator">=</span> <span class="token maybe-class-name">MyContext</span><span class="token punctuation">;</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">context</span><span class="token punctuation">;</span>
    <span class="token comment">/* רינדור משהו בהתאם לערך */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></section><section id="contextconsumer-contextconsumer"class="level3"><h3><code>Context.Consumer</code> {#contextconsumer}</h3><pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">MyContext</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Consumer</span></span><span class="token operator">></span>
  <span class="token punctuation">{</span><span class="token parameter">value</span> <span class="token arrow operator">=></span> <span class="token comment">/* רינדור משהו בהתאם לערך */</span><span class="token punctuation">}</span>
<span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">MyContext</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Consumer</span></span><span class="token operator">></span></code></pre><p>קומפוננטת React שמקשיבה לשינויים בקונטקסט. שימוש בקומפוננטה זו מאפשר לצרוך קונטקסט מתוך <a href="./components-and-props.html#function-and-class-components">קומפוננטת פונקציה</a>.<p>דורשת <a href="./render-props.html#using-props-other-than-render">פונקציה בתור ילד</a>. הפונקציה הזאת מקבלת את ערך הקונטקסט הנוכחי ומחזירה צומת React. ערך הארגומנט שמועבר לפונקציה יהיה זהה ל- <code>value</code> prop של ספק הקונטקסט הקרוב ביותר מעלינו בעץ. אם אין ספק לקונטקס, הערך יהיה זהה לערך ברירת המחדל שנקבע בזמן יצירת הקונטקסט (עם <code>createContext()</code>).<blockquote><p>הערה<p>למידע נוסף על תבנית ״פונקציה כילד״ בקרו בעמוד <a href="./render-props.html">render props</a>.</blockquote></section><section id="contextdisplayname-contextdisplayname"class="level3"><h3><code>Context.displayName</code> {#contextdisplayname}</h3><p>אובייקט context מקבל מאפיין <code>displayName</code> מסוג מחרוזת. React DevTools משתמש במחרוזת זו על מנת לקבוע מה להציג ל-context.<p>לדוגמה, הקומפוננטה הבאה תופיע כ-MyDisplayName ב-DevTools:<pre class="language-js{2}"><code class="language-js{2}">const MyContext = React.createContext(/* ערך מסויים */);
MyContext.displayName = 'MyDisplayName';

&#x3C;MyContext.Provider> // "MyDisplayName.Provider" ב-DevTools
&#x3C;MyContext.Consumer> // "MyDisplayName.Consumer" ב-DevTools</code></pre></section></section><section id="examples"class="level2"><h2>דוגמאות</h2><section id="dynamic-context"class="level3"><h3>קונטקסט דינאמי</h3><p>דוגמא מורכבת יותר עם ערך דינאמי של ערכת הנושא:<p><strong>theme-context.js</strong> <code>embed:context/theme-detailed-theme-context.js</code><p><strong>themed-button.js</strong> <code>embed:context/theme-detailed-themed-button.js</code><p><strong>app.js</strong> <code>embed:context/theme-detailed-app.js</code></section><section id="updating-context-from-a-nested-component"class="level3"><h3>עדכון הקונטקסט מתוך קומפוננטה מקוננת</h3><p>לפעמים יש צורך לעדכן את הקונטקסט מתוך קומפוננטה שמוגדרת עמוק בתוך עץ הקומפוננטות. במקרה הזה, אפשר להעביר פונקציה דרך הקונטקסט כדי לתת לצרכניו לעדכן אותו:<p><strong>theme-context.js</strong> <code>embed:context/updating-nested-context-context.js</code><p><strong>theme-toggler-button.js</strong> <code>embed:context/updating-nested-context-theme-toggler-button.js</code><p><strong>app.js</strong> <code>embed:context/updating-nested-context-app.js</code></section><section id="consuming-multiple-contexts"class="level3"><h3>שימוש ביותר מקונטקסט אחד</h3><p>כדי לודא שרינדור הקונטקסט מחדש יהיה מהיר, React צריך להפוך את כל אחד מצרכני הקונטקסט לצומת נפרדת בעץ.<p><code>embed:context/multiple-contexts.js</code><p>אם שני ערכי קונטקסט (או יותר) בדרך כלל משומשים ביחד, יכול להיות שתרצו לשקול יצירת קומפוננטת רינדור prop שתספק אותם ביחד.</section></section><section id="caveats"class="level2"><h2>הסתיגויות</h2><p>בגלל שקונטקסט משתמש בזיהוי הפניה כדי להחליט מתי לעורר רינדור מחדש, יש כל מיני מקרי קצה שיכולים לגרום לרינדור הצרכנים בטעות, כשקומפוננטת האב של הספק מרנדרת את עצמה מחדש. לדוגמא, הקוד הנ״ל ירדנר את כל הצרכנים בכל פעם שהספק מרנדר את עצמו מחדש, כיוון ש-<code>value</code> הוא עצם שנוצר מחדש כל פעם:<p><code>embed:context/reference-caveats-problem.js</code><p>כדי לעקוף את הבעיה הזאת, אפשר להעביר את הערך ל-state של האב:<p><code>embed:context/reference-caveats-solution.js</code></section><section id="legacy-api"class="level2"><h2>ממשק תכנות מדור קודם</h2><blockquote><p>הערה<p>בעבר, React הכילה ממשק תכנות נסיוני לקונטקסט. הממשק הישן ייתמך בכל גרסאות ה-16.x, אבל אפליקציות שמשתמשות בו צריכות לעבור לשימוש בגרסה החדשה. הממשק הישן יוסר בגרסה הראשית הבאה של React. עוד מידע על <a href="./legacy-context.html">ממשק הקונטקסט הישן</a>. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></blockquote></section></section>