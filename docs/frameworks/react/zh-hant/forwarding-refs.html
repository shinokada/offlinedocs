<!doctype html>
<html lang="zh-hant">
  <head>
    <meta charset="utf-8">
    <title>傳送 Ref</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="傳送-ref" class="level1">
      <h1>傳送 Ref</h1>
      <p>傳送 ref 是一種自動把 <a href="./refs-and-the-dom.html">ref</a> 從一個 component 傳遞到它底下的其中一個 child 的技巧。通常來說，應用程式裡大部分的 component 都不需要用到它。然而，對某些種類的 component 來說它很有用，特別是能夠重複使用的函式庫。以下會解釋最常見的情形。</p>
      <section id="forwarding-refs-to-dom-components" class="level2">
        <h2>傳送 ref 到 DOM component</h2>
        <p>試著考慮一個叫做 <code>FancyButton</code> 的 component，它會 render 一個原生的 <code>button</code> DOM element：<code>embed:forwarding-refs/fancy-button-simple.js</code></p>
        <p>React component 會隱藏包含 render 的結果在內的實作細節。其他使用到 <code>FancyButton</code> 的 component <strong>通常不需要</strong>獲得內部按鈕的 DOM element 的 <a href="./refs-and-the-dom.html">ref</a>。這樣帶來的好處是，我們能夠避免讓其他 component 過度依賴彼此的 DOM 的結構。</p>
        <p>雖然這樣的封裝對於應用程式層級的 component（像是 <code>FeedStory</code> 或 <code>Comment</code>）來說是我們所希望擁有的，但對於常用的「末端」 component，像是 <code>FancyButton</code> 或 <code>MyTextInput</code> 來說，可能會變得不方便使用。這些末端 component 通常會像普通的 DOM <code>button</code> 和 <code>input</code> 一樣，在應用程式的各個地方被使用，在處理 focus、選取或動畫時，取得它們的 DOM 節點可能是不可避免的。</p>
        <p><strong>傳送 ref 是個選擇性的功能，它能夠讓某些 component 利用它們收到的 <code>ref</code> 來傳遞到底下的 child component。</strong></p>
        <p>在下面的例子中，<code>FancyButton</code> 藉由 <code>React.forwardRef</code> 來獲取傳遞到它身上的 <code>ref</code>，然後再傳遞到它 render 的 DOM <code>button</code> 上：</p>
        <p><code>embed:forwarding-refs/fancy-button-simple-ref.js</code></p>
        <p>這樣一來，使用 <code>FancyButton</code> 的 component 可以獲得它底下的 <code>button</code> 的 DOM 節點的 ref，並可以在需要的時候獲取它 —— 就如同直接使用 <code>button</code> DOM 一樣。</p>
        <p>以下一步一步的解釋上面的例子到底發生了什麼事：</p>
        <ol>
          <li>我們藉由呼叫 <code>React.createRef</code> 產生了一個 <a href="./refs-and-the-dom.html">React ref</a>，然後將它賦值於叫做 <code>ref</code> 的變數裡。</li>
          <li>我們藉由把 <code>ref</code> 當成一個 JSX attribute 來把它傳遞到 <code>&#x3C;FancyButton ref={ref}></code>。</li>
          <li>React 把 <code>ref</code> 當作第二個變數傳到 <code>forwardRef</code> 裡的 <code>(props, ref) => ...</code> function。</li>
          <li>我們藉由把這個 <code>ref</code> 當作 JSX attribute 來傳遞到更下面的 <code>&#x3C;button ref={ref}></code>。</li>
          <li>當 ref 被附上之後，<code>ref.current</code> 會指向 <code>&#x3C;button></code> DOM 節點。</li>
        </ol>
        <blockquote>
          <p>注意</p>
          <p>第二個 <code>ref</code> 變數只會在你用 <code>React.forwardRef</code> 呼叫定義一個 component 的時候存在。一般 function 或 class component 不會獲得 <code>ref</code> 變數，且在 props 裡 ref 也不存在。。</p>
          <p>傳送 ref 不侷限於 DOM 元件。你可以也將 ref 傳遞到 class component。</p>
        </blockquote>
      </section>
      <section id="note-for-component-library-maintainers" class="level2">
        <h2>對於 component 函式庫維護者的提醒</h2>
        <p><strong>當你在函式庫開始使用 <code>forwardRef</code> 時，你應該要把它當作重大變化，然後為你的元件庫發佈新的主要版號。</strong> 因為你的函式庫可能會有可見的不同行為（像是 ref 被指定在哪，或是什麼型別會被輸出），然後它可能會破壞那些依賴於舊有行為的應用程式或其他套件。</p>
        <p>有條件的在 ref 存在時才使用 <code>React.forwardRef</code> 也是不推薦的方式，相同的原因：它改變了你的套件的行為，且當你的使用者升級 React 之後可能會破壞使用者的應用程式。</p>
      </section>
      <section id="forwarding-refs-in-higher-order-components" class="level2">
        <h2>在 Higher-Order Component 內傳送 ref</h2>
        <p>
          在 <a href="./higher-order-components.html">Higher-Order Component</a>（也叫做 HOC）裡，這樣的技巧會特別有用。讓我們用一個會把 component 的 prop 記錄到 console 的 HOC 為例：
          <code>embed:forwarding-refs/log-props-before.js</code>
        </p>
        <p>
          這個「logProps」HOC 把所有的 <code>prop</code> 傳遞到他所包裹的 component，所以被 render 出的結果會是一樣的。舉例來說，我們可以用這個 HOC 來記錄所有經過「fancy button」元件的 prop：
          <code>embed:forwarding-refs/fancy-button.js</code>
        </p>
        <p>以上的範例有個警告：ref 不會被傳遞過去。因為 <code>ref</code> 不是個 prop。就像 <code>key</code> 一樣，React 用不同的方式處理它。如果你想要在 HOC 加上一個 ref，ref 會被指定到最外層的 component，而不是直接包裹它的那個 component。</p>
        <p>
          這代表對於 <code>FancyButton</code> component 所用的 ref 會直接被附到 <code>LogProps</code> component：
          <code>embed:forwarding-refs/fancy-button-ref.js</code>
        </p>
        <p>
          幸運的是，我們可以刻意利用 <code>React.forwardRef</code> API 把 ref 傳送到裡面的 <code>FancyButton</code> component。<code>React.forwardRef</code> 接受一個用到 <code>props</code> 和 <code>ref</code> 參數的 render 的 function 並回傳一個 React 節點。例如：
          <code>embed:forwarding-refs/log-props-after.js</code>
        </p>
      </section>
      <section id="displaying-a-custom-name-in-devtools" class="level2">
        <h2>在 DevTool 裡顯示客製化的名稱</h2>
        <p><code>React.forwardRef</code> 接受一個 render function。React DevTool 使用這個 function 來決定這個傳送 ref 的 component 該顯示什麼。</p>
        <p>例如，在 DevTool 裡，這個傳送的 component 會顯示為 「<em>ForwardRef</em>」：</p>
        <p><code>embed:forwarding-refs/wrapped-component.js</code></p>
        <p>如果你對 render function 取名，DevTool 會包含它的名字（例如：「<em>ForwardRef(myFunction)</em>」）：</p>
        <p><code>embed:forwarding-refs/wrapped-component-with-function-name.js</code></p>
        <p>你也可以設定 function 的 <code>displayName</code> 來包裹你的 component：</p>
        <p>
          <code>embed:forwarding-refs/customized-display-name.js</code>
          <span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span>
        </p>
      </section>
    </section>
  </body>
</html>
