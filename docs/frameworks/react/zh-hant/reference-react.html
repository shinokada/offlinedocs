<!doctype html>
<html lang="zh-hant">
  <head>
    <meta charset="utf-8">
    <title>React 頂層 API</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="react-頂層-api" class="level1">
      <h1>React 頂層 API</h1>
      <p><code>React</code> 是 React 函式庫的進入點。 如果你使用 <code>&#x3C;script></code> 標籤載入 React,這些頂層 API 可以在 <code>React</code> 全域變數使用。如果你使用 ES6 撰寫並使用 npm，你可以寫成 <code>import React from 'react'</code> 。如果你使用 ES5 撰寫並使用 npm，你可以寫成 <code>var React = require('react')</code> 。</p>
      <section id="overview" class="level2">
        <h2>概觀</h2>
        <section id="components" class="level3">
          <h3>Component</h3>
          <p>React component 可以讓你把 UI 切分為獨立並可重複使用的單位，並且每個單位可以抽出來獨立思考。React component 可以透過繼承 <code>React.Component</code> 或是 <code>React.PureComponent</code> 定義。</p>
          <ul>
            <li><a href="#reactcomponent"><code>React.Component</code></a></li>
            <li><a href="#reactpurecomponent"><code>React.PureComponent</code></a></li>
          </ul>
          <p>如果你沒有使用 ES6 class，你可以使用 <code>create-react-class</code> 模組。請參閱<a href="./react-without-es6.html">使用 React 但不使用 ES6</a> 取得更多資訊。</p>
          <p>React component 也可以定義為 function 並可以被封裝：</p>
          <ul>
            <li><a href="#reactmemo"><code>React.memo</code></a></li>
          </ul>
        </section>
        <section id="creating-react-elements" class="level3">
          <h3>建立 React Element</h3>
          <p>我們推薦<a href="./introducing-jsx.html">使用 JSX</a> 來描述你的 UI 應該長成什麼樣子。 每個 JSX element 都只是呼叫 <a href="#createelement"><code>React.createElement()</code></a> 的語法糖。當你使用 JSX 的時候你將不需要直接呼叫以下的 method：</p>
          <ul>
            <li><a href="#createelement"><code>createElement()</code></a></li>
            <li><a href="#createfactory"><code>createFactory()</code></a></li>
          </ul>
          <p>參閱<a href="./react-without-jsx.html">使用 React 但不使用 JSX</a> 取得更多資訊。</p>
        </section>
        <section id="transforming-elements" class="level3">
          <h3>操作 Element</h3>
          <p><code>React</code> 提供了多種 API 讓你可以操作 element：</p>
          <ul>
            <li><a href="#cloneelement"><code>cloneElement()</code></a></li>
            <li><a href="#isvalidelement"><code>isValidElement()</code></a></li>
            <li><a href="#reactchildren"><code>React.Children</code></a></li>
          </ul>
        </section>
        <section id="fragments" class="level3">
          <h3>Fragment</h3>
          <p><code>React</code> 也提供了一個 component 讓你一次 render 多個 element 而不需要額外的 wrapper。</p>
          <ul>
            <li><a href="#reactfragment"><code>React.Fragment</code></a></li>
          </ul>
        </section>
        <section id="refs" class="level3">
          <h3>Refs</h3>
          <ul>
            <li><a href="#reactcreateref"><code>React.createRef</code></a></li>
            <li><a href="#reactforwardref"><code>React.forwardRef</code></a></li>
          </ul>
        </section>
        <section id="suspense" class="level3">
          <h3>Suspense</h3>
          <p>Suspense 讓 components 在 render 之前可以「暫停」並等待其他事情。目前 Suspense 只支援一個情境：<a href="./code-splitting.html#reactlazy">使用 <code>React.lazy</code> 動態載入 component</a> 。在未來，我們也會支援像是抓取資料等更多的使用情境。</p>
          <ul>
            <li><a href="#reactlazy"><code>React.lazy</code></a></li>
            <li><a href="#reactsuspense"><code>React.Suspense</code></a></li>
          </ul>
        </section>
        <section id="transitions" class="level3">
          <h3>Transitions</h3>
          <p><em>Transitions</em> 是 React 18 引入的新 concurrent 功能。它們允許你 mark 更新為 transitions，這是告訴 React 它們可以被中斷，並且對於已經可看見的內容，避免回到 Suspense fallback。</p>
          <ul>
            <li><a href="#starttransition"><code>React.startTransition</code></a></li>
            <li><a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a></li>
          </ul>
        </section>
        <section id="hooks" class="level3">
          <h3>Hooks</h3>
          <p><em>Hooks</em> 是 React 16.8 開始的新功能。這讓你可以使用 state 以及其他的 React 功能而不需要撰寫一個 class。Hooks 有一個專屬的<a href="./hooks-intro.html">文件專區</a> 和分開的 API 參考資料：</p>
          <ul>
            <li><a href="./hooks-reference.html#basic-hooks">基本 Hooks</a>
              <ul>
                <li><a href="./hooks-reference.html#usestate"><code>useState</code></a></li>
                <li><a href="./hooks-reference.html#useeffect"><code>useEffect</code></a></li>
                <li><a href="./hooks-reference.html#usecontext"><code>useContext</code></a></li>
              </ul>
            </li>
            <li><a href="./hooks-reference.html#additional-hooks">進階 Hooks</a>
              <ul>
                <li><a href="./hooks-reference.html#usereducer"><code>useReducer</code></a></li>
                <li><a href="./hooks-reference.html#usecallback"><code>useCallback</code></a></li>
                <li><a href="./hooks-reference.html#usememo"><code>useMemo</code></a></li>
                <li><a href="./hooks-reference.html#useref"><code>useRef</code></a></li>
                <li><a href="./hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a></li>
                <li><a href="./hooks-reference.html#uselayouteffect"><code>useLayoutEffect</code></a></li>
                <li><a href="./hooks-reference.html#usedebugvalue"><code>useDebugValue</code></a></li>
                <li><a href="./hooks-reference.html#usedeferredvalue"><code>useDeferredValue</code></a></li>
                <li><a href="./hooks-reference.html#usetransition"><code>useTransition</code></a></li>
                <li><a href="./hooks-reference.html#useid"><code>useId</code></a></li>
              </ul>
            </li>
            <li><a href="./hooks-reference.html#library-hooks">Library Hooks</a>
              <ul>
                <li><a href="./hooks-reference.html#usesyncexternalstore"><code>useSyncExternalStore</code></a></li>
                <li><a href="./hooks-reference.html#useinsertioneffect"><code>useInsertionEffect</code></a></li>
              </ul>
            </li>
          </ul>
          <hr>
        </section>
      </section>
      <section id="reference" class="level2">
        <h2>參考資料</h2>
        <section id="reactcomponent-reactcomponent" class="level3">
          <h3><code>React.Component</code> {#reactcomponent}</h3>
          <p><code>React.Component</code> 是當你使用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6 classes</a> 定義 React component 時所用的 base class：</p>
          <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Greeting</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token maybe-class-name">Hello</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
          <p>參閱 <a href="./react-component.html">React.Component API 參考資料</a> 可查到跟 <code>React.Component</code> 相關的 method 及 properties。</p>
          <hr>
        </section>
        <section id="reactpurecomponent-reactpurecomponent" class="level3">
          <h3><code>React.PureComponent</code> {#reactpurecomponent}</h3>
          <p><code>React.PureComponent</code> 跟 <a href="#reactcomponent"><code>React.Component</code></a> 很相似。他們之間的差別是 <a href="#reactcomponent"><code>React.Component</code></a> 並沒有實作 <a href="./react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a>，但 <code>React.PureComponent</code> 提供了一個實作以對於 prop 及 state 進行 shallow compare。</p>
          <blockquote>
            <p>備註</p>
            <p><code>React.PureComponent</code> 的 <code>shouldComponentUpdate()</code> 只對 object 進行 shallow compare。如果這些 object 包含複雜的資料結構，在深層的資料有所改變的時候將有可能回傳錯誤結果 (false-negative)。繼承 <code>PureComponent</code> 的時候，請確保你只有簡單的 prop 跟 state，或在當你知道深層的資料有所改變的時候使用 <a href="./react-component.html#forceupdate"><code>forceUpdate()</code></a>。你也可以考慮改用 <a href="https://immutable-js.com/">immutable objects</a> 進行快速的深層資料比較。</p>
            <p>此外，<code>React.PureComponent</code> 的 <code>shouldComponentUpdate()</code> 將會跳過整個 subtree 的 prop 更新。請確保所有 children component 也是「pure」的。</p>
          </blockquote>
          <hr>
        </section>
        <section id="reactmemo-reactmemo" class="level3">
          <h3><code>React.memo</code> {#reactmemo}</h3>
          <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token maybe-class-name">MyComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* render using props */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
          <p><code>React.memo</code> 是一個 <a href="./higher-order-components.html">higher order component</a>。</p>
          <p>如果你的 function component 每次得到相同 prop 的時候都會 render 相同結果，你可以將其包在 <code>React.memo</code> 之中，透過快取 render 結果來在某些情況下加速。這表示 React 會跳過 render 這個 component，並直接重用上次的 render 結果。</p>
          <p><code>React.memo</code> 只會確認 props 的改變。如果你的 function component 被 wrap 在 <code>React.memo</code> 內，實作中具有一個 <a href="./hooks-state.html"><code>useState</code></a>、<a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> 或 <a href="./hooks-reference.html#usecontext"><code>useContext</code></a> Hook，當 state 或 context 改變時，它仍然會持續 rerender。</p>
          <p>這預設只會對 prop 進行 shallow compare 。如果你需要控制比較的方法，你可以提供一個自訂的比較 function 作為第二個參數。</p>
          <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* render using props */</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">areEqual</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*
  return true if passing nextProps to render would return
  the same result as passing prevProps to render,
  otherwise return false
  */</span>
<span class="token punctuation">}</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token maybe-class-name">MyComponent</span><span class="token punctuation">,</span> areEqual<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
          <p>這個 function 是用來作為<strong><a href="./optimizing-performance.html">效能最佳化</a></strong>所用。請勿依賴這個 function 來「避免」render，這可能會產生 bug。</p>
          <blockquote>
            <p>備註</p>
            <p>與 class component 的 <a href="./react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a> method 不同,<code>areEqual</code> function 當 prop 相等的時候回傳 <code>true</code>，不相等的時候回傳 <code>false</code>。 這跟 <code>shouldComponentUpdate</code> 剛好相反。</p>
          </blockquote>
          <hr>
        </section>
        <section id="createelement-createelement" class="level3">
          <h3><code>createElement()</code> {#createelement}</h3>
          <pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">createElement</span><span class="token punctuation">(</span>
  type<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>props<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token spread operator">...</span>children<span class="token punctuation">]</span>
<span class="token punctuation">)</span></code></pre>
          <p>建立並回傳一個新的 <a href="./rendering-elements.html">React element</a> 描述指定的 type。 Type 參數可以是一個標籤名稱字串（像是 <code>'div'</code> 或是 <code>'span'</code>）、一個 <a href="./components-and-props.html">React component</a> type (class 或是 function) 或者是一個 <a href="#reactfragment">React fragment</a> type。</p>
          <p>使用 <a href="./introducing-jsx.html">JSX</a> 寫的程式將會被轉換使用 <code>React.createElement()</code>。如果使用 JSX，你通常不需要自己呼叫 <code>React.createElement()</code>。請參閱<a href="./react-without-jsx.html">使用 React 但不使用 JSX</a>。</p>
          <hr>
        </section>
        <section id="cloneelement-cloneelement" class="level3">
          <h3><code>cloneElement()</code> {#cloneelement}</h3>
          <pre class="language-text"><code class="language-text">React.cloneElement(
  element,
  [config],
  [...children]
)</code></pre>
          <p>使用 <code>element</code> 作為開始 clone 並回傳一個新 React element。<code>config</code> 應該包含所有新的 props、<code>key</code>、或 <code>ref</code>。產生的 element 將會有原始 element 的 props 以及新 props 的 shallow merge。新的 children 會取代現有的 children。如果 <code>config</code> 中不存在 <code>key</code> 和 <code>ref</code>，則原始的 <code>key</code> 和 <code>ref</code> 會被保留。</p>
          <p><code>React.cloneElement()</code> 幾乎等於：</p>
          <pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span>element<span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>props<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token operator">></span></code></pre>
          <p>但是，這同時也會保留 <code>ref</code>。如果你有一個 child 上有 <code>ref</code> 的時候，你將不會不小心從你的上層元件偷走 ref。你的新 element 會保留一樣的 <code>ref</code>。如果有存在 <code>ref</code> 或 <code>key</code> 的話，將會取代舊的。</p>
          <p>這個 API 是用來取代目前已經過時的 <code>React.addons.cloneWithProps()</code>。</p>
          <hr>
        </section>
        <section id="createfactory-createfactory" class="level3">
          <h3><code>createFactory()</code> {#createfactory}</h3>
          <pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">createFactory</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span></code></pre>
          <p>回傳一個 function 可以產生指定 type 的 React element。跟 <a href="#createelement"><code>React.createElement()</code></a> 一樣，這個 type 參數可以是一個標籤名稱字串（像是 <code>'div'</code> 或是 <code>'span'</code>）、一個 <a href="./components-and-props.html">React component</a> type (class 或是 function) 或者是一個 <a href="#reactfragment">React fragment</a> type。</p>
          <p>這個 helper 已經被認定為過時，我們建議你使用 JSX 或是直接使用 <code>React.createElement()</code>。</p>
          <p>如果使用 JSX，你通常不需要自己呼叫 <code>React.createFactory()</code>。請參閱<a href="./react-without-jsx.html">使用 React 但不使用 JSX</a>。</p>
          <hr>
        </section>
        <section id="isvalidelement-isvalidelement" class="level3">
          <h3><code>isValidElement()</code> {#isvalidelement}</h3>
          <pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">isValidElement</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span></code></pre>
          <p>檢查一個 object 是否為 React element。通常回傳 <code>true</code> 或是 <code>false</code>。</p>
          <hr>
        </section>
        <section id="reactchildren-reactchildren" class="level3">
          <h3><code>React.Children</code> {#reactchildren}</h3>
          <p><code>React.Children</code> 提供了一些工具可以將 <code>this.props.children</code> 作為不透明的資料結構處理。</p>
          <section id="reactchildrenmap-reactchildrenmap" class="level4">
            <h4><code>React.Children.map</code> {#reactchildrenmap}</h4>
            <pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">[</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>
            <p>對每一個列為 <code>children</code> 之中的直接 child 呼叫 function 並將 <code>this</code> 設定為 <code>thisArg</code>。如果 <code>children</code> 是一個 array，這將會列舉整個 array 並對每一個 child 呼叫這個 function。如果 children 是 <code>null</code> 或是 <code>undefined</code>，這個 method 將會回傳 <code>null</code> 或是 <code>undefined</code> 而不是一個 array。</p>
            <blockquote>
              <p>備註</p>
              <p>如果 <code>children</code> 是一個 <code>Fragment</code>，它將會被視為只有一個 child 而不會繼續深入列舉。</p>
            </blockquote>
          </section>
          <section id="reactchildrenforeach-reactchildrenforeach" class="level4">
            <h4><code>React.Children.forEach</code> {#reactchildrenforeach}</h4>
            <pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">[</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>
            <p>跟 <a href="#reactchildrenmap"><code>React.Children.map()</code></a> 一樣，但不會回傳一個 array 。</p>
          </section>
          <section id="reactchildrencount-reactchildrencount" class="level4">
            <h4><code>React.Children.count</code> {#reactchildrencount}</h4>
            <pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">count</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre>
            <p>回傳 <code>children</code> 到底有幾個 child，跟傳入 <code>map</code> 或是 <code>forEach</code> 的 callback 會被呼叫的次數一致。</p>
          </section>
          <section id="reactchildrenonly-reactchildrenonly" class="level4">
            <h4><code>React.Children.only</code> {#reactchildrenonly}</h4>
            <pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">only</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre>
            <p>確認 <code>children</code> 只有一個 child (一個 React element）並回傳它，不然這個 method 將會拋出錯誤。</p>
            <blockquote>
              <p>備註</p>
              <p><code>React.Children.only()</code> 無法接受 <a href="#reactchildrenmap"><code>React.Children.map()</code></a> 的回傳值，因為那個回傳值將會是一個 array 而不是一個 React element 。</p>
            </blockquote>
          </section>
          <section id="reactchildrentoarray-reactchildrentoarray" class="level4">
            <h4><code>React.Children.toArray</code> {#reactchildrentoarray}</h4>
            <pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">toArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre>
            <p>將 <code>children</code> 這個不透明的資料結構轉為一個扁平的 array 並對每個 child 指定一個 key。如果你想要在你的 render method 中操作 children 的集合時非常有用，特別是當你想要在傳遞它們之前調整順序或是擷取一部份 <code>this.props.children</code> 的時候。</p>
            <blockquote>
              <p>備註</p>
              <p><code>React.Children.toArray()</code> 會改變 key 來保留巢狀 array 的語意。也就是說 <code>toArray</code> 將會在每個 key 前面加入前綴，確保每個 element 的 key 都在與它原本輸入的 array 相關。</p>
            </blockquote>
            <hr>
          </section>
        </section>
        <section id="reactfragment-reactfragment" class="level3">
          <h3><code>React.Fragment</code> {#reactfragment}</h3>
          <p><code>React.Fragment</code> 讓你可以在一個 <code>render()</code> method 中一次回傳多個 element 而不需要建立一個額外的 DOM element：</p>
          <pre class="language-javascript"><code class="language-javascript"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Fragment</span></span><span class="token operator">></span>
      <span class="token maybe-class-name">Some</span> text<span class="token punctuation">.</span>
      <span class="token operator">&#x3C;</span>h2<span class="token operator">></span><span class="token constant">A</span> heading<span class="token operator">&#x3C;</span><span class="token operator">/</span>h2<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Fragment</span></span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
          <p>你也可以使用 <code>&#x3C;>&#x3C;/></code> 的精簡表示法。請參閱 <a href="/blog/2017/11/28/react-v16.2.0-fragment-support.html">React v16.2.0： 更好的 Fragment 支援</a>以獲得更多資訊。</p>
        </section>
        <section id="reactcreateref-reactcreateref" class="level3">
          <h3><code>React.createRef</code> {#reactcreateref}</h3>
          <p>
            <code>React.createRef</code> 會建立一個 <a href="./refs-and-the-dom.html">ref</a> 以透過 ref attribute 夾帶在一個 React element 之上。
            <code>embed:16-3-release-blog-post/create-ref-example.js</code>
          </p>
        </section>
        <section id="reactforwardref-reactforwardref" class="level3">
          <h3><code>React.forwardRef</code> {#reactforwardref}</h3>
          <p><code>React.forwardRef</code> 會建立一個 React component 並將 <a href="./refs-and-the-dom.html">ref</a> attribute 轉交給旗下的另外一個 component 。這個技巧不是很常被使用，但在以下兩個情況很適合：</p>
          <ul>
            <li><a href="./forwarding-refs.html#forwarding-refs-to-dom-components">將 ref 轉交給 DOM component</a></li>
            <li><a href="./forwarding-refs.html#forwarding-refs-in-higher-order-components">在 higher-order-component 之中轉交 ref</a></li>
          </ul>
          <p><code>React.forwardRef</code> 接受一個 render function 作為參數。React 會呼叫這個 function 並傳入兩個參數： <code>props</code> 以及 <code>ref</code> 。這個 function 應該要回傳一個 React node。</p>
          <p><code>embed:reference-react-forward-ref.js</code></p>
          <p>在上面這個範例，React 會把給予 <code>&#x3C;FancyButton ref={ref}></code> 的 <code>ref</code> 轉交給傳入 <code>React.forwardRef</code> 的 function 作為其第二個參數。這個 render function 接著將這個 <code>ref</code> 轉交給 <code>&#x3C;button ref={ref}></code> element。</p>
          <p>結果，當 React 夾上這個 ref 的時候，<code>ref.current</code> 將會直接指到 <code>&#x3C;button></code> 這個 DOM element 實例。</p>
          <p>請參閱<a href="./forwarding-refs.html">轉交 ref</a> 獲得更多資訊。</p>
        </section>
        <section id="reactlazy-reactlazy" class="level3">
          <h3><code>React.lazy</code> {#reactlazy}</h3>
          <p><code>React.lazy()</code> 讓你可以定義一個動態載入的 component。這可以在初始 render 期間延緩載入沒有被用到的 component 來減少 bundle size。</p>
          <p>你可以閱讀我們的 <a href="./code-splitting.html#reactlazy">code splitting 文件</a> 來學習怎麼使用它。你可能也想要閱讀<a href="https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d">這篇文章</a> 更深入了解如何使用這個 function。</p>
          <pre class="language-js"><code class="language-js"><span class="token comment">// This component is loaded dynamically</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">SomeComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./SomeComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
          <p>請注意當你使用 <code>lazy</code> component 的時候，你的 render tree 上層中必須包含一個 <code>&#x3C;React.Suspense></code> 來指定 loading indicator。</p>
        </section>
        <section id="reactsuspense-reactsuspense" class="level3">
          <h3><code>React.Suspense</code> {#reactsuspense}</h3>
          <p><code>React.Suspense</code> 讓你指定 loading indicator，避免下面 tree 中的某些 component 尚未準備好 render。未來我們計畫讓 <code>Suspense</code> 處理更多場景，像是資料的取得。你可以閱讀關於這個在<a href="/blog/2018/11/27/react-16-roadmap.html">我們的 roadmap</a>。</p>
          <p>現在，lazy loading component 是 <code>&#x3C;React.Suspense></code> <strong>唯一</strong>支援的使用場景：</p>
          <pre class="language-js"><code class="language-js"><span class="token comment">// This component is loaded dynamically</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">OtherComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./OtherComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token comment">// Displays &#x3C;Spinner> until OtherComponent loads</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Suspense</span></span> fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Spinner</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
        <span class="token operator">&#x3C;</span><span class="token maybe-class-name">OtherComponent</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Suspense</span></span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
          <p>在我們的 <a href="./code-splitting.html#reactlazy">code splitting 文件</a> 有更多資訊。請注意 <code>lazy</code> component 可以在 <code>Suspense</code> tree 中底下很多層 ── 你不需要把每一個 <code>lazy</code> 元素包起來。最好的方法是將 <code>&#x3C;Suspense></code> 放在你想看到 loading indicator 的地方，而在所有你想進行 code splitting 的地方使用 <code>lazy()</code> 。</p>
          <blockquote>
            <p>注意：</p>
            <p>對於已經顯示給使用者的內容，切換回 loading indicator 可能會讓人迷惑。有時候在新的 UI 準備好之前，顯示「舊」的 UI 會來得更好。若要達成這個方式，你可以使用新的 <a href="#starttransition"><code>startTransition</code></a> 和 <a href="./hooks-reference.html#usetransition"><code>useTransition</code></a> transition APIs，來 mark 更新為一個 transitions，並且避免不預期的 fallback。</p>
          </blockquote>
          <section id="reactsuspense-in-server-side-rendering" class="level4">
            <h4><code>React.Suspense</code> 是 Server Side Rendering</h4>
            <p>
              在 server side rendering 期間，Suspense Boundaries 允許你透過 suspending 以更小的 chunks 來 flush 應用程式。
              當一個 component suspends 時，我們 schedule 一個低優先級的 task 來 render 最近的 Suspense boundary 的 fallback。如果 component 在我們 flush fallback 之前 unsuspends，那麼我們把實際的內容傳送下去，並丟棄 fallback。
            </p>
          </section>
          <section id="reactsuspense-during-hydration" class="level4">
            <h4><code>React.Suspense</code> during hydration</h4>
            <p>Suspense boundary 依賴於它們的 parent boundary 在它們被 hydrate 之前被 hydrate，但它們可以獨立於 sibling boundary hydrate。在被 hydrate 之前發生的 event 將會導致 boundary hydrate 的優先級高於相鄰的 boundary。<a href="https://github.com/reactwg/react-18/discussions/130">閱讀更多</a>。</p>
          </section>
        </section>
        <section id="reactstarttransition-starttransition" class="level3">
          <h3><code>React.startTransition</code> {#starttransition}</h3>
          <pre class="language-js"><code class="language-js"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">startTransition</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span></code></pre>
          <p>這個方法被設計的是被用在當 <a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a> 不可使用時。</p>
          <blockquote>
            <p>注意：</p>
            <p>在 transition 中的更新會產生更緊急的更新，例如：點擊。</p>
            <p>在 transition 中的更新不會顯示 re-suspended 的 fallback 內容，允許使用者可以在更新期間繼續互動。</p>
            <p>
              <code>React.startTransition</code> 不提供一個 <code>isPending</code> 的 flag。若要追蹤 transition 的 pending 狀態，參考 <a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a>。
              <span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span>
            </p>
          </blockquote>
        </section>
      </section>
    </section>
  </body>
</html>
