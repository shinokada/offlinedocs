<!doctypehtml><html lang="zh-hant"><meta charset="utf-8"><title>Hooks API 參考</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="hooks-api-參考"class="level1"><h1>Hooks API 參考</h1><p><em>Hook</em> 是 React 16.8 中增加的新功能。它讓你不必寫 class 就能使用 state 以及其他 React 的功能。<p>本頁面描述 React 中內建 Hook 的 API。<p>如果你剛開始接觸 Hook，你可能會想先查閱 <a href="./hooks-overview.html">Hook 概論</a>。你也可以在 <a href="./hooks-faq.html">Hook 常見問題</a>中找到有用的資訊。<ul><li><a href="#basic-hooks">基礎的 Hook</a><ul><li><a href="#usestate"><code>useState</code></a><li><a href="#useeffect"><code>useEffect</code></a><li><a href="#usecontext"><code>useContext</code></a></ul><li><a href="#additional-hooks">額外的 Hook</a><ul><li><a href="#usereducer"><code>useReducer</code></a><li><a href="#usecallback"><code>useCallback</code></a><li><a href="#usememo"><code>useMemo</code></a><li><a href="#useref"><code>useRef</code></a><li><a href="#useimperativehandle"><code>useImperativeHandle</code></a><li><a href="#uselayouteffect"><code>useLayoutEffect</code></a><li><a href="#usedebugvalue"><code>useDebugValue</code></a><li><a href="#usedeferredvalue"><code>useDeferredValue</code></a><li><a href="#usetransition"><code>useTransition</code></a><li><a href="#useid"><code>useId</code></a></ul><li><a href="#library-hooks">Library Hooks</a><ul><li><a href="#usesyncexternalstore"><code>useSyncExternalStore</code></a><li><a href="#useinsertioneffect"><code>useInsertionEffect</code></a></ul></ul><section id="basic-hooks"class="level2"><h2>基礎的 Hook</h2><section id="usestate-usestate"class="level3"><h3><code>useState</code> {#usestate}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>initialState<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>回傳一個 state 的值，以及更新 state 的 function。<p>在首次 render 時，回傳的 <code>state</code> 的值會跟第一個參數（<code>initialState</code>）一樣。<p><code>setState</code> function 是用來更新 state。它接收一個新的 state 並將 component 的重新 render 排進隊列。<pre class="language-js"><code class="language-js"><span class="token function">setState</span><span class="token punctuation">(</span>newState<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在後續的重新 render，<code>useState</code> 回傳的第一個值必定會是最後更新的 state。<blockquote><p>注意<p>React 確保 <code>setState</code> function 本身是穩定的，而且不會在重新 render 時改變。這就是為什麼可以安全地從 <code>useEffect</code> 或 <code>useCallback</code> 的依賴列表省略它。</blockquote><section id="functional-updates"class="level4"><h4>函數式更新</h4><p>如果新的 state 是用先前的 state 計算出，你可以傳遞一個 function 到 <code>setState</code>。該 function 將接收先前的 state，並回傳一個已更新的值。下列的計算器 component 範例示範了 <code>setState</code> 的兩種用法。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Counter</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>initialCount<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>initialCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token literal-property property">Count</span><span class="token operator">:</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>initialCount<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token maybe-class-name">Reset</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token parameter">prevCount</span> <span class="token arrow operator">=></span> prevCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">-</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token parameter">prevCount</span> <span class="token arrow operator">=></span> prevCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">+</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>「+」和「-」按鈕使用了函數式形式，因為被更新的值是基於先前的值。但是「Reset」按鈕則使用普通形式，因為它總是把 count 設定回初始值。<p>如果你的 update 函式回傳與目前的 state 相同的值，後續的 render 將會被完整跳過。<blockquote><p>注意<p>與 class component 的 <code>setState</code> 方法不同，<code>useState</code> 不會自動合併更新 object。你可以用函數式更新的形式結合 object spread 語法來達到相同效果：<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setState</span><span class="token punctuation">(</span><span class="token parameter">prevState</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// 也可以使用 Object.assign</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>prevState<span class="token punctuation">,</span> <span class="token spread operator">...</span>updatedValues<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>另一個選擇是 <code>useReducer</code>，它更適合用於管理有多個子數值的 state object。</blockquote></section><section id="lazy-initial-state"class="level4"><h4>惰性初始 state</h4><p><code>initialState</code> 參數只會在初始 render 時使用，在後續 render 時會被忽略。如果初始 state 需要通過複雜的計算來獲得，你可以傳入一個 function，該 function 只會在初始 render 時被調用：<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> initialState <span class="token operator">=</span> <span class="token function">someExpensiveComputation</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> initialState<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section><section id="bailing-out-of-a-state-update"class="level4"><h4>跳過 state 更新</h4><p>如果你使用與目前 state 相同值來更新 State Hook，React 將會跳過子 component 的 render 及 effect 的執行。（React 使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"><code>Object.is</code></a>來比較。）<p>請注意 React 可能仍需要在跳過 render 之前 render 該 component。這不應該是個問題，因為 React 不會不必要地「深入」到 component tree 中。如果你在 render 當中執行了昂貴的計算，你可以使用 <code>useMemo</code> 來最佳化。</section><section id="batching-of-state-updates"class="level4"><h4>Batching of state updates</h4><p>React may group several state updates into a single re-render to improve performance. Normally, this improves performance and shouldn't affect your application's behavior.<p>Before React 18, only updates inside React event handlers were batched. Starting with React 18, <a href="/blog/2022/03/08/react-18-upgrade-guide.html#automatic-batching">batching is enabled for all updates by default</a>. Note that React makes sure that updates from several <em>different</em> user-initiated events -- for example, clicking a button twice -- are always processed separately and do not get batched. This prevents logical mistakes.<p>In the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in <a href="./react-dom.html#flushsync"><code>flushSync</code></a>. However, this can hurt performance so do this only where needed.</section></section><section id="useeffect-useeffect"class="level3"><h3><code>useEffect</code> {#useeffect}</h3><pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span>didUpdate<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>接受一個包含指令式，且可能有副作用程式碼的 function。<p>在 function component（指的是 React 的 render 階段）的 function 內，mutation、subscription、timer、日誌記錄、以及其他 side effect 是不被允許的。因為這可能會導致容易混淆的 bug 和不一致的 UI。<p>相反的，使用 <code>useEffect</code>。傳遞到 <code>useEffect</code> 的 function 會在 render 到螢幕之後執行。可以把 effect 看作 React 從純函式世界通往指令式世界的跳脫方式。<p>在預設情況下，effect 會在每一個完整 render 後執行，但你也可以選擇它們在<a href="#conditionally-firing-an-effect">某些值改變的時候</a>才執行。<section id="cleaning-up-an-effect"class="level4"><h4>清除一個 effect</h4><p>通常來說，在 component 離開螢幕之前需要清除 effect 所建立的資源，例如像是 subscription 或計時器的 ID。要做到這一點，傳遞到 <code>useEffect</code> 的 function 可以回傳一個清除的 function。例如，要建立一個 subscription：<pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> subscription <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">source</span><span class="token punctuation">.</span><span class="token method function property-access">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// Clean up the subscription</span>
    subscription<span class="token punctuation">.</span><span class="token method function property-access">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清除 function 會在 component 從 UI 被移除前執行，來防止 memory leak。此外，如果 component render 了數次（它們通常會這樣），在<strong>執行下一個 effect 前，上一個 effect 就已被清除</strong>。在上述的例子中，意味著每一次更新都會建立一個新 subscription。要避免每次更新都觸發 effect 的執行，請參閱下一個章節。</section><section id="timing-of-effects"class="level4"><h4>Effect 的時機</h4><p>與 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 不同，在延遲事件期間，傳遞給 <code>useEffect</code> 的 function 會在 layout 和 render <strong>之後</strong>觸發。這使它適用於很多常見的 side effect，例如設定 subscription 和 event handler，因為絕大部份的工作都不應該阻礙瀏覽器更新晝面。<p>然而，不是所有的 effect 都可以被延後。例如，使用者可見的 DOM 改變必須在下一次繪製之前同步觸發，這樣使用者才不會感覺到視覺不一致。（概念上類似被動和主動 event listener 的區別。）為這類型的 effect，React 提供了一個額外的 <a href="#uselayouteffect"><code>useLayoutEffect</code></a> Hook。它和 <code>useEffect</code> 的結構相同，只是執行的時機不同而已。<p>此外，從 React 18 開始，傳給 <code>useEffect</code> 的 function 將在 layout 和 paint <strong>之前</strong> 同步的觸發，當它是一個離散的使用者輸入（像是點擊）或當它是一個被 wrap 在 <a href="./react-dom.html#flushsync"><code>flushSync</code></a> 的更新結果。這個行為讓 event system 或 <a href="./react-dom.html#flushsync"><code>flushSync</code></a> 的 caller 觀察 effect 的結果。<blockquote><p>注意<p>這只會影響傳遞給 <code>useEffect</code> 的 function 的被呼叫時間 - 在這些 effect 中安排的更新仍然會被延遲。這與 <a href="#uselayouteffect"><code>useLayoutEffect</code></a> 不同，後者會觸發 function 並立即處理其更新。</blockquote><p>雖然 <code>useEffect</code> 會被延遲直到瀏覽器繪制完成，但會保證在任何新 render 前執行。React 會在開始新一個更新前刷新上一輪 render 的 effect。</section><section id="conditionally-firing-an-effect"class="level4"><h4>有條件的觸發 effect</h4><p>effect 的預設行為是在每次完成 render 後觸發 effect。這樣的話，如果其中一個依賴有改變，則會重新建立一個 effect。<p>然而，在某些情況下這可能矯枉過正，例如在上一章節的 subscription 範例。我們只需要在 <code>source</code> prop 改變後才重新建立 subscription，而不需要在每次更新後。<p>要實現這一點，可以向 <code>useEffect</code> 傳遞第二個參數，它是該 effect 所依賴的值 array。我們更新後的範例如下：<pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> subscription <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">source</span><span class="token punctuation">.</span><span class="token method function property-access">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      subscription<span class="token punctuation">.</span><span class="token method function property-access">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>props<span class="token punctuation">.</span><span class="token property-access">source</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>現在只有當 <code>props.source</code> 改變時才會重新建立 subscription。<blockquote><p>注意<p>若你使用這個最佳化的方式，請確保該 array 包含了<strong>所有在該 component 中會隨時間而變的值（例如 props 和 state）以及在該 effect 所使用到的值。</strong>否則，你的程式碼會引用先前 render 的舊變數。了解更多<a href="./hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">如何處理 function</a> 和當 <a href="./hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often">array 的值頻繁變化時</a>的處理。<p>如果你想 effect 只執行和清除一次（在 mount 和 unmount），你可以傳遞一個空的 array （<code>[]</code>）作為第二個參數。這告訢 React 你的 effect 沒有依賴<em>任何</em>在 props 或 state 的值，所以它永遠不需被再次執行。這並不是一個特殊處理 -- 它依然遵循依賴 array 的運作方式。<p>如果你傳入了一個空的 array（<code>[]</code>），effect 內部的 props 和 state 就一直擁有其初始值。儘管傳入 <code>[]</code> 作為第二個參數有點類似 <code>componentDidMount</code> 和 <code>componentWillUnmount</code> 的思維模式，但其實有<a href="./hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">更好的</a><a href="./hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often">方法</a>來避免過於頻繁地重複執行 effect。而且，不要忘記 React 會延後執行 <code>useEffect</code> 直至瀏覽器完成繪制，所以額外的工作也不會是太大問題。<p>我們建議使用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> 中的 <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> 規則。它會在依賴錯誤時發出警告並提出修正建議。</blockquote><p>依賴 array 並不作為傳到 effect function 的參數。但從概念上來説，這是它所代表的：所有在 effect function 中引用的值都應該出現在依賴 array 中。在未來，一個足夠先進的編譯器可以自動建立這個 array。</section></section><section id="usecontext-usecontext"class="level3"><h3><code>useContext</code> {#usecontext}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span><span class="token maybe-class-name">MyContext</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>接收一個 context object（<code>React.createContext</code> 的回傳值）並回傳該 context 目前的值。Context 目前的值是取決於由上層 component 距離最近的 <code>&#x3C;MyContext.Provider></code> 的 <code>value</code> prop。<p>當 component 上層最近的 <code>&#x3C;MyContext.Provider></code> 更新時，該 hook 會觸發重新 render，並使用最新傳遞到 <code>MyContext</code> 的 context <code>value</code> 傳送到 <code>MyContext</code> provider。即便 ancestor 使用 <a href="./react-api.html#reactmemo"><code>React.memo</code></a> 或 <a href="./react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate</code></a>，重新 render 仍然從使用 <code>useContext</code> 的 component 本身開始。<p>不要忘記 <code>useContext</code> 的參數必需為 <em>context object 自己</em>：<ul><li><strong>正確:</strong> <code>useContext(MyContext)</code><li><strong>錯誤:</strong> <code>useContext(MyContext.Consumer)</code><li><strong>錯誤:</strong> <code>useContext(MyContext.Provider)</code></ul><p>呼叫 <code>useContext</code> 的 component 總是會在 context 值更新時重新 render。如果重新 render component 的操作很昂貴，你可以<a href="https://github.com/facebook/react/issues/15156#issuecomment-474590693">透過 memoization 來最佳化</a>。<blockquote><p>注意<p>假若你在接觸 hook 前已熟悉 context API，<code>useContext(MyContext)</code> 就相等於 class 中的 <code>static contextType = MyContext</code> 或 <code>&#x3C;MyContext.Consumer></code>。<p><code>useContext(MyContext)</code> 只能讓你<em>讀取</em> context 及訂閱其變更。你仍然需要在 tree 的上層使用<code>&#x3C;MyContext.Provider></code> 來提供 context 的值。</blockquote><p><strong>與 Context.Provider 放在一起</strong><pre class="language-js{31-36}"><code class="language-js{31-36}">const themes = {
  light: {
    foreground: "#000000",
    background: "#eeeeee"
  },
  dark: {
    foreground: "#ffffff",
    background: "#222222"
  }
};

const ThemeContext = React.createContext(themes.light);

function App() {
  return (
    &#x3C;ThemeContext.Provider value={themes.dark}>
      &#x3C;Toolbar />
    &#x3C;/ThemeContext.Provider>
  );
}

function Toolbar(props) {
  return (
    &#x3C;div>
      &#x3C;ThemedButton />
    &#x3C;/div>
  );
}

function ThemedButton() {
  const theme = useContext(ThemeContext);

  return (
    &#x3C;button style={{ background: theme.background, color: theme.foreground }}>
      I am styled by theme context!
    &#x3C;/button>
  );
}</code></pre><p>此為使用 Hook 修改之前 <a href="./context.html">Context Advanced Guide</a> 中的範例，你可以在那裡了解更多 Context 的資訊，像是何時以及如何使用 Context。</section></section><section id="additional-hooks"class="level2"><h2>額外的 Hooks</h2><p>以下的 Hook，有些是上一節中基礎的 Hook 的變異，有些則是在特殊情況下使用。不用特地預先學習它們。<section id="usereducer-usereducer"class="level3"><h3><code>useReducer</code> {#usereducer}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> initialArg<span class="token punctuation">,</span> init<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a href="#usestate"><code>useState</code></a> 的替代方案。接受一個 <code>(state, action) => newState</code> 的 reducer，然後回傳現在的 state 以及其配套的 <code>dispatch</code> 方法。（如果你熟悉 Redux，你已經知道這如何運作。）<p>當你需要複雜的 state 邏輯而且包括多個子數值或下一個 state 依賴之前的 state，<code>useReducer</code> 會比 <code>useState</code> 更適用。而且 <code>useReducer</code> 可以讓你觸發深層更新的 component 作效能的最佳化，因為<a href="./hooks-faq.html#how-to-avoid-passing-callbacks-down">你可以傳遞 dispatch 而不是 callback</a>。<p>以下是用 reducer 重寫 <a href="#usestate"><code>useState</code></a> 一節的範例：<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> initialState <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">reducer</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'increment'</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">'decrement'</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword module">default</span><span class="token operator">:</span>
      <span class="token keyword control-flow">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Counter</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> initialState<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token literal-property property">Count</span><span class="token operator">:</span> <span class="token punctuation">{</span>state<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'decrement'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">-</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'increment'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">+</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><blockquote><p>注意<p>React 確保 <code>dispatch</code> function 本身是穩定的，而且不會在重新 render 時改變。這就為什麼可以安全地從 <code>useEffect</code> 或 <code>useCallback</code> 的依賴列表省略它。</blockquote><section id="specifying-the-initial-state"class="level4"><h4>指定初始 state</h4><p>有兩種不同初始化 <code>useReducer</code> state 的方法。你可以根據使用場景選擇任何一種。最簡單的方法就是把初始 state 作為第二個參數傳入：<pre class="language-js{3}"><code class="language-js{3}">  const [state, dispatch] = useReducer(
    reducer,
    {count: initialCount}
  );</code></pre><blockquote><p>注意<p>React 不使用 <code>state = initialState</code> 這個由 Redux 推廣開來的參數慣例。初始值有時需要依賴於 prop，因此需要在呼叫 Hook 時指定。如果你較偏愛上述的慣例，你可以呼叫 <code>useReducer(reducer, undefined, reducer)</code> 來摸擬 Redux 的行為，但這是不鼓勵的。</blockquote></section><section id="lazy-initialization"class="level4"><h4>惰性初始化</h4><p>你也可以惰性的建立初始 state。你可以傳入 <code>init</code> function 作為第三個參數。初始的 state 會被設定為 <code>init(initialArg)</code>。<p>這樣讓你可以將計算初始 state 的邏輯提取到 reducer 外。而且也方便了將來處理重置 state 的 action：<pre class="language-js{1-3,11-12,19,24}"><code class="language-js{1-3,11-12,19,24}">function init(initialCount) {
  return {count: initialCount};
}

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    case 'reset':
      return init(action.payload);
    default:
      throw new Error();
  }
}

function Counter({initialCount}) {
  const [state, dispatch] = useReducer(reducer, initialCount, init);
  return (
    &#x3C;>
      Count: {state.count}
      &#x3C;button
        onClick={() => dispatch({type: 'reset', payload: initialCount})}>
        Reset
      &#x3C;/button>
      &#x3C;button onClick={() => dispatch({type: 'decrement'})}>-&#x3C;/button>
      &#x3C;button onClick={() => dispatch({type: 'increment'})}>+&#x3C;/button>
    &#x3C;/>
  );
}</code></pre></section><section id="bailing-out-of-a-dispatch"class="level4"><h4>跳過 dispatch</h4><p>如果你在 Reducer Hook 回傳的值與目前的 state 相同，React 將會跳過 child component 的 render 及 effect 的執行。（React 使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"><code>Object.is</code></a>來比較。）<p>請注意 React 可能仍需要在跳過 render 之前 render 該 component。這不應該是個問題，因為 React 不會不必要地「深入」到 tree 中。如果你在 render 當中執行了昂貴的計算，你可以使用 <code>useMemo</code> 來最佳化。</section></section><section id="usecallback-usecallback"class="level3"><h3><code>useCallback</code> {#usecallback}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> memoizedCallback <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">doSomething</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>回傳一個 <a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> 的 callback。<p>傳遞一個 inline callback 及依賴 array。<code>useCallback</code> 會回傳該 callback 的 memoized 版本，它僅在依賴改變時才會更新。當傳遞 callback 到已經最佳化的 child component 時非常有用，這些 child component 依賴於引用相等性來防止不必要的 render（例如，<code>shouldComponentUpdate</code>）<p><code>useCallback(fn, deps)</code> 相等於 <code>useMemo(() => fn, deps)</code>。<blockquote><p>注意<p>依賴 array 並不作為傳到 callback 的參數。但從概念上來説，這是它所代表的：所有在 callback 中引用的值都應該出現在依賴 array 中。在未來，一個足夠先進的編譯器可以自動建立這個 array。<p>我們建議使用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> 中的 <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> 規則。它會在依賴錯誤時發出警告並提出修正建議。</blockquote></section><section id="usememo-usememo"class="level3"><h3><code>useMemo</code> {#usememo}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">computeExpensiveValue</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>回傳一個 <a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> 的值。<p>傳遞一個「建立」function 及依賴 array。<code>useMemo</code> 只會在依賴改變時才重新計算 memoized 的值。這個最佳化可以避免在每次 render 都進行昂貴的計算。<p>要謹記傳到 <code>useMemo</code> 的 function 會在 render 期間執行。不要做一些通常不會在 render 期間做的事情。例如，處理 side effect 屬於 <code>useEffect</code>，而不是 <code>useMemo</code>。<p>如果沒有提供 array，每次 render 時都會計算新的值。<p><strong>你可以把 <code>useMemo</code> 作為效能最佳化的手段，但請不要把它當作成語意上的保證。</strong>在將來，React 可能會選擇「忘記」某些之前已 memorize 的值並在下一次 render 時重新計算，例如，為已離開螢幕的 component 釋放記憶體。先撰寫沒有 <code>useMemo</code> 也可執行的代碼 — 然後再加入它來做效能最佳化。<blockquote><p>注意<p>依賴 array 並不作為傳到 function 的參數。但從概念上來説，這是它所代表的：所有在 callback 中引用的值都應該出現在依賴 array 中。在未來，一個足夠先進的編譯器可以自動建立這個 array。<p>我們建議使用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> 中的 <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> 規則。它會在依賴錯誤時發出警告並提出修正建議。</blockquote></section><section id="useref-useref"class="level3"><h3><code>useRef</code> {#useref}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> refContainer <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>initialValue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>useRef</code> 回傳一個 mutable 的 ref object，<code>.current</code> 屬性被初始為傳入的參數（<code>initialValue</code>）。回傳的 object 在 component 的生命週期將保持不變。<p>一個常見的使用情境就是命令式的訪問 child component：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">TextInputWithFocusButton</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> inputEl <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">onButtonClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// `current` points to the mounted text input element</span>
    inputEl<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">.</span><span class="token method function property-access">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span>inputEl<span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">"text"</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onButtonClick<span class="token punctuation">}</span><span class="token operator">></span><span class="token maybe-class-name">Focus</span> the input<span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>本質上，<code>useRef</code> 就像一個可以持有 mutable 的值在 <code>.current</code> 屬性的「盒子」。<p>你應該熟悉 ref，它一種主要是用來<a href="./refs-and-the-dom.html">訪問 DOM</a> 的方式。如果你在 React 中以 <code>&#x3C;div ref={myRef} /></code> 傳入 ref object，無論節點如何改變，React 都會將其 <code>.current</code> 屬性設為相應的 DOM 節點。<p>然而，<code>useRef()</code> 比 <code>ref</code> 屬性更有用。它可以<a href="./hooks-faq.html#is-there-something-like-instance-variables">很方便地持有任何 mutable 的值</a>，跟 class 中的 instance field 類似。<p>這是因為 <code>useRef()</code> 會建立一個普通的 JavaScript object。<code>useRef()</code> 和自建一個 <code>{current: ...}</code> object 的唯一不同是，<code>useRef</code> 在每次 render 時都會給你同一個的 ref object。<p>請記住 <code>useRef</code> 在其內容有變化時並<em>不會</em>通知你。變更 <code>.current</code> 屬性不會觸發重新 render。如果你想要在 React 綁定或解綁 DOM 節點的 ref 時執行程式碼，你可能需要使用 <a href="./hooks-faq.html#how-can-i-measure-a-dom-node">callback ref</a> 來實現。</section><section id="useimperativehandle-useimperativehandle"class="level3"><h3><code>useImperativeHandle</code> {#useimperativehandle}</h3><pre class="language-js"><code class="language-js"><span class="token function">useImperativeHandle</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> createHandle<span class="token punctuation">,</span> <span class="token punctuation">[</span>deps<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><code>useImperativeHandle</code> 可以讓使用 <code>ref</code> 時能向父 component 暴露自定義的 instance 值。一如既往，在大多數的情況下應避免使用 ref 的命令式代碼。<code>useImperativeHandle</code> 應與 <a href="./react-api.html#reactforwardref"><code>forwardRef</code></a> 一同使用：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">FancyInput</span></span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> inputRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useImperativeHandle</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">focus</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      inputRef<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">.</span><span class="token method function property-access">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span>inputRef<span class="token punctuation">}</span> <span class="token spread operator">...</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token maybe-class-name">FancyInput</span> <span class="token operator">=</span> <span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token maybe-class-name">FancyInput</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在這個範例中，render <code>&#x3C;FancyInput ref={inputRef} /></code> 的父 component 能呼叫 <code>inputRef.current.focus()</code>。</section><section id="uselayouteffect-uselayouteffect"class="level3"><h3><code>useLayoutEffect</code> {#uselayouteffect}</h3><p>與宣告 <code>useEffect</code> 本身相同，但它會在所有 DOM 改變後，同步調用。使用它來讀取 DOM layout 並同步重新 render。在瀏覽器執行繪製之前，<code>useLayoutEffect</code> 內部的更新將被同步刷新。<p>盡可能使用標準的 <code>useEffect</code> 來避免阻礙視覺上的更新。<blockquote><p>注意<p>如果你是從 class component migrate 程式碼，請注意 <code>useLayoutEffect</code> 與 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 的呼叫時機是一樣。不過，<strong>我們建議先使用 <code>useEffect</code></strong>，只當它有問題時才嘗試使用 <code>useLayoutEffect</code>。<p>如果你使用伺服器 render，請記住 <code>useLayoutEffect</code> 或 <code>useEffect</code> <em>均不會</em>執行，直到 JavaScript 完成載入。這是為什麼在伺服器 render 的 component 包含 <code>useLayoutEffect</code> 時 React 會發出警告。要解決這問題，把該邏輯搬到 <code>useEffect</code> 裡（如果首次 render 不需要該邏輯），或把 component 延遲到客戶端完成 render 後才出現（如果直到 <code>useLayoutEffect</code> 執行前 HTML 都會錯亂的情況下）。<p>要在伺服器 render 的 HTML 排除需要 layout effect 的 component，可以利用 <code>showChild &#x26;&#x26; &#x3C;Child /></code> 進行條件 render，並使用 <code>useEffect(() => { setShowChild(true); }, [])</code> 來延遲顯示。這樣，UI 就不會在完成 render 之前顯示錯亂了。</blockquote></section><section id="usedebugvalue-usedebugvalue"class="level3"><h3><code>useDebugValue</code> {#usedebugvalue}</h3><pre class="language-js"><code class="language-js"><span class="token function">useDebugValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span></code></pre><p><code>useDebugValue</code> 可以用來在 React DevTools 中顯示自訂義 hook 的標籤。<p>例如，在<a href="./hooks-custom.html">「打造你的 Hook」</a>中提及的 <code>useFriendStatus</code> 自定義 Hook：<pre class="language-js{6-8}"><code class="language-js{6-8}">function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  // ...

  // Show a label in DevTools next to this Hook
  // e.g. "FriendStatus: Online"
  useDebugValue(isOnline ? 'Online' : 'Offline');

  return isOnline;
}</code></pre><blockquote><p>注意<p>我們不建議在每個自定義 Hook 都加上 debug 值。它在自定義 Hook 的共享函式庫中才是最有價值的。</blockquote><section id="defer-formatting-debug-values"class="level4"><h4>延遲格式化 Debug Value</h4><p>在某些情況下，格式化一個顯示值可能會是昂貴的操作。除非實際檢查 Hook，否則沒有必要。<p>因此，<code>useDebugValue</code> 接受一個格式化 function 作為可選的第二個參數。該 function 只有在 Hook 被檢查時才會被呼叫。它接受 debug 值作為參數，然後回傳一個被格式化的顯示值。<p>例如，一個回傳 <code>Date</code> 值的自定義 Hook 可以通過以下的格式化 function 來避免不必要地呼叫 <code>toDateString</code> function：<pre class="language-js"><code class="language-js"><span class="token function">useDebugValue</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> <span class="token parameter">date</span> <span class="token arrow operator">=></span> date<span class="token punctuation">.</span><span class="token method function property-access">toDateString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section></section><section id="usedeferredvalue-usedeferredvalue"class="level3"><h3><code>useDeferredValue</code> {#usedeferredvalue}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> deferredValue <span class="token operator">=</span> <span class="token function">useDeferredValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>useDeferredValue</code> 接受一個值，並且回傳值的新拷貝，新的拷貝會被推遲到更緊急的更新。如果目前的 render 是緊急更新的結果，像是使用者輸入，React 將會回傳先前的值，並接著在緊急更新完成後，render 新的值。<p>這個 hook 類似 user-space 的 hook，被用在 deboucing 或 throttiling 來延遲更新。使用 <code>useDeferredValue</code> 的好處是 React 將會在其他工作完成後，立即進行更新（而不是等待一個任意的時間），像是 <a href="./react-api.html#starttransition"><code>startTransition</code></a>，延遲的值可以暫停而不會觸發一個現有內容的 unexpected fallback。<section id="memoizing-deferred-children"class="level4"><h4>Memoizing 延遲的 Children</h4><p><code>useDeferredValue</code> 只延遲你傳送給它的值。如果你想要防止一個 child component 在一個緊急更新中不斷重新 render，你必須 使用 <a href="./react-api.html#reactmemo"><code>React.memo</code></a> 或 <a href="./hooks-reference.html#usememo"><code>React.useMemo</code></a> 來 memoize component：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Typeahead</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> query <span class="token operator">=</span> <span class="token function">useSearchQuery</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> deferredQuery <span class="token operator">=</span> <span class="token function">useDeferredValue</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Memoizing tells React to only re-render when deferredQuery changes,</span>
  <span class="token comment">// not when query changes.</span>
  <span class="token keyword">const</span> suggestions <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">SearchSuggestions</span> query<span class="token operator">=</span><span class="token punctuation">{</span>deferredQuery<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>deferredQuery<span class="token punctuation">]</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">SearchInput</span> query<span class="token operator">=</span><span class="token punctuation">{</span>query<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Suspense</span> fallback<span class="token operator">=</span><span class="token string">"Loading results..."</span><span class="token operator">></span>
        <span class="token punctuation">{</span>suggestions<span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Suspense</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Memoizing children 告訴 React 它只需要在 <code>deferredQuery</code> 重新 render，而不是在 <code>query</code> 改變時。這個警告不是 <code>useDeferredValue</code> 獨有的，它與你使用的 debouncing 或 throttling 類似的 hook 使用的模式相同。</section></section><section id="usetransition-usetransition"class="level3"><h3><code>useTransition</code> {#usetransition}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>isPending<span class="token punctuation">,</span> startTransition<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>回傳一個 transition pending 狀態的 stateful 值，以及一個啟動 function。<p><code>startTransition</code> lets you mark updates in the provided callback as transitions: 讓你在提供的 callback 中標記更新為 transitions：<pre class="language-js"><code class="language-js"><span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>isPending</code> 表示當一個 transition 是 active 時顯示 pending state：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">App</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isPending<span class="token punctuation">,</span> startTransition<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token arrow operator">=></span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token punctuation">{</span>isPending <span class="token operator">&#x26;&#x26;</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Spinner</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><blockquote><p>注意：<p>Updates in a transition yield to more urgent updates such as clicks.<p>Updates in a transition will not show a fallback for re-suspended content. This allows the user to continue interacting with the current content while rendering the update.</blockquote></section><section id="useid-useid"class="level3"><h3><code>useId</code> {#useid}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">useId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>useId</code> is a hook for generating unique IDs that are stable across the server and client, while avoiding hydration mismatches.<blockquote><p>Note<p><code>useId</code> is <strong>not</strong> for generating <a href="./lists-and-keys.html#keys">keys in a list</a>. Keys should be generated from your data.</blockquote><p>For a basic example, pass the <code>id</code> directly to the elements that need it:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Checkbox</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">useId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>label htmlFor<span class="token operator">=</span><span class="token punctuation">{</span>id<span class="token punctuation">}</span><span class="token operator">></span><span class="token maybe-class-name">Do</span> you like <span class="token maybe-class-name">React</span><span class="token operator">?</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>label<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>input id<span class="token operator">=</span><span class="token punctuation">{</span>id<span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">"checkbox"</span> name<span class="token operator">=</span><span class="token string">"react"</span><span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>For multiple IDs in the same component, append a suffix using the same <code>id</code>:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">NameFields</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">useId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>label htmlFor<span class="token operator">=</span><span class="token punctuation">{</span>id <span class="token operator">+</span> <span class="token string">'-firstName'</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token maybe-class-name">First</span> <span class="token maybe-class-name">Name</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>label<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
        <span class="token operator">&#x3C;</span>input id<span class="token operator">=</span><span class="token punctuation">{</span>id <span class="token operator">+</span> <span class="token string">'-firstName'</span><span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">"text"</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>label htmlFor<span class="token operator">=</span><span class="token punctuation">{</span>id <span class="token operator">+</span> <span class="token string">'-lastName'</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token maybe-class-name">Last</span> <span class="token maybe-class-name">Name</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>label<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
        <span class="token operator">&#x3C;</span>input id<span class="token operator">=</span><span class="token punctuation">{</span>id <span class="token operator">+</span> <span class="token string">'-lastName'</span><span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">"text"</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><blockquote><p>注意：<p><code>useId</code> generates a string that includes the <code>:</code> token. This helps ensure that the token is unique, but is not supported in CSS selectors or APIs like <code>querySelectorAll</code>.<p><code>useId</code> supports an <code>identifierPrefix</code> to prevent collisions in multi-root apps. To configure, see the options for <a href="./react-dom-client.html#hydrateroot"><code>hydrateRoot</code></a> and <a href="./react-dom-server.html"><code>ReactDOMServer</code></a>.</blockquote></section></section><section id="library-hooks"class="level2"><h2>Library Hooks</h2><p>The following Hooks are provided for library authors to integrate libraries deeply into the React model, and are not typically used in application code.<section id="usesyncexternalstore-usesyncexternalstore"class="level3"><h3><code>useSyncExternalStore</code> {#usesyncexternalstore}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">useSyncExternalStore</span><span class="token punctuation">(</span>subscribe<span class="token punctuation">,</span> getSnapshot<span class="token punctuation">[</span><span class="token punctuation">,</span> getServerSnapshot<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>useSyncExternalStore</code> is a hook recommended for reading and subscribing from external data sources in a way that's compatible with concurrent rendering features like selective hydration and time slicing.<p>This method returns the value of the store and accepts three arguments:<ul><li><code>subscribe</code>: function to register a callback that is called whenever the store changes.<li><code>getSnapshot</code>: function that returns the current value of the store.<li><code>getServerSnapshot</code>: function that returns the snapshot used during server rendering.</ul><p>The most basic example simply subscribes to the entire store:<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">useSyncExternalStore</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span><span class="token property-access">subscribe</span><span class="token punctuation">,</span> store<span class="token punctuation">.</span><span class="token property-access">getSnapshot</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>However, you can also subscribe to a specific field:<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> selectedField <span class="token operator">=</span> <span class="token function">useSyncExternalStore</span><span class="token punctuation">(</span>
  store<span class="token punctuation">.</span><span class="token property-access">subscribe</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> store<span class="token punctuation">.</span><span class="token method function property-access">getSnapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">selectedField</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>When server rendering, you must serialize the store value used on the server, and provide it to <code>useSyncExternalStore</code>. React will use this snapshot during hydration to prevent server mismatches:<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> selectedField <span class="token operator">=</span> <span class="token function">useSyncExternalStore</span><span class="token punctuation">(</span>
  store<span class="token punctuation">.</span><span class="token property-access">subscribe</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> store<span class="token punctuation">.</span><span class="token method function property-access">getSnapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">selectedField</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">INITIAL_SERVER_SNAPSHOT</span><span class="token punctuation">.</span><span class="token property-access">selectedField</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>注意：<p><code>getSnapshot</code> must return a cached value. If getSnapshot is called multiple times in a row, it must return the same exact value unless there was a store update in between.<p>A shim is provided for supporting multiple React versions published as <code>use-sync-external-store/shim</code>. This shim will prefer <code>useSyncExternalStore</code> when available, and fallback to a user-space implementation when it's not.<p>As a convenience, we also provide a version of the API with automatic support for memoizing the result of getSnapshot published as <code>use-sync-external-store/with-selector</code>.</blockquote></section><section id="useinsertioneffect-useinsertioneffect"class="level3"><h3><code>useInsertionEffect</code> {#useinsertioneffect}</h3><pre class="language-js"><code class="language-js"><span class="token function">useInsertionEffect</span><span class="token punctuation">(</span>didUpdate<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The signature is identical to <code>useEffect</code>, but it fires synchronously <em>before</em> all DOM mutations. Use this to inject styles into the DOM before reading layout in <a href="#uselayouteffect"><code>useLayoutEffect</code></a>. Since this hook is limited in scope, this hook does not have access to refs and cannot schedule updates.<blockquote><p>注意：<p><code>useInsertionEffect</code> should be limited to css-in-js library authors. Prefer <a href="#useeffect"><code>useEffect</code></a> or <a href="#uselayouteffect"><code>useLayoutEffect</code></a> instead. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></blockquote></section></section></section>