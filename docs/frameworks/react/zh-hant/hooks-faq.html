<!doctype html><html lang="zh-hant"><meta charset="utf-8"><title>Hooks 常見問題</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="hooks-常見問題"class="level1"><h1>Hooks 常見問題</h1><p><em>Hooks</em> 是 React 16.8 中增加的新功能。它讓你不必寫 class 就能使用 state 以及其他 React 的功能。<p>這一頁會解答一些關於 <a href="./hooks-overview.html">Hook</a> 常見的問題。<ul><li><strong><a href="#adoption-strategy">採用策略</a></strong><ul><li><a href="#which-versions-of-react-include-hooks">React 哪一個版本中包含 Hook？</a><li><a href="#do-i-need-to-rewrite-all-my-class-components">我需要重寫所有的 Class component 嗎？</a><li><a href="#what-can-i-do-with-hooks-that-i-couldnt-with-classes">我可以在 Hook 做什麼是我在 Class 所不能做的？</a><li><a href="#how-much-of-my-react-knowledge-stays-relevant">Hook 與我的 React 知識有多少保持相關性？</a><li><a href="#should-i-use-hooks-classes-or-a-mix-of-both">我應該使用 Hook、Class 或是兩者兼具？</a><li><a href="#do-hooks-cover-all-use-cases-for-classes">Hook 包含所有 Class 的使用情境嗎？</a><li><a href="#do-hooks-replace-render-props-and-higher-order-components">Hook 可以取代 Render Props 和 Higher-Order Component 嗎？</a><li><a href="#what-do-hooks-mean-for-popular-apis-like-redux-connect-and-react-router">Hook 對於 Redux connect() 和 React Router 等等其他流行的 API 意味著什麼？</a><li><a href="#do-hooks-work-with-static-typing">Hook 可以使用靜態型別嗎？</a><li><a href="#how-to-test-components-that-use-hooks">如何測試使用 Hook 的 component？</a><li><a href="#what-exactly-do-the-lint-rules-enforce">Lint 規則究竟強制了些什麼？</a></ul><li><strong><a href="#from-classes-to-hooks">從 Class 到 Hook</a></strong><ul><li><a href="#how-do-lifecycle-methods-correspond-to-hooks">生命週期方法與 Hook 如何對應？</a><li><a href="#how-can-i-do-data-fetching-with-hooks">我如何使用 Hook fetch 資料？</a><li><a href="#is-there-something-like-instance-variables">是否有類似 Instance 變數的東西？</a><li><a href="#should-i-use-one-or-many-state-variables">我應該使用一個或是多個 state 變數？</a><li><a href="#can-i-run-an-effect-only-on-updates">我可以只在更新時執行 effect 嗎？</a><li><a href="#how-to-get-the-previous-props-or-state">如何取得先前的 prop 或 state？</a><li><a href="#why-am-i-seeing-stale-props-or-state-inside-my-function">為什麼我在 function 內看到舊的 prop 或 state？</a><li><a href="#how-do-i-implement-getderivedstatefromprops">我該如何實作 getDerivedStateFromProps？</a><li><a href="#is-there-something-like-forceupdate">有類似 forceUpdate 的東西嗎？</a><li><a href="#can-i-make-a-ref-to-a-function-component">我可以對 function component 建立一個 ref 嗎？</a><li><a href="#how-can-i-measure-a-dom-node">我該如何測量一個 DOM node？</a><li><a href="#what-does-const-thing-setthing--usestate-mean">const [thing, setThing] = useState() 是什麼意思？</a></ul><li><strong><a href="#performance-optimizations">效能最佳化</a></strong><ul><li><a href="#can-i-skip-an-effect-on-updates">我可以在更新時忽略 effect 嗎？</a><li><a href="#is-it-safe-to-omit-functions-from-the-list-of-dependencies">在依賴項目的列表中忽略 function 是安全的嗎？</a><li><a href="#what-can-i-do-if-my-effect-dependencies-change-too-often">如果我的 effect 依賴項目經常變化的話該怎麼辦？</a><li><a href="#how-do-i-implement-shouldcomponentupdate">我該如何實作 shouldComponentUpdate？</a><li><a href="#how-to-memoize-calculations">如何 memoize 計算？</a><li><a href="#how-to-create-expensive-objects-lazily">如何延遲建立昂貴的 object？</a><li><a href="#are-hooks-slow-because-of-creating-functions-in-render">在 render 時建立 function，Hooks 會變慢嗎？</a><li><a href="#how-to-avoid-passing-callbacks-down">如何避免向下傳遞 callback？</a><li><a href="#how-to-read-an-often-changing-value-from-usecallback">如何從 useCallback 讀取一個經常變化的值？</a></ul><li><strong><a href="#under-the-hood">深入理解</a></strong><ul><li><a href="#how-does-react-associate-hook-calls-with-components">React 如何將 Hook 呼叫與 component 關聯？</a><li><a href="#what-is-the-prior-art-for-hooks">Hook 現有的技術是什麼？</a></ul></ul><section id="adoption-strategy"class="level2"><h2>採用策略</h2><section id="which-versions-of-react-include-hooks"class="level3"><h3>React 哪一個版本中包含 Hook？</h3><p>從 16.8.0 開始，React 包含一個穩定的 React Hooks 實作：<ul><li>React DOM<li>React Native<li>React DOM Server<li>React Test Renderer<li>React Shallow Renderer</ul><p>注意，若要<strong>啟動 Hook，所有 React package 需要升級到 16.8.0 或是更高的版本</strong>。例如你忘了升級 React DOM，Hook 將無法正常執行。<p><a href="https://reactnative.dev/blog/2019/03/12/releasing-react-native-059">React Native 0.59</a> 以上的版本支援 Hooks。</section><section id="do-i-need-to-rewrite-all-my-class-components"class="level3"><h3>我需要重寫所有的 Class component 嗎？</h3><p>不需要。React <a href="./hooks-intro.html#gradual-adoption-strategy">沒有計劃</a>移除 class -- 我們需要讓產品保持運作，重寫的成本很高，我們建議你在新的程式碼中嘗試 Hook。</section><section id="what-can-i-do-with-hooks-that-i-couldnt-with-classes"class="level3"><h3>我可以在 Hook 做什麼是我在 Class 所不能做的？</h3><p>Hook 在 component 之間提供強大而富有表現力的新方式來重複使用功能。在<a href="./hooks-custom.html">「打造你的 Hook」</a>提供了一個可行的方式。<a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889">這篇文章</a>是由 React 核心團隊成員深入研究 Hook 解鎖的新功能。</section><section id="how-much-of-my-react-knowledge-stays-relevant"class="level3"><h3>Hook 與我的 React 知識有多少保持相關性？</h3><p>Hook 已經有許多你知道的方式可以直接使用 React 的功能 -- 像是 state、lifecycle、context 以及 ref。基本上它們並沒有改變 React 的運作方式，而且你對於 component、prop 以及上至下的資料流了解也一樣重要。<p>Hook 的確有它本身的學習曲線。如果在這份文件中缺漏了些什麼，<a href="https://github.com/reactjs/reactjs.org/issues/new">提出一個 issue</a>，我們將會嘗試幫助你。</section><section id="should-i-use-hooks-classes-or-a-mix-of-both"class="level3"><h3>我應該使用 Hook、Class 或是兩者兼具？</h3><p>當你準備好時，我們鼓勵開始使用 Hook 撰寫你新的 component。確保你團隊的成員們使用 Hook 並熟悉本文件。我們並不鼓勵你重寫現有的 class component 成 Hook，除非你已經計劃重寫它們（例如：修正 bug）。<p>你不可以在 class component <em>內</em>使用 Hook，但你絕對可以在單個 tree 中將 class 和 function component 與 Hook 混合使用。無論是 class 或 function component，使用 Hook 是該 component 實作的細節。從長遠來看，我們期待 Hook 可以是大家撰寫 React component 的主要方式。</section><section id="do-hooks-cover-all-use-cases-for-classes"class="level3"><h3>Hook 包含所有 Class 的使用情境嗎？</h3><p>我們的目標是讓 Hook 盡快能涵蓋 class 的所有使用情境。對於不常見的 <code>getSnapshotBeforeUpdate</code> 和 <code>componentDidCatch</code> 的生命週期並沒有等價的 Hook 方式，但我們計劃很快會加入它們。</section><section id="do-hooks-replace-render-props-and-higher-order-components"class="level3"><h3>Hook 可以取代 Render Props 和 Higher-Order Component 嗎？</h3><p>我們思考 Hook 是一個更簡單的方式來提供這個使用情境。這兩種模式仍然有它的用處（例如：一個 virtual scroller component 可能有一個 <code>renderItem</code> prop，或是一個 virtual container component 可能有它本身的 DOM 結構）。但在大部分的情況下，Hook 就可以滿足了，而且可以幫助你減少在 tree 內的巢狀 component。</section><section id="what-do-hooks-mean-for-popular-apis-like-redux-connect-and-react-router"class="level3"><h3>Hook 對於 Redux <code>connect()</code> 和 React Router 等等其他流行的 API 意味著什麼？</h3><p>你可以繼續使用與以往完全相同的 API；它們依然可以正常使用。<p>React Redux 從 v7.1.0 <a href="https://react-redux.js.org/api/hooks">支援 Hooks API</a> 並提供像是 <code>useDispatch</code> 或 <code>useSelector</code> 的 hooks。<p>React Router 從 v5.1 版本後<a href="https://reacttraining.com/react-router/web/api/Hooks">支援 Hooks</a>。<p>其他像是 React Router 可能在未來會支援 Hooks。</section><section id="do-hooks-work-with-static-typing"class="level3"><h3>Hook 可以使用靜態型別嗎？</h3><p>Hook 的設計考慮到了靜態型別。因為它們是 function，比 Higher-Order Component 等其他模式的 component 更容易正確的定義。最新的 Flow 和 TypeScript 定義包含對 React Hook 的支援。<p>重要的是，如果你想要以某種嚴格的方式定義 React API，自訂的 Hook 讓你有權利限制。React 為你提供了 primitive，但你可以將它與我們提供的方式，用不同的方式組合在一起。</section><section id="how-to-test-components-that-use-hooks"class="level3"><h3>如何測試使用 Hook 的 component？</h3><p>從 React 的角度來看，使用 Hook 的 component 就只是一個正常的 component。如果你的測試方案不依賴在 React 內部，測試使用 Hook 的 component 通常與你測試 component 的方式相同。<blockquote><p>注意<p><a href="./testing-recipes.html">測試方法</a>包含許多範例，讓你可以複製貼上。</blockquote><p>例如，如果我們有一個計數器 component：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Example</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token maybe-class-name">You</span> clicked <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times<span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Click</span> me
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>我們將會使用 React DOM 測試它。為了確保它在瀏覽器發生的行為，我們將會把程式碼透過呼叫 <code>ReactTestUtils.act()</code> 來 render 和更新：<pre class="language-js{3,20-22,29-31}"><code class="language-js{3,20-22,29-31}">import React from 'react';
import ReactDOM from 'react-dom/client';
import { act } from 'react-dom/test-utils';
import Counter from './Counter';

let container;

beforeEach(() => {
  container = document.createElement('div');
  document.body.appendChild(container);
});

afterEach(() => {
  document.body.removeChild(container);
  container = null;
});

it('can render and update a counter', () => {
  // 第一次測試 render 和 effect
  act(() => {
    ReactDOM.createRoot(container).render(&#x3C;Counter />);
  });
  const button = container.querySelector('button');
  const label = container.querySelector('p');
  expect(label.textContent).toBe('You clicked 0 times');
  expect(document.title).toBe('You clicked 0 times');

  // 第二次測試 render 和 effect
  act(() => {
    button.dispatchEvent(new MouseEvent('click', {bubbles: true}));
  });
  expect(label.textContent).toBe('You clicked 1 times');
  expect(document.title).toBe('You clicked 1 times');
});</code></pre><p>對 <code>act()</code>的呼叫也會更新它內部的 effect。<p>如果你需要測試自定義的 Hook，你可以透過在測試中建立你的 component，並從中使用 Hook。接著你可以測試你撰寫的 component。<p>為了減少 boilerplate，我們推薦使用 <a href="https://testing-library.com/react"><code>react-testing-library</code></a>，它的設計理念是鼓勵你撰寫像使用者在使用 component 的測試。<p>更多資訊，請參考<a href="./testing-recipes.html">測試方法</a>。</section><section id="what-exactly-do-the-lint-rules-enforce"class="level3"><h3><a href="(https://www.npmjs.com/package/eslint-plugin-react-hooks)">Lint 規則</a>究竟強制了些什麼？</h3><p>我們提供一個 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">ESLint plugin</a> 強制 <a href="./hooks-rules.html">Hook 的規則</a> 來避免 bug。它假設任何以「<code>use</code>」為開頭的 function 和緊跟在它之後的大寫字母是 Hook。我們認知到這個啟發式的搜尋不是完美而且可能有一些誤判，但是如果沒有一個全生態系統的慣例，就沒有辦法讓 Hook 良好的運作 -- 而且，較長的命名會阻礙人們採用 Hook 或是遵循慣例。<p>特別是，該規範強制執行：<ul><li>呼叫 Hook 要麼是在一個 <code>PascalCase</code> function（假設是一個 component）內，或者是其他 <code>useSomething</code> function （假設是一個字定義的 Hook）。<li>在每次的 render 上以相同的順序呼叫 Hook。</ul><p>這裡還有一些啟發式的方法，當我們發現錯誤並微調規則以平衡避免誤判時，這些規則可能會隨著時間而改變。</section></section><section id="from-classes-to-hooks"class="level2"><h2>從 Class 到 Hook</h2><section id="how-do-lifecycle-methods-correspond-to-hooks"class="level3"><h3>生命週期方法與 Hook 如何對應？</h3><ul><li><p><code>constructor</code>：Function component 不需要 constructor。你可以在呼叫 <a href="./hooks-reference.html#usestate"><code>useState</code></a> 時初始化 state。如果初始化 state 的操作代價很高，你可以傳遞一個 function 到 <code>useState</code>。<li><p><code>getDerivedStateFromProps</code>：改為<a href="#how-do-i-implement-getderivedstatefromprops">在 render</a> 時安排更新。<li><p><code>shouldComponentUpdate</code>：參考 <code>React.memo</code> <a href="#how-do-i-implement-shouldcomponentupdate">如下</a>。<li><p><code>render</code>：這是 function component body 本身。<li><p><code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code>：<a href="./hooks-reference.html#useeffect"><code>useEffect</code> Hook</a> 可以表達這些所有的組合（包含<a href="#can-i-skip-an-effect-on-updates">少見</a>和<a href="#can-i-run-an-effect-only-on-updates">常見</a>）的情況<li><p><code>getSnapshotBeforeUpdate</code>、<code>componentDidCatch</code> 和 <code>getDerivedStateFromError</code>：現在沒有 Hook 等價於這些方法，，但是它們未來很快會被加入。</ul></section><section id="how-can-i-do-data-fetching-with-hooks"class="level3"><h3>我如何使用 Hook fetch 資料？</h3><p>這裡有一個<a href="https://codesandbox.io/s/jvvkoo8pq3">範例</a>讓你可以開始。想要學習更多，閱讀這篇關於使用 Hook fetch 資料的<a href="https://www.robinwieruch.de/react-hooks-fetch-data/">文章</a>。</section><section id="is-there-something-like-instance-variables"class="level3"><h3>是否有類似 Instance 變數的東西？</h3><p>是的！<a href="./hooks-reference.html#useref"><code>useRef()</code></a> Hook 不只是針對 DOM 的 ref。「ref」object 是一個 generic container，其 <code>current</code> 屬性是可變的，可以保存任何值，類似於 class 上的 instance 屬性。<p>你可以從 <code>useEffect</code> 內撰寫它：<pre class="language-js{2,8}"><code class="language-js{2,8}">function Timer() {
  const intervalRef = useRef();

  useEffect(() => {
    const id = setInterval(() => {
      // ...
    });
    intervalRef.current = id;
    return () => {
      clearInterval(intervalRef.current);
    };
  });

  // ...
}</code></pre><p>如果我們想要設定一個計時器，我們不需要 ref（<code>id</code> 可能是在 effect），但是如果我們想要從一個 event handler 清除定時器它會很有幫助：<pre class="language-js{3}"><code class="language-js{3}">  // ...
  function handleCancelClick() {
    clearInterval(intervalRef.current);
  }
  // ...</code></pre><p>概念上，你可以將 ref 視為類似於 class 中 instance 的變數。除非你正在做<a href="#how-to-create-expensive-objects-lazily">延遲初始化</a>，避免在 render 時設定 ref -- 這可能會造成非預期的行為。相反的，通常你會在 event handler 和 effect 中修改 ref。</section><section id="should-i-use-one-or-many-state-variables"class="level3"><h3>我應該使用一個或是多個 state 變數？</h3><p>如果你原來是使用 class component，你可能會想要呼叫 <code>useState()</code> 並一次放入所有的 state 到一個 object，你想要的話可以這麼做。這裡是一個隨著滑鼠移動的 component 範例。我們保持它的位置和大小在 local state 內：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Box</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">left</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">top</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">width</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>現在我們想要撰寫一些邏輯，當使用者移動滑鼠時，改變 <code>left</code> 和 <code>top</code>。注意我們如何手動合併這些欄位至先前的 state object：<pre class="language-js{4,5}"><code class="language-js{4,5}">  // ...
  useEffect(() => {
    function handleWindowMouseMove(e) {
      // 使用展開運算子「...state」確保我們不會「漏掉」width 和 height
      setState(state => ({ ...state, left: e.pageX, top: e.pageY }));
    }
    // 注意：這個實作是相當簡化的
    window.addEventListener('mousemove', handleWindowMouseMove);
    return () => window.removeEventListener('mousemove', handleWindowMouseMove);
  }, []);
  // ...</code></pre><p>這是因為當我們更新 state 變數時，我們<em>替換</em>它的值。這與 class 中的<code>this.setState</code>不同，將被更新的欄位<em>合併</em>到 object 中。<p>如果你漏掉了自動合併，你可以撰寫一個自訂的 <code>useLegacyState</code> Hook 來合併 object state 的更新。然而，<strong>我們建議根據哪些值是趨於一起變化的，拆分為多個 state 變數</strong><p>例如，我們可以拆分 component state 成 <code>position</code> 和 <code>size</code> object，並總是替換 <code>position</code> 而不需要合併：<pre class="language-js{2,7}"><code class="language-js{2,7}">function Box() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  const [size, setSize] = useState({ width: 100, height: 100 });

  useEffect(() => {
    function handleWindowMouseMove(e) {
      setPosition({ left: e.pageX, top: e.pageY });
    }
    // ...</code></pre><p>分離獨立的 state 變數也有另一個好處。稍後可以輕鬆地將一些相關邏輯提取到自定義的 Hook 中，例如：<pre class="language-js{2,7}"><code class="language-js{2,7}">function Box() {
  const position = useWindowPosition();
  const [size, setSize] = useState({ width: 100, height: 100 });
  // ...
}

function useWindowPosition() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  useEffect(() => {
    // ...
  }, []);
  return position;
}</code></pre><p>注意我們是如何移動 <code>position</code> state 變數的 <code>useState</code> 呼叫，並且在不改變我們程式碼的情況下，將相關 effect 寫到自定義的 Hook。如果所有的 state 在一個單一的 object，提取它會變得困難。<p>以上兩者都將所有 state 放到各自的 <code>useState</code>，並可以被呼叫。當你在這兩個極端之間找到平衡時，component 往往最具可讀性，並且將相關 state 變成一些獨立的 state 變數。如果 state 邏輯變得複雜，我們推薦<a href="./hooks-reference.html#usereducer">用 reducer 管理</a>或者是一個自定義的 Hook。</section><section id="can-i-run-an-effect-only-on-updates"class="level3"><h3>我可以只在更新時執行 effect 嗎？</h3><p>這是一個特殊的情況，如果你有需要的話，可以<a href="#is-there-something-like-instance-variables">使用 mutable ref</a> 來手動的儲存對應於第一次或是後續的 render，然後檢查在你 effect 內的 flag。（如果你發現自己經常這樣做，可以為其建立一個自定義的 Hook。）</section><section id="how-to-get-the-previous-props-or-state"class="level3"><h3>如何取得先前的 prop 或 state？</h3><p>有兩種情況下，你可能想取得先前的 prop 或 state。<p>有時候，你需要先前的 prop 來 <strong>清除一個 effect。</strong>例如，你可能有一個基於 <code>userId</code> prop 來 subscribe 一個 socket 的 effect，你想要 unsubscribe <em>先前的</em> 的 <code>userId</code> 以及 subscribe <em>下一個</em>。對於這樣的工作你不需要做任何事：<pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToSocket</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">userId</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromSocket</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">userId</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>props<span class="token punctuation">.</span><span class="token property-access">userId</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上面的範例中，如果 <code>userId</code> 從 <code>3</code> 變成 <code>4</code>，<code>ChatAPI.unsubscribeFromSocket(3)</code> 會回傳第一個，接著執行 <code>ChatAPI.subscribeToSocket(4)</code>。這裡不需要取得「先前的」 <code>userId</code>，因為 cleanup function 會在它的 closure 捕獲它。<p>其他時候，你可能需要<strong>基於 prop 或 state 的變化來調整 state</strong>。這很少需要，而且這通常是個訊號你有一些重複或多餘的 state。然而，在極少數的情況下你需要這個模式，你可以 <a href="#how-do-i-implement-getderivedstatefromprops">儲存先前的 state 或 prop 在 state 並且在 rendering 期間更新它們</a>。<p>我們之前提出了一個自定義的 hook 叫做 <code>usePrevious</code> 來儲存前一個值。然而，我們發現大部分的使用案例都是向上面所描述的兩種模式。如果你的使用情境非常不同，你可以<a href="#is-there-something-like-instance-variables">儲存一個值在 ref</a> 並且當它需要的時候手動更新它。避免在 rendering 中讀取和更新 ref，因為這讓你 component 的行為難以預測和理解。</section><section id="why-am-i-seeing-stale-props-or-state-inside-my-function"class="level3"><h3>為什麼我在 function 內看到舊的 prop 或 state？</h3><p>任何在 component 內的 function，包括 event handler 和 effect，從被建立的 render 中「看見」props 和 state。例如，思考一下這個程式碼：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Example</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleAlertClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'You clicked on: '</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token maybe-class-name">You</span> clicked <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times<span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Click</span> me
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleAlertClick<span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Show</span> alert
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>如果你第一次點擊「Show alert」並且遞增 counter，那麼 alert 將會顯示<strong>你當時點擊「Show alert」按鈕</strong>時的 count 變數。假設 prop 和 state 沒有改變的話，這可以避免 bug。<p>如果你想要從一些非同步的 callback 讀取<em>最新的</em> state，你可以把它保留在 <a href="./hooks-faq.html#is-there-something-like-instance-variables">ref</a>，mutate 它，並從中讀取。<p>最後，如果你使用「dependency array」做最佳化，但沒有正確的指定所有的依賴，你可能會看到舊的 props 或是 state。例如，如果在 effect 指定 <code>[]</code> 作為第二個參數，但是在內部讀取 <code>someProp</code>，它將只會「看到」<code>someProp</code> 的初始值。解決方式是移除 dependency array 或者是修正它。這裡是<a href="#is-it-safe-to-omit-functions-from-the-list-of-dependencies">你如何處理這些 function</a>，以及<a href="#what-can-i-do-if-my-effect-dependencies-change-too-often">其他常見的策略</a>在不錯誤地跳過依賴項的情況下減少執行 effect。<blockquote><p>注意<p>我們提供了一個 <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> 的 ESLint 規則作為 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> package 的一部份。它會在指定錯誤的依賴時，發出警告並提供建議修復。</blockquote></section><section id="how-do-i-implement-getderivedstatefromprops"class="level3"><h3>我該如何實作 getDerivedStateFromProps？</h3><p>雖然你可能<a href="/blog/2018/06/07/you-probably-dont-need-derived-state.html">不需要它</a>，但在極少數情況下（例如實作<code>&#x3C;Transition></code> component），你可以在 render 期間更新 state。React 將會在第一次的 render 退出後，重新執行 component 並且立即更新 state，這個操作代價不會很昂貴。<p>在這裡，我們將 <code>row</code> prop 先前的值存儲在 state 變數中，讓我們可以方便的比較：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ScrollView</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>row<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isScrollingDown<span class="token punctuation">,</span> setIsScrollingDown<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>prevRow<span class="token punctuation">,</span> setPrevRow<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>row <span class="token operator">!==</span> prevRow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Row 在最後一次 render 被改變。更新 isScrollingDown</span>
    <span class="token function">setIsScrollingDown</span><span class="token punctuation">(</span>prevRow <span class="token operator">!==</span> <span class="token keyword null nil">null</span> <span class="token operator">&#x26;&#x26;</span> row <span class="token operator">></span> prevRow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setPrevRow</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Scrolling down: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isScrollingDown<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>這個第一眼看起來可能很奇怪，但是 render 過程中的更新正是 <code>getDerivedStateFromProps</code> 的概念。</section><section id="is-there-something-like-forceupdate"class="level3"><h3>有類似 forceUpdate 的東西嗎？</h3><p>如果新的值與先前相同的話，<code>useState</code> 和 <code>useReducer</code> Hook 兩者都可以從<a href="./hooks-reference.html#bailing-out-of-a-state-update">更新中跳脫</a>。<p>通常來說，你不應該在 React 內 mutate local state，然而，你可以使用一個 increment couter 來作為跳脫方式，強迫重新 render，即使 state 沒有改變。<pre class="language-js"><code class="language-js">  <span class="token keyword">const</span> <span class="token punctuation">[</span>ignored<span class="token punctuation">,</span> forceUpdate<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token arrow operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">forceUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre><p>如果可以的話，盡量避免使用這個方式。</section><section id="can-i-make-a-ref-to-a-function-component"class="level3"><h3>我可以對 function component 建立一個 ref 嗎？</h3><p>雖然你不應該經常這樣做，但是你可以使用 <a href="./hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a> Hook expose 一些 imperative 方法給 parent component。</section><section id="how-can-i-measure-a-dom-node"class="level3"><h3>我該如何測量一個 DOM node？</h3><p>為了測量 DOM node 的位置或是大小，你可以使用 <a href="./refs-and-the-dom.html#callback-refs">callback ref</a>。只要 ref 被 attach 到不同的 node，React 將會呼叫這個 callback。這裡是一個<a href="https://codesandbox.io/s/l7m0v5x4v9">簡易的範例</a>：<pre class="language-js{4-8,12}"><code class="language-js{4-8,12}">function MeasureExample() {
  const [height, setHeight] = useState(0);

  const measuredRef = useCallback(node => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  }, []);

  return (
    &#x3C;>
      &#x3C;h1 ref={measuredRef}>Hello, world&#x3C;/h1>
      &#x3C;h2>The above header is {Math.round(height)}px tall&#x3C;/h2>
    &#x3C;/>
  );
}</code></pre><p>在這個範例我們不選擇 <code>useRef</code> 是因為一個 object 的 ref 不會通知我們目前的 ref 值的<em>改變</em>。使用一個 callback ref 確保<a href="https://codesandbox.io/s/818zzk8m78">即使 child component 延遲顯示測量的 node</a> （例如：在 response click），我們仍然會在 parent component 中收到有關它的通知，並可以更新測量結果。<p>這確保我們的 ref callback 不會在 re-render 時改變，因此 React 不需要呼叫它。<p>在這個範例，callback ref 只會在當 component mount 以及 unmount 時被呼叫，由於被 render 的 <code>&#x3C;h1></code> component 在所有 render 都保持存在。如果你想要在任何時候在 component resize 時被通知，你可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code>ResizeObserver</code></a> 或其他第三方的 Hook。<p>如果你希望呼叫它的話，你可以<a href="https://codesandbox.io/s/m5o42082xy">抽出這個邏輯</a>變成一個可重複使用的 Hook：<pre class="language-js{2}"><code class="language-js{2}">function MeasureExample() {
  const [rect, ref] = useClientRect();
  return (
    &#x3C;>
      &#x3C;h1 ref={ref}>Hello, world&#x3C;/h1>
      {rect !== null &#x26;&#x26;
        &#x3C;h2>The above header is {Math.round(rect.height)}px tall&#x3C;/h2>
      }
    &#x3C;/>
  );
}

function useClientRect() {
  const [rect, setRect] = useState(null);
  const ref = useCallback(node => {
    if (node !== null) {
      setRect(node.getBoundingClientRect());
    }
  }, []);
  return [rect, ref];
}</code></pre></section><section id="what-does-const-thing-setthing--usestate-mean"class="level3"><h3><code>const [thing, setThing] = useState()</code> 是什麼意思？</h3><p>如果你不熟悉這個語法的話，可以參考在 State Hook 文件的<a href="./hooks-state.html#tip-what-do-square-brackets-mean">解釋</a>。</section></section><section id="performance-optimizations"class="level2"><h2>效能最佳化</h2><section id="can-i-skip-an-effect-on-updates"class="level3"><h3>我可以在更新時忽略 effect 嗎？</h3><p>可以的。請參考<a href="./hooks-reference.html#conditionally-firing-an-effect">條件式觸發 effect</a>。請注意，忘記處理更新通常<a href="./hooks-effect.html#explanation-why-effects-run-on-each-update">導致 bug</a>，這就是為什麼這不是預設行為。</section><section id="is-it-safe-to-omit-functions-from-the-list-of-dependencies"class="level3"><h3>在依賴項目的列表中忽略 function 是安全的嗎？</h3><p>一般來說，不是。<pre class="language-js{3,8}"><code class="language-js{3,8}">function Example({ someProp }) {
  function doSomething() {
    console.log(someProp);
  }

  useEffect(() => {
    doSomething();
  }, []); // 🔴 這個不安全（呼叫 `doSomething` 的 function 使用了 `someProp`）
}</code></pre><p>要記住 effect 之外的 function 使用了哪些 props 或 state 是很困難的。這也是為什麼<strong>通常你需要在 effect <em>內</em>宣告所需要的 function。</strong>然後可以很容易的看出 effect 依賴了 component 範圍內的值：<pre class="language-js{4,8}"><code class="language-js{4,8}">function Example({ someProp }) {
  useEffect(() => {
    function doSomething() {
      console.log(someProp);
    }

    doSomething();
  }, [someProp]); // ✅ OK（我們的 effect 只使用 `someProp`）
}</code></pre><p>如果之後我們仍然不使用 component 範圍內的任何值，則可以安全的指定為 <code>[]</code>：<pre class="language-js{7}"><code class="language-js{7}">useEffect(() => {
  function doSomething() {
    console.log('hello');
  }

  doSomething();
}, []); // ✅ OK，在這個範例中，因為我們不使用 component 範圍中的*任何*值</code></pre><p>根據你的使用情境，還有一些選項如下所述。<blockquote><p>注意<p>我們提供了 <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> ESLint 規則作為 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> package 的一部份。它可以幫助你找到不一致的處理更新的 component。</blockquote><p>讓我們看看這個為什麼很重要。<p>如果你在 <code>useEffect</code>、<code>useLayoutEffect</code>、<code>useMemo</code>、<code>useCallback</code> 或是 <code>useImperativeHandle</code> 的最後指定了<a href="./hooks-reference.html#conditionally-firing-an-effect">依賴項目的列表</a>，它必須包含在 callback 內使用的值以及參與 React 的資料流。包含了 props、state 和從它們取得的任何值。<p>如果沒有任何內容（或由它呼叫的 function）reference 到 props、state 或是從它們取得的值，那麼從依賴項目中省略一個 function 是<em>唯一</em>安全的。這個範例有一個 bug：<pre class="language-js{5,12}"><code class="language-js{5,12}">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);

  async function fetchProduct() {
    const response = await fetch('http://myapi/product/' + productId); // 使用 productId prop
    const json = await response.json();
    setProduct(json);
  }

  useEffect(() => {
    fetchProduct();
  }, []); // 🔴 無效，因為 `fetchProduct` 使用 `productId`
  // ...
}</code></pre><p><strong>推薦修正的方法是將 function 移動到你的 effect <em>內部</em>。</strong>這樣可以很容易地看到你的 effect 使用了哪些 props 或 state，並確保他們都被宣告：<pre class="language-js{5-10,13}"><code class="language-js{5-10,13}">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);

  useEffect(() => {
    // 透過將這個 function 移動到 effect 內部，我們可以清楚地看到值的使用。
    async function fetchProduct() {
      const response = await fetch('http://myapi/product/' + productId);
      const json = await response.json();
      setProduct(json);
    }

    fetchProduct();
  }, [productId]); // ✅ 有效，因為我們的 effect 只使用 productId
  // ...
}</code></pre><p>這也可以允許你處理在 effect 內使用 local 變數處理無序的 response：<pre class="language-js{2,6,10}"><code class="language-js{2,6,10}">  useEffect(() => {
    let ignore = false;
    async function fetchProduct() {
      const response = await fetch('http://myapi/product/' + productId);
      const json = await response.json();
      if (!ignore) setProduct(json);
    }

    fetchProduct();
    return () => { ignore = true };
  }, [productId]);</code></pre><p>我們搬移 function 到 effect 內部，所以它不需要被加入在依賴列表。<blockquote><p>Tip<p>查看<a href="https://codesandbox.io/s/jvvkoo8pq3">這個簡易的範例</a>以及<a href="https://www.robinwieruch.de/react-hooks-fetch-data/">這篇文章</a>來學習關於如何使用 Hooks 來取得資料。</blockquote><p><strong>如果有一些因素讓你<em>不能</em>搬移 function 到 effect 內，這裡有一些其他的選項：</strong><ul><li><strong>你可以嘗試將 function 搬移到 component 之外</strong>。在這個情況下， function 可以保證不 reference 到任何的 props 或 state，而且也不需要在依賴項目的列表中。<li>如果你正在呼叫的 function 是 pure 的計算，而且可以在 render 時被安全的呼叫，<strong>你可以在 effect 外呼叫它，</strong>並讓 effect 取決於回傳的值。<li>作為最後的手段，你可以<strong>加入一個 function 到 effect 依賴項目，但是<em>封裝它的定義</em></strong>成 <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a> Hook。這可以確保它不會在每次 render 時改變，除非<em>它自己</em>的依賴項目也改變：</ul><pre class="language-js{2-5}"><code class="language-js{2-5}">function ProductPage({ productId }) {
  // ✅ 藉由 useCallback 封裝可以避免在每次 render 時改變
  const fetchProduct = useCallback(() => {
    // ... Does something with productId ...
  }, [productId]); // ✅ 所有 useCallback 依賴已經被指定

  return &#x3C;ProductDetails fetchProduct={fetchProduct} />;
}

function ProductDetails({ fetchProduct })
  useEffect(() => {
    fetchProduct();
  }, [fetchProduct]); // ✅ 所有 useEffect 依賴已經被指定
  // ...
}</code></pre><p>注意，在上面的範例中，我們<em>需要</em>保持 function 在依賴列表內。這可以確保 <code>ProductPage</code> 中的 <code>productId</code> 改變自動會觸發 <code>ProductDetails</code> component 的 refetch。</section><section id="what-can-i-do-if-my-effect-dependencies-change-too-often"class="level3"><h3>如果我的 effect 依賴項目經常變化的話該怎麼辦？</h3><p>有時候，你的 effect 可能使用 state 而且它經常改變。你可能想從依賴的項目列表中省略該 state，但這通常會導致 bug：<pre class="language-js{6,9}"><code class="language-js{6,9}">function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(count + 1); // 這個 effect 依賴於 `count` state
    }, 1000);
    return () => clearInterval(id);
  }, []); // 🔴 Bug：`count` 沒有被指定作為一個依賴

  return &#x3C;h1>{count}&#x3C;/h1>;
}</code></pre><p>設定空的依賴 <code>[]</code>，意味著 effect 將只會在 component mount 的時候只執行一次，而不是在每次 re-render。問題在於內部的 <code>setInterval</code> callback，<code>count</code> 值並不會改變，因為我們已經建立一個 closure 並且設定 <code>count</code> 為 <code>0</code>，就像執行 effect callback 時一樣。在每秒鐘，這個 callback 呼叫 <code>setCount(0 + 1)</code>，所以 count 永遠不會大於 1。<p>指定 <code>[count]</code> 作為依賴項目可以修正這個 bug，但會導致每次更改時重置間隔。實際上，每個 <code>setInterval</code> 在被清除之前都有一次機會執行（類似於 <code>setTimeout</code>。）這可能並不理想。要修正這個問題，我們可以使用 <a href="./hooks-reference.html#functional-updates"><code>setState</code> 的 functional 更新的形式</a>。它允許我們指定<em>如何</em> state 需要改變而不引用<em>目前</em>的 state：<pre class="language-js{6,9}"><code class="language-js{6,9}">function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + 1); // ✅ 這不會依賴於外部的 `count` 變數
    }, 1000);
    return () => clearInterval(id);
  }, []); // ✅ 我們的 effect 不使用 component 範圍內的任何變數

  return &#x3C;h1>{count}&#x3C;/h1>;
}</code></pre><p>（<code>setCount</code> function 的 identity 的保證是穩定的，因此省略它是安全的。）<p>現在，<code>setInterval</code> callback 每秒執行一次，但每次對 <code>setCount</code> 內部的呼叫都可以使用 <code>count</code> 最新的值（在 callback 中被呼叫的 <code>c</code>。）<p>在許多複雜的情況下（例如，一個 state 依賴另一個 state），嘗試使用 <a href="./hooks-reference.html#usereducer"><code>useReducer</code> Hook</a> 將 state 的更新邏輯搬移到 effect 外。<a href="https://adamrackis.dev/state-and-use-reducer/">這篇文章</a>提供了一個如何做到的範例。<strong><code>useReducer</code> 中的 <code>dispatch</code> function 的 identity 是穩定的</strong> — 即使 reducer function 被宣告在 component 內並讀取它的 props。<p>作為最後的手段，如果你需要像是 class 內的 <code>this</code>，你可以<a href="./hooks-faq.html#is-there-something-like-instance-variables">使用 ref</a> 來持有一個 mutable 變數。然後你可以寫入和讀取它。例如：<pre class="language-js{2-6,10-11,16}"><code class="language-js{2-6,10-11,16}">function Example(props) {
  // 保持最新的 props 在 ref。
  const latestProps = useRef(props);
  useEffect(() => {
    latestProps.current = props;
  });

  useEffect(() => {
    function tick() {
      // 在任何時候讀取最新的 props
      console.log(latestProps.current);
    }

    const id = setInterval(tick, 1000);
    return () => clearInterval(id);
  }, []); // 這個 effect 永遠不會重新執行
}</code></pre><p>如果你真的找不到其他更好的方式才這麼做，因為依賴 mutation 會讓 component 的可預測性降低。如果有一個特定的模式不能很好地轉換，請<a href="https://github.com/facebook/react/issues/new">提出 issue</a> 並附上可執行的範例程式碼，我們可以嘗試提供幫助。</section><section id="how-do-i-implement-shouldcomponentupdate"class="level3"><h3>我該如何實作 shouldComponentUpdate？</h3><p>你可以藉由 <code>React.memo</code> 封裝 function 來對它的 props 進行淺比較：<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">Button</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// 你的 component</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>它不是一個 Hook，因為它並不像 Hooks 那樣的組成。<code>React.memo</code> 相等於 <code>PureComponent</code>，但是它只比較 props。（你也可以加入第二參數，指定一個舊 props 和新 props 的比較 function 。如果它回傳 true，則跳過更新。）<p><code>React.memo</code> 不比較 state，因為沒有單一的 state object 可以比較。但你也可以讓 children 變成 pure，甚至可以<a href="./hooks-faq.html#how-to-memoize-calculations">透過 <code>useMemo</code> 來最佳化個別的 children</a>。</section><section id="how-to-memoize-calculations"class="level3"><h3>如何 memoize 計算？</h3><p><a href="./hooks-reference.html#usememo"><code>useMemo</code></a> Hook 讓你可以透過「記住」先前的計算來快取多個 render 之間的計算：<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">computeExpensiveValue</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>這個程式碼呼叫 <code>computeExpensiveValue(a, b)</code>。但是如果 <code>[a, b]</code> 依賴自上一個值沒有改變，那麼 <code>useMemo</code> 會跳過第二次的呼叫並只重複使用它回傳的最後一個值。<p>記住，被傳到 <code>useMemo</code> 的 function 會在 render 期間執行。不要在 render 期間做一些通常不會做的事情。例如，side effects 屬於在 <code>useEffect</code> 被處理，而不是 <code>useMemo</code>。<p><strong>你可以依賴 <code>useMemo</code> 作為效能的最佳化，而不是依賴語意的保證。</strong> 未來 React 可能會選擇「忘記」一些先前 memoize 的值，並在下一次 render 重新計算，例如，釋放螢幕以外的 component 記憶體。撰寫你的程式碼，讓它在沒有 <code>useMemo</code> 的狀況下依然可以執行 - 並且加上它來最佳化效能。（對於極少數的情況，值<em>永遠</em>不會被重新計算，你可以<a href="#how-to-create-expensive-objects-lazily">延遲初始化</a> ref。）<p>方便的是，<code>useMemo</code> 也可以讓你跳過一個 child 昂貴的 re-render：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Parent</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 只會在 `a` 改變時 re-render：</span>
  <span class="token keyword">const</span> child1 <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Child1</span> a<span class="token operator">=</span><span class="token punctuation">{</span>a<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 只會在 `b` 改變時 re-render：</span>
  <span class="token keyword">const</span> child2 <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Child2</span> b<span class="token operator">=</span><span class="token punctuation">{</span>b<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token punctuation">{</span>child1<span class="token punctuation">}</span>
      <span class="token punctuation">{</span>child2<span class="token punctuation">}</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>注意，這個方法在一個迴圈中無法執行，因為 Hook <a href="./hooks-rules.html">不能</a>被放在迴圈內。但是你可以提取一個清單列表的獨立 component，並在這裡呼叫 <code>useMemo</code>。</section><section id="how-to-create-expensive-objects-lazily"class="level3"><h3>如何延遲建立昂貴的 object？</h3><p>如果依賴相同的話，<code>useMemo</code> 讓你可以 <a href="#how-to-memoize-calculations">memoize 一個昂貴的計算</a>。然而，它只是個提示，並不能<em>保證</em>計算不會重新執行。但有時候你需要確保一個 object 只被建立一次。<p><strong>第一個常見的情況是建立昂貴的初始 state：</strong><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Table</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ⚠️ createRows() 在每次 render 被呼叫</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>rows<span class="token punctuation">,</span> setRows<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token function">createRows</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>為了避免重新建立初始 state，我們可以傳遞一個 <strong>function</strong> 給 <code>useState</code>：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Table</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ✅ createRows() 只會被呼叫一次</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>rows<span class="token punctuation">,</span> setRows<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">createRows</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>React 只會在第一次 render 時呼叫這個 function。參考 <a href="./hooks-reference.html#usestate"><code>useState</code> API</a>。<p><strong>你偶爾可能也想要避免重新建立 <code>useRef()</code> 初始值。</strong>例如，或許你想要確保某些 imperative class 只被建立一次：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ⚠️ IntersectionObserver 在每次 render 時被建立</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>onIntersect<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p><code>useRef</code> <strong>不</strong>接受像 <code>useState</code> 這樣特殊的重載 function。你可以撰寫你自己的 function 來建立並延遲設定：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ✅ IntersectionObserver 會延遲被建立一次</span>
  <span class="token keyword">function</span> <span class="token function">getObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>onIntersect<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> ref<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 當你需要它的時候，呼叫 getObserver()</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>這是避免了在第一次真正需要之前建立昂貴的 object。如果你使用 Flow 或者是 TypeScript，為了方便你也可以給定 <code>getObserver()</code> 一個 non-nullable 的型別。</section><section id="are-hooks-slow-because-of-creating-functions-in-render"class="level3"><h3>在 render 時建立 function，Hooks 會變慢嗎？</h3><p>不會，在現代瀏覽器中，除了在極端情況下，closure 的原生效能與 class 相較之下沒有明顯的差異。<p>此外，考慮到 Hooks 的設計在以下幾個方面很有效：<ul><li><p>Hook 可以避免 class 的大量開銷，像是建立 class instance 並在 constructor 綁定 event handler。<li><p><strong>習慣使用 Hooks 的程式碼後，就不需要深層的巢狀 component</strong>，這在 higher-order component、render props 和 context 等其他流行函式庫中普遍存在，使用較小的 component tree，React 可以減少更多的工作量。</ul><p>傳統上，在 React inline function 的效能問題與如何在 child component 中，在每個 render 打破 <code>shouldComponentUpdate</code> 最佳化傳遞新的 callback 有關。Hooks 從三個方面來處理這個問題。<ul><li><p>The <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a> Hook 讓你可以在重新 render 之間保持相同的 callback，所以 <code>shouldComponentUpdate</code> 依然可以運作：<pre class="language-js{2}"><code class="language-js{2}">// 除非 `a` 或 `b` 改變，否則不改變
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);</code></pre><li><p><a href="./hooks-faq.html#how-to-memoize-calculations"><code>useMemo</code></a> Hook 讓獨立的 children 更新時，可以更容易的被控制，減少對 pure component 的需求。<li><p>最後，<a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> Hook 減少傳遞深層的 callback 需要，我們將會在下面解釋。</ul></section><section id="how-to-avoid-passing-callbacks-down"class="level3"><h3>如何避免向下傳遞 callback？</h3><p>我們發現大部分的人不喜歡透過 component tree 的每一層手動傳遞 callback。即使它是更明確，它可以感覺像是有許多「管道」。<p>在大型的 component tree 中，我們推薦另一個方法是透過 context 從 <a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> 傳遞一個 <code>dispatch</code> function：<pre class="language-js{4,5}"><code class="language-js{4,5}">const TodosDispatch = React.createContext(null);

function TodosApp() {
  // 注意：`dispatch` 在 re-render 之間不會改變
  const [todos, dispatch] = useReducer(todosReducer);

  return (
    &#x3C;TodosDispatch.Provider value={dispatch}>
      &#x3C;DeepTree todos={todos} />
    &#x3C;/TodosDispatch.Provider>
  );
}</code></pre><p>任何在 <code>TodosApps</code> 內的 child component 可以使用 <code>dispatch</code> function 來傳遞 action 到 <code>TodosApp</code>：<pre class="language-js{2,3}"><code class="language-js{2,3}">function DeepChild(props) {
  // 如果我們想要執行一個 action，我們可以從 context 取得 dispatch。
  const dispatch = useContext(TodosDispatch);

  function handleClick() {
    dispatch({ type: 'add', text: 'hello' });
  }

  return (
    &#x3C;button onClick={handleClick}>Add todo&#x3C;/button>
  );
}</code></pre><p>從維護的角度來看更方便（不需要持有轉發 callback），並且完全避免了 callback 問題。像這樣傳遞 <code>dispatch</code> 是深度更新的推薦模式。<p>請注意，你仍然可以選擇是否將應用程式的 <em>state</em> 向下傳遞為 props（更明確）還是作為 context（對於非常深的更新更方便）。如果你也使用 context 傳遞 state，使用兩個不同的 context type -- <code>dispatch</code> context 永遠不會改變，因此讀取它的 component 不需要重新 render，除非它們也需要應用程式的 state。</section><section id="how-to-read-an-often-changing-value-from-usecallback"class="level3"><h3>如何從 <code>useCallback</code> 讀取一個經常變化的值？</h3><blockquote><p>注意<p>我們建議<a href="#how-to-avoid-passing-callbacks-down">在 context 中傳遞 <code>dispatch</code></a>，而不是在 props 中傳遞單獨的 callback。下面的方法僅在此處提及完整性和跳脫方法。</blockquote><p>在極少數的情況下你可能會透過 <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a> memoize 一個 callback，但是因為內部 function 必須常常被重新建立，所以 memoize 沒有辦法很好個運作。如果你要 memoize 的 function 是一個 event handler，而且它不會被在 render 時被使用，你可以使用 <a href="#is-there-something-like-instance-variables">ref 作為一個 instance 變數</a>，並手動儲存最後被 commit 的值：<pre class="language-js{6,10}"><code class="language-js{6,10}">function Form() {
  const [text, updateText] = useState('');
  const textRef = useRef();

  useEffect(() => {
    textRef.current = text; // 將它寫到 ref
  });

  const handleSubmit = useCallback(() => {
    const currentText = textRef.current; // 從 ref 讀取它
    alert(currentText);
  }, [textRef]); // 不要像 [text] 那樣重新建立 handleSubmit

  return (
    &#x3C;>
      &#x3C;input value={text} onChange={e => updateText(e.target.value)} />
      &#x3C;ExpensiveTree onSubmit={handleSubmit} />
    &#x3C;/>
  );
}</code></pre><p>這是一個相當複雜的模式，但如果你需要，可以執行這個跳脫最佳化。如果你提取它到自訂的 Hook：<pre class="language-js{4,16}"><code class="language-js{4,16}">function Form() {
  const [text, updateText] = useState('');
  // 如果 `text` 改變，將會被 memoize：
  const handleSubmit = useEventCallback(() => {
    alert(text);
  }, [text]);

  return (
    &#x3C;>
      &#x3C;input value={text} onChange={e => updateText(e.target.value)} />
      &#x3C;ExpensiveTree onSubmit={handleSubmit} />
    &#x3C;/>
  );
}

function useEventCallback(fn, dependencies) {
  const ref = useRef(() => {
    throw new Error('Cannot call an event handler while rendering.');
  });

  useEffect(() => {
    ref.current = fn;
  }, [fn, ...dependencies]);

  return useCallback(() => {
    const fn = ref.current;
    return fn();
  }, [ref]);
}</code></pre><p>在任何一種情況下，我們<strong>都不推薦這種模式</strong>，僅在此呈現完整性。相反的，最好<a href="#how-to-avoid-passing-callbacks-down">避免在深處傳遞 callback</a>。</section></section><section id="under-the-hood"class="level2"><h2>深入理解</h2><section id="how-does-react-associate-hook-calls-with-components"class="level3"><h3>React 如何將 Hook 呼叫與 component 關聯？</h3><p>React 會持續追蹤目前 render 的 component。感謝 <a href="./hooks-rules.html">Hooks 的規則</a>，我們知道 Hook 只能從 React component（或自訂的 Hook -- 它們也只能從 React component 中被呼叫）被呼叫。<p>每一個 component 有一個「memory cell」的內部列表。它們只是我們可以放入一些資料的 JavaScript object。當你呼叫像是 <code>useState()</code> 的 Hook，它會讀取目前的 cell（或在第一次 render 時初始化它），並將指標移動到下一個。這就是多個 <code>useState()</code> 的呼叫，取得每個獨立的 local state。</section><section id="what-is-the-prior-art-for-hooks"class="level3"><h3>Hook 現有的技術是什麼？</h3><p>Hooks 綜合了幾個不同來源的想法：<ul><li>在 <a href="https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State">react-future</a> repository 中，我們使用 functional APIs 的舊實驗。<li>React 社群使用 render props APIs 的實驗，包括 <a href="https://github.com/ryanflorence">Ryan Florence</a> 的 <a href="https://github.com/reactions/component">Reactions Component</a>。<li><a href="https://github.com/trueadm">Dominic Gannaway</a> 的 <a href="https://gist.github.com/trueadm/17beb64288e30192f3aa29cad0218067"><code>adopt</code> keyword</a> 提案作為 render props 的語法糖。<li><a href="http://displayscript.org/introduction.html">DisplayScript</a> 中的 state 變數以及 state 單元。<li>ReasonReact 中的 <a href="https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html">Reducer components</a>。<li>Rx 中的 <a href="http://reactivex.io/rxjs/class/es6/Subscription.js~Subscription.html">Subscriptions</a>。<li>Multicore OCaml 中的 <a href="https://github.com/ocamllabs/ocaml-effects-tutorial#2-effectful-computations-in-a-pure-setting">Algebraic effects</a>。</ul><p><a href="https://github.com/sebmarkbage">Sebastian Markbåge</a> 想出了 Hook 的原始設計，之後由 <a href="https://github.com/acdlite">Andrew Clark</a>、<a href="https://github.com/sophiebits">Sophie Alpert</a>、<a href="https://github.com/trueadm">Dominic Gannaway</a> 以及其他 React 團隊的成員加以完善。 <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section></section>