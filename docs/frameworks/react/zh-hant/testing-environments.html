<!doctype html>
<html lang="zh-hant">
  <head>
    <meta charset="utf-8">
    <title>測試環境</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="測試環境" class="level1">
      <h1>測試環境</h1><!-- This document is intended for folks who are comfortable with JavaScript, and have probably written tests with it. It acts as a reference for the differences in testing environments for React components, and how those differences affect the tests that they write. This document also assumes a slant towards web-based react-dom components, but has notes for other renderers. -->
      <p>本份文件介紹了可能影響環境的因素以及某些場景下的建議。</p>
      <section id="test-runners" class="level3">
        <h3>Test runner</h3>
        <p>像是 <a href="https://jestjs.io/">Jest</a>、<a href="https://mochajs.org/">mocha</a>、<a href="https://github.com/avajs/ava">ava</a> 的 Test runner 讓你以常規的 JavaScript 來撰寫測試，並在開發過程中執行它們。此外，test suite 也會作為持續整合中執行的一部份。</p>
        <ul>
          <li>Jest 廣泛的兼容 React 專案，支援像是 <a href="#mocking-modules">module</a> 和 <a href="#mocking-timers">timer</a>，以及 <a href="#mocking-a-rendering-surface"><code>jsdom</code></a> 的 mock 功能。<strong>如果你使用 Create React App，<a href="https://facebook.github.io/create-react-app/docs/running-tests">內建已經包含了 Jest </a>與有用的預設設定。</strong></li>
          <li>像是 <a href="https://mochajs.org/#running-mocha-in-the-browser">mocha</a> 之類的函式庫，在實際的瀏覽器環境中可以很好地工作，並且可以幫助明確需要它的測試在實際的瀏覽器環境中可以很好的運作，並且可以幫助明確需要它的測試。</li>
          <li>End-to-end 測試被用在較長需要橫跨多個頁面的流程，並且需要一個<a href="#end-to-end-tests-aka-e2e-tests">不同的設定</a>。</li>
        </ul>
      </section>
      <section id="mocking-a-rendering-surface" class="level3">
        <h3>Mock 一個 render 的 surface</h3>
        <p>測試通常不會在存取像是瀏覽器真實的 surface 的環境中執行。對於這些環境，我們建議使用 <a href="https://github.com/jsdom/jsdom"><code>jsdom</code></a> 模擬一個瀏覽器，它是一個可以在 Node.js 中執行的輕量瀏覽器實作。</p>
        <p>在大多數情況下，jsdom 的行為像是一個正常的瀏覽器，但是沒有像是 <a href="https://github.com/jsdom/jsdom#unimplemented-parts-of-the-web-platform">layout 和 navigation</a> 的功能。這對於大部分基於 web component 的測試仍然有用，因為它執行的速度比每次測試都啟動瀏覽器還要來得快。它也在相同的 process 執行你的測試，因此你可以撰寫程式來檢查和 assert 被 render 的 DOM。</p>
        <p>就像在一個真實的瀏覽器一樣，jsdom 讓我們模擬使用者的互動；測試可以在 DOM node 上 dispatch event，並且觀察和 assert 這些操作<a href="./testing-recipes.html#events"><small>（範例）</small></a>的 side effect。</p>
        <p>上述的設定可以撰寫大部分的 UI 測試：使用 Jest 作為 test runner，render 到 jsdom，透過 <code>act()</code> helper <a href="./testing-recipes.html"><small>（範例）</small></a> 將使用者互動指定為瀏覽器 event 的序列。例如，React 本身許多的測試都是由此組合所撰寫的。</p>
        <p>如果你正在撰寫一個函式庫，它主要測試於特定的瀏覽器行為，並要求原生的瀏覽器行為像是 layout 或是真實的輸入，你可以使用像是 <a href="https://mochajs.org/">mocha</a> 的測試框架。</p>
        <p>在<em>無法</em>模擬 DOM 的環境中（例如：在 Node.js 上測試 React Native 的 component），你可以使用 <a href="./test-utils.html#simulate">event simulation helper</a> 來模擬互動的 element。或者，你可以使用 <a href="https://testing-library.com/docs/react-native-testing-library/intro"><code>@testing-library/react-native</code></a> 的 <code>fireEvent</code> helper。</p>
        <p>像是 <a href="https://www.cypress.io/">Cypress</a>、<a href="https://github.com/GoogleChrome/puppeteer">puppeteer</a> 和 <a href="https://www.seleniumhq.org/projects/webdriver/">webdriver</a> 的框架對於執行 <a href="#end-to-end-tests-aka-e2e-tests">end-to-end tests</a> 非常有用。</p>
      </section>
      <section id="mocking-functions" class="level3">
        <h3>Mock 函式</h3>
        <p>當撰寫測試時，我們會想要 mock 在我們測試環境中沒有等效的程式碼部分（例如：在 Node.js 內判斷 <code>navigator.onLine</code> 狀態）。測試也可以監視（spy）某些函式，並觀察其他部分的測試如何與它交互。可以使用易於測試的版本，對於選擇性地來 mock 這些函式很有用。</p>
        <p>這特別是對於資料的 fetch 非常有用。通常最好是使用「假」資料來測試，避免從真實 API endpoint 取得資料，造成緩慢和脆弱的測試<a href="./testing-recipes.html#data-fetching"><small>（範例）</small></a>。這增進了測試的可預期性。像是 <a href="https://jestjs.io/">Jest</a> 和 <a href="https://sinonjs.org/">sinon</a> 的函式庫，都支援 mock 函式。對於 end-to-end 測試來說，mock network 可能會更困難，但你仍然可能也想要在測試中測試真實的 API endpoint。</p>
      </section>
      <section id="mocking-modules" class="level3">
        <h3>Mocking module</h3>
        <p>有些 component 與其他 module 可能有依賴關係，在測試環境中可能會無法運作，或者是對於測試不可缺少的。選擇性的 mock 這些 module 並進行適當的替換會很有用<a href="./testing-recipes.html#mocking-modules"><small>（範例）</small></a>。</p>
        <p>在 Node.js 中，像是 Jest 的 runner <a href="https://jestjs.io/docs/en/manual-mocks">支援 mock module</a>。你也可以選擇像是 <a href="https://www.npmjs.com/package/mock-require"><code>mock-require</code></a> 的函式庫。</p>
      </section>
      <section id="mocking-timers" class="level3">
        <h3>Mocking timer</h3>
        <p>Component 可能使用基於像是 <code>setTimeout</code>、<code>setInterval</code> 或是 <code>Date.now</code> 的時間函式。在測試環境中，可以透過 mock 這些函式來做替換，對於你想要手動「提前」時間非常有用。這可以確保你的測試很快地執行！依賴於 timer 的測試仍然可以按順序 resolve，但速度更快<a href="./testing-recipes.html#timers"><small>（範例）</small></a>。大部分的測試框架，包含 <a href="https://jestjs.io/docs/en/timer-mocks">Jest</a>、<a href="https://sinonjs.org/releases/latest/fake-timers">sinon</a> 以及 <a href="https://github.com/sinonjs/lolex">lolex</a> 讓你可以在測試中 mock timer。</p>
        <p>有時候你可能不想要 mock timer。例如，或許你想要測試一個 animation，或是與一個對時間較敏感的 endpoint 交互（像是 API 的 rate limiter）。函式庫的 timer mock 讓你在每個測試的基礎上啟用和關閉它們，所以你可以明確的選擇這些測試的執行方式。</p>
      </section>
      <section id="end-to-end-tests-aka-e2e-tests" class="level3">
        <h3>End-to-end 測試</h3>
        <p>End-to-end 測試對於測試更長的 workflow 非常有用，特別是當它們對於你的商業邏輯至關重要時（像是付款或是註冊）。對於這些測試，你可能需要測試真實瀏覽器是如何 render 整個應用程式，從真實 API endpoint 來 fetch 資料，使用 session 和 cookie，在不同的連結之間導航。你可能不只想要 assert 在 DOM 上的 state，而且還要備份資料的 assert（例如：驗證更新是否已經被儲存到資料庫）。</p>
        <p>
          在這個場景下，你會使用像是 <a href="https://www.cypress.io/">Cypress</a>、<a href="https://playwright.dev">Playwright</a>，或是像是 <a href="https://pptr.dev/">Puppeteer</a> 的函式庫，所以你可以在不同的 route 之間切換，並 assert side effect，而不是只有在瀏覽器內，也有可能在後端。
          <span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span>
        </p>
      </section>
    </section>
  </body>
</html>
