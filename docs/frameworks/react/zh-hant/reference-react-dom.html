<!doctype html><html lang="zh-hant"><meta charset="utf-8"><title>ReactDOM</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="reactdom"class="level1"><h1>ReactDOM</h1><p><code>react-dom</code> 提供了 DOM 的特定方法讓你可以在你的應用程式頂層使用，如果有需要，也可以作為一個逃生窗口來脫離 React 模型。<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> <span class="token maybe-class-name">ReactDOM</span></span> <span class="token keyword module">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span></code></pre><p>如果你使用 ES5 與 npm，你可以這樣寫：<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token maybe-class-name">ReactDOM</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'react-dom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>react-dom</code> package 也提供了特定於 client 和 server 應用程式的 module：<ul><li><a href="./react-dom-client.html"><code>react-dom/client</code></a><li><a href="./react-dom-server.html"><code>react-dom/server</code></a></ul><section id="overview"class="level2"><h2>概覽</h2><p><code>react-dom</code> package export 這些方法：<ul><li><a href="#createportal"><code>createPortal()</code></a><li><a href="#flushsync"><code>flushSync()</code></a></ul><p>這些 <code>react-dom</code> 方法也被 export，但是被視為是 legacy：<ul><li><a href="#render"><code>render()</code></a><li><a href="#hydrate"><code>hydrate()</code></a><li><a href="#finddomnode"><code>findDOMNode()</code></a><li><a href="#unmountcomponentatnode"><code>unmountComponentAtNode()</code></a></ul><blockquote><p>注意：<p><code>render</code> 與 <code>hydrate</code> 兩者在 React 18 已經替換為新的 <a href="./react-dom-client.html">client 方法</a>。如果你使用像是 React 17 方式，這些方法將警告你的應用程式的行為。（<a href="https://reactjs.org/link/switch-to-createroot">從這裡</a>了解更多）。</blockquote><section id="browser-support"class="level3"><h3>瀏覽器支援</h3><p>React 支援所有主流瀏覽器，雖然對於一些舊版瀏覽器<a href="./javascript-environment-requirements.html">需要一些 polyfill</a>。<blockquote><p>注意：<p>我們不支援那些較舊不支援 ES5 方法或是 microtasks 的瀏覽器，像是 Internet Explorer。但如果頁面上引入了像是 <a href="https://github.com/es-shims/es5-shim">es5-shim 和 es5-sham</a> 等 polyfill 你可能會發現你的應用程式在較舊的瀏覽器上仍可使用，但如果你選擇了這條路你就只能靠你自己了。</blockquote></section></section><section id="reference"class="level2"><h2>參考</h2><section id="createportal-createportal"class="level3"><h3><code>createPortal()</code> {#createportal}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token function">createPortal</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> container<span class="token punctuation">)</span></code></pre><p>提供了一個方式將 children <a href="./portals.html">render 存在於 DOM component 層次結構之外的 DOM 節點中</a>。</section><section id="flushsync-flushsync"class="level3"><h3><code>flushSync()</code> {#flushsync}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token function">flushSync</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span></code></pre><p>強制 React 同步 flush 提供的 callback 中的任何更新。這可以確保 DOM 被立即的更新。<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// Force this state update to be synchronous.</span>
<span class="token function">flushSync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// By this point, DOM is updated.</span></code></pre><blockquote><p>注意：<p><code>flushSync</code> 可能會對效能產生重大的影響。謹慎使用。<p><code>flushSync</code> 可能會迫使 pending 的 Suspense boundary 顯示 <code>fallback</code> 狀態。<p><code>flushSync</code> 也可以執行 pending effects，並在回傳之前同步 apply 它們包含的任何更新。<p><code>flushSync</code> <code>flushSync</code> 在必要時也可以在 callback 外 flush 更新，以 flush callback 内的更新。例如，如果有來自 click 的 pending 更新，React 可能會在 flush callback 中的更新之前 flush 這些内容。</blockquote></section></section><section id="legacy-reference"class="level2"><h2>Legacy Reference</h2><section id="render-render"class="level3"><h3><code>render()</code> {#render}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token function">render</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> container<span class="token punctuation">[</span><span class="token punctuation">,</span> callback<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><blockquote><p>注意：<p><code>render</code> 在 React 18 已經被 <code>createRoot</code> 取代。更多資訊請參考 <a href="./react-dom-client.html#createroot">createRoot</a>。</blockquote><p>將一個 React elemnt render 到提供提供的 <code>container</code> 的 DOM 中，並回傳一個該 component 的 <a href="./more-about-refs.html">reference</a>（對於 <a href="./components-and-props.html#function-and-class-components">stateless components</a> 回傳 <code>null</code>）。<p>如果 React element 之前已經在 <code>container</code> 內被 render，它只會執行更新並 mutate 必要的 DOM，來呈現最新的 React element。<p>如果提供了可選的 callback，它將會在 component 被 render 或更新之後，才被執行。<blockquote><p>注意：<p><code>render()</code> 控制了你傳入到 container 內的 node 內容。當第一次被呼叫時，任何存在於 container 的 DOM element 都會被替換。之後的呼叫會使用 React 的 DOM diffing 演算法進行高效率的更新。<p><code>render()</code> 不修改 container 的 node（只修改 container 的 children）。它可以將 component 插入一個現有的 DOM node 而不用覆蓋已經存在的 children。<p><code>render()</code> 目前回傳一個 reference 到 root <code>ReactComponent</code> instance。然而，使用這個回傳值是被遺留的方式 並且應該被避免，因為未來版本的 React 在某些情況下可能會非同步地 render component。如果你需要 reference 到 root <code>ReactComponent</code> instance，首選的解決方式是附加一個 <a href="./refs-and-the-dom.html#callback-refs">callback ref</a> 在 root element 上。<p>使用 <code>render()</code> 來 hydrate 一個 server-render container 已經被棄用。使用 <a href="./react-dom-client.html#hydrateroot"><code>hydrateRoot()</code></a> 作為代替。</blockquote><hr></section><section id="hydrate-hydrate"class="level3"><h3><code>hydrate()</code> {#hydrate}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token function">hydrate</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> container<span class="token punctuation">[</span><span class="token punctuation">,</span> callback<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><blockquote><p>注意：<p><code>hydrate</code> 在 React 18 已經被 <code>hydrateRoot</code> 取代。更多資訊請參考 <a href="./react-dom-client.html#hydrateroot">hydrateRoot</a>。</blockquote><p>如同 <a href="#render"><code>render()</code></a>，但它是被用來 hydrate 一個 container，其 HTML 內容是由 <a href="./react-dom-server.html"><code>ReactDOMServer</code></a> render。React 將嘗試將 event listener attach 到現有 markup 上。s<p>React 預期在伺服器端和客戶端所 render 的內容是相同的。它可以修補 text content 的差異，但你應該把不匹配的部分視為 bug 並且修正。在開發模式中，React 會警告關於 hydration 過程中的不匹配。在不匹配的情況下，將無法保證 attribute 的差異會被修補。這對於效能來說很重要，因為在大部分的應用程式中，不匹配的情況很少見，也因此驗證要所有 markup 的成本非常高。<p>如果在伺服器端和客戶端某個 element 的 attribute 或 text content 無可避免的不相同（例如，時間戳），你可以透過加入 <code>suppressHydrationWarning={true}</code> 到 element 來關閉警告。這個只有在第一層時有效並且傾向於應急的做法。不要過度使用它。除非它是 text content 否則 React 仍然不會嘗試對其進行修補，所以在未來更新之前它可能會保持不一致。<p>如果你刻意要在服務端和客戶端上 render 不同的內容，你可以進行兩次的 render。在客戶端上呈現不同內容的 component 可以透過讀取一個 state 變數像是 <code>this.state.isClient</code> 之後在 <code>componentDidMount()</code> 內把它設定成 <code>true</code>。這樣初始 render 將跟伺服器端 render 的內容一樣，從而避免不匹配，但在 hydrate 之後將會立即同步額外的程序。請注意，此方法會使你的 component 變慢，因為它必須被 render 兩次，因此請謹慎使用。<p>請記得要留意連線緩慢的使用者體驗。JavaScript 載入顯然比 HTML 首次 render 要晚得多，因此，如果你只有在客戶端 render 一些不同的東西，則轉換可能會不穩定。然而，如果執行順利的話，在伺服器上 render 應用程式的「shell」可能是有幫助的，而且只顯示一些額外的插件在客戶端。要了解如何執行此操作而不會出現 markup 不匹配的問題，請參考上一個段落的說明。<hr></section><section id="unmountcomponentatnode-unmountcomponentatnode"class="level3"><h3><code>unmountComponentAtNode()</code> {#unmountcomponentatnode}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token function">unmountComponentAtNode</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span></code></pre><blockquote><p>注意：<p><code>unmountComponentAtNode</code> 在 React 18 已經被 <code>root.unmount()</code> 取代。更多資訊請參考 <a href="./react-dom-client.html#createroot">createRoot</a>。</blockquote><p>從 DOM 移除一個 mount React component 並清除它的 event handler 以及 state。如果沒有 component 被 mount 在 container 的話，呼叫這個 function 並不會做任何事。如果一個 component 被 unmount 回傳一個 <code>true</code>，反之如果沒有 component 被 unmount，回傳 <code>false</code>。<hr></section><section id="finddomnode-finddomnode"class="level3"><h3><code>findDOMNode()</code> {#finddomnode}</h3><blockquote><p>注意：<p><code>findDOMNode</code> 是一個用來存取底層 DOM node 應急的做法。在大多數情況下，不鼓勵使用這個應急的做法因為它會穿透 component 抽象化。<a href="./strict-mode.html#warning-about-deprecated-finddomnode-usage">它已經在 <code>StrictMode</code> 中被棄用了。</a></blockquote><pre class="language-javascript"><code class="language-javascript"><span class="token function">findDOMNode</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span></code></pre><p>如果這個 component 已經被 mount 到 DOM，則回傳對應原生瀏覽器的 DOM element。這個方法對於從 DOM 中讀取值是有用的，像是表單的欄位值和執行 DOM 的測量。 <strong>在大多數情況下，你可以附加一個 ref 給 DOM node 來避免使用 <code>findDOMNode</code>。</strong><p>當一個 component render 成 <code>null</code> 或 <code>false</code> 時， <code>findDOMNode</code> 回傳 <code>null</code>。當一個 component render 成字串時， <code>findDOMNode</code> 回傳一個包含該值的文字 DOM node。從 React 16 開始，component 可以回傳包含很多 children 的 fragment，在這種情況下 <code>findDOMNode</code> 將會回傳和第一個非空的子節點相對應的 DOM node。<blockquote><p>注意：<p><code>findDOMNode</code> 只在已經 mount 的 component 上有用（即已放置在 DOM 中的 component）。 如果你嘗試在尚未 mount 的 component 上呼叫它（比如在尚未建立的 component 的 <code>render()</code> 中調用 <code>findDOMNode()</code>），將會拋出異常。<p><code>findDOMNode</code> 不能被用在 function component。</blockquote><hr><p><span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section></section>