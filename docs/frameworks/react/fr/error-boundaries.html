<!doctypehtml><html lang="fr"><meta charset="utf-8"><title>Périmètres d'erreurs</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="périmètres-derreurs"class="level1"><h1>Périmètres d'erreurs</h1><p>Auparavant, les erreurs JavaScript au sein des composants avaient l'habitude de corrompre l'état interne de React, et de causer des <a href="https://github.com/facebook/react/issues/4026">erreurs</a> <a href="https://github.com/facebook/react/issues/6895">assez</a> <a href="https://github.com/facebook/react/issues/8579">incompréhensibles</a> lors des rendus suivants. Ces erreurs étaient toujours causées par une erreur antérieure dans le code applicatif et comme React ne proposait alors aucun moyen de les gérer correctement dans les composants, il n'avait pas la possibilité de se rétablir.<section id="introducing-error-boundaries"class="level2"><h2>L'arrivée des périmètres d'erreurs</h2><p>Une erreur JavaScript au sein d’une partie de l'interface utilisateur (UI) ne devrait pas casser l'ensemble de l'application. Pour résoudre ce problème, React 16 a introduit un nouveau concept appelé « Périmètres d’erreurs » <em>(Error Boundaries, NdT)</em>.<p>Les périmètres d'erreurs sont des composants React qui <strong>interceptent les erreurs JavaScript n'importe où au sein de leur arbre de composants enfants, enregistrent ces erreurs, et affichent une UI de repli</strong> à la place de l'arbre de composants qui a planté. Les périmètres d'erreurs interceptent les erreurs survenant au rendu, dans les méthodes de cycle de vie, ainsi que dans les constructeurs de tous les éléments de leur arborescence.<blockquote><p>Remarque<p>Les périmètres d'erreurs n'interceptent <strong>pas</strong> les erreurs qui surviennent dans :<ul><li>Les gestionnaires d'événements (<a href="#how-about-event-handlers">en savoir plus</a>).<li>Le code asynchrone (par exemple les fonctions de rappel de <code>setTimeout</code> ou <code>requestAnimationFrame</code>).<li>Le rendu côté serveur.<li>Les erreurs levées dans le composant du périmètre d'erreur lui-même (plutôt qu'au sein de ses enfants).</ul></blockquote><p>Une classe de composant devient un périmètre d'erreur si elle définit au moins une des méthodes de cycle de vie <a href="./react-component.html#static-getderivedstatefromerror"><code>static getDerivedStateFromError()</code></a> ou <a href="./react-component.html#componentdidcatch"><code>componentDidCatch()</code></a>. Utilisez <code>static getDerivedStateFromError()</code> pour afficher une UI de repli lorsqu'une erreur est levée. Utilisez <code>componentDidCatch()</code> pour enregistrer les informations relatives à l'erreur.<pre class="language-js{7-10,12-15,18-21}"><code class="language-js{7-10,12-15,18-21}">class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Mettez à jour l'état, de façon à montrer l'UI de repli au prochain rendu.
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Vous pouvez aussi enregistrer l'erreur au sein d'un service de rapport.
    logErrorToMyService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // Vous pouvez afficher n'importe quelle UI de repli.
      return &#x3C;h1>Something went wrong.&#x3C;/h1>;
    }

    return this.props.children;
  }
}</code></pre><p>Vous pouvez alors l'utiliser comme un composant classique :<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">ErrorBoundary</span><span class="token operator">></span>
  <span class="token operator">&#x3C;</span><span class="token maybe-class-name">MyWidget</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">ErrorBoundary</span><span class="token operator">></span></code></pre><p>Les périmètres d'erreurs fonctionnent comme un bloc JavaScript <code>catch {}</code>, mais pour les composants. Seuls les composants à base de classe peuvent être des périmètres d'erreurs. En pratique, vous voudrez généralement définir un seul composant de périmètre d'erreur puis l'utiliser partout dans votre application.<p>Notez bien que <strong>les périmètres d'erreurs ne détectent que les erreurs présentes en dessous d'eux dans l'arbre des composants</strong>. Un périmètre d'erreur ne peut intercepter une erreur survenant dans son propre code. Si un périmètre d'erreur plante en tentant d'afficher son message d'erreur, l’erreur se propagera alors au périmètre d'erreur le plus proche au-dessus de lui dans l'arbre. Là aussi, c'est similaire à la façon dont le bloc <code>catch {}</code> fonctionne en JavaScript.</section><section id="live-demo"class="level2"><h2>Démonstration interactive</h2><p>Jetez un coup d'œil sur <a href="https://codepen.io/gaearon/pen/wqvxGa?editors=0010">cet exemple de déclaration et d'utilisation d'un périmètre d'erreur</a> avec <a href="/blog/2017/09/26/react-v16.0.html">React 16</a>.</section><section id="where-to-place-error-boundaries"class="level2"><h2>Où placer les périmètres d'erreurs ?</h2><p>La granularité des périmètres d'erreurs est à votre discrétion. Vous pourriez enrober les composants racines de routage pour afficher à l'utilisateur un message du type « Quelque chose s'est mal passé », à l'image de ce qui est souvent fait par les frameworks côté serveur. Vous pourriez aussi enrober des éléments d'interface précis avec un périmètre d'erreur afin de les empêcher de planter le reste de l'application.</section><section id="new-behavior-for-uncaught-errors"class="level2"><h2>Nouveau comportement pour les erreurs non-rattrapées</h2><p>Ce changement a un impact important. <strong>À compter de React 16, les erreurs qui ne sont pas interceptées par un périmètre d'erreur entraîneront le démontage de l'intégralité de l'arbre des composants</strong>.<p>Cette décision a été débattue, mais l'expérience nous a montré qu'il est bien pire de laisser en place une interface corrompue que de la supprimer complètement. Par exemple, dans un produit tel que Messenger, laisser visible une interface dégradée peut amener l'utilisateur à envoyer un message à la mauvaise personne. De la même façon, pour une application de paiement, afficher un mauvais montant est bien pire que de ne rien afficher du tout.<p>Cette modification signifie que lorsque vous migrez vers React 16, vous découvrirez probablement des plantages dans votre application qui étaient jusque-là passés inaperçus. L'ajout de périmètres d'erreurs permet d'offrir une meilleure expérience utilisateur en cas de problème.<p>Par exemple, Facebook Messanger enrobe le contenu de la barre latérale, du panneau d'information, du journal de conversation, ainsi que de la saisie de message dans des périmètres d'erreurs distincts. Si l'un des composants de ces zones d'interface plante, les autres continueront de fonctionner normalement.<p>Nous vous encourageons également à utiliser des services de rapport d'erreurs JavaScript (ou à construire le vôtre) afin de mieux connaître les exceptions non gérées dès qu'elles apparaissent en production, et donc de pouvoir les corriger.</section><section id="component-stack-traces"class="level2"><h2>Traces de piles des composants</h2><p>En mode développement, React 16 affiche dans la console toutes les erreurs qui apparaissent durant le rendu, même si l'application les cache accidentellement. En plus du message d'erreur et de la trace de pile <em>(stack trace, NdT)</em> JavaScript, il fournit également la trace de pile du composant. Vous pouvez désormais voir exactement où l'erreur est apparue dans l'arbre des composants :</p><img src="./docs/error-boundaries-stack-trace.png"style="max-width:100%"alt="Une erreur interceptée par un périmètre d&#x27;erreur"><p>Vous pouvez également voir les noms des fichiers et les numéros de lignes dans la trace de pile du composant. C'est le fonctionnement par défaut pour les projets créés avec <a href="https://github.com/facebookincubator/create-react-app">Create React App</a> :</p><img src="./docs/error-boundaries-stack-trace-line-numbers.png"style="max-width:100%"alt="Une erreur interceptée par un périmètre d&#x27;erreur avec les numéros de lignes"><p>Si vous n'utilisez pas Create React App, vous pouvez ajouter <a href="https://www.npmjs.com/package/@babel/plugin-transform-react-jsx-source">cette extension</a> manuellement dans votre configuration Babel. Remarquez que c'est conçu pour le développement et <strong>ne doit pas être activé en production</strong>.<blockquote><p>Remarque<p>Les noms des composants affichés dans la trace de pile dépendent de la propriété <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Function/name"><code>Function.name</code></a>. Si vous devez prendre en charge des navigateurs ou des dispositifs plus anciens qui ne proposent pas ça nativement (par exemple IE 11), vous pouvez envisager d'inclure le polyfill <a href="https://github.com/JamesMGreene/Function.name"><code>function.name-polyfill</code></a> dans votre application. Autrement, vous pouvez également définir explicitement la propriété <a href="./react-component.html#displayname"><code>displayName</code></a> sur tous vos composants.</blockquote></section><section id="how-about-trycatch"class="level2"><h2>Et pourquoi pas try / catch ?</h2><p>Les <code>try</code> / <code>catch</code> sont super, mais ne marchent qu'avec du code impératif :<pre class="language-js"><code class="language-js"><span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>
  <span class="token function">showButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword control-flow">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>Mais les composants React sont déclaratifs et spécifient <em>ce qui</em> doit être rendu :<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Button</span> <span class="token operator">/</span><span class="token operator">></span></code></pre><p>Les périmètres d'erreurs respectent la nature déclarative de React, et se comportent sans surprises. Par exemple, même si une erreur survient dans une méthode <code>componentDidUpdate</code> suite à un <code>setState</code> quelque part au fin fond de l'arbre des composants, elle se propagera correctement jusqu’au périmètre d'erreur le plus proche.</section><section id="how-about-event-handlers"class="level2"><h2>Et les gestionnaires d'événements ?</h2><p>Les périmètres d'erreurs n'interceptent <strong>pas</strong> les erreurs qui surviennent au sein des gestionnaires d'événements.<p>React n'a pas besoin de périmètres d'erreurs pour gérer les erreurs dans les gestionnaires d'événements. Contrairement aux méthodes de rendu ou de cycle de vie, les gestionnaires d'événements ne sont pas appelés pendant le rendu. Du coup même si ces gestionnaires lèvent une erreur, React saura tout de même quoi afficher à l'écran.<p>Si vous avez besoin d'intercepter une erreur au sein d'un gestionnaire d'événements, il suffit d'utiliser un classique <code>try</code> / <code>catch</code> JavaScript :<pre class="language-js{9-13,17-20}"><code class="language-js{9-13,17-20}">class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { error: null };
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    try {
      // Faites ici quelque chose qui va lever une erreur
    } catch (error) {
      this.setState({ error });
    }
  }

  render() {
    if (this.state.error) {
      return &#x3C;h1>Une erreur a été interceptée.&#x3C;/h1>
    }
    return &#x3C;button onClick={this.handleClick}>Cliquez ici&#x3C;/button>
  }
}</code></pre><p>Remarquez que l'exemple ci-dessus illustre un comportement JavaScript classique et n'utilise aucun périmètre d'erreur.</section><section id="naming-changes-from-react-15"class="level2"><h2>Changements de nommage par rapport à React 15</h2><p>React 15 disposait d'une prise en charge très limitée des périmètres d'erreurs sous un nom de méthode différent : <code>unstable_handleError</code>. Cette méthode ne fonctionne plus, et vous devrez la remplacer par <code>componentDidCatch</code> dans votre code à partir de la première version bêta de React 16.<p>Pour ce changement, nous fournissons un <a href="https://github.com/reactjs/react-codemod#error-boundaries">codemod</a> qui vous permet de migrer automatiquement votre code. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>