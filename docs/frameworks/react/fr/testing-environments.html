<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <title>Environnements de test</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="environnements-de-test" class="level1">
      <h1>Environnements de test</h1><!-- Ce document vise les personnes déjà à l’aise avec JavaScript, et qui ont probablement déjà écrit des tests avec.  Il constitue une sorte de référence des différences entre les environnements de test pour les composants React, en explicitant en quoi ces différences affectent l’écriture des tests.  Ce document suppose par ailleurs une légère priorité envers les composants web basés sur react-dom, mais comprend des informations pour les autres moteurs de rendu. -->
      <p>Ce document détaille les facteurs susceptibles d’affecter votre environ­­nement, et fournit des conseils pour quelques scénarios.</p>
      <section id="test-runners" class="level3">
        <h3>Harnais de test</h3>
        <p>Les harnais de test tels que <a href="https://jestjs.io/">Jest</a>, <a href="https://mochajs.org/">mocha</a> ou <a href="https://github.com/avajs/ava">ava</a> vous permettent d’écrire des suites de tests en utilisant du JavaScript classique, et les exécutent dans le cadre de votre processus de développement. Qui plus est, les suites de tests peuvent être exécutées au sein de votre intégration continue.</p>
        <ul>
          <li>Jest est largement compatible avec les projets React, en offrant des fonctionnalités telles que l’isolation des <a href="#mocking-modules">modules</a> et des <a href="#mocking-timers">horloges</a>, ainsi qu’une prise en charge de <a href="#mocking-a-rendering-surface"><code>jsdom</code></a>. <strong>Si vous utilisez Create React App, <a href="https://facebook.github.io/create-react-app/docs/running-tests">Jest est fourni de base</a> avec des réglages par défaut très utiles.</strong></li>
          <li>Les bibliothèques comme <a href="https://mochajs.org/#running-mocha-in-the-browser">mocha</a> sont bien adaptées à une utilisation au sein de véritables navigateurs, et pourraient vous aider pour des tests ayant explicitement besoin de ce type de contexte d’exécution.</li>
          <li>Les tests de bout en bout sont surtout pertinents pour des scénarios plus longs impliquant plusieurs pages successives, et requièrent une <a href="#end-to-end-tests-aka-e2e-tests">mise en place distincte</a>.</li>
        </ul>
      </section>
      <section id="mocking-a-rendering-surface" class="level3">
        <h3>Simuler une surface d’affichage</h3>
        <p>Les tests s’exécutent souvent dans un environnement qui n’est pas doté d’une véritable surface d’affichage (comme le serait un navigateur). Pour ces environnements-là, nous vous conseillons de simuler un navigateur avec <a href="https://github.com/jsdom/jsdom"><code>jsdom</code></a>, une implémentation légère de navigateur qui s’exécute dans un processus Node.js.</p>
        <p>La plupart du temps, jsdom se comporte comme un navigateur classique, à ceci près qu’il ne fournit pas des aspects comme <a href="https://github.com/jsdom/jsdom#unimplemented-parts-of-the-web-platform">la mise en page et la navigation</a>. Ça reste utile pour la plupart des tests de composants basés web, dans la mesure où il s’exécute bien plus vite que lorsque vous devez démarrer un navigateur pour chaque test. Qui plus est, il s’exécute dans le même processus que vos tests, de sorte qu’il est facile d’écrire du code qui examine le DOM obtenu et vérifie son contenu.</p>
        <p>Tout comme un véritable navigateur, jsdom nous permet de modéliser les interactions utilisateurs ; vos tests peuvent déclencher des événements sur les nœuds du DOM, puis observer le DOM et vérifier les effets de bord de ces actions <a href="./testing-recipes.html#events"><small>(exemple)</small></a>.</p>
        <p>Une large part des tests d’interface utilisateur (UI) peuvent être écrits de cette façon : en utilisant Jest comme harnais, en réalisant le rendu avec jsdom, et en spécifiant les interactions utilisateurs sous forme de séquences d’événements au sein du navigateur, à l’aide de la fonction utilitaire <code>act()</code> <a href="./testing-recipes.html"><small>(exemple)</small></a>. Par exemple, de très nombreux tests de React lui-même sont écrits ainsi.</p>
        <p>Si vous écrivez une bibliothèque qui doit tester principalement des comportements spécifiques aux navigateurs, et requiert donc des comportements natifs du navigateur tels que la mise en page ou de véritables champs de saisie, il vous faudra alors plutôt une solution comme <a href="https://mochajs.org/">mocha</a>.</p>
        <p>Dans un environnement où vous <em>ne pouvez pas</em> simuler un DOM (par exemple en testant des composants React Native depuis Node.js), vous pourriez opter pour des <a href="./test-utils.html#simulate">utilitaires de simulation d’événements</a>, qui simulent les interactions avec les éléments. Une autre option consisterait à utiliser la fonction utilitaire <code>fireEvent</code> fournie par <a href="https://testing-library.com/docs/react-native-testing-library/intro"><code>@testing-library/react-native</code></a>.</p>
        <p>Les frameworks comme <a href="https://www.cypress.io/">Cypress</a>, <a href="https://github.com/GoogleChrome/puppeteer">puppeteer</a> et <a href="https://www.seleniumhq.org/projects/webdriver/">webdriver</a> sont quant à eux utiles pour exécuter des <a href="#end-to-end-tests-aka-e2e-tests">tests de bout en bout</a>.</p>
      </section>
      <section id="mocking-functions" class="level3">
        <h3>Simuler des fonctions</h3>
        <p>Lorsqu’on écrit des tests, on aimerait les isoler des parties de notre code qui n’ont pas d’équivalent dans notre environnement de test (par exemple pour vérifier l’état de <code>navigator.onLine</code> alors qu’on est en Node.js). Les tests peuvent aussi surveiller certaines fonctions, et observer l’interaction entre ces fonctions et d’autres parties du test. Il est alors utile de pouvoir simuler sélectivement ces fonctions en les remplaçant par des versions adaptées à nos tests.</p>
        <p>C’est particulièrement vrai pour le chargement de données. Il est généralement préférable d’utiliser de « fausses » données pour nos tests, afin d’éviter la lenteur et la fragilité d’une récupération depuis de véritables points d’accès API <a href="./testing-recipes.html#data-fetching"><small>(exemple)</small></a>. On gagne ainsi en fiabilité pour nos tests. Des bibliothèques comme <a href="https://jestjs.io/">Jest</a> et <a href="https://sinonjs.org/">sinon</a>, entre autres, permettent de simuler les fonctions. Pour des tests de bout en bout, il peut être un peu plus délicat de simuler complètement le réseau, mais vous voudrez sans doute utiliser de véritables points d’accès API dans ces tests-là de toutes façons.</p>
      </section>
      <section id="mocking-modules" class="level3">
        <h3>Simuler des modules</h3>
        <p>Certains composants ont des dépendances à des modules qui peuvent ne pas bien fonctionner dans un environnement de test, ou ne sont pas essentiels à nos tests. Il peut alors être utile de les simuler en les remplaçant par des versions appropriées <a href="./testing-recipes.html#mocking-modules"><small>(exemple)</small></a>.</p>
        <p>Dans Node.js, les harnais comme Jest <a href="https://jestjs.io/docs/en/manual-mocks">permettent la simulation de modules</a>. Vous pouvez aussi recourir à des bibliothèques telles que <a href="https://www.npmjs.com/package/mock-require"><code>mock-require</code></a>.</p>
      </section>
      <section id="mocking-timers" class="level3">
        <h3>Simuler des horloges</h3>
        <p>Vos composants pourront parfois utiliser des fonctionnalités sensibles au temps, telles que <code>setTimeout</code>, <code>setInterval</code>, ou <code>Date.now</code>. Dans des environnements de test, il peut être pratique de les remplacer par des versions qui vous permettent de faire manuellement « avancer » le temps. C’est super pour garantir que nos tests s’exécutent rapidement ! Les tests basés sur des horloges seraient toujours exécutés dans l’ordre, juste plus vite <a href="./testing-recipes.html#timers"><small>(exemple)</small></a>. La plupart des frameworks, y compris <a href="https://jestjs.io/docs/en/timer-mocks">Jest</a>, <a href="https://sinonjs.org/releases/v7.3.2/fake-timers/">sinon</a> et <a href="https://github.com/sinonjs/lolex">lolex</a>, vous permettent de simuler les horloges dans vos tests.</p>
        <p>Parfois, vous voudrez sans doute ne pas simuler les horloges, par exemple si vous testez une animation, ou une interaction avec un point d’accès sensible au temps (tel qu’une API imposant une limitation de trafic). Les bibliothèques qui simulent les horloges vous permettent d’activer ou désactiver ces interceptions par test ou par suite de tests, de sorte que vous pouvez choisir explicitement dans quels tests ces simulations sont exploitées.</p>
      </section>
      <section id="end-to-end-tests-aka-e2e-tests" class="level3">
        <h3>Tests de bout en bout</h3>
        <p>Les tests de bout en bout sont utiles pour tester des scénarios plus longs, en particulier s’ils sont critiques à votre activité (comme des paiements ou des inscriptions). Pour de tels tests, vous voudrez sans doute tester comment un véritable navigateur affiche votre appli entière, charge les données depuis de véritables points d’accès API, utilise les sessions et les cookies, navigue au travers de divers liens… Vous voudrez sans doute aussi vérifier non seulement l’état du DOM, mais les données sous-jacentes (par exemple pour vérifier si des mises à jour ont bien été persistées en base).</p>
        <p>
          Dans un tel scénario, vous utiliserez probablement un framework comme <a href="https://www.cypress.io/">Cypress</a> ou une bibliothèque telle que <a href="https://github.com/GoogleChrome/puppeteer">puppeteer</a> afin de pouvoir naviguer à travers de multiples routes et vérifier les effets de bord non seulement au sein du navigateur, mais dans votre couche serveur également.
          <span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span>
        </p>
      </section>
    </section>
  </body>
</html>
