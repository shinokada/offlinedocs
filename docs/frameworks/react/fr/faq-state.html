<!doctypehtml><html lang="fr"><meta charset="utf-8"><title>État local de composant</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="état-local-de-composant"class="level1"><h1>État local de composant</h1><section id="what-does-setstate-do"class="level3"><h3>Que fait <code>setState</code> ?</h3><p><code>setState()</code> planifie la mise à jour de l'objet <code>state</code> du composant. Quand l'état local change, le composant répond en se rafraîchissant.</section><section id="what-is-the-difference-between-state-and-props"class="level3"><h3>Quelle est la différence entre <code>state</code> et <code>props</code> ?</h3><p><a href="./components-and-props.html"><code>props</code></a> (diminutif de « propriétés ») et <a href="./state-and-lifecycle.html"><code>state</code></a> sont tous les deux des objets JavaScript bruts. Même s'ils contiennent tous les deux des informations qui influencent le résultat produit, ils présentent une différence majeure : <code>props</code> est passé <em>au</em> composant (à la manière des arguments d'une fonction) tandis que <code>state</code> est géré <em>dans</em> le composant (comme le sont les variables déclarées à l'intérieur d'une fonction).<p>Voici quelques ressources utiles pour mieux comprendre selon quels critères choisir entre <code>props</code> et <code>state</code> :<ul><li><a href="https://github.com/uberVU/react-guide/blob/master/props-vs-state.md">Props vs State</a><li><a href="https://lucybain.com/blog/2016/react-state-vs-pros/">ReactJS: Props vs. State</a></ul></section><section id="why-is-setstate-giving-me-the-wrong-value"class="level3"><h3>Pourquoi <code>setState</code> me renvoie-t-elle une valeur incorrecte ?</h3><p>En React, <code>this.props</code> et <code>this.state</code> représentent l'un comme l'autre les valeurs du rendu, c’est-à-dire ce qui est actuellement affiché.<p>Les appels à <code>setState</code> sont asynchrones : ne comptez pas sur <code>this.state</code> pour refléter la nouvelle valeur immédiatement après avoir appelé <code>setState</code>. Passez une fonction de mise à jour à la place d'un objet si vous devez calculer des valeurs en fonction de l'état actuel (voir ci-dessous pour plus de détails).<p>Voici un exemple de code qui ne se comporte <em>pas</em> comme attendu :<pre class="language-jsx"><code class="language-jsx"><span class="token function">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Attention : ça ne va *pas* fonctionner comme prévu.</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">handleSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Disons que `this.state.count` commence à 0.</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Lorsque React rafraîchira le composant, `this.state.count` sera à 1,</span>
  <span class="token comment">// pourtant, on s'attendait à 3.</span>

  <span class="token comment">// C'est parce que la fonction `incrementCount()` ci-dessus lit `this.state.count`,</span>
  <span class="token comment">// mais React ne met pas à jour `this.state.count` tant que le composant n'est pas rafraîchi.</span>
  <span class="token comment">// Du coup `incrementCount()` lit `this.state.count` qui est égal à 0 à chaque fois,</span>
  <span class="token comment">// et le définit à 1.</span>

  <span class="token comment">// Le correctif est décrit ci-dessous !</span>
<span class="token punctuation">}</span></code></pre><p>Voir ci-dessous pour savoir comment résoudre ce problème.</section><section id="how-do-i-update-state-with-values-that-depend-on-the-current-state"class="level3"><h3>Comment mettre à jour l'état avec des valeurs qui dépendent de l'état actuel ?</h3><p>Passez une fonction au lieu d'un objet à <code>setState</code> pour vous assurer que l'appel utilise toujours la version la plus récente de l'état (voir ci-dessous).</section><section id="what-is-the-difference-between-passing-an-object-or-a-function-in-setstate"class="level3"><h3>Quelle est la différence entre passer un objet ou une fonction à <code>setState</code> ?</h3><p>Passer une fonction de mise à jour vous permet d'accéder à la valeur à jour de l'état actuel au sein de cette fonction. Comme les appels <code>setState</code> sont groupés par lots, ça vous permet d'enchaîner les mises à jour et de vous assurer qu'elles sont effectuées les unes après les autres au lieu d'entrer en conflit :<pre class="language-jsx"><code class="language-jsx"><span class="token function">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// Important : lisez `state` au lieu de `this.state` lors de la mise à jour.</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">handleSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Disons que `this.state.count` commence à 0.</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Si vous lisiez `this.state.count` maintenant, il serait toujours à 0.</span>
  <span class="token comment">// Mais quand React rafraîchira le composant, il vaudra bien 3.</span>
<span class="token punctuation">}</span></code></pre><p><a href="./react-component.html#setstate">En apprendre davantage sur setState</a></section><section id="when-is-setstate-asynchronous"class="level3"><h3>Quand <code>setState</code> est-elle asynchrone ?</h3><p>Actuellement, <code>setState</code> est asynchrone à l'intérieur des gestionnaires d'événements.<p>Ça permet de garantir, par exemple, que si <code>Parent</code> et <code>Child</code> appellent tous les deux <code>setState</code> lors d'un clic, <code>Child</code> ne sera pas rafraîchi deux fois. Au lieu de ça, React « apure » les mises à jour de l'état à la fin de l'événement du navigateur. Ça permet une amélioration significative des performances pour les applications de grande ampleur.<p>Il s'agit d'un détail d'implémentation donc évitez de vous appuyer dessus. Dans de futures versions, React groupera par défaut les mises à jour dans davantage encore de cas de figure.</section><section id="why-doesnt-react-update-thisstate-synchronously"class="level3"><h3>Pourquoi React ne met-il pas à jour <code>this.state</code> de façon synchrone ?</h3><p>Comme expliqué dans la section précédente, React « attend » volontairement que tous les composants aient fini d'appeler <code>setState()</code> dans leurs gestionnaires d'événements avant de commencer à mettre à jour les rendus. Ça améliore les performances en évitant des rafraîchissements inutiles.<p>Cependant, vous vous demandez peut-être toujours pourquoi React ne met pas juste à jour <code>this.state</code> immédiatement sans rafraîchir.<p>Il y a deux raisons principales :<ul><li>Ça briserait la cohérence entre <code>props</code> et <code>state</code>, entraînant des problèmes très difficiles à déboguer.<li>Ça rendrait certaines nouvelles fonctionnalités sur lesquelles nous travaillons impossibles à implémenter.</ul><p>Ce <a href="https://github.com/facebook/react/issues/11527#issuecomment-360199710">commentaire GitHub</a> entre dans le détail d’exemples spécifiques.</section><section id="should-i-use-a-state-management-library-like-redux-or-mobx"class="level3"><h3>Devrais-je utiliser une bibliothèque de gestion d'état, comme par exemple Redux ou Mobx ?</h3><p><a href="https://redux.js.org/faq/general#when-should-i-use-redux">Peut-être.</a><p>Bien connaître React avant d'ajouter des bibliothèques supplémentaires reste une bonne idée. Vous pouvez créer des applications plutôt complexes en utilisant uniquement React. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>