<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <title>Utiliser un Hook d’effet</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="utiliser-un-hook-deffet" class="level1">
      <h1>Utiliser un Hook d’effet</h1>
      <p>Les <em>Hooks</em> sont une nouveauté de React 16.8. Ils permettent de bénéficier d’un état local et d'autres fonctionnalités de React sans avoir à écrire de classes.</p>
      <p>Le <em>Hook d’effet</em> permet l’exécution d’effets de bord dans les fonctions composants :</p>
      <pre class="language-js{1,6-10}"><code class="language-js{1,6-10}">import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // Similaire à componentDidMount et componentDidUpdate :
  useEffect(() => {
    // Met à jour le titre du document via l’API du navigateur
    document.title = `Vous avez cliqué ${count} fois`;
  });

  return (
    &#x3C;div>
      &#x3C;p>Vous avez cliqué {count} fois&#x3C;/p>
      &#x3C;button onClick={() => setCount(count + 1)}>
        Cliquez ici
      &#x3C;/button>
    &#x3C;/div>
  );
}</code></pre>
      <p>Cet extrait se base sur <a href="./hooks-state.html">l’exemple de compteur présenté à la page précédente</a>, avec toutefois une fonctionnalité supplémentaire : le titre du document est mis à jour avec un message personnalisé affichant le nombre de clics.</p>
      <p>Charger des données depuis un serveur distant, s’abonner à quelque chose et modifier manuellement le DOM sont autant d’exemples d’effets de bord. Que vous ayez ou non l’habitude de les appeler « effets de bord » (ou juste « effets »), il est hautement probable que vous les ayez déjà utilisés dans vos composants par le passé.</p>
      <blockquote>
        <p>Astuce</p>
        <p>Si vous avez l’habitude des méthodes de cycle de vie des classes React, pensez au Hook <code>useEffect</code> comme à une combinaison de <code>componentDidMount</code>, <code>componentDidUpdate</code>, et <code>componentWillUnmount</code>.</p>
      </blockquote>
      <p>Il existe deux grands types d’effets de bord dans les composants React : ceux qui ne nécessitent pas de nettoyage, et ceux qui en ont besoin. Examinons cette distinction en détail.</p>
      <section id="effects-without-cleanup" class="level2">
        <h2>Effets sans nettoyage</h2>
        <p>Parfois, nous souhaitons <strong>exécuter du code supplémentaire après que React a mis à jour le DOM</strong>. Les requêtes réseau, les modifications manuelles du DOM, et la journalisation sont des exemples courants d’effets qui ne nécessitent aucun nettoyage. Cela s’explique par le fait qu’ils peuvent être oubliés immédiatement après leur exécution. Comparons donc la manière dont les classes et les Hooks nous permettent d’exprimer ce genre d’effets de bord.</p>
        <section id="example-using-classes" class="level3">
          <h3>Exemple en utilisant les classes</h3>
          <p>Dans les composants React à base de classe, la méthode <code>render</code> ne devrait causer aucun effet de bord par elle-même. Ce serait trop tôt : ces effets ne sont utiles qu’<em>après</em> que React a mis à jour le DOM.</p>
          <p>C’est la raison pour laquelle, dans les classes React, nous plaçons les effets de bord dans les méthodes <code>componentDidMount</code> et <code>componentDidUpdate</code>. En reprenant notre exemple, voici un composant React à base de classe implémentant un compteur qui met à jour le titre du document juste après que React a modifié le DOM :</p>
          <pre class="language-js{9-15}"><code class="language-js{9-15}">class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    document.title = `Vous avez cliqué ${this.state.count} fois`;
  }

  componentDidUpdate() {
    document.title = `Vous avez cliqué ${this.state.count} fois`;
  }

  render() {
    return (
      &#x3C;div>
        &#x3C;p>Vous avez cliqué {this.state.count} fois&#x3C;/p>
        &#x3C;button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Cliquez ici
        &#x3C;/button>
      &#x3C;/div>
    );
  }
}</code></pre>
          <p>Notez la <strong>duplication de code entre ces deux méthodes de cycle de vie du composant.</strong></p>
          <p>En effet, la plupart du temps nous voulons que l’effet de bord soit exécuté tant au montage qu’à la mise à jour du composant. Conceptuellement, nous voulons que l’effet soit exécuté à chaque affichage, mais les composants React à base de classe ne disposent pas d’une telle méthode. Même en déplaçant l’effet de bord dans une fonction à part, on aurait tout de même besoin de l’appeler à deux endroits distincts.</p>
          <p>Maintenant, voyons comment faire la même chose avec le Hook <code>useEffect</code>.</p>
        </section>
        <section id="example-using-hooks" class="level3">
          <h3>Exemple en utilisant les Hooks</h3>
          <p>Cet exemple figurait déjà en haut de page, mais examinons-le de plus près :</p>
          <pre class="language-js{1,6-8}"><code class="language-js{1,6-8}">import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `Vous avez cliqué ${count} fois`;
  });

  return (
    &#x3C;div>
      &#x3C;p>Vous avez cliqué {count} fois&#x3C;/p>
      &#x3C;button onClick={() => setCount(count + 1)}>
        Cliquez ici
      &#x3C;/button>
    &#x3C;/div>
  );
}</code></pre>
          <p><strong>Que fait <code>useEffect</code> ?</strong> On utilise ce Hook pour indiquer à React que notre composant doit exécuter quelque chose après chaque affichage. React enregistre la fonction passée en argument (que nous appellerons « effet »), et l’appellera plus tard, après avoir mis à jour le DOM. L’effet ci-dessus met à jour le titre du document, mais il pourrait aussi bien charger des données distantes, ou appeler n’importe quelle autre API impérative.</p>
          <p><strong>Pourquoi <code>useEffect</code> est-elle invoquée à l’intérieur d’un composant ?</strong> Le fait d’appeler <code>useEffect</code> à l’intérieur de notre composant nous permet d’accéder à la variable d’état <code>count</code> (ou à n’importe quelle prop) directement depuis l’effet. Pas besoin d’une API dédiée pour les lire : elle est déjà dans la portée de la fonction. Les Hooks profitent pleinement des fermetures lexicales <em>(closures, NdT)</em> de JavaScript au lieu d’introduire de nouvelles API spécifiques à React, là où JavaScript propose déjà une solution.</p>
          <p><strong>Est-ce que <code>useEffect</code> est appelée après chaque affichage ?</strong> Oui ! Elle est exécutée par défaut après le premier affichage <em>et</em> après chaque mise à jour. (Nous verrons comment <a href="#tip-optimizing-performance-by-skipping-effects">personnaliser et optimiser ça</a> ultérieurement.) Au lieu de penser en termes de « montage » et de « démontage », pensez plutôt que les effets arrivent tout simplement « après l’affichage ». React garantit que le DOM a été mis à jour avant chaque exécution des effets.</p>
        </section>
        <section id="detailed-explanation" class="level3">
          <h3>Explication détaillée</h3>
          <p>À présent que nous en savons davantage sur les effets, ces quelques lignes devraient paraître plus claires :</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Example</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Vous avez cliqué </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> fois</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
          <p>Nous déclarons la variable d’état <code>count</code>, puis indiquons à React que nous avons besoin d’utiliser un effet. Nous passons alors une fonction au Hook <code>useEffect</code>. Cette fonction <em>est</em> notre effet. À l’intérieur de celui-ci, nous mettons à jour le titre du document en utilisant l’API du navigateur <code>document.title</code>. Il est possible d’y lire la dernière valeur de <code>count</code>, puisqu’elle est accessible depuis la portée de notre fonction. Lorsque React affichera notre composant, il se souviendra de notre effet, et l’exécutera après avoir mis à jour le DOM. Ce procédé est le même à chaque affichage, dont le tout premier.</p>
          <p>Les développeurs JavaScript expérimentés remarqueront sans doute que la fonction passée à <code>useEffect</code> sera différente à chaque affichage. C‘est voulu, et c’est ce qui nous permet d’accéder à la valeur de <code>count</code> depuis l’intérieur de l’effet sans nous inquiéter de l’obsolescence de notre fonction. À chaque nouvel affichage, nous planifions un effet <em>différent</em>, qui succède au précédent. Dans un sens, les effets font partie intégrante du résultat du rendu : chaque effet « appartient » à un rendu particulier. Nous reviendrons plus en détail sur l’utilité d’un tel comportement <a href="#explanation-why-effects-run-on-each-update">plus bas</a>.</p>
          <blockquote>
            <p>Astuce</p>
            <p>À l’inverse de <code>componentDidMount</code> ou de <code>componentDidUpdate</code>, les effets planifiés avec <code>useEffect</code> ne bloquent en rien la mise à jour de l’affichage par le navigateur, ce qui rend votre application plus réactive. La majorité des effets n’ont pas besoin d’être synchrones. Dans les cas plus rares où ils pourraient en avoir besoin (comme mesurer les dimensions d’un élément de l’interface), il existe un Hook particulier <a href="./hooks-reference.html#uselayouteffect"><code>useLayoutEffect</code></a> avec une API identique à celle de <code>useEffect</code>.</p>
          </blockquote>
        </section>
      </section>
      <section id="effects-with-cleanup" class="level2">
        <h2>Effets avec nettoyage</h2>
        <p>Nous avons vu précédemment comment écrire des effets de bord ne nécessitant aucun nettoyage. Toutefois, quelques effets peuvent en avoir besoin. Par exemple, <strong>nous pourrions souhaiter nous abonner</strong> à une source de données externe. Dans ce cas-là, il est impératif de nettoyer par la suite pour éviter les fuites de mémoire ! Comparons les approches à base de classe et de Hooks pour y arriver.</p>
        <section id="example-using-classes-1" class="level3">
          <h3>Exemple en utilisant les classes</h3>
          <p>Dans une classe React, on s’abonne généralement dans <code>componentDidMount</code>, et on se désabonne dans <code>componentWillUnmount</code>. Par exemple, imaginons que nous avons un module <code>ChatAPI</code> qui permet de nous abonner au statut de connexion d’un ami. Voici comment on pourrait s’abonner et l’afficher en utilisant une classe :</p>
          <pre class="language-js{8-26}"><code class="language-js{8-26}">class FriendStatus extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOnline: null };
    this.handleStatusChange = this.handleStatusChange.bind(this);
  }

  componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  handleStatusChange(status) {
    this.setState({
      isOnline: status.isOnline
    });
  }

  render() {
    if (this.state.isOnline === null) {
      return 'Chargement...';
    }
    return this.state.isOnline ? 'En ligne' : 'Hors-ligne';
  }
}</code></pre>
          <p>Remarquez l’effet miroir de <code>componentDidMount</code> et <code>componentWillUnmount</code>. Les méthodes de cycle de vie nous forcent à séparer cette logique alors que conceptuellement le code des deux méthodes a trait au même effet.</p>
          <blockquote>
            <p>Remarque</p>
            <p>Les lecteurs les plus attentifs remarqueront sans doute que cet exemple nécessite aussi <code>componentDidUpdate</code> pour être tout à fait correct. Nous avons choisi d’ignorer ça pour l’instant mais nous y reviendrons dans <a href="#explanation-why-effects-run-on-each-update">une section ultérieure</a> de cette page.</p>
          </blockquote>
        </section>
        <section id="example-using-hooks-1" class="level3">
          <h3>Exemple en utilisant les Hooks</h3>
          <p>Voyons comment réécrire notre exemple avec les Hooks.</p>
          <p>Instinctivement, vous pourriez imaginer qu’un effet distinct est nécessaire pour le nettoyage. Mais les codes pour s’abonner et se désabonner sont si fortement liés que <code>useEffect</code> a été pensé pour les conserver ensemble. Si votre effet renvoie une fonction, React l’exécutera lors du nettoyage :</p>
          <pre class="language-js{6-16}"><code class="language-js{6-16}">import React, { useState, useEffect } from 'react';

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    // Indique comment nettoyer l'effet :
    return function cleanup() {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) {
    return 'Chargement...';
  }
  return isOnline ? 'En ligne' : 'Hors-ligne';
}</code></pre>
          <p><strong>Pourquoi notre effet renvoie-t-il une fonction ?</strong> Il s’agit d’un mécanisme optionnel de nettoyage des effets. Tout effet peut renvoyer une fonction qui se chargera de son propre nettoyage. Cela permet de conserver les logiques d’abonnement et de désabonnement proches l’une de l’autre. Elles font partie du même effet !</p>
          <p><strong>À quel moment précis React nettoie-t-il un effet ?</strong> React effectue le nettoyage lorsqu’il démonte le composant. Cependant, comme nous l’avons appris précédemment, les effets sont exécutés à chaque affichage, donc potentiellement plus d’une fois. C’est la raison pour laquelle React nettoie <em>aussi</em> les effets du rendu précédent avant de les exécuter une nouvelle fois. Nous verrons <a href="#explanation-why-effects-run-on-each-update">pourquoi ça permet d’éviter des bugs</a> et <a href="#tip-optimizing-performance-by-skipping-effects">comment éviter ce comportement s’il nuit aux performances</a> dans un instant.</p>
          <blockquote>
            <p>Remarque</p>
            <p>La fonction renvoyée par l’effet peut parfaitement être anonyme. Dans notre exemple, nous l’avons nommée <code>cleanup</code> par souci de clarté, mais vous pouvez renvoyer une fonction fléchée ou lui donner n’importe quel nom.</p>
          </blockquote>
        </section>
      </section>
      <section id="recap" class="level2">
        <h2>En résumé</h2>
        <p>Nous avons appris que <code>useEffect</code> nous permet d’exprimer différentes sortes d’effets de bord après l’affichage d’un composant. Certains effets ont besoin de nettoyer derrière eux, et peuvent renvoyer une fonction pour ça :</p>
        <pre class="language-js"><code class="language-js">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">handleStatusChange</span><span class="token punctuation">(</span><span class="token parameter">status</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setIsOnline</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token property-access">isOnline</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">friend</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">friend</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>D’autres effets n’ont pas besoin de nettoyage, et ne renvoient rien.</p>
        <pre class="language-js"><code class="language-js">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Vous avez cliqué </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> fois</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>Le Hook d’effet traite ces deux cas en une seule API.</p>
        <hr>
        <p><strong>Si vous pensez avoir déjà bien saisi le fonctionnement du Hook d’effet, ou si c’en est déjà trop pour vous, n’hésitez pas à passer dès maintenant à la <a href="./hooks-rules.html">prochaine page sur les règles des Hooks</a>.</strong></p>
        <hr>
      </section>
      <section id="tips-for-using-effects" class="level2">
        <h2>Astuces pour l’utilisation des effets</h2>
        <p>Nous allons maintenant nous pencher sur certaines caractéristiques de <code>useEffect</code> qui ne manqueront pas de susciter la curiosité des utilisateurs les plus expérimentés de React. Ne vous sentez pas tenu·e d’y plonger dès à présent. Vous pourrez toujours revenir plus tard sur cette page afin d’y parfaire votre connaissance du Hook d’effet.</p>
        <section id="tip-use-multiple-effects-to-separate-concerns" class="level3">
          <h3>Astuce : Utiliser plusieurs effets pour séparer les sujets</h3>
          <p>Un des problèmes soulignés dans les <a href="./hooks-intro.html#complex-components-become-hard-to-understand">raisons</a> pour les Hooks, c’est que les méthodes de cycle de vie d’une classe de composant deviennent souvent des ramassis de logiques différentes, alors que celles qui sont liées entre elles sont éparpillées dans plusieurs méthodes. Voici un composant qui implémente à la fois notre exemple de compteur et celui du statut de connexion d’un ami :</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">FriendStatusWithCounter</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">isOnline</span><span class="token operator">:</span> <span class="token keyword null nil">null</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleStatusChange</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">handleStatusChange</span><span class="token punctuation">.</span><span class="token method function property-access">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Vous avez cliqué </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> fois</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToFriendStatus</span><span class="token punctuation">(</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">friend</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleStatusChange</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Vous avez cliqué </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> fois</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">friend</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleStatusChange</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">handleStatusChange</span><span class="token punctuation">(</span><span class="token parameter">status</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">isOnline</span><span class="token operator">:</span> status<span class="token punctuation">.</span><span class="token property-access">isOnline</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span></code></pre>
          <p>Remarquez comme le code qui modifie <code>document.title</code> est découpé entre <code>componentDidMount</code> et <code>componentDidUpdate</code>. Quant à la gestion de l'abonnement, elle est éparpillée entre <code>componentDidMount</code> et <code>componentWillUnmount</code>. De plus, <code>componentDidMount</code> contient du code relatif aux deux tâches.</p>
          <p>Comment les Hooks résolvent-ils ce problème ? À l’instar du <a href="./hooks-state.html#tip-using-multiple-state-variables">Hook <code>useState</code> qui peut être utilisé plusieurs fois</a>, il est possible d’utiliser plusieurs effets. Cela nous permet de séparer correctement les sujets sans rapport au sein d’effets distincts :</p>
          <pre class="language-js{3,8}"><code class="language-js{3,8}">function FriendStatusWithCounter(props) {
  const [count, setCount] = useState(0);
  useEffect(() => {
    document.title = `Vous avez cliqué ${count} fois`;
  });

  const [isOnline, setIsOnline] = useState(null);
  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });
  // ...
}</code></pre>
          <p><strong>Les Hooks permettent de découper le code selon ce qu’il fait</strong> plutôt qu’en fonction des noms de méthodes de cycle de vie. React appliquera <em>tous</em> les effets utilisés par le composant, dans l’ordre de leur déclaration.</p>
        </section>
        <section id="explanation-why-effects-run-on-each-update" class="level3">
          <h3>Explication : raisons pour lesquelles les effets sont exécutés à chaque mise à jour</h3>
          <p>Si vous avez l'habitude des classes, vous pourriez vous demander pourquoi le nettoyage des effets s’effectue après chaque rendu, au lieu d’une seule fois au démontage. Voyons un exemple pratique pour comprendre en quoi ce choix de conception nous aide à réduire les bugs dans nos composants.</p>
          <p><a href="#example-using-classes-1">Plus haut dans cette page</a>, nous avons présenté le composant d’exemple <code>FriendStatus</code> qui affiche le statut de connexion d’un ami. Notre classe récupère <code>friend.id</code> depuis <code>this.props</code>, s’abonne au statut de connexion une fois le composant monté, et se désabonne au démontage :</p>
          <pre class="language-js"><code class="language-js">  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToFriendStatus</span><span class="token punctuation">(</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">friend</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleStatusChange</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">friend</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleStatusChange</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre>
          <p><strong>Mais que se passe-t-il si la propriété <code>friend</code> change</strong> alors que le composant est affiché ? Notre composant continuerait d’afficher le statut de connexion de notre ami initial. C’est un bug. Nous causerions également une fuite de mémoire ou un plantage au démontage, la fonction de désabonnement utilisant l’ID du nouvel ami.</p>
          <p>Dans un composant à base de classe, il faudrait ajouter <code>componentDidUpdate</code> pour gérer ce cas :</p>
          <pre class="language-js{8-19}"><code class="language-js{8-19}">  componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentDidUpdate(prevProps) {
    // Se désabonne du statut de l’ami précédent
    ChatAPI.unsubscribeFromFriendStatus(
      prevProps.friend.id,
      this.handleStatusChange
    );
    // S’abonne au statut du prochain ami
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }</code></pre>
          <p>Les applications React souffrent fréquemment de bugs dus à l’oubli d’une gestion correcte de <code>componentDidUpdate</code>.</p>
          <p>Maintenant, examinez ce même composant qui utiliserait des Hooks :</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">FriendStatus</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">friend</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">friend</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
          <p>Il ne rencontre pas ce bug. (Mais nous n’y avons apporté aucun changement.)</p>
          <p>Pas besoin de code spécifique pour gérer les mises à jour puisque <code>useEffect</code> les traite <em>par défaut</em>. Le hook nettoie les effets précédents avant d’appliquer les suivants. Pour illustrer ça, voici la séquence des abonnements et des désabonnements que ce composant pourrait produire au fil du temps :</p>
          <pre class="language-js"><code class="language-js"><span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToFriendStatus</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Exécute l’effet 1</span>

<span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Nettoie l’effet 1</span>
<span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToFriendStatus</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Exécute l’effet 2</span>

<span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Nettoie l’effet 2</span>
<span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToFriendStatus</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Exécute l’effet 3</span>

<span class="token comment">// Démontage</span>
<span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Nettoie l’effet 3</span></code></pre>
          <p>Ce comportement par défaut garantit la cohérence et résout les bugs les plus courants des composants à base de classe qui oublient de gérer les mises à jour.</p>
        </section>
        <section id="tip-optimizing-performance-by-skipping-effects" class="level3">
          <h3>Astuce : optimiser les performances en sautant des effets</h3>
          <p>Dans certains cas, nettoyer ou exécuter l’effet après chaque affichage risque de nuire aux performances. Dans les composants à base de classe, une solution consiste à comparer <code>prevProps</code> ou <code>prevState</code> dans <code>componentDidUpdate</code> :</p>
          <pre class="language-js"><code class="language-js"><span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>prevState<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Vous avez cliqué </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> fois</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
          <p>Ce genre de comportement est tellement courant qu’il est intégré dans l’API du Hook <code>useEffect</code>. Il est possible d’indiquer à React de <em>sauter</em> l’exécution d’un effet si certaines valeurs n’ont pas été modifiées entre deux affichages. Pour cela, il suffit de passer une liste comme second argument optionnel à <code>useEffect</code> :</p>
          <pre class="language-js{3}"><code class="language-js{3}">useEffect(() => {
  document.title = `Vous avez cliqué ${count} fois`;
}, [count]); // N’exécute l’effet que si count a changé</code></pre>
          <p>Dans l’exemple ci-dessus, nous passons <code>[count]</code> comme second argument. Qu’est-ce que ça signifie ? Si <code>count</code> vaut <code>5</code>, et que notre composant est ré-affiché avec <code>count</code> toujours égal à <code>5</code>, React comparera le <code>[5]</code> de l’affichage précédent au <code>[5]</code> du suivant. Comme tous les éléments de la liste sont identiques (<code>5 === 5</code>), React n’exécutera pas l’effet. Et voilà notre optimisation.</p>
          <p>Quand le composant est ré-affiché avec <code>count</code> égal à <code>6</code>, React comparera la liste d’éléments <code>[5]</code> de l'affichage précédent avec la liste <code>[6]</code> du suivant. Cette fois, React ré-exécutera l’effet car <code>5 !== 6</code>. Dans le cas où la liste contiendrait plusieurs éléments, React ré-appliquera l’effet si au moins l’un d’entre eux est différent de sa version précédente.</p>
          <p>Le fonctionnement est le même pour la phase de nettoyage :</p>
          <pre class="language-js{10}"><code class="language-js{10}">useEffect(() => {
  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
  return () => {
    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
  };
}, [props.friend.id]); // Ne se ré-abonne que si props.friend.id change</code></pre>
          <p>À l’avenir, ce second argument pourrait être injecté automatiquement au moment de la compilation.</p>
          <blockquote>
            <p>Remarque</p>
            <p>Si vous utilisez cette optimisation, assurez-vous que votre tableau inclut bien <strong>toutes les valeurs dans la portée du composant (telles que les props et l'état local) qui peuvent changer avec le temps et sont utilisées par l'effet</strong>. Sinon, votre code va référencer des valeurs obsolètes issues des rendus précédents. Vous pouvez en apprendre davantage sur <a href="./hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">la façon de gérer les dépendances à des fonctions</a> et comment faire quand <a href="./hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often">les dépendances listées changent trop souvent</a>.</p>
            <p>Si vous voulez exécuter un effet et le nettoyer une seule fois (au montage puis au démontage), vous pouvez passer un tableau vide (<code>[]</code>) comme second argument. Ça indique à React que votre effet ne dépend <em>d’aucune</em> valeur issue des props ou de l'état local, donc il n’a jamais besoin d’être ré-exécuté. Il ne s'agit pas d'un cas particulier : ça découle directement de la façon dont le tableau des dépendances fonctionne à la base.</p>
            <p>Si vous passez un tableau vide (<code>[]</code>), les props et l'état local vus depuis l'intérieur de l'effet feront toujours référence à leurs valeurs initiales. Même si passer <code>[]</code> comme second argument vous rapproche du modèle mental habituel de <code>componentDidMount</code> et <code>componentWillUnmount</code>, il y a en général de <a href="./hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">meilleures</a> <a href="./hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often">solutions</a> pour éviter de ré-exécuter les effets trop souvent. Par ailleurs, ne perdez pas de vue que React défère l’exécution de <code>useEffect</code> jusqu’à ce que le navigateur ait fini de rafraîchir l’affichage, du coup y faire plus de travail est moins un problème.</p>
            <p>Nous vous conseillons d’utiliser la règle <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> fournie par le module <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a>. Elle vous avertira si des dépendances sont mal spécifiées et vous suggèrera un correctif.</p>
          </blockquote>
        </section>
      </section>
      <section id="next-steps" class="level2">
        <h2>Prochaines étapes</h2>
        <p>Félicitations ! C‘était une bien longue page, mais avec un peu de chance la plupart de vos questions à propos des effets ont pu y trouver une réponse. Vous avez appris à utiliser le Hook d’état et le Hook d’effet, qui vous ouvrent <em>beaucoup</em> de possibilités à eux deux. Ils couvrent la majorité des cas d’usage pour les classes—et sinon, peut-être trouverez-vous les <a href="./hooks-reference.html">Hooks supplémentaires</a> bien utiles.</p>
        <p>Nous commençons également à deviner comment les Hooks peuvent résoudre les problématiques listées dans les <a href="./hooks-intro.html#motivation">raisons</a>. Nous avons vu comment le nettoyage des effets évite la duplication de code dans <code>componentDidUpdate</code> et <code>componentWillUnmount</code>, regroupe le code par sujet, et aide à éviter les bugs. Enfin, nous avons appris comment séparer les effets selon leur finalité, ce qui était totalement impossible avec les classes.</p>
        <p>
          A ce stade vous vous demandez peut-être comment les Hooks fonctionnent. Comment React sait-il quel appel de <code>useState</code> correspond à quelle variable d’état local d’un affichage à l’autre ? Comment React « associe-t-il » l’effet précédent au suivant à chaque mise à jour ? <strong>Rendez-vous dans la prochaine page pour apprendre les <a href="./hooks-rules.html">règles des Hooks</a>, qui sont indispensables à leur bon fonctionnement.</strong>
          <span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span>
        </p>
      </section>
    </section>
  </body>
</html>
