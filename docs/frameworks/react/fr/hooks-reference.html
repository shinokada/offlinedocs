<!doctypehtml><html lang="fr"><meta charset="utf-8"><title>Référence de l'API des Hooks</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="référence-de-lapi-des-hooks"class="level1"><h1>Référence de l'API des Hooks</h1><p>Les <em>Hooks</em> sont une nouveauté de React 16.8. Ils permettent de bénéficier d’un état local et d'autres fonctionnalités de React sans avoir à écrire de classes.<p>Cette page décrit l’API des Hooks prédéfinis de React.<p>Si les Hooks sont nouveaux pour vous, vous voudrez peut-être consulter <a href="./hooks-overview.html">l’aperçu</a> en premier. Vous trouverez peut-être aussi des informations utiles dans <a href="./hooks-faq.html">la foire aux questions</a>.<ul><li><a href="#basic-hooks">Les Hooks de base</a><ul><li><a href="#usestate"><code>useState</code></a><li><a href="#useeffect"><code>useEffect</code></a><li><a href="#usecontext"><code>useContext</code></a></ul><li><a href="#additional-hooks">Hooks supplémentaires</a><ul><li><a href="#usereducer"><code>useReducer</code></a><li><a href="#usecallback"><code>useCallback</code></a><li><a href="#usememo"><code>useMemo</code></a><li><a href="#useref"><code>useRef</code></a><li><a href="#useimperativehandle"><code>useImperativeHandle</code></a><li><a href="#uselayouteffect"><code>useLayoutEffect</code></a><li><a href="#usedebugvalue"><code>useDebugValue</code></a></ul></ul><section id="basic-hooks"class="level2"><h2>Les Hooks de base</h2><section id="usestate-usestate"class="level3"><h3><code>useState</code> {#usestate}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>initialState<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Renvoie une valeur d'état local et une fonction pour la mettre à jour.<p>Pendant le rendu initial, l'état local (<code>state</code>) a la même valeur que celle passée en premier argument (<code>initialState</code>).<p>La fonction <code>setState</code> permet de mettre à jour l'état local. Elle accepte une nouvelle valeur d'état local et planifie un nouveau rendu du composant.<pre class="language-js"><code class="language-js"><span class="token function">setState</span><span class="token punctuation">(</span>newState<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Au cours des rendus suivants, la première valeur renvoyée par <code>useState</code> sera toujours celle de l'état local le plus récent, une fois les mises à jour effectuées.<blockquote><p>Remarque<p>React garantit que l’identité de la fonction <code>setState</code> est stable et ne changera pas d’un rendu à l’autre. C’est pourquoi on peut l'omettre de la liste des dépendances de <code>useEffect</code> et <code>useCallback</code> en toute sécurité.</blockquote><section id="functional-updates"class="level4"><h4>Mises à jour fonctionnelles</h4><p>Si le nouvel état local est déduit de l'état local précédent, vous pouvez passer une fonction à <code>setState</code>. Cette fonction recevra la valeur précédente de l'état local et renverra une nouvelle valeur de l'état local. Voici un exemple d'un composant compteur qui utilise les deux formes de <code>setState</code> :<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Counter</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>initialCount<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>initialCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token literal-property property">Total</span> <span class="token operator">:</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>initialCount<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token constant">R</span>éinitialiser<span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token parameter">prevCount</span> <span class="token arrow operator">=></span> prevCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">-</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token parameter">prevCount</span> <span class="token arrow operator">=></span> prevCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">+</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Les boutons « + » et « - » utilisent la forme fonctionnelle, puisque la nouvelle valeur est calculée à partir de la valeur précédente. Le bouton « Réinitialiser » utilise quant à lui la forme normale puisqu'il remet toujours le total à sa valeur initiale.<p>Si votre fonction de mise à jour renvoie exactement la même valeur que l’état courant, le rendu ultérieur sera carrément sauté.<blockquote><p>Remarque<p>À l'inverse de la méthode <code>setState</code> que l'on trouve dans les composants définis à l'aide d'une classe, <code>useState</code> ne fusionne pas automatiquement les objets de mise à jour. Vous pouvez imiter ce comportement en combinant la forme fonctionnelle de mise à jour avec la syntaxe de <em>spread</em> des objets :<pre class="language-js"><code class="language-js"><span class="token function">setState</span><span class="token punctuation">(</span><span class="token parameter">prevState</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// Object.assign marcherait aussi</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>prevState<span class="token punctuation">,</span> <span class="token spread operator">...</span>updatedValues<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Il est aussi possible d'utiliser <code>useReducer</code>, qui est plus adapté pour gérer les objets d'état local qui contiennent plusieurs sous-valeurs.</blockquote></section><section id="lazy-initial-state"class="level4"><h4>État local initial paresseux</h4><p>Le rendu initial utilise l'argument <code>initialState</code> comme état local. Au cours des rendus suivants, il est ignoré. Si l'état local initial est le résultat d'un calcul coûteux, vous pouvez plutôt fournir une fonction qui sera executée seulement au cours du rendu initial :<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> initialState <span class="token operator">=</span> <span class="token function">someExpensiveComputation</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> initialState<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section><section id="bailing-out-of-a-state-update"class="level4"><h4>Abandon de la mise à jour de l'état local</h4><p>Si vous mettez à jour un Hook d'état avec la même valeur que son état actuel, React abandonnera cette mise à jour, ce qui signifie qu'aucun nouveau rendu des enfants ne sera effectué et qu'aucun effet ne sera déclenché. (React utilise <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/is">l'algorithme de comparaison <code>Object.is</code></a>.)<p>Remarquez que React peut quand même avoir besoin d’afficher ce composant à nouveau avant d'abandonner. Ça ne devrait pas pose problème car React n'ira pas « plus profondément » dans l'arbre. Si vous effectuez des calculs coûteux lors du rendu, vous pouvez les optimiser avec <code>useMemo</code>.</section></section><section id="useeffect-useeffect"class="level3"><h3><code>useEffect</code> {#useeffect}</h3><pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span>didUpdate<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Accepte une fonction qui contient du code impératif, pouvant éventuellement produire des effets.<p>L'utilisation de mutations, abonnements, horloges, messages de journalisation, et autres effets de bord n'est pas autorisée au sein du corps principal d'une fonction composant (qu'on appelle la <em>phase de rendu</em> de React). Autrement ça pourrait entraîner des bugs déconcertants et des incohérences dans l'interface utilisateur (UI).<p>Pour ce faire, utilisez plutôt <code>useEffect</code>. La fonction fournie à <code>useEffect</code> sera exécutée après que le rendu est apparu sur l'écran. Vous pouvez considérer les effets comme des échappatoires pour passer du monde purement fonctionnel de React au monde impératif.<p>Par défaut, les effets de bord s'exécutent après chaque rendu, mais vous pouvez choisir d’en exécuter certains <a href="#conditionally-firing-an-effect">uniquement quand certaines valeurs ont changé</a>.<section id="cleaning-up-an-effect"class="level4"><h4>Nettoyage d'un effet de bord</h4><p>Souvent, les effets de bord créent des ressources qui nécessitent d'être nettoyées avant que le composant ne quitte l'écran, telles qu'un abonnement ou l'ID d'une horloge. Pour ce faire, la fonction fournie à <code>useEffect</code> peut renvoyer une fonction de nettoyage. Par exemple, pour créer un abonnement :<pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> subscription <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">source</span><span class="token punctuation">.</span><span class="token method function property-access">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// Nettoyage de l'abonnement</span>
    subscription<span class="token punctuation">.</span><span class="token method function property-access">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>La fonction de nettoyage est exécutée avant que le composant ne soit retiré de l'UI pour éviter les fuites de mémoire. Par ailleurs, si un composant s’affiche plusieurs fois (comme c'est typiquement le cas), <strong>l'effet de bord précédent est nettoyé avant l'exécution du prochain effet de bord</strong>. Dans notre exemple, ça veut dire qu'un nouvel abonnement est créé à chaque mise à jour. Pour éviter d'exécuter un effet de bord à chaque mise à jour, voyez la section sur l’exécution conditionnelle un peu plus loin.</section><section id="timing-of-effects"class="level4"><h4>Moment d'exécution des effets de bord</h4><p>Contrairement à <code>componentDidMount</code> et <code>componentDidUpdate</code>, la fonction fournie à <code>useEffect</code> est exécutée de façon différée, <strong>après</strong> la mise en page et l’affichage. <code>useEffect</code> est donc bien adapté pour une grande partie des effets de bord, comme la mise en place d'abonnements et de gestionnaires d'événements, puisque la plupart des types de tâche ne devraient pas gêner la mise à jour de l'affichage par le navigateur.<p>Cependant, tous les effets de bord ne peuvent pas être différés. Par exemple, une mutation du DOM qui est visible pour l'utilisateur doit s'exécuter de manière synchrone avant l’affichage suivant, afin que l'utilisateur ne puisse pas percevoir une incohérence visuelle. (La distinction est conceptuellement similaire à celle entre écouteur d'événement passif et actif.) Pour ces types d'effets de bord, React fournit un Hook supplémentaire appelé <a href="#uselayouteffect"><code>useLayoutEffect</code></a>. Il a la même signature que <code>useEffect</code>, et s'en distingue seulement par le moment où il s'exécute.<p>Bien que <code>useEffect</code> soit différé jusqu'à ce que le navigateur ait terminé l’affichage, son exécution est garantie avant les rendus ultérieurs. React traitera toujours les effets de bord des rendus précédents avant de commencer une nouvelle mise à jour.</section><section id="conditionally-firing-an-effect"class="level4"><h4>Exécution conditionnelle d'un effet de bord</h4><p>Le comportement par défaut des effets de bord consiste à exécuter l'effet après chaque affichage. Ainsi, un effet est toujours recréé si une de ses entrées (les données dont il dépend) change.<p>Cependant, ça pourrait être exagéré dans certains cas, comme dans l'exemple avec l'abonnement dans la section précédente. On n’a pas besoin d’un nouvel abonnement à chaque mise à jour, mais seulement si la prop <code>source</code> a changé.<p>Pour mettre ça en œuvre, fournissez un deuxième argument à <code>useEffect</code> qui consiste en un tableau de valeurs dont l'effet dépend. Notre exemple mis à jour ressemble maintenant à ça :<pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> subscription <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">source</span><span class="token punctuation">.</span><span class="token method function property-access">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      subscription<span class="token punctuation">.</span><span class="token method function property-access">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>props<span class="token punctuation">.</span><span class="token property-access">source</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>L'abonnement sera maintenant recréé uniquement quand <code>props.source</code> change.<blockquote><p>Remarque<p>Si vous utilisez cette optimisation, assurez-vous que votre tableau inclut bien <strong>toutes les valeurs dans la portée du composant (telles que les props et l'état local) qui peuvent changer avec le temps et sont utilisées par l'effet</strong>. Sinon, votre code va référencer des valeurs obsolètes issues des rendus précédents. Vous pouvez en apprendre davantage sur <a href="./hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">la façon de gérer les dépendances à des fonctions</a> et comment faire quand <a href="./hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often">les dépendances listées changent trop souvent</a>.<p>Si vous voulez exécuter un effet et le nettoyer une seule fois (au montage puis au démontage), vous pouvez passer un tableau vide (<code>[]</code>) comme deuxième argument. Ça indique à React que votre effet ne dépend <em>d’aucune</em> valeur issue des props ou de l'état local, donc il n’a jamais besoin d’être ré-exécuté. Il ne s'agit pas d'un cas particulier : ça découle directement de la façon dont le tableau des dépendances fonctionne.<p>Si vous passez un tableau vide (<code>[]</code>), les props et l'état local vus depuis l'intérieur de l'effet feront toujours référence à leurs valeurs initiales. Même si passer <code>[]</code> comme deuxième argument vous rapproche du modèle mental habituel de <code>componentDidMount</code> et <code>componentWillUnmount</code>, il y a en général de <a href="./hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">meilleures</a> <a href="./hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often">solutions</a> pour éviter de ré-exécuter les effets trop souvent. Par ailleurs, ne perdez pas de vue que React défère l’exécution de <code>useEffect</code> jusqu’à ce que la navigateur ait fini de rafraîchir l’affichage, du coup y faire plus de travail est moins un problème.<p>Nous vous conseillons d’utiliser la règle <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> fournie par le module <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a>. Elle vous avertira si des dépendances sont mal spécifiées et vous suggèrera un correctif.</blockquote><p>Le tableau d'entrées n'est pas fourni comme argument à la fonction d'effet. Conceptuellement cependant, c'est en quelque sorte ce qui se passe : chaque valeur référencée dans la fonction d'effet devrait aussi apparaître dans le tableau d'entrées. À l'avenir, un compilateur suffisamment avancé pourrait créer ce tableau automatiquement.</section></section><section id="usecontext-usecontext"class="level3"><h3><code>useContext</code> {#usecontext}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span><span class="token maybe-class-name">MyContext</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Accepte un objet contexte (la valeur renvoyée par <code>React.createContext</code>), et renvoie la valeur actuelle du contexte. Celle-ci est déterminée par la prop <code>value</code> du plus proche <code>&#x3C;MyContext.Provider></code> au-dessus du composant dans l'arbre.<p>Quand le plus proche <code>&#x3C;MyContext.Provider></code> au-dessus du composant est mis à jour, ce Hook va déclencher un rafraîchissement avec la <code>value</code> la plus récente passée au fournisseur <code>MyContext</code>. Même si un ancêtre utilise <a href="./react-api.html#reactmemo"><code>React.memo</code></a> ou <a href="./react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate</code></a>, le rendu aura quand même à nouveau lieu à partir du composant qui recourt à <code>useContext</code>.<p>N’oubliez pas que l’argument de <code>useContext</code> doit être <em>l’objet contexte lui-même</em> :<ul><li><strong>Correct :</strong> <code>useContext(MyContext)</code><li><strong>Erroné :</strong> <code>useContext(MyContext.Consumer)</code><li><strong>Erroné :</strong> <code>useContext(MyContext.Provider)</code></ul><p>Un composant qui appelle <code>useContext</code> se rafraîchira toujours quand la valeur du contexte change. Si ce rafraîchissement est coûteux, vous pouvez <a href="https://github.com/facebook/react/issues/15156#issuecomment-474590693">l’optimiser grâce à la mémoïsation</a>.<blockquote><p>Astuce<p>Si vous aviez l’habitude de l’API de Contexte avant les Hooks, <code>useContext(MyContext)</code> est équivalent à <code>static contextType = MyContext</code> dans une classe, ou à <code>&#x3C;MyContext.Consumer></code>.<p><code>useContext(MyContext)</code> vous permet seulement de <em>lire</em> le contexte et de vous abonner à ses modifications. Vous aurez toujours besoin d’un <code>&#x3C;MyContext.Provider></code> plus haut dans l’arbre pour <em>fournir</em> une valeur de contexte.</blockquote><p><strong>Un exemple consolidé avec Context.Provider</strong><pre class="language-js{31-36}"><code class="language-js{31-36}">const themes = {
  light: {
    foreground: "#000000",
    background: "#eeeeee"
  },
  dark: {
    foreground: "#ffffff",
    background: "#222222"
  }
};

const ThemeContext = React.createContext(themes.light);

function App() {
  return (
    &#x3C;ThemeContext.Provider value={themes.dark}>
      &#x3C;Toolbar />
    &#x3C;/ThemeContext.Provider>
  );
}

function Toolbar(props) {
  return (
    &#x3C;div>
      &#x3C;ThemedButton />
    &#x3C;/div>
  );
}

function ThemedButton() {
  const theme = useContext(ThemeContext);

  return (
    &#x3C;button style={{ background: theme.background, color: theme.foreground }}>
      Je suis stylé par le contexte de thème !
    &#x3C;/button>
  );
}</code></pre><p>Cet exemple est une version modifiée pour utiliser les Hooks de l’exemple dans le <a href="./context.html">guide avancé des Contextes</a>, au sein duquel vous pourrez trouver davantage d’informations sur l’utilisation appropriée de Context.</section></section><section id="additional-hooks"class="level2"><h2>Hooks supplémentaires</h2><p>Les Hooks qui suivent sont soit des variantes des Hooks basiques des sections précédentes, soit seulement nécessaires pour des cas à la marge spécifiques. Ne vous sentez pas obligé·e de les apprendre dès le départ.<section id="usereducer-usereducer"class="level3"><h3><code>useReducer</code> {#usereducer}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> initialArg<span class="token punctuation">,</span> init<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Alternative à <a href="#usestate"><code>useState</code></a>. Accepte un réducteur de type <code>(state, action) => newState</code>, et renvoie l'état local actuel accompagné d'une méthode <code>dispatch</code>. (Si vous avez l’habitude de Redux, vous savez déjà comment ça fonctionne.)<p><code>useReducer</code> est souvent préférable à <code>useState</code> quand vous avez une logique d'état local complexe qui comprend plusieurs sous-valeurs, ou quand l'état suivant dépend de l'état précédent. <code>useReducer</code> vous permet aussi d'optimiser les performances pour des composants qui déclenchent des mises à jours profondes puisque <a href="./hooks-faq.html#how-to-avoid-passing-callbacks-down">vous pouvez fournir <code>dispatch</code> à la place de fonctions de rappel</a>.<p>Voici l'exemple du composant compteur du paragraphe <a href="#usestate"><code>useState</code></a> ré-écrit avec un réducteur :<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> initialState <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">reducer</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'increment'</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">'decrement'</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword module">default</span><span class="token operator">:</span>
      <span class="token keyword control-flow">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Counter</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> initialState<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token literal-property property">Total</span> <span class="token operator">:</span> <span class="token punctuation">{</span>state<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'decrement'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">-</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'increment'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">+</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><blockquote><p>Remarque<p>React garantit que l’identité de la fonction <code>dispatch</code> est stable et ne changera pas d’un rendu à l’autre. C’est pourquoi on peut l'omettre de la liste des dépendances de <code>useEffect</code> et <code>useCallback</code> en toute sécurité.</blockquote><section id="specifying-the-initial-state"class="level4"><h4>Préciser l'état local initial</h4><p>Il existe deux manières différentes d'initialiser l'état de <code>useReducer</code>. Vous pouvez choisir l'une ou l'autre suivant le cas. La manière la plus simple consiste à fournir l'état initial comme deuxième argument :<pre class="language-js{3}"><code class="language-js{3}">  const [state, dispatch] = useReducer(
    reducer,
    {count: initialCount}
  );</code></pre><blockquote><p>Remarque<p>React n'utilise pas la convention d'argument <code>state = initialState</code> popularisée par Redux. La valeur initiale doit parfois dépendre de props et c’est donc plutôt l'appel du Hook qui la précise. Si vous avez déjà une préférence bien arrêtée là-dessus, vous pouvez utiliser <code>useReducer(reducer, undefined, reducer)</code> pour simuler le comportement de Redux, mais nous ne vous le conseillons pas.</blockquote></section><section id="lazy-initialization"class="level4"><h4>Initialisation paresseuse</h4><p>Vous pouvez aussi créer l'état local initial paresseusement. Pour ce faire, vous pouvez fournir une fonction <code>init</code> comme troisième argument. L'état initial sera alors égal à <code>init(initialArg)</code>.<p>Ça vous permet d'extraire la logique pour calculer l'état local initial hors du réducteur. C'est aussi pratique pour réinitialiser l'état local en réponse à une action ultérieure :<pre class="language-js{1-3,11-12,19,24}"><code class="language-js{1-3,11-12,19,24}">function init(initialCount) {
  return {count: initialCount};
}

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    case 'reset':
      return init(action.payload);
    default:
      throw new Error();
  }
}

function Counter({initialCount}) {
  const [state, dispatch] = useReducer(reducer, initialCount, init);
  return (
    &#x3C;>
      Total : {state.count}
      &#x3C;button
        onClick={() => dispatch({type: 'reset', payload: initialCount})}>
        Réinitialiser
      &#x3C;/button>
      &#x3C;button onClick={() => dispatch({type: 'decrement'})}>-&#x3C;/button>
      &#x3C;button onClick={() => dispatch({type: 'increment'})}>+&#x3C;/button>
    &#x3C;/>
  );
}</code></pre></section><section id="bailing-out-of-a-dispatch"class="level4"><h4>Abandon d'un dispatch</h4><p>Si vous renvoyez la même valeur que l'état actuel dans un Hook de réduction, React abandonnera la mise à jour, ce qui signifie qu'aucun nouveau rendu des enfants ne sera effectué et qu'aucun effet ne sera déclenché. (React utilise <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/is">l'algorithme de comparaison <code>Object.is</code></a>.)<p>Remarquez que React pourrait encore avoir besoin de mettre à jour ce composant spécifique avant de lâcher l’affaire. Ça ne devrait pas vous soucier car React n'ira pas inutilement « plus profond » dans l’arbre. Si vous effectuez des calculs coûteux lors du rendu, vous pouvez les optimiser avec <code>useMemo</code>.</section></section><section id="usecallback-usecallback"class="level3"><h3><code>useCallback</code> {#usecallback}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> memoizedCallback <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">doSomething</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Renvoie une fonction de rappel <a href="https://fr.wikipedia.org/wiki/M%C3%A9mo%C3%AFsation">mémoïsée</a><p>Fournissez une fonction de rappel et un tableau d'entrées. <code>useCallback</code> renverra une version mémoïsée de la fonction de rappel qui changera uniquement si une des entrées a changé. C’est utile pour passer des fonctions de rappel à des composants enfants optimisés qui se basent sur une égalité référentielle pour éviter des rendus superflus (par exemple avec <code>shouldComponentUpdate</code>).<p><code>useCallback(fn, inputs)</code> est équivalent à <code>useMemo(() => fn, inputs)</code>.<blockquote><p>Remarque<p>Le tableau d'entrées n'est pas fourni comme argument à la fonction de rappel. Conceptuellement cependant, c'est en quelque sorte ce qui se passe : chaque valeur référencée dans la fonction de rappel devrait aussi apparaître dans le tableau d'entrées. À l’avenir, un compilateur suffisamment avancé pourrait créer ce tableau automatiquement.<p>Nous vous conseillons d’utiliser la règle <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> fournie par le module <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a>. Elle vous avertira si des dépendances sont mal spécifiées et vous suggèrera un correctif.</blockquote></section><section id="usememo-usememo"class="level3"><h3><code>useMemo</code> {#usememo}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">computeExpensiveValue</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Renvoie une valeur <a href="https://fr.wikipedia.org/wiki/M%C3%A9mo%C3%AFsation">mémoïsée</a><p>Fournissez une fonction de « création » et un tableau d'entrées. <code>useMemo</code> recalculera la valeur mémoïsée seulement si une des entrées a changé. Cette optimisation permet d'éviter des calculs coûteux à chaque rendu.<p>Rappelez-vous que la fonction fournie à <code>useMemo</code> s'exécute pendant le rendu. N’y faites rien que vous ne feriez pas normalement pendant un rendu. Par exemple, les effets de bord doivent passer par <code>useEffect</code>, et non <code>useMemo</code>.<p>Si vous ne fournissez aucun tableau, une nouvelle valeur sera calculée à chaque appel.<p><strong>Vous pouvez vous appuyer sur <code>useMemo</code> comme un moyen d'optimiser les performances, mais pas comme une garantie sémantique.</strong> À l'avenir, React pourrait choisir « d'oublier » certaines valeurs précédemment mémoïsées et de les recalculer au rendu suivant, par exemple pour libérer la mémoire exploitée par des composants présents hors de l'écran. Écrivez votre code de façon à ce qu'il fonctionne sans <code>useMemo</code> et ajoutez-le ensuite pour optimiser les performances.<blockquote><p>Remarque<p>Le tableau d'entrées n'est pas fourni comme argument à la fonction. Conceptuellement cependant, c'est en quelque sorte ce qui se passe : chaque valeur référencée dans la fonction devrait aussi apparaître dans le tableau d'entrées. À l'avenir, un compilateur suffisamment avancé pourrait créer ce tableau automatiquement.<p>Nous vous conseillons d’utiliser la règle <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> fournie par le module <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a>. Elle vous avertira si des dépendances sont mal spécifiées et vous suggèrera un correctif.</blockquote></section><section id="useref-useref"class="level3"><h3><code>useRef</code> {#useref}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> refContainer <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>initialValue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>useRef</code> renvoie un objet ref modifiable dont la propriété <code>current</code> est initialisée avec l'argument fourni (<code>initialValue</code>). L'objet renvoyé persistera pendant toute la durée de vie du composant.<p>Un cas d’usage courant consiste à accéder à un enfant de manière impérative :<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">TextInputWithFocusButton</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> inputEl <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">onButtonClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// `current` fait référence au champ textuel monté dans le DOM</span>
    inputEl<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">.</span><span class="token method function property-access">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span>inputEl<span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">"text"</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onButtonClick<span class="token punctuation">}</span><span class="token operator">></span><span class="token maybe-class-name">Donner</span> le focus au champ<span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>En gros, <code>useRef</code> est comme une « boîte » qui pourrait contenir une valeur modifiable dans sa propriété <code>.current</code>.<p>Vous avez peut-être l'habitude d'utiliser des refs principalement pour <a href="./refs-and-the-dom.html">accéder au DOM</a>. Si vous passez un objet ref à React avec <code>&#x3C;div ref={myRef} /></code>, React calera sa propriété <code>.current</code> sur le nœud DOM correspondant chaque fois que ce dernier change.<p>Ceci dit, <code>useRef()</code> est utile au-delà du seul attribut <code>ref</code>. C'est <a href="./hooks-faq.html#is-there-something-like-instance-variables">pratique pour garder des valeurs modifiables sous la main</a>, comme lorsque vous utilisez des champs d’instance dans les classes.<p>Ça fonctionne parce que <code>useRef()</code> crée un objet JavaScript brut. La seule différence entre <code>useRef()</code> et la création manuelle d’un objet <code>{current: ... }</code>, c'est que <code>useRef</code> vous donnera le même objet à chaque rendu.<p>Gardez à l'esprit que <code>useRef</code> <em>ne vous notifie pas</em> quand le contenu change. Modifier la propriété <code>.current</code> n'entraîne pas un rafraîchissement. Si vous voulez exécuter du code quand React attache ou détache une ref sur un nœud DOM, vous voudrez sans doute utiliser plutôt une <a href="./hooks-faq.html#how-can-i-measure-a-dom-node">ref à base de fonction de rappel</a>.</section><section id="useimperativehandle-useimperativehandle"class="level3"><h3><code>useImperativeHandle</code> {#useimperativehandle}</h3><pre class="language-js"><code class="language-js"><span class="token function">useImperativeHandle</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> createHandle<span class="token punctuation">,</span> <span class="token punctuation">[</span>deps<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><code>useImperativeHandle</code> personnalise l'instance qui est exposée au composant parent lors de l'utilisation de <code>ref</code>. Comme toujours, il vaut mieux s'abstenir d'utiliser du code impératif manipulant des refs dans la plupart des cas. <code>useImperativeHandle</code> est conçu pour être utilisé en conjonction avec <a href="./react-api.html#reactforwardref"><code>forwardRef</code></a> :<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">FancyInput</span></span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> inputRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useImperativeHandle</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">focus</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      inputRef<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">.</span><span class="token method function property-access">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span>inputRef<span class="token punctuation">}</span> <span class="token spread operator">...</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token maybe-class-name">FancyInput</span> <span class="token operator">=</span> <span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token maybe-class-name">FancyInput</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Dans cet exemple, un composant parent qui utiliserait <code>&#x3C;FancyInput ref={inputRef} /></code> pourrait appeler <code>inputRef.current.focus()</code>.</section><section id="uselayouteffect-uselayouteffect"class="level3"><h3><code>useLayoutEffect</code> {#uselayouteffect}</h3><p>La signature est identique à celle de <code>useEffect</code>, mais <code>useLayoutEffect</code> s'exécute de manière synchrone après que toutes les mutations du DOM ont eu lieu. Utilisez-le pour inspecter la mise en page du DOM et effectuer un nouveau rendu de manière synchrone. Les mises à jour planifiées dans <code>useLayoutEffect</code> seront traitées de manière synchrone avant que le navigateur ait pu procéder à l’affichage.<p>Préférez l'utilisation du <code>useEffect</code> standard chaque fois que possible, pour éviter de bloquer les mises à jour visuelles.<blockquote><p>Astuce<p>Si vous migrez du code depuis un composant écrit à l'aide d'une classe, sachez que <code>useLayoutEffect</code> s'exécute dans la même phase que <code>componentDidMount</code> et <code>componentDidUpdate</code>. <strong>Nous vous conseillons de commencer avec <code>useEffect</code></strong>, et de ne tenter <code>useLayoutEffect</code> que si vous rencontrez des problèmes.<p>Si vous faites du rendu côté serveur , n'oubliez pas que <em>ni</em> <code>useLayoutEffect</code> ni <code>useEffect</code> ne seront exécutés jusqu'à ce que votre code JS soit téléchargé et exécuté côté client. C’est pourquoi React vous averti quand un composant utilise <code>useLayoutEffect</code> dans le cadre d’un rendu côté serveur. Pour corriger ça, vous pouvez soit déplacer la logique dans <code>useEffect</code> (si elle n'est pas nécessaire pour le premier affichage), soit reporter l'affichage du composant jusqu'à ce que l’affichage côté client soit effectué (si le HTML aurait eu l’air cassé avant exécution du <code>useLayoutEffect</code>).<p>Pour exclure un composant nécessitant des effets de mise en page <em>(layout effects, NdT)</em> du HTML généré côté serveur, vous pouvez l'afficher conditionnellement avec un <code>showChild &#x26;&#x26; &#x3C;Child /></code>, et différer son affichage grâce à un <code>useEffect(() => { setShowChild(true); }, [])</code>. Ainsi, l’UI ne semblera pas cassé avec son hydratation.</blockquote></section><section id="usedebugvalue-usedebugvalue"class="level3"><h3><code>useDebugValue</code> {#usedebugvalue}</h3><pre class="language-js"><code class="language-js"><span class="token function">useDebugValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span></code></pre><p>Vous pouvez utiliser <code>useDebugValue</code> pour afficher une étiquette pour les Hooks personnalisés dans les outils de développement React <em>(React DevTools, NdT)</em>.<p>Par exemple, prenez le hook personnalisé <code>useFriendStatus</code> décrit dans <a href="./hooks-custom.html">« Construire vos propres Hooks »</a> :<pre class="language-js{6-8}"><code class="language-js{6-8}">function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  // ...

  // Affiche une étiquette dans les DevTools à côté de ce Hook
  // par exemple, "FriendStatus: En ligne"
  useDebugValue(isOnline ? 'En ligne' : 'Hors-ligne');

  return isOnline;
}</code></pre><blockquote><p>Astuce<p>Nous déconseillons d'ajouter ces étiquettes à chaque Hook personnalisé. C'est surtout utile pour les Hooks personnalisés provenant de bibliothèques partagées.</blockquote><section id="defer-formatting-debug-values"class="level4"><h4>Différer le formatage des valeurs de débogage</h4><p>Formater une valeur à afficher peut parfois s’avérer coûteux. C'est par ailleurs inutile tant que le Hook n'est pas effectivement inspecté.<p>C’est pourquoi <code>useDebugValue</code> accepte une fonction de formatage comme deuxième argument optionnel. Cette fonction est appelée uniquement si les Hooks sont inspectés. Elle reçoit la valeur de débogage comme argument et devrait renvoyer la valeur formatée.<p>Par exemple, un Hook personnalisé qui renvoie une valeur <code>Date</code> pourrait éviter d'appeler inutilement la fonction <code>toDateString</code> en fournissant le formateur suivant :<pre class="language-js"><code class="language-js"><span class="token function">useDebugValue</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> <span class="token parameter">date</span> <span class="token arrow operator">=></span> date<span class="token punctuation">.</span><span class="token method function property-access">toDateString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section></section></section>