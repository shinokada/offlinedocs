<!doctypehtml><html lang="fr"><meta charset="utf-8"><title>Réconciliation</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="réconciliation"class="level1"><h1>Réconciliation</h1><p>React fournit une API déclarative afin que vous n'ayez pas à vous soucier de savoir ce qui change exactement lors de chaque mise à jour. Ça facilite grandement l'écriture d'applications, mais la manière dont React s’y prend n'est pas forcément évidente. Cet article explique les choix que nous avons faits dans l'algorithme de comparaison de façon à rendre prévisibles les mises à jour des composants tout en restant suffisamment rapide pour des applications à hautes performances.<section id="motivation"class="level2"><h2>Raisons</h2><p>Quand vous utilisez React, à chaque instant précis vous pouvez considérer que la fonction <code>render()</code> crée un arbre d'éléments React. Lors de la mise à jour suivante de l’état local ou des props, cette fonction <code>render()</code> renverra un arbre différent d'éléments React. React doit alors déterminer comment mettre efficacement à jour l'interface utilisateur (UI) pour qu'elle corresponde à l'arbre le plus récent.<p>Il existe des solutions génériques à ce problème algorithmique consistant à générer le nombre minimal d'opérations pour transformer un arbre en un autre. Néanmoins, <a href="http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf">les algorithmes à la pointe de l'état de l'art</a> (en anglais) ont une complexité de l'ordre de <em>O(n<sup>3</sup>)</em> où <em>n</em> est le nombre d'éléments dans l'arbre.<p>Si nous les utilisions dans React, l'affichage de 1 000 éléments nécessiterait environ un milliard d'opérations. C’est beaucoup trop coûteux. React implémente plutôt un algorithme heuristique en <em>O(n)</em> basé sur deux hypothèses :<ol><li>Deux éléments de types différents produiront des arbres différents.<li>Le développeur peut indiquer quels éléments peuvent être stables d’un rendu à l’autre grâce à la prop <code>key</code>.</ol><p>En pratique, ces hypothèses sont valables dans presque tous les cas.</section><section id="the-diffing-algorithm"class="level2"><h2>L'algorithme de comparaison</h2><p>En comparant deux arbres, React va commencer par comparer les éléments racines. Le comportement est différent selon le type des éléments racines.<section id="elements-of-different-types"class="level3"><h3>Éléments de types différents</h3><p>Chaque fois que les éléments racines ont des types différents, React va détruire l'ancien arbre et reconstruire le nouvel arbre à partir de zéro. Passer de <code>&#x3C;a></code> à <code>&#x3C;img></code>, ou de <code>&#x3C;Article></code> à <code>&#x3C;Comment></code>, ou de <code>&#x3C;Button></code> à <code>&#x3C;div></code> : tous aboutiront à une reconstruction complète.<p>Lors de la destruction d'un arbre, les anciens nœuds DOM sont détruits. Les instances des composants reçoivent <code>componentWillUnmount()</code>. Lors de la construction d'un nouvel arbre, les nouveaux nœuds sont insérés dans le DOM. Les instances de composants reçoivent <code>UNSAFE_componentWillMount()</code> puis <code>componentDidMount()</code>. Tous les états associés à l'ancien arbre sont perdus.<p>Tous les composants au-dessous de la racine seront également démontés et leur état détruit. Par exemple, en comparant :<pre class="language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>div</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>Counter</span> <span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>div</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>span</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>Counter</span> <span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>span</span><span class="token punctuation">></span></span></code></pre><p>Ça détruira l'ancien <code>Counter</code> puis en remontera un nouveau.<blockquote><p>Remarque<p>Les méthodes suivantes sont considérées dépréciées et vous devriez <a href="/blog/2018/03/27/update-on-async-rendering.html">les éviter</a> dans vos nouveaux codes :<ul><li><code>UNSAFE_componentWillMount()</code></ul></blockquote></section><section id="dom-elements-of-the-same-type"class="level3"><h3>Éléments DOM de même type</h3><p>Lors de la comparaison entre deux éléments DOM React de même type, React examine les attributs des deux, conserve le même nœud DOM sous-jacent, et ne met à jour que les attributs modifiés. Par exemple :<pre class="language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>before<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stuff<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>after<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stuff<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>En comparant ces deux éléments, React sait qu'il ne faut modifier que le <code>className</code> du nœud DOM sous-jacent.<p>Lors d'une mise à jour du <code>style</code>, React là aussi sait ne mettre à jour que les propriétés qui ont changé. Par exemple :<pre class="language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>div</span> <span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>{{color:</span> <span class="token attr-name">'red',</span> <span class="token attr-name"><span class="token namespace">fontWeight:</span></span> <span class="token attr-name">'bold'}}</span> <span class="token punctuation">/></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>div</span> <span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>{{color:</span> <span class="token attr-name">'green',</span> <span class="token attr-name"><span class="token namespace">fontWeight:</span></span> <span class="token attr-name">'bold'}}</span> <span class="token punctuation">/></span></span></code></pre><p>Lors de la conversion entre les deux éléments, React sait qu'il ne doit modifier que le style <code>color</code> et pas <code>fontWeight</code>.<p>Après avoir manipulé le nœud DOM, React applique le même traitement sur les enfants.</section><section id="component-elements-of-the-same-type"class="level3"><h3>Éléments composants de même type</h3><p>Lorsqu'un composant est mis à jour, l'instance reste la même, afin que l'état soit maintenu d’un rendu à l’autre. React met à jour les props de l’instance de composant sous-jacente pour correspondre au nouvel élément, et appelle <code>UNSAFE_componentWillReceiveProps()</code>, <code>UNSAFE_componentWillUpdate()</code> et <code>componentDidUpdate()</code> dessus.<p>Ensuite, la méthode <code>render()</code> est appelée et l'algorithme de comparaison reprend entre son résultat précédent et le nouveau.<blockquote><p>Remarque<p>Les méthodes suivantes sont considérées dépréciées et vous devriez <a href="/blog/2018/03/27/update-on-async-rendering.html">les éviter</a> dans vos nouveaux codes :<ul><li><code>UNSAFE_componentWillReceiveProps()</code><li><code>UNSAFE_componentWillUpdate()</code></ul></blockquote></section><section id="recursing-on-children"class="level3"><h3>Traitement récursif sur les enfants</h3><p>Par défaut, lorsqu'il traite les enfants d'un nœud DOM, React parcourt simultanément les deux listes d'enfants et génère une modification chaque fois qu'il y a une différence.<p>Par exemple, lors de l'ajout d'un élément à la fin des enfants, la conversion entre les deux arbres fonctionne bien :<pre class="language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>ul</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>li</span><span class="token punctuation">></span></span>first<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>li</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>li</span><span class="token punctuation">></span></span>second<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>li</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>ul</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>ul</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>li</span><span class="token punctuation">></span></span>first<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>li</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>li</span><span class="token punctuation">></span></span>second<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>li</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>li</span><span class="token punctuation">></span></span>third<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>li</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>ul</span><span class="token punctuation">></span></span></code></pre><p>React fera correspondre les deux arbres <code>&#x3C;li>first&#x3C;/li></code>, les deux arbres <code>&#x3C;li>second&#x3C;/li></code>, et insérera l'arbre <code>&#x3C;li>third&#x3C;/li></code>.<p>Si vous l'implémentez de façon naïve, l'insertion d'un élément au début aura de moins bonnes performances. Par exemple, la conversion entre ces deux arbres fonctionnera assez mal :<pre class="language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>ul</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>li</span><span class="token punctuation">></span></span>Duke<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>li</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>li</span><span class="token punctuation">></span></span>Villanova<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>li</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>ul</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>ul</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>li</span><span class="token punctuation">></span></span>Connecticut<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>li</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>li</span><span class="token punctuation">></span></span>Duke<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>li</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>li</span><span class="token punctuation">></span></span>Villanova<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>li</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>ul</span><span class="token punctuation">></span></span></code></pre><p>React va modifier chaque enfant plutôt que de réaliser qu'il pouvait garder les sous-arbres <code>&#x3C;li>Duke&#x3C;/li></code> et <code>&#x3C;li>Villanova&#x3C;/li></code> intacts. Cette inefficacité peut être un problème.</section><section id="keys"class="level3"><h3>Clés</h3><p>Afin de résoudre ce problème, React prend en charge l'attribut <code>key</code>. Quand des enfants ont cette clé, React l'utilise pour faire correspondre les enfants de l'arbre d'origine avec les enfants de l'arbre suivant. Par exemple, l'ajout d'une <code>key</code> dans notre exemple inefficace peut rendre la conversion de l'arbre plus efficace :<pre class="language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>ul</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2015<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Duke<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>li</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2016<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Villanova<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>li</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>ul</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>ul</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2014<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Connecticut<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>li</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2015<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Duke<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>li</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2016<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Villanova<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>li</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>ul</span><span class="token punctuation">></span></span></code></pre><p>À présent, React sait que l'élément avec la clé <code>'2014'</code> est nouveau, et que les éléments avec les clés <code>'2015'</code> et <code>'2016'</code> ont juste été déplacés.<p>En pratique, trouver une clé n'est généralement pas difficile. L'élément que vous allez afficher peut déjà disposer d'un identifiant unique, la clé provenant alors de vos données :<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>item<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>li<span class="token operator">></span></code></pre><p>Quand ce n'est pas le cas, vous pouvez ajouter une nouvelle propriété d'identification à votre modèle, ou hacher certaines parties de votre contenu pour générer une clé. La clé n’a besoin d’être unique que parmi ses éléments frères, et non au niveau global.<p>En dernier recours, vous pouvez utiliser l'index de l'élément dans un tableau comme clé. Cela fonctionne correctement si les éléments ne sont jamais réordonnés et s’il n’y a ni insertion ni suppression, dans le cas contraire ce serait assez lent.<p>Les tris peuvent également causer des problèmes avec les états des composants quand les index sont utilisés comme des clés. Les instances des composants sont mises à jour et réutilisées en fonction de leur clé. Si la clé est un index, déplacer un élément changera sa clé. En conséquence, l'état local des composants utilisés pour des saisies non-contrôlées peut s'emmêler et être mis à jour de manière inattendue.<p>Voici <a href="codepen://reconciliation/index-used-as-key">un exemple sur CodePen des problèmes qui peuvent être causés en utilisant des index comme clés</a>. Voilà <a href="codepen://reconciliation/no-index-used-as-key">une version mise à jour du même exemple montrant comment, en évitant d'utiliser les index comme clés, on résoudra ces problèmes de réordonnancement, de tri et d'insertion</a>.</section></section><section id="tradeoffs"class="level2"><h2>Compromis</h2><p>Rappelez-vous bien que l'algorithme de réconciliation est un détail d'implémentation. React pourrait rafraîchir l'ensemble de l'application à chaque action ; le résultat final serait le même. Pour être clair, rafraîchir dans ce contexte signifie appeler <code>render</code> sur tous les composants, ça ne signifie pas que React les démontera et remontera. Il n'appliquera que les différences obtenues en suivant les règles énoncées dans les sections précédentes.<p>Nous affinons régulièrement les heuristiques afin d'accélérer les cas d'usage courants. Dans l'implémentation actuelle, vous pouvez exprimer le fait qu'un sous-arbre a été déplacé parmi ses frères, mais vous ne pouvez pas dire qu'il a été déplacé ailleurs. L'algorithme va refaire le rendu de l'ensemble du sous-arbre.<p>Puisque React se repose sur des heuristiques, si les hypothèses derrière celles-ci s’avèrent erronées, ça réduira les performances.<ol><li>L'algorithme n'essaiera pas de faire correspondre des sous-arbres de types de composants différents. Si vous êtes amené·e à alterner entre deux types de composants au rendu très similaire, vous devriez peut-être en faire un type unique. En pratique, nous ne considérons pas ça comme un problème.<li>Les clés doivent être stables, prévisibles et uniques. Des clés instables (comme celles produites par <code>Math.random()</code>) entraîneront la re-création superflue de nombreuses instances de composants et de nœuds DOM, ce qui peut dégrader les performances et perdre l'état local des composants enfants. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></ol></section></section>