<!doctypehtml><html lang="fr"><meta charset="utf-8"><title>L'API haut-niveau de React</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="lapi-haut-niveau-de-react"class="level1"><h1>L'API haut-niveau de React</h1><p>L'objet <code>React</code> est le point d'entrée de la bibliothèque React. Si vous chargez React depuis une balise <code>&#x3C;script></code>, ces API de haut-niveau sont disponibles depuis l'objet global <code>React</code>. Si vous utilisez npm avec la syntaxe ES6, vous pouvez écrire : <code>import React from 'react'</code>. Si vous utilisez npm avec la syntaxe ES5, vous pouvez écrire : <code>var React = require('react')</code>.<section id="overview"class="level2"><h2>Aperçu</h2><section id="components"class="level3"><h3>Composants</h3><p>Les composants React vous permettent de découper une interface utilisateur <em>(UI, pour User Interface, NdT)</em> en blocs indépendants et réutilisables, ce qui vous permet de concevoir chaque partie en isolation. Un composant React peut être défini en étendant les classes <code>React.Component</code> ou <code>React.PureComponent</code>.<ul><li><a href="#reactcomponent"><code>React.Component</code></a><li><a href="#reactpurecomponent"><code>React.PureComponent</code></a></ul><p>Si vous n'utilisez pas les classes ES6, vous pouvez utiliser le module <code>create-react-class</code> à la place. Lisez <a href="./react-without-es6.html">React sans ES6</a> pour plus de détails.<p>Un composant React peut aussi être défini via une fonction que l'on pourra choisir d’enrober avec <code>React.memo</code> :<ul><li><a href="#reactmemo"><code>React.memo</code></a></ul></section><section id="creating-react-elements"class="level3"><h3>Créer des éléments React</h3><p>Nous vous recommandons d'<a href="./introducing-jsx.html">utiliser JSX</a> pour définir à quoi ressemblera votre UI. Tous les éléments JSX ne sont que du sucre syntaxique qui cache des appels à <a href="#createelement"><code>React.createElement()</code></a>. Si vous utilisez JSX, vous ne devriez pas avoir besoin d'appeler les méthodes suivantes :<ul><li><a href="#createelement"><code>createElement()</code></a><li><a href="#createfactory"><code>createFactory()</code></a></ul><p>Lisez <a href="./react-without-jsx.html">React sans JSX</a> pour plus de détails.</section><section id="transforming-elements"class="level3"><h3>Transformer des éléments</h3><p><code>React</code> propose plusieurs API pour manipuler les éléments :<ul><li><a href="#cloneelement"><code>cloneElement()</code></a><li><a href="#isvalidelement"><code>isValidElement()</code></a><li><a href="#reactchildren"><code>React.Children</code></a></ul></section><section id="fragments"class="level3"><h3>Fragments</h3><p><code>React</code> fournit également un composant particulier pour réaliser le rendu de plusieurs éléments sans avoir à les envelopper avec un autre.<ul><li><a href="#reactfragment"><code>React.Fragment</code></a></ul></section><section id="refs"class="level3"><h3>Refs</h3><ul><li><a href="#reactcreateref"><code>React.createRef</code></a><li><a href="#reactforwardref"><code>React.forwardRef</code></a></ul></section><section id="suspense"class="level3"><h3>Suspense</h3><p><em>Suspense</em> permet aux composants « d'attendre » quelque chose avant de s’afficher. Pour le moment, <em>Suspense</em> ne prend en charge qu'un seul cas d'usage : <a href="./code-splitting.html#reactlazy">le chargement dynamique de composants avec <code>React.lazy</code></a>. À l’avenir, il permettra de gérer d'autres cas d'usages tels que le chargement de données distantes.<ul><li><a href="#reactlazy"><code>React.lazy</code></a><li><a href="#reactsuspense"><code>React.Suspense</code></a></ul></section><section id="hooks"class="level3"><h3>Hooks</h3><p>Les <em>Hooks</em> sont une nouveauté de React 16.8. Ils vous permettent d'utiliser les états et d'autres fonctionnalités de React sans avoir à écrire de classes. Les <em>Hooks</em> disposent de <a href="./hooks-intro.html">leur propre documentation</a> et leur API est détaillée à part :<ul><li><a href="./hooks-reference.html#basic-hooks"><em>Hooks</em> de base</a><ul><li><a href="./hooks-reference.html#usestate"><code>useState</code></a><li><a href="./hooks-reference.html#useeffect"><code>useEffect</code></a><li><a href="./hooks-reference.html#usecontext"><code>useContext</code></a></ul><li><a href="./hooks-reference.html#additional-hooks"><em>Hooks</em> supplémentaires</a><ul><li><a href="./hooks-reference.html#usereducer"><code>useReducer</code></a><li><a href="./hooks-reference.html#usecallback"><code>useCallback</code></a><li><a href="./hooks-reference.html#usememo"><code>useMemo</code></a><li><a href="./hooks-reference.html#useref"><code>useRef</code></a><li><a href="./hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a><li><a href="./hooks-reference.html#uselayouteffect"><code>useLayoutEffect</code></a><li><a href="./hooks-reference.html#usedebugvalue"><code>useDebugValue</code></a></ul></ul><hr></section></section><section id="reference"class="level2"><h2>Référence de l’API</h2><section id="reactcomponent-reactcomponent"class="level3"><h3><code>React.Component</code> {#reactcomponent}</h3><p><code>React.Component</code> est la classe de base utilisée pour créer des composants React avec la syntaxe des <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Classes">classes ES6</a> :<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Greeting</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token maybe-class-name">Bonjour</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Rendez-vous sur <a href="./react-component.html">la page de référence de l'API <code>React.Component</code></a> pour voir la liste complète des méthodes et propriétés de la classe de base <code>React.Component</code>.<hr></section><section id="reactpurecomponent-reactpurecomponent"class="level3"><h3><code>React.PureComponent</code> {#reactpurecomponent}</h3><p><code>React.PureComponent</code> est similaire à <a href="#reactcomponent"><code>React.Component</code></a>. La seule différence est que <a href="#reactcomponent"><code>React.Component</code></a> n'implémente pas la méthode <a href="./react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a>, alors que <code>React.PureComponent</code> l’implémente en réalisant une comparaison de surface de l'état et des propriétés.<p>Si la fonction <code>render()</code> d'un de vos composants React produit un rendu identique pour le même état et les mêmes propriétés, le faire étendre <code>React.PureComponent</code> devrait améliorer les performances dans certains cas.<blockquote><p>Remarque<p>La méthode <code>shouldComponentUpdate()</code> de <code>React.PureComponent</code> réalise une simple comparaison de surface. Avec des données complexes, elle peut produire des faux négatifs si la structure de données subit des changements profonds. Ne créez des composants avec <code>PureComponent</code> que si vous avez des états et des props simples, et le cas échéant utilisez <a href="./react-component.html#forceupdate"><code>forceUpdate()</code></a> si vous savez que vos données ont changé en profondeur. Vous pouvez aussi envisager d'utiliser des <a href="https://facebook.github.io/immutable-js/">objets immuables</a> pour simplifier la comparaison rapide de données imbriquées.<p>De plus, la méthode <code>shouldComponentUpdate()</code> de <code>React.PureComponent</code> ignore la mise à jour des propriétés de tout l'arbre des composants enfants. Assurez-vous donc que tous les composants enfants sont également « purs ».</blockquote><hr></section><section id="reactmemo-reactmemo"class="level3"><h3><code>React.memo</code> {#reactmemo}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token maybe-class-name">MyComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* Faire le rendu en utilisant les props */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>React.memo</code> est un <a href="./higher-order-components.html">composant d'ordre supérieur</a>.<p>Si vous avez un composant qui affiche toujours le même résultat pour un même jeu de propriétés, vous pouvez l'enrober avec <code>React.memo</code>, ce qui mémoïsera le résultat et devrait augmenter les performances dans certains cas. Cela signifie que React sautera le rafraîchissement du composant en réutilisant son dernier rendu en date.<p><code>React.memo</code> ne se préoccupe que des modifications de props. Si votre fonction composant enrobée par <code>React.memo</code> utilise un Hook <a href="./hooks-state.html"><code>useState</code></a> ou <a href="./hooks-reference.html#usecontext"><code>useContext</code></a> dans son implémentation, des changements d’état local ou de contexte entraîneront tout de même un nouveau rendu.<p>Par défaut, seule une comparaison de surface des props sera faite. Si vous voulez gérer cette comparaison vous-même, vous pouvez fournir une fonction de comparaison personnalisée en deuxième argument.<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* Faire le rendu en utilisant les props */</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">areEqual</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*
  Renvoie `true` si passer l'objet nextProps à la fonction de rendu
  produira le même résultat que de lui passer l'objet prevProps.
  Renvoie `false` dans le cas contraire.
  */</span>
<span class="token punctuation">}</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token maybe-class-name">MyComponent</span><span class="token punctuation">,</span> areEqual<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Cette méthode n'est qu'un outil d'<strong><a href="./optimizing-performance.html">optimisation des performances</a></strong>. Ne vous y fiez pas pour « empêcher » un rendu car cela peut causer des bugs.<blockquote><p>Remarque<p>Contrairement à la méthode <a href="./react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a> des composants créés à l'aide de classes, la fonction <code>areEqual</code> renvoie <code>true</code> si les props sont égales et <code>false</code> dans le cas contraire. C'est donc l'inverse de <code>shouldComponentUpdate</code>.</blockquote><hr></section><section id="createelement-createelement"class="level3"><h3><code>createElement()</code> {#createelement}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">createElement</span><span class="token punctuation">(</span>
  type<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>props<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token spread operator">...</span>children<span class="token punctuation">]</span>
<span class="token punctuation">)</span></code></pre><p>Cette méthode crée et renvoie un nouvel <a href="./rendering-elements.html">élément React</a> du type indiqué. L'argument <code>type</code> peut être au choix : une chaîne contenant un nom de balise (tel que <code>'div'</code> ou <code>'span'</code>), un type de <a href="./components-and-props.html">composant React</a> (une classe ou une fonction), ou encore un <a href="#reactfragment">fragment React</a>.<p>Tout code écrit avec <a href="./introducing-jsx.html">JSX</a> sera converti de manière à utiliser <code>React.createElement()</code>. Normalement vous ne devriez pas appeler <code>React.createElement()</code> si vous utilisez JSX. Lisez <a href="./react-without-jsx.html">React sans JSX</a> pour en savoir plus.<hr></section><section id="cloneelement-cloneelement"class="level3"><h3><code>cloneElement()</code> {#cloneelement}</h3><pre class="language-text"><code class="language-text">React.cloneElement(
  element,
  [props],
  [...children]
)</code></pre><p>Cette méthode clone et renvoie un nouvel élément en utilisant <code>element</code> comme point de départ. L'élément obtenu aura les props de l'élément originel augmentées par une fusion de surface des nouvelles props. Les nouveaux éléments enfants (<code>children</code>) remplaceront les anciens. Les <code>key</code> et <code>ref</code> issues de l'élément originel seront préservées.<p><code>React.cloneElement()</code> est quasiment équivalent à :<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span>element<span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>props<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token operator">></span></code></pre><p>Cependant elle préserve les <code>ref</code>. Concrètement, ça signifie que si vous avez un enfant avec une <code>ref</code> associée, vous ne la volerez pas accidentellement à votre ancêtre. Vous aurez la même <code>ref</code> associée au nouvel élément.<p>Cette API a été introduite pour remplacer la méthode dépréciée <code>React.addons.cloneWithProps()</code>.<hr></section><section id="createfactory-createfactory"class="level3"><h3><code>createFactory()</code> {#createfactory}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">createFactory</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span></code></pre><p>Cette méthode renvoie une fonction qui produit des éléments React d'un type donné. Comme pour <a href="#createelement"><code>React.createElement()</code></a>, l'argument <code>type</code> peut être au choix : une chaîne contenant un nom de balise (tel que <code>'div'</code> ou <code>'span'</code>), un type de <a href="./components-and-props.html">composant React</a> (une classe ou une fonction), ou encore un type de <a href="#reactfragment">fragment React</a>.<p>Cette fonction d'aide est historique et nous vous encourageons plutôt à utiliser JSX ou directement <code>React.createElement()</code>.<p>Normalement vous ne devriez pas appeler <code>React.createFactory()</code> si vous utilisez JSX. Lisez <a href="./react-without-jsx.html">React sans JSX</a> pour en savoir plus.<hr></section><section id="isvalidelement-isvalidelement"class="level3"><h3><code>isValidElement()</code> {#isvalidelement}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">isValidElement</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span></code></pre><p>Cette méthode vérifie qu'un objet est bien un élément React. Elle renvoie <code>true</code> ou <code>false</code>.<hr></section><section id="reactchildren-reactchildren"class="level3"><h3><code>React.Children</code> {#reactchildren}</h3><p><code>React.Children</code> fournit des utilitaires pour interagir avec la structure de données opaque de <code>this.props.children</code>.<section id="reactchildrenmap-reactchildrenmap"class="level4"><h4><code>React.Children.map</code> {#reactchildrenmap}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">[</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>Cette méthode exécute une fonction sur chacun des enfants directs contenus dans <code>children</code> avec le <code>this</code> en vigueur transmis dans l’argument <code>thisArg</code>. Si <code>children</code> est un tableau, il sera parcouru et la fonction sera appelée sur chacun des enfants du tableau. Si <code>children</code> est <code>null</code> ou <code>undefined</code>, la méthode renverra <code>null</code> ou <code>undefined</code> plutôt qu'un tableau.<blockquote><p>Remarque<p>Si <code>children</code> est un <code>Fragment</code> il sera traité comme un unique enfant et ne sera pas parcouru.</blockquote></section><section id="reactchildrenforeach-reactchildrenforeach"class="level4"><h4><code>React.Children.forEach</code> {#reactchildrenforeach}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">[</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>Même chose que <a href="#reactchildrenmap"><code>React.Children.map()</code></a> mais sans renvoyer de tableau.</section><section id="reactchildrencount-reactchildrencount"class="level4"><h4><code>React.Children.count</code> {#reactchildrencount}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">count</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p>Cette méthode renvoie le nombre total de composants présents dans <code>children</code>, ce total étant égal au nombre de fois qu’une fonction de rappel passée à <code>map</code> ou <code>forEach</code> serait exécutée.</section><section id="reactchildrenonly-reactchildrenonly"class="level4"><h4><code>React.Children.only</code> {#reactchildrenonly}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">only</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p>Cette méthode vérifie que <code>children</code> n'a qu'un seul enfant (un élément React) et le renvoie. Si ce n'est pas le cas elle lèvera une erreur.<blockquote><p>Remarque<p><code>React.Children.only()</code> n'accepte pas la valeur de retour de <a href="#reactchildrenmap"><code>React.Children.map()</code></a> car il s'agit d'un tableau et non d'un élément React.</blockquote></section><section id="reactchildrentoarray-reactchildrentoarray"class="level4"><h4><code>React.Children.toArray</code> {#reactchildrentoarray}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">toArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p>Cette méthode renvoie la structure de donnée opaque de <code>children</code> sous la forme d'un tableau linéarisé ou chaque enfant est doté d’une <code>key</code>. C'est utile si vous voulez manipuler une collection d'enfants dans votre méthode de rendu, en particulier si vous voulez réorganiser ou découper <code>this.props.children</code> avant de le passer à d'autres éléments.<blockquote><p>Remarque<p><code>React.Children.toArray()</code> change les <code>key</code> pour préserver la sémantique des tableaux imbriqués pendant la linéarisation des enfants. Pour cela, <code>toArray</code> préfixe chaque <code>key</code> dans le tableau qui sera renvoyé de manière a ce que la <code>key</code> de chaque élément soit associée au tableau originel qui les contient.</blockquote><hr></section></section><section id="reactfragment-reactfragment"class="level3"><h3><code>React.Fragment</code> {#reactfragment}</h3><p>Le composant <code>React.Fragment</code> vous permet de renvoyer plusieurs éléments depuis une méthode <code>render()</code> sans avoir à créer un élément DOM supplémentaire :<pre class="language-javascript"><code class="language-javascript"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Fragment</span></span><span class="token operator">></span>
      <span class="token maybe-class-name">Du</span> texte<span class="token punctuation">.</span>
      <span class="token operator">&#x3C;</span>h2<span class="token operator">></span><span class="token maybe-class-name">Un</span> en<span class="token operator">-</span>tête<span class="token operator">&#x3C;</span><span class="token operator">/</span>h2<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Fragment</span></span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Vous pouvez également l'utiliser via la syntaxe raccourcie <code>&#x3C;>&#x3C;/></code> . Pour plus d'information, lisez <a href="/blog/2017/11/28/react-v16.2.0-fragment-support.html"><em>React v16.2.0: Improved Support for Fragments</em></a> (en anglais).</section><section id="reactcreateref-reactcreateref"class="level3"><h3><code>React.createRef</code> {#reactcreateref}</h3><p><code>React.createRef</code> crée une <a href="./refs-and-the-dom.html"><code>ref</code></a> qui peut être associée à des éléments React via l'attribut <code>ref</code>. <code>embed:16-3-release-blog-post/create-ref-example.js</code></section><section id="reactforwardref-reactforwardref"class="level3"><h3><code>React.forwardRef</code> {#reactforwardref}</h3><p><code>React.forwardRef</code> crée un composant React qui transfère la valeur de l'attribut <a href="./refs-and-the-dom.html">ref</a> qu'il reçoit à un autre composant plus bas dans l'arbre. Cette technique est assez inhabituelle mais elle est particulièrement utile dans deux cas :<ul><li><a href="./forwarding-refs.html#forwarding-refs-to-dom-components">Transférer une référence à un composant DOM</a><li><a href="./forwarding-refs.html#forwarding-refs-in-higher-order-components">Transférer une référence au sein d’un composant d’ordre supérieur</a></ul><p><code>React.forwardRef</code> prend une fonction de rendu comme argument. React appellera cette fonction avec deux arguments <code>props</code> et <code>ref</code>. Cette fonction devrait renvoyer un nœud React.<p><code>embed:reference-react-forward-ref.js</code><p>Dans l'exemple ci-avant, la fonction de rendu passée à <code>React.forwardRef</code> recevra comme deuxième argument la <code>ref</code> initialement fournie à l'élément <code>&#x3C;FancyButton ref={ref}></code>. Cette fonction va alors transférer la <code>ref</code> à l'élément <code>&#x3C;button ref={ref}></code>.<p>En conséquence, après que React aura attaché la ref, <code>ref.current</code> pointera directement vers l'instance de l'élément DOM de <code>&#x3C;button></code>.<p>Pour en savoir plus, lisez <a href="./forwarding-refs.html">Transférer les refs</a></section><section id="reactlazy-reactlazy"class="level3"><h3><code>React.lazy</code> {#reactlazy}</h3><p><code>React.lazy()</code> vous permet de définir un composant qui sera chargé dynamiquement. Cela aide à réduire la taille du fichier initial en reportant à plus tard le chargement des composants inutiles lors du rendu initial.<p>Vous pouvez apprendre comment l'utiliser en lisant <a href="./code-splitting.html#reactlazy">la documentation sur la découpe du code</a>. Vous voudrez peut-être aussi jeter un œil à <a href="https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d">cet article</a>, qui explique comment l'utiliser en détail.<pre class="language-js"><code class="language-js"><span class="token comment">// Ce composant est chargé dynamiquement</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">SomeComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./SomeComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Notez bien que l'affichage d'un composant <code>lazy</code> a besoin d'un composant <code>&#x3C;React.Suspense></code> plus haut dans l'arbre de rendu. C'est de cette manière que vous pouvez spécifier un indicateur de chargement.<blockquote><p>Remarque<p>Utiliser <code>React.lazy</code> avec un <code>import()</code> dynamique requiert une prise en charge des <em>Promises</em> par l'environnement JS. Vous aurez donc besoin d’un <em>polyfill</em> pour IE11 et inférieurs.</blockquote></section><section id="reactsuspense-reactsuspense"class="level3"><h3><code>React.Suspense</code> {#reactsuspense}</h3><p><code>React.Suspense</code> vous permet de définir un indicateur de chargement pour le cas où certains composants plus bas dans l’arbre de rendu ne seraient pas encore prêts à être affichés. Pour le moment le <strong>seul</strong> cas d'usage pris en charge par <code>&#x3C;React.Suspense></code>, c’est le chargement différé de composants via <a href="#reactlazy"><code>React.lazy</code></a> :<pre class="language-js"><code class="language-js"><span class="token comment">// Ce composant est chargé dynamiquement</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">OtherComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./OtherComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token comment">// Affiche &#x3C;Spinner> jusqu'à ce que &#x3C;OtherComponent> soit chargé</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Suspense</span></span> fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Spinner</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
        <span class="token operator">&#x3C;</span><span class="token maybe-class-name">OtherComponent</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Suspense</span></span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Tout ça est détaillé dans <a href="./code-splitting.html#reactlazy">notre guide sur la découpe du code</a>. Remarquez que les composants <code>lazy</code> peuvent être profondément enfouis dans l'arbre des descendants de <code>Suspense</code>—ils n'ont pas besoin d'être enveloppés individuellement. La bonne pratique consiste à placer un <code>&#x3C;Suspense></code> aux endroits où vous souhaitez voir un indicateur de chargement, et à utiliser <code>lazy()</code> partout ou vous voulez découper votre code.<p>Bien que ce ne soit pas le cas pour le moment, nous prévoyons d'étendre les capacités de <code>Suspense</code> pour qu'il puisse gérer d'autre scénarios tel que le chargement de données. Vous pourrez en savoir plus en jetant un coup d'œil à <a href="/blog/2018/11/27/react-16-roadmap.html">notre feuille de route</a>.<blockquote><p>Remarque<p><code>React.lazy()</code> et <code>&#x3C;React.Suspense></code> ne sont pas encore pris en charge par <code>ReactDOMServer</code>. C'est une limitation connue qui devrait être résolue à l’avenir. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></blockquote></section></section></section>