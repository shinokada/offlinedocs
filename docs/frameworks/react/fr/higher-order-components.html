<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <title>Composants d’ordre supérieur</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="composants-dordre-supérieur" class="level1">
      <h1>Composants d’ordre supérieur</h1>
      <p>Un composant d'ordre supérieur <em>(Higher-Order Component ou HOC, NdT)</em> est une technique avancée de React qui permet de réutiliser la logique de composants. Les HOC ne font pas partie de l'API de React à proprement parler, mais découlent de sa nature compositionnelle.</p>
      <p>Concrètement, <strong>un composant d'ordre supérieur est une fonction qui accepte un composant et renvoie un nouveau composant.</strong></p>
      <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">higherOrderComponent</span><span class="token punctuation">(</span><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      <p>Là où un composant transforme des props en interface utilisateur (UI), un composant d'ordre supérieur transforme un composant en un autre composant.</p>
      <p>Les HOC sont courants dans des bibliothèques tierces de React, comme <a href="https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect"><code>connect</code></a> dans Redux et <a href="http://facebook.github.io/relay/docs/en/fragment-container.html"><code>createFragmentContainer</code></a> dans Relay.</p>
      <p>Dans ce guide, nous verrons pourquoi les composants d'ordre supérieurs sont utiles, et comment créer le vôtre.</p>
      <section id="use-hocs-for-cross-cutting-concerns" class="level2">
        <h2>Utiliser les HOC pour les questions transversales</h2>
        <blockquote>
          <p>Remarque</p>
          <p>Auparavant, nous recommandions d'employer des <em>mixins</em> pour gérer les questions transversales. Depuis, nous nous sommes rendus compte que les <em>mixins</em> créent plus de problèmes qu'ils n'en résolvent. Vous pouvez <a href="/blog/2016/07/13/mixins-considered-harmful.html">lire le détail</a> des raisons qui nous ont fait renoncer aux <em>mixins</em>, et de la façon dont vous pouvez faire de même pour vos composants existants.</p>
        </blockquote>
        <p>Les composants sont le principal moyen de réutiliser du code en React. Cependant, vous remarquerez que les composants classiques ne conviennent pas à tous les modèles.</p>
        <p>Imaginez que vous ayez créé un composant <code>CommentList</code> qui s’abonne à une source externe de données pour afficher une liste de commentaires :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CommentList</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">handleChange</span><span class="token punctuation">.</span><span class="token method function property-access">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token comment">// `DataSource` est une source de données quelconque</span>
      <span class="token literal-property property">comments</span><span class="token operator">:</span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getComments</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// On s’abonne aux modifications</span>
    <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">addChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// On se désabonne</span>
    <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">removeChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Met à jour l’état local quand la source de données est modifiée</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">comments</span><span class="token operator">:</span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getComments</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
        <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">comments</span><span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">comment</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span>
          <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Comment</span> comment<span class="token operator">=</span><span class="token punctuation">{</span>comment<span class="token punctuation">}</span> key<span class="token operator">=</span><span class="token punctuation">{</span>comment<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>Plus tard, vous créez un composant <code>BlogPost</code> qui s'abonne à un unique article, et dont la structure est similaire :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">BlogPost</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">handleChange</span><span class="token punctuation">.</span><span class="token method function property-access">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">blogPost</span><span class="token operator">:</span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getBlogPost</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">addChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">removeChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">blogPost</span><span class="token operator">:</span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getBlogPost</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">TextBlock</span> text<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">blogPost</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p><code>CommentList</code> et <code>BlogPost</code> ne sont pas identiques : ils appellent des méthodes différentes sur <code>DataSource</code>, et ont des affichages distincts. Pourtant une grande partie de leur implémentation est la même :</p>
        <ul>
          <li>Au montage <em>(quand le composant entre dans la couche d'affichage, NdT)</em>, ils ajoutent un écouteur d'événements à <code>DataSource</code>.</li>
          <li>Dans l'écouteur, ils appellent <code>setState</code> quand la source de données est modifiée.</li>
          <li>Au démontage <em>(quand le composant sort de la couche d'affichage, NdT)</em>, ils enlèvent l'écouteur d'événements.</li>
        </ul>
        <p>Vous imaginez bien que dans une appli importante, ce motif d'abonnement à une <code>DataSource</code> et d'appel à <code>setState</code> sera récurrent. Il nous faut une abstraction qui nous permette de définir cette logique en un seul endroit et de la réutiliser pour de nombreux composants. C'est là que les composants d'ordre supérieur sont particulièrement utiles.</p>
        <p>Nous pouvons écrire une fonction qui crée des composants qui s'abonnent à une <code>DataSource</code>, comme <code>CommentList</code> et <code>BlogPost</code>. La fonction acceptera parmi ses arguments un composant initial, qui recevra les données suivies en props. Appelons cette fonction <code>withSubscription</code> :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">CommentListWithSubscription</span> <span class="token operator">=</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span>
  <span class="token maybe-class-name">CommentList</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">DataSource</span></span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getComments</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token maybe-class-name">BlogPostWithSubscription</span> <span class="token operator">=</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span>
  <span class="token maybe-class-name">BlogPost</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">DataSource</span><span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getBlogPost</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>Le premier paramètre est le composant initial. Le second charge les données qui nous intéressent, en fonction de la <code>DataSource</code> et des props existantes.</p>
        <p>Lorsque <code>CommentListWithSubscription</code> et <code>BlogPostWithSubscription</code> s'affichent, <code>CommentList</code> et <code>BlogPost</code> reçoivent une prop <code>data</code> qui contient les données les plus récentes issues de la <code>DataSource</code> :</p>
        <pre class="language-js"><code class="language-js"><span class="token comment">// Cette fonction accepte un composant...</span>
<span class="token keyword">function</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">,</span> selectData</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... et renvoie un autre composant...</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Component</span></span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">handleChange</span><span class="token punctuation">.</span><span class="token method function property-access">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token function">selectData</span><span class="token punctuation">(</span><span class="token maybe-class-name">DataSource</span><span class="token punctuation">,</span> props<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ... qui s’occupe de l'abonnement...</span>
      <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">addChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">removeChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token function">selectData</span><span class="token punctuation">(</span><span class="token maybe-class-name">DataSource</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ... et affiche le composant enrobé avec les données à jour !</span>
      <span class="token comment">// Remarquez qu’on passe aussi toute autre prop reçue.</span>
      <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">WrappedComponent</span> data<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
        <p>Remarquez qu'un HOC ne modifie pas le composant qu'on lui passe, et ne recourt pas non plus à l’héritage pour copier son comportement. Un HOC <em>compose</em> le composant initial en l'<em>enrobant</em> dans un composant conteneur. Il s'agit d'une fonction pure, sans effets de bord.</p>
        <p>Et voilà ! Le composant enrobé reçoit toutes les props du conteneur ainsi qu'une nouvelle prop, <code>data</code>, qu'il emploie pour produire son résultat. Le HOC ne se préoccupe pas de savoir comment ou pourquoi les données sont utilisées, et le composant enrobé ne se préoccupe pas de savoir d'où viennent les données.</p>
        <p>Puisque <code>withSubscription</code> est juste une fonction, vous pouvez lui définir autant ou aussi peu de paramètres que vous le souhaitez. Par exemple, vous pourriez rendre configurable le nom de la prop <code>data</code>, afin d’isoler encore davantage le HOC et le composant enrobé. Ou alors, vous pourriez accepter un argument qui configure <code>shouldComponentUpdate</code>, ou un autre qui configure la source de données. Tout ça est possible parce que le HOC a un contrôle total sur la façon dont le composant est défini.</p>
        <p>Comme pour les composants, le rapport entre <code>withSubscription</code> et le composant enrobé se base entièrement sur les props. Ça facilite l'échange d'un HOC pour un autre, du moment qu'ils fournissent les mêmes props au composant enrobé. Ça peut s'avérer utile si vous changez de bibliothèque pour charger vos données, par exemple.</p>
      </section>
      <section id="dont-mutate-the-original-component-use-composition" class="level2">
        <h2>Ne modifiez pas le composant initial : composez-le.</h2>
        <p>Résistez à la tentation de modifier le prototype d'un composant (ou de le modifier de quelque façon que ce soit) dans un HOC.</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">logProps</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">InputComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">InputComponent</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">componentDidUpdate</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">prevProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'Props actuelles : '</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'Props précédentes : '</span><span class="token punctuation">,</span> prevProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// Le fait que le composant initial soit renvoyé est un signe qu’il a été modifié.</span>
  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">InputComponent</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// EnhancedComponent fera un log à chaque fois qu’il reçoit des props.</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">logProps</span><span class="token punctuation">(</span><span class="token maybe-class-name">InputComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>Ce genre d'approche pose quelques problèmes. Pour commencer, le composant initial ne peut pas être réutilisé indépendamment du composant amélioré. Plus important encore, si vous appliquez un autre HOC sur <code>EnhancedComponent</code> qui modifie <em>aussi</em> <code>componentDidUpdate</code>, les fonctionnalités du premier HOC seront perdues ! Enfin, ce HOC ne fonctionnera pas avec des fonctions composants, qui n'ont pas de méthodes de cycle de vie.</p>
        <p>Les HOC qui modifient le composant enrobé sont une abstraction foireuse : leurs utilisateurs doivent savoir comment ils sont implémentés afin d’éviter des conflits avec d'autres HOC.</p>
        <p>Plutôt que la mutation, les HOC devraient utiliser la composition, en enrobant le composant initial dans un composant conteneur.</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">logProps</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Component</span></span> <span class="token punctuation">{</span>
    <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'Props actuelles : '</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'Props précédentes : '</span><span class="token punctuation">,</span> prevProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Enrobe le composant initial dans un conteneur, sans le modifier. Mieux !</span>
      <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">WrappedComponent</span> <span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>Ce HOC a la même fonctionnalité que la version modifiante, tout en évitant le risque de conflits. Il fonctionne tout aussi bien avec les composants à base de classe et les fonctions composants. Et puisqu'il s'agit d'une fonction pure, il est composable avec d'autres HOC voire même avec lui-même.</p>
        <p>Vous avez peut-être remarqué des ressemblances entre les HOC et le motif des <strong>composants conteneurs</strong>. Les composants conteneurs participent à des stratégies de séparation de responsabilités entre les préoccupations de haut et de bas niveau. Les conteneurs se préoccupent par exemple des abonnements et de l'état, et passent des props à d'autres composants qui se préoccupent par exemple d'afficher l’UI. Les HOC utilisent des conteneurs dans leur implémentation. Vous pouvez voir les HOC comme des définitions paramétrables de composants conteneurs.</p>
      </section>
      <section id="convention-pass-unrelated-props-through-to-the-wrapped-component" class="level2">
        <h2>Convention : transmettez les props annexes au composant enrobé</h2>
        <p>Les HOC ajoutent des fonctionnalités à un composant. Ils ne devraient pas drastiquement modifier son contrat. On s'attend à ce que le composant renvoyé par un HOC ait une interface semblable au composant initial.</p>
        <p>Les HOC devraient transmettre les props sans rapport avec leur propre fonctionnement. La plupart des HOC ont une méthode de rendu qui ressemble à ça :</p>
        <pre class="language-js"><code class="language-js"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Filtre les props supplémentaires propres à ce HOC</span>
  <span class="token comment">// qui ne devraient pas être transmises</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> extraProp<span class="token punctuation">,</span> <span class="token spread operator">...</span>passThroughProps <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>

  <span class="token comment">// Injecte les props dans le composant enrobé. Il s’agit en général</span>
  <span class="token comment">// de valeurs de l’état local ou de méthodes d’instance.</span>
  <span class="token keyword">const</span> injectedProp <span class="token operator">=</span> someStateOrInstanceMethod<span class="token punctuation">;</span>

  <span class="token comment">// Transmet les props au composant enrobé</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">WrappedComponent</span>
      injectedProp<span class="token operator">=</span><span class="token punctuation">{</span>injectedProp<span class="token punctuation">}</span>
      <span class="token punctuation">{</span><span class="token spread operator">...</span>passThroughProps<span class="token punctuation">}</span>
    <span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
        <p>Cette convention améliore la flexibilité et la réutilisabilité de nos HOC.</p>
      </section>
      <section id="convention-maximizing-composability" class="level2">
        <h2>Convention : maximisez la composabilité</h2>
        <p>Tous les HOC n’ont pas la même interface. Ils n'acceptent parfois qu'un seul argument, le composant enrobé :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">NavbarWithRouter</span> <span class="token operator">=</span> <span class="token function">withRouter</span><span class="token punctuation">(</span><span class="token maybe-class-name">Navbar</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>Mais en général, les HOC acceptent des arguments supplémentaires. Dans cet exemple tiré de Relay, un objet de configuration <code>config</code> est transmis pour spécifier les dépendances d'un composant aux données :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">CommentWithRelay</span> <span class="token operator">=</span> <span class="token maybe-class-name">Relay</span><span class="token punctuation">.</span><span class="token method function property-access">createContainer</span><span class="token punctuation">(</span><span class="token maybe-class-name">Comment</span><span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>La signature la plus courante pour un HOC ressemble à ceci :</p>
        <pre class="language-js"><code class="language-js"><span class="token comment">// `connect` de React Redux</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">ConnectedComment</span> <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span>commentSelector<span class="token punctuation">,</span> commentActions<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token maybe-class-name">CommentList</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p><em>Pardon ?!</em> Il est plus facile de voir ce qui se passe si on décortique l'appel.</p>
        <pre class="language-js"><code class="language-js"><span class="token comment">// connect est une fonction qui renvoie une autre fonction</span>
<span class="token keyword">const</span> enhance <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span>commentListSelector<span class="token punctuation">,</span> commentListActions<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// La fonction renvoyée est un HOC, qui renvoie un composant connecté au store Redux</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">ConnectedComment</span> <span class="token operator">=</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token maybe-class-name">CommentList</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>Autrement dit, <code>connect</code> est une fonction d'ordre supérieur… qui renvoie un composant d'ordre supérieur !</p>
        <p>Cette forme peut sembler déroutante ou superflue, pourtant elle a une propriété utile. Les HOC n'acceptant qu'un argument comme celui que renvoie la fonction <code>connect</code> ont une signature <code>Composant => Composant</code>. Les fonctions dont le type de données est le même en sortie qu'en entrée sont beaucoup plus faciles à composer.</p>
        <pre class="language-js"><code class="language-js"><span class="token comment">// Plutôt que de faire ceci...</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">withRouter</span><span class="token punctuation">(</span><span class="token function">connect</span><span class="token punctuation">(</span>commentSelector<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// ... vous pouvez utiliser un utilitaire de composition de fonction.</span>
<span class="token comment">// compose(f, g, h) est l’équivalent de (...args) => f(g(h(...args)))</span>
<span class="token keyword">const</span> enhance <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  <span class="token comment">// Ces deux-là sont des HOC n’acceptant qu’un argument.</span>
  withRouter<span class="token punctuation">,</span>
  <span class="token function">connect</span><span class="token punctuation">(</span>commentSelector<span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span></code></pre>
        <p>(C'est aussi cette propriété qui permet à <code>connect</code> et à d'autres HOC du même type d'être utilisés comme décorateurs, une proposition expérimentale JavaScript.)</p>
        <p>La fonction utilitaire <code>compose</code> est fournie par de nombreuses bibliothèques tierces, dont lodash (sous le nom <a href="https://lodash.com/docs/#flowRight"><code>lodash.flowRight</code></a>), <a href="https://redux.js.org/api/compose">Redux</a>, et <a href="https://ramdajs.com/docs/#compose">Ramda</a>.</p>
      </section>
      <section id="convention-wrap-the-display-name-for-easy-debugging" class="level2">
        <h2>Convention : enrobez le <code>displayName</code> pour faciliter le débogage</h2>
        <p>Tout comme n'importe quel autre composant, les composants conteneurs créés par des HOC apparaissent dans les <a href="https://github.com/facebook/react-devtools">Outils de développement React</a>. Pour faciliter votre débogage, donnez-leur un nom affichable qui indique qu'ils sont le résultat d'un HOC.</p>
        <p>Le technique la plus répandue consiste à enrober le nom d'affichage du composant enrobé. Par exemple, si votre composant d'ordre supérieur s'appelle <code>withSubscription</code>, et que le nom d'affichage du composant enrobé est <code>CommentList</code>, utilisez le nom d'affichage <code>WithSubscription(CommentList)</code> :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">WithSubscription</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token comment">/* ... */</span><span class="token punctuation">}</span>
  <span class="token maybe-class-name">WithSubscription</span><span class="token punctuation">.</span><span class="token property-access">displayName</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">WithSubscription(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">getDisplayName</span><span class="token punctuation">(</span><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">WithSubscription</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getDisplayName</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">.</span><span class="token property-access">displayName</span> <span class="token operator">||</span> <span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">||</span> <span class="token string">'Component'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </section>
      <section id="caveats" class="level2">
        <h2>Limitations</h2>
        <p>L'utilisation de composants d'ordre supérieur est sujette à quelques limitations qui ne sont pas tout de suite évidentes si vous débutez avec React.</p>
        <section id="dont-use-hocs-inside-the-render-method" class="level3">
          <h3>Pas de HOC à l'intérieur de la méthode de rendu</h3>
          <p>L'algorithme de comparaison de React (qu'on appelle la réconciliation) utilise l'identité des composants pour déterminer s'il faut mettre à jour l'arborescence existante ou la jeter et en monter une nouvelle. Si le composant renvoyé par <code>render</code> est identique (<code>===</code>) au composant du rendu précédent, React met récursivement à jour l'arborescence en la comparant avec la nouvelle. S'ils ne sont pas identiques, l'ancienne arborescence est intégralement démontée.</p>
          <p>En général, vous ne devriez pas avoir à y penser. Mais dans le cadre des HOC c'est important, puisque ça signifie que vous ne pouvez pas appliquer un HOC au sein de la méthode de rendu d'un composant :</p>
          <pre class="language-js"><code class="language-js"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Une nouvelle version de EnhancedComponent est créée à chaque rendu</span>
  <span class="token comment">// EnhancedComponent1 !== EnhancedComponent2</span>
  <span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token maybe-class-name">MyComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Ça entraîne un démontage/remontage complet à chaque fois !</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
          <p>Il ne s'agit pas uniquement d'un problème de performances : remonter un composant signifie que l'état local de ce composant ainsi que ceux de tous ses enfants seront perdus.</p>
          <p>Appliquez plutôt les HOC à l'extérieur de la définition d'un composant, afin de créer le composant enrobé une seule fois. Son identité sera alors constante d’un rendu à l'autre. C'est généralement ce que vous voulez, de toutes façons.</p>
          <p>Dans les rares cas où vous avez besoin d’appliquer un HOC de façon dynamique, vous pouvez le faire au sein des méthodes de cycle de vie d'un composant ou dans son constructeur.</p>
        </section>
        <section id="static-methods-must-be-copied-over" class="level3">
          <h3>Les méthodes statiques doivent être copiées</h3>
          <p>Il est parfois utile de définir une méthode statique dans un composant React. Par exemple, les conteneurs Relay exposent une méthode statique <code>getFragment</code> pour simplifier la composition de fragments GraphQL.</p>
          <p>Cependant, quand vous appliquez un HOC à un composant, le composant initial est enrobé par un composant conteneur. Ça signifie que le nouveau composant ne comporte aucune des méthodes statiques du composant initial.</p>
          <pre class="language-js"><code class="language-js"><span class="token comment">// Définit une méthode statique</span>
<span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">staticMethod</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
<span class="token comment">// Applique un HOC</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Le composant amélioré n’a pas de méthode statique</span>
<span class="token keyword">typeof</span> <span class="token maybe-class-name">EnhancedComponent</span><span class="token punctuation">.</span><span class="token property-access">staticMethod</span> <span class="token operator">===</span> <span class="token string">'undefined'</span> <span class="token comment">// true</span></code></pre>
          <p>Pour résoudre ça, vous pouvez copier les méthodes dans le conteneur avant de le renvoyer :</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">Enhance</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
  <span class="token comment">// Doit savoir exactement quelles méthodes recopier :(</span>
  <span class="token maybe-class-name">Enhance</span><span class="token punctuation">.</span><span class="token property-access">staticMethod</span> <span class="token operator">=</span> <span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">.</span><span class="token property-access">staticMethod</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">Enhance</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
          <p>Le problème, c’est que ça exige que vous sachiez exactement quelles méthodes doivent être recopiées. Vous devriez plutôt utiliser <a href="https://github.com/mridgway/hoist-non-react-statics">hoist-non-react-statics</a> pour copier automatiquement toutes les méthodes statiques qui ne viennent pas de React :</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports">hoistNonReactStatics</span> <span class="token keyword module">from</span> <span class="token string">'hoist-non-react-statics'</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">Enhance</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
  <span class="token function">hoistNonReactStatics</span><span class="token punctuation">(</span><span class="token maybe-class-name">Enhance</span><span class="token punctuation">,</span> <span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">Enhance</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
          <p>Une autre solution consiste à exporter les méthodes statiques de façon séparée du composant lui-même.</p>
          <pre class="language-js"><code class="language-js"><span class="token comment">// Plutôt que...</span>
<span class="token maybe-class-name">MyComponent</span><span class="token punctuation">.</span><span class="token property-access">someFunction</span> <span class="token operator">=</span> someFunction<span class="token punctuation">;</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token maybe-class-name">MyComponent</span><span class="token punctuation">;</span>

<span class="token comment">// ... exportez les méthodes séparément...</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span> someFunction <span class="token punctuation">}</span></span><span class="token punctuation">;</span>

<span class="token comment">// ... et dans le module qui les utilise, importez les deux.</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">MyComponent</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> someFunction <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./MyComponent.js'</span><span class="token punctuation">;</span></code></pre>
        </section>
        <section id="refs-arent-passed-through" class="level3">
          <h3>Les refs ne sont pas transmises</h3>
          <p>Bien que que la convention pour les composants d'ordre supérieur soit de transmettre toutes les props au composant enrobé, ça ne marche pas pour les refs. C'est parce que <code>ref</code> n'est pas vraiment une prop : comme <code>key</code>, React la traite de façon particulière. Si vous ajoutez une ref à un élément dont le composant résulte d'un HOC, la ref fait référence à une instance du composant conteneur extérieur, et non au composant enrobé.</p>
          <p>
            La solution à ce problème réside dans l'utilisation de l'API <code>React.forwardRef</code> (introduite dans React 16.3). <a href="./forwarding-refs.html">Vous pouvez en apprendre davantage dans la section sur la transmission des refs</a>.
            <span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span>
          </p>
        </section>
      </section>
    </section>
  </body>
</html>
