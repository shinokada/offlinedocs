<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <title>Notes d’implémentation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="notes-dimplémentation" class="level1">
      <h1>Notes d’implémentation</h1>
      <p>Cette section fournit un ensemble de notes relatives à l’implémentation du <a href="./codebase-overview.html#stack-reconciler">réconciliateur <em>“stack”</em></a>.</p>
      <p>C'est très technique et suppose une solide compréhension de l’API publique de React ainsi que de sa structure divisée en noyau, moteurs de rendu et réconciliateur. Si vous ne connaissez pas bien la base de code React, lisez d'abord l'<a href="./codebase-overview.html">aperçu du code source</a>.</p>
      <p>Ça suppose également de comprendre les <a href="/blog/2015/12/18/react-components-elements-and-instances.html">différences entre les composants React, leurs instances et leurs éléments</a>.</p>
      <p>Le réconciliateur <em>“stack”</em> était utilisé jusqu’à React 15 inclus. Il se trouve dans <a href="https://github.com/facebook/react/tree/15-stable/src/renderers/shared/stack/reconciler">src/renderers/shared/stack/reconciler</a>.</p>
      <section id="video-building-react-from-scratch" class="level3">
        <h3>Vidéo : construire React à partir de zéro</h3>
        <p><a href="https://twitter.com/zpao">Paul O'Shannessy</a> a donné une conférence (en anglais) sur la <a href="https://www.youtube.com/watch?v=_MAD4Oly9yg">construction de React à partir de zéro</a> qui a largement inspiré ce document.</p>
        <p>Ce document et sa conférence sont des simplifications de la véritable base de code : en vous familiarisant avec ces deux sources, vous devriez mieux comprendre.</p>
      </section>
      <section id="overview" class="level3">
        <h3>Aperçu</h3>
        <p>Le réconciliateur lui-même n’a pas d’API publique. Les <a href="./codebase-overview.html#renderers">moteurs de rendu</a> comme React DOM et React Native l'utilisent pour mettre à jour efficacement l'interface utilisateur en fonction des composants React écrits par l'utilisateur.</p>
      </section>
      <section id="mounting-as-a-recursive-process" class="level3">
        <h3>Le montage, un processus récursif</h3>
        <p>Intéressons-nous à la première fois que vous montez un composant :</p>
        <pre class="language-js"><code class="language-js"><span class="token maybe-class-name">ReactDOM</span><span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>React DOM passera <code>&#x3C;App /></code> au réconciliateur. Rappelez-vous que <code>&#x3C;App /></code> est un élément React, c’est-à-dire une description de <em>quoi</em> afficher. Vous pouvez le considérer comme un simple objet :</p>
        <pre class="language-js"><code class="language-js"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { type: App, props: {} }</span></code></pre>
        <p>Le réconciliateur vérifiera si <code>App</code> est une classe ou une fonction.</p>
        <p>Si <code>App</code> est une fonction, le réconciliateur appellera <code>App(props)</code> pour obtenir le rendu de l’élément associé.</p>
        <p>Si <code>App</code> est une classe, le réconciliateur instanciera une <code>App</code> avec <code>new App(props)</code>, appellera la méthode de cycle de vie <code>componentWillMount()</code>, puis appellera la méthode <code>render()</code> pour obtenir le rendu de l’élément.</p>
        <p>Dans les deux cas, le réconciliateur saura quel élément « a été produit par le rendu » de <code>App</code>.</p>
        <p>Ce processus est récursif. Le rendu de <code>App</code> peut produire un <code>&#x3C;Greeting /></code>, celui de <code>Greeting</code> peut produire un <code>&#x3C;Button /></code>, et ainsi de suite. Le réconciliateur « creusera » récursivement dans les composants définis par l'utilisateur, et saura ainsi ce que produit le rendu de chacun.</p>
        <p>Vous pouvez imaginer ce processus comme un pseudo-code :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isClass</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Les sous-classes de React.Component ont ce drapeau</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token known-class-name class-name">Boolean</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">)</span> <span class="token operator">&#x26;&#x26;</span>
    <span class="token known-class-name class-name">Boolean</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">isReactComponent</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Cette fonction prend en paramètre un élément React (par exemple &#x3C;App />)</span>
<span class="token comment">// et renvoie un nœud DOM ou natif représentant l’arbre monté.</span>
<span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> props <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>

  <span class="token comment">// Nous déterminerons l’élément rendu</span>
  <span class="token comment">// soit en exécutant le type comme une fonction</span>
  <span class="token comment">// soit en créant une instance puis en appelant render().</span>
  <span class="token keyword">var</span> renderedElement<span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isClass</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Composant basé classe</span>
    <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Initialise les props</span>
    publicInstance<span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
    <span class="token comment">// Appelle le cycle de vie si besoin</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">.</span><span class="token property-access">componentWillMount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      publicInstance<span class="token punctuation">.</span><span class="token method function property-access">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Obtient l’élément rendu en appelant render()</span>
    renderedElement <span class="token operator">=</span> publicInstance<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// Fonction composant</span>
    renderedElement <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Ce processus est récursif parce qu’un composant peut</span>
  <span class="token comment">// renvoyer un élément avec un autre type de composant.</span>
  <span class="token keyword control-flow">return</span> <span class="token function">mount</span><span class="token punctuation">(</span>renderedElement<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Remarque : cette implémentation est incomplète et la récursivité est infinie !</span>
  <span class="token comment">// Ça gère uniquement les éléments comme &#x3C;App /> ou &#x3C;Button />.</span>
  <span class="token comment">// Ça ne gère pas pour l’instant les éléments comme &#x3C;div /> ou &#x3C;p />.</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> rootEl <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> node <span class="token operator">=</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
rootEl<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <blockquote>
          <p>Remarque</p>
          <p>C’est <em>vraiment</em> du pseudo-code. L'implémentation actuelle diffère pas mal. Ce code saturerait la pile car nous n’avons pas précisé de condition d’arrêt pour la récursivité.</p>
        </blockquote>
        <p>Récapitulons quelques idées clés dans l’exemple ci-dessus :</p>
        <ul>
          <li>Les éléments React sont des objets simples représentant le type du composant (par exemple <code>App</code>) et les props.</li>
          <li>Les composants définis par l'utilisateur (par exemple <code>App</code>) peuvent être des classes ou des fonctions mais toutes « font un rendu » avec des éléments comme résultat.</li>
          <li>Le « montage » est un processus récursif qui crée un arbre DOM ou natif à partir de l'élément racine React (par exemple <code>&#x3C;App /></code>).</li>
        </ul>
      </section>
      <section id="mounting-host-elements" class="level3">
        <h3>Montage d'éléments hôtes</h3>
        <p>Ce processus serait inutile si nous n'affichions pas quelque chose à l'écran au final.</p>
        <p>En plus des composants définis par l'utilisateur (« composites »), les éléments React peuvent également représenter des composants pour des plates-formes spécifiques (« hôtes »). Par exemple, la méthode de rendu de <code>Button</code> pourrait renvoyer une <code>&#x3C;div /></code>.</p>
        <p>Si la propriété <code>type</code> de l'élément est une chaîne de caractères, il s’agit d’un élément hôte :</p>
        <pre class="language-js"><code class="language-js"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span>div <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { type: 'div', props: {} }</span></code></pre>
        <p>Il n’y a aucun code défini par l’utilisateur associé aux éléments hôtes.</p>
        <p>Lorsque le réconciliateur rencontre un élément hôte, il laisse le moteur de rendu s'occuper du montage. Par exemple, React DOM créerait un nœud DOM.</p>
        <p>Si l'élément hôte a des enfants, le réconciliateur les monte de manière récursive en suivant le même algorithme que celui décrit plus haut. Peu importe que les enfants soient hôtes (comme <code>&#x3C;div>&#x3C;hr />&#x3C;/div></code>), composites (comme <code>&#x3C;div>&#x3C;Button />&#x3C;/div></code>) ou un mélange des deux.</p>
        <p>Les nœuds DOM produits par les composants enfants seront ajoutés au nœud DOM parent, et donc de manière récursive, l’ensemble de la structure DOM sera constituée.</p>
        <blockquote>
          <p>Remarque</p>
          <p>Le réconciliateur lui-même n'est pas lié au DOM. Le résultat exact du montage (parfois appelé <em>“mount image”</em> dans le code source) dépend du moteur de rendu, et donc peut être un nœud DOM (React DOM), une chaîne de caractères (React DOM Server) ou un nombre représentant une vue native (React Native).</p>
        </blockquote>
        <p>Si nous devions étendre le code pour gérer des éléments hôtes, il ressemblerait à ceci :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isClass</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Les sous-classes de React.Component ont ce drapeau</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token known-class-name class-name">Boolean</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">)</span> <span class="token operator">&#x26;&#x26;</span>
    <span class="token known-class-name class-name">Boolean</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">isReactComponent</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Cette fonction gère uniquement les éléments avec un type composite.</span>
<span class="token comment">// Par exemple, elle gère &#x3C;App /> et &#x3C;Button />, mais pas une &#x3C;div />.</span>
<span class="token keyword">function</span> <span class="token function">mountComposite</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> props <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>

  <span class="token keyword">var</span> renderedElement<span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isClass</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Composant basé classe</span>
    <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Initialise les props</span>
    publicInstance<span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
    <span class="token comment">// Appelle le cycle de vie si besoin</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">.</span><span class="token property-access">componentWillMount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      publicInstance<span class="token punctuation">.</span><span class="token method function property-access">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    renderedElement <span class="token operator">=</span> publicInstance<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Fonction composant</span>
    renderedElement <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// C’est récursif mais nous atteindrons finalement le bas de la récursion lorsque</span>
  <span class="token comment">// l’élément sera hôte (par exemple &#x3C;div />) au lieu de composite (par exemple &#x3C;App />) :</span>
  <span class="token keyword control-flow">return</span> <span class="token function">mount</span><span class="token punctuation">(</span>renderedElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Cette fonction gère uniquement les éléments avec un type hôte.</span>
<span class="token comment">// Par exemple, il gère &#x3C;div /> et &#x3C;p />, mais pas un &#x3C;App />.</span>
<span class="token keyword">function</span> <span class="token function">mountHost</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> props <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> children <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    children <span class="token operator">=</span> <span class="token punctuation">[</span>children<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  children <span class="token operator">=</span> children<span class="token punctuation">.</span><span class="token method function property-access">filter</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Ce bloc de code ne devrait pas être dans le réconciliateur.</span>
  <span class="token comment">// Les différents moteurs de rendu peuvent initialiser les nœuds différemment.</span>
  <span class="token comment">// Par exemple, React Native crée des vues iOS ou Android.</span>
  <span class="token keyword">var</span> node <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">createElement</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">propName</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>propName <span class="token operator">!==</span> <span class="token string">'children'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node<span class="token punctuation">.</span><span class="token method function property-access">setAttribute</span><span class="token punctuation">(</span>propName<span class="token punctuation">,</span> props<span class="token punctuation">[</span>propName<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Monte les enfants</span>
  children<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">childElement</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// L’enfant peut être hôte (par exemple &#x3C;div />) ou composite (par exemple &#x3C;Button />).</span>
    <span class="token comment">// Nous les monterons également de manière récursive :</span>
    <span class="token keyword">var</span> childNode <span class="token operator">=</span> <span class="token function">mount</span><span class="token punctuation">(</span>childElement<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Cette ligne de code est également spécifique au moteur de rendu.</span>
    <span class="token comment">// Ce serait différent en fonction du moteur de rendu :</span>
    node<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>childNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Renvoie le nœud DOM comme résultat de montage.</span>
  <span class="token comment">// C’est ici que se termine la récursion.</span>
  <span class="token keyword control-flow">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Composants définis par l’utilisateur</span>
    <span class="token keyword control-flow">return</span> <span class="token function">mountComposite</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Composants spécifiques aux plates-formes</span>
    <span class="token keyword control-flow">return</span> <span class="token function">mountHost</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> rootEl <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> node <span class="token operator">=</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
rootEl<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>Ça fonctionne mais ça reste loin de la manière dont le réconciliateur est réellement implémenté. L’ingrédient clé manquant est la prise en charge des mises à jour.</p>
      </section>
      <section id="introducing-internal-instances" class="level3">
        <h3>Voici venir les instances internes</h3>
        <p>La principale caractéristique de React est que vous pouvez refaire tout le rendu sans recréer le DOM ni réinitialiser l'état :</p>
        <pre class="language-js"><code class="language-js"><span class="token maybe-class-name">ReactDOM</span><span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Devrait réutiliser le DOM existant :</span>
<span class="token maybe-class-name">ReactDOM</span><span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>Cependant, notre implémentation ci-dessus sait uniquement monter l'arbre initial. Elle ne peut pas effectuer de mises à jour dans l'arborescence car elle ne stocke pas toutes les informations nécessaires, telles que toutes les références <code>publicInstance</code> ou les nœuds DOM qui correspondent aux composants.</p>
        <p>La base de code du réconciliateur <em>“stack”</em> résout ce problème en faisant de la fonction <code>mount()</code> une méthode au sein d’une classe. Cette approche présente des inconvénients et nous allons dans la direction opposée pour la <a href="./codebase-overview.html#fiber-reconciler">réécriture en cours du réconciliateur</a>. Cependant, voici comment ça fonctionne dans le réconciliateur historique.</p>
        <p>Plutôt que deux fonctions distinctes <code>mountHost</code> et <code>mountComposite</code>, nous créerons deux classes : <code>DOMComponent</code> et <code>CompositeComponent</code>.</p>
        <p>Les deux classes ont un constructeur acceptant <code>element</code>, ainsi qu'une méthode <code>mount()</code> qui renvoie le nœud monté. Nous remplacerons la fonction racine <code>mount()</code> par une fabrique <em>(factory, NdT)</em> qui instanciera la bonne classe :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Composants définis par l’utilisateur</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">CompositeComponent</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Composants spécifiques aux plates-formes</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">DOMComponent</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>Tout d’abord, examinons l'implémentation de <code>CompositeComponent</code> :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CompositeComponent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">publicInstance</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">getPublicInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Pour les composants composites, exposons l’instance de la classe.</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">publicInstance</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> element <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> props <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> publicInstance<span class="token punctuation">;</span>
    <span class="token keyword">var</span> renderedElement<span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isClass</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Composant basé classe</span>
      publicInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// Initialise les props</span>
      publicInstance<span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
      <span class="token comment">// Appelle le cycle de vie si besoin</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">.</span><span class="token property-access">componentWillMount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        publicInstance<span class="token punctuation">.</span><span class="token method function property-access">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      renderedElement <span class="token operator">=</span> publicInstance<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Fonction composant</span>
      publicInstance <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
      renderedElement <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Sauvegarde l’instance publique</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">publicInstance</span> <span class="token operator">=</span> publicInstance<span class="token punctuation">;</span>

    <span class="token comment">// Construit l’instance interne de l’enfant en fonction de l’élément.</span>
    <span class="token comment">// Ce sera un DOMComponent pour &#x3C;div /> ou &#x3C;p />,</span>
    <span class="token comment">// et un CompositeComponent pour &#x3C;App /> ou &#x3C;Button /> :</span>
    <span class="token keyword">var</span> renderedComponent <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>renderedElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span> <span class="token operator">=</span> renderedComponent<span class="token punctuation">;</span>

    <span class="token comment">// Monte le résultat du rendu</span>
    <span class="token keyword control-flow">return</span> renderedComponent<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>Ce n'est pas très différent de notre implémentation précédente de <code>mountComposite()</code>, mais maintenant, nous pouvons sauver certaines informations, telles que <code>this.currentElement</code>, <code>this.renderedComponent</code> et <code>this.publicInstance</code>, pour les utiliser lors des mises à jour d’éléments.</p>
        <p>Remarquez qu’une instance de <code>CompositeComponent</code> n’est pas la même chose qu’une instance du <code>element.type</code> fourni par l'utilisateur. <code>CompositeComponent</code> est un détail d'implémentation de notre réconciliateur et n'est jamais exposé à l'utilisateur. La classe définie par l'utilisateur est celle que nous avons lue dans <code>element.type</code>, et <code>CompositeComponent</code> crée une instance de celle-ci.</p>
        <p>Pour éviter toute confusion, nous appellerons les instances de <code>CompositeComponent</code> et <code>DOMComponent</code> des « instances internes ». Elles existent pour nous permettre de leur associer des données durables. Seuls le moteur de rendu et le réconciliateur s’en servent.</p>
        <p>En revanche, nous appelons une instance de classe définie par l'utilisateur « instance publique ». L'instance publique, c'est ce que vous voyez comme <code>this</code> dans <code>render()</code> et les autres méthodes de vos composants personnalisés.</p>
        <p>La fonction <code>mountHost()</code> a été refactorisée pour devenir la méthode <code>mount()</code> dans la classe <code>DOMComponent</code>, et son code a des airs familiers :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">DOMComponent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedChildren</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">getPublicInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Pour les composants DOM, expose uniquement le nœud du DOM.</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> element <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> props <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> children <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      children <span class="token operator">=</span> <span class="token punctuation">[</span>children<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Crée et sauvegarde le nœud</span>
    <span class="token keyword">var</span> node <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">createElement</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>

    <span class="token comment">// Initialise les attributs</span>
    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">propName</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>propName <span class="token operator">!==</span> <span class="token string">'children'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span><span class="token method function property-access">setAttribute</span><span class="token punctuation">(</span>propName<span class="token punctuation">,</span> props<span class="token punctuation">[</span>propName<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Crée et sauvegarde les enfants contenus.</span>
    <span class="token comment">// Chacun d’eux peut être un DOMComponent ou un CompositeComponent,</span>
    <span class="token comment">// selon que le type de l’élément est une chaîne de caractères ou une fonction.</span>
    <span class="token keyword">var</span> renderedChildren <span class="token operator">=</span> children<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span>instantiateComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedChildren</span> <span class="token operator">=</span> renderedChildren<span class="token punctuation">;</span>

    <span class="token comment">// Collecte les nœuds DOM qui sont renvoyés lors du montage</span>
    <span class="token keyword">var</span> childNodes <span class="token operator">=</span> renderedChildren<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token arrow operator">=></span> child<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    childNodes<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">childNode</span> <span class="token arrow operator">=></span> node<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>childNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Renvoie le nœud DOM comme résultat du montage</span>
    <span class="token keyword control-flow">return</span> node<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>Après la refactorisation de <code>mountHost()</code>, la différence principale est que nous conservons <code>this.node</code> et <code>this.renderedChildren</code>, qui sont maintenant associés à l'instance interne du composant DOM. Nous les utiliserons également à l'avenir pour appliquer des mises à jour non destructives.</p>
        <p>Par conséquent, chaque instance interne, composite ou hôte, pointe maintenant vers ses instances internes enfants. Pour vous aider à le visualiser, si une fonction composant <code>&#x3C;App></code> donne un composant basé classe <code>&#x3C;Button></code>, et qu’un <code>Button</code> donne une <code>&#x3C;div></code>, l'arbre des instances internes ressemblera à ceci :</p>
        <pre class="language-js"><code class="language-js"><span class="token punctuation">[</span>object <span class="token maybe-class-name">CompositeComponent</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">currentElement</span><span class="token operator">:</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span>
  <span class="token literal-property property">publicInstance</span><span class="token operator">:</span> <span class="token keyword null nil">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">renderedComponent</span><span class="token operator">:</span> <span class="token punctuation">[</span>object <span class="token maybe-class-name">CompositeComponent</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">currentElement</span><span class="token operator">:</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Button</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span>
    <span class="token literal-property property">publicInstance</span><span class="token operator">:</span> <span class="token punctuation">[</span>object <span class="token maybe-class-name">Button</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token literal-property property">renderedComponent</span><span class="token operator">:</span> <span class="token punctuation">[</span>object <span class="token maybe-class-name">DOMComponent</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">currentElement</span><span class="token operator">:</span> <span class="token operator">&#x3C;</span>div <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span>
      <span class="token literal-property property">node</span><span class="token operator">:</span> <span class="token punctuation">[</span>object <span class="token maybe-class-name">HTMLDivElement</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token literal-property property">renderedChildren</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>Dans le DOM, vous verriez uniquement la <code>&#x3C;div></code>. Pourtant, l’arbre d’instances internes contient tant les instances internes composites que celles hôtes.</p>
        <p>Les instances internes composites ont besoin de stocker :</p>
        <ul>
          <li>L'élément actuel.</li>
          <li>L'instance publique si le type de l'élément est une classe.</li>
          <li>L’instance interne unique produite par le rendu. Il peut s'agir d'un <code>DOMComponent</code> ou d’un <code>CompositeComponent</code>.</li>
        </ul>
        <p>Les instances internes hôtes ont besoin de stocker :</p>
        <ul>
          <li>L'élément actuel.</li>
          <li>Le nœud DOM.</li>
          <li>Toutes les instances internes enfants. Chacune d’elles peut être soit un <code>DOMComponent</code> soit un <code>CompositeComponent</code>.</li>
        </ul>
        <p>Si vous avez du mal à imaginer la structure d’un arbre d’instances internes dans des applications plus complexes, <a href="https://github.com/facebook/react-devtools">React DevTools</a> peut vous donner une bonne approximation, dans la mesure où il signale les instances hôtes en gris, et les instances composites en violet :</p>
        <img src="./docs/implementation-notes-tree.png" width="500" style="max-width: 100%" alt="Arbre React DevTools">
        <p>Pour terminer cette refactorisation, nous allons introduire une fonction qui monte une arbre complet dans un nœud conteneur, tout comme <code>ReactDOM.render()</code>. Elle renvoie une instance publique, là aussi comme <code>ReactDOM.render()</code> :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> containerNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Crée une instance interne racine</span>
  <span class="token keyword">var</span> rootComponent <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Monte le composant racine dans le conteneur</span>
  <span class="token keyword">var</span> node <span class="token operator">=</span> rootComponent<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  containerNode<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Renvoie l’instance publique fournie</span>
  <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> rootComponent<span class="token punctuation">.</span><span class="token method function property-access">getPublicInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> publicInstance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> rootEl <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </section>
      <section id="unmounting" class="level3">
        <h3>Démontage</h3>
        <p>Maintenant que nous avons des instances internes qui conservent leurs enfants et les nœuds DOM, nous pouvons implémenter le démontage. Pour un composant composite, le démontage appelle une méthode de cycle de vie et opère récursivement.</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CompositeComponent</span> <span class="token punctuation">{</span>

  <span class="token comment">// ...</span>

  <span class="token function">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Appelle la méthode de cycle de vie si besoin</span>
    <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">publicInstance</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">.</span><span class="token property-access">componentWillUnmount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        publicInstance<span class="token punctuation">.</span><span class="token method function property-access">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Démonte l’unique composant affiché</span>
    <span class="token keyword">var</span> renderedComponent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span><span class="token punctuation">;</span>
    renderedComponent<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>Pour <code>DOMComponent</code>, le démontage appelle celui de chaque enfant :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">DOMComponent</span> <span class="token punctuation">{</span>

  <span class="token comment">// ...</span>

  <span class="token function">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Démonte tous les éléments enfants</span>
    <span class="token keyword">var</span> renderedChildren <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedChildren</span><span class="token punctuation">;</span>
    renderedChildren<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token arrow operator">=></span> child<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>En pratique, le démontage des composants DOM enlève également les écouteurs d'événements et efface certains caches, mais nous ignorerons ces détails.</p>
        <p>Nous pouvons maintenant ajouter une nouvelle fonction racine appelée <code>unmountTree(containerNode)</code>, semblable à <code>ReactDOM.unmountComponentAtNode()</code> :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">unmountTree</span><span class="token punctuation">(</span><span class="token parameter">containerNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Lit l’instance interne depuis un nœud DOM :</span>
  <span class="token comment">// (Ça ne fonctionne pas encore, il faudra changer mountTree() pour le stocker.)</span>
  <span class="token keyword">var</span> node <span class="token operator">=</span> containerNode<span class="token punctuation">.</span><span class="token property-access">firstChild</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> rootComponent <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token property-access">_internalInstance</span><span class="token punctuation">;</span>

  <span class="token comment">// Démonte l’arbre et efface le conteneur</span>
  rootComponent<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  containerNode<span class="token punctuation">.</span><span class="token property-access">innerHTML</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
        <p>Pour que ça fonctionne, nous devons lire une instance interne racine à partir d'un nœud DOM. Nous modifierons <code>mountTree()</code> pour ajouter la propriété <code>_internalInstance</code> au nœud DOM racine. Nous apprendrons aussi à <code>mountTree()</code> à détruire n'importe quel arbre existant, donc nous pourrons l'appeler plusieurs fois :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> containerNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Détruit un éventuel arbre existant</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>containerNode<span class="token punctuation">.</span><span class="token property-access">firstChild</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">unmountTree</span><span class="token punctuation">(</span>containerNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Crée l’instance interne racine</span>
  <span class="token keyword">var</span> rootComponent <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Monte le composant racine dans un conteneur</span>
  <span class="token keyword">var</span> node <span class="token operator">=</span> rootComponent<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  containerNode<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Sauvegarde une référence à l’instance interne</span>
  node<span class="token punctuation">.</span><span class="token property-access">_internalInstance</span> <span class="token operator">=</span> rootComponent<span class="token punctuation">;</span>

  <span class="token comment">// Renvoie l’instance publique fournie</span>
  <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> rootComponent<span class="token punctuation">.</span><span class="token method function property-access">getPublicInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> publicInstance<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
        <p>À présent, l’exécution répétée de <code>unmountTree()</code> ou de <code>mountTree()</code> supprime l’ancien arbre et exécute la méthode de cycle de vie <code>componentWillUnmount()</code> sur les composants.</p>
      </section>
      <section id="updating" class="level3">
        <h3>Mise à jour</h3>
        <p>Dans la section précédente, nous avons implémenté le démontage. Cependant, React ne serait pas très utile si à chaque modification de prop, l'arbre entier était démonté puis remonté. Le but du réconciliateur est de réutiliser dans la mesure du possible les instances existantes afin de préserver le DOM et l’état local :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">var</span> rootEl <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Devrait réutiliser le DOM existant :</span>
<span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>Nous allons ajouter une méthode supplémentaire au contrat de nos instances internes. En plus de <code>mount()</code> et <code>unmount()</code>, <code>DOMComponent</code> et <code>CompositeComponent</code> implémenteront une nouvelle méthode appelée <code>receive(nextElement)</code> :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CompositeComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token function">receive</span><span class="token punctuation">(</span><span class="token parameter">nextElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">DOMComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token function">receive</span><span class="token punctuation">(</span><span class="token parameter">nextElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>Son travail consiste à faire tout le nécessaire pour mettre à jour le composant (et ses enfants) avec la description fournie par <code>nextElement</code>.</p>
        <p>C’est la partie qui est souvent décrite comme la « comparaison de DOM virtuel » <em>(virtual DOM diffing, NdT)</em>, même si ça consiste en réalité à parcourir récursivement l'arbre interne pour permettre à chaque instance interne de recevoir une mise à jour.</p>
      </section>
      <section id="updating-composite-components" class="level3">
        <h3>Mise à jour des composants composites</h3>
        <p>Lorsqu'un composant composite reçoit un nouvel élément, nous exécutons la méthode de cycle de vie <code>componentWillUpdate()</code>.</p>
        <p>Ensuite nous rafraîchissons le composant avec les nouvelles props et récupérons le prochain élément issu du rendu :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CompositeComponent</span> <span class="token punctuation">{</span>

  <span class="token comment">// ...</span>

  <span class="token function">receive</span><span class="token punctuation">(</span><span class="token parameter">nextElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> prevProps <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">publicInstance</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevRenderedComponent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevRenderedElement <span class="token operator">=</span> prevRenderedComponent<span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">;</span>

    <span class="token comment">// Met à jour l’élément *associé*</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span> <span class="token operator">=</span> nextElement<span class="token punctuation">;</span>
    <span class="token keyword">var</span> type <span class="token operator">=</span> nextElement<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nextProps <span class="token operator">=</span> nextElement<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>

    <span class="token comment">// Détermine quel est le prochain résultat de render()</span>
    <span class="token keyword">var</span> nextRenderedElement<span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isClass</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Composant basé classe</span>
      <span class="token comment">// Appelle le cycle de vie si besoin</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">.</span><span class="token property-access">componentWillUpdate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        publicInstance<span class="token punctuation">.</span><span class="token method function property-access">componentWillUpdate</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// Met à jour les props</span>
      publicInstance<span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">=</span> nextProps<span class="token punctuation">;</span>
      <span class="token comment">// Rafraîchit</span>
      nextRenderedElement <span class="token operator">=</span> publicInstance<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Fonction composant</span>
      nextRenderedElement <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ...</span></code></pre>
        <p>Ensuite, nous pouvons regarder le <code>type</code> de l'élément produit. Si le <code>type</code> n'a pas changé depuis le dernier rendu, le composant sous-jacent peut être mis à jour directement.</p>
        <p>Par exemple, s'il renvoie <code>&#x3C;Button color="red" /></code> la première fois et <code>&#x3C;Button color="blue" /></code> la seconde fois, nous pouvons simplement dire à l'instance interne correspondante de recevoir (<code>receive()</code>) l'élément mis à jour :</p>
        <pre class="language-js"><code class="language-js">    <span class="token comment">// ...</span>

    <span class="token comment">// Si le type de l’élément affiché n’a pas changé,</span>
    <span class="token comment">// réutilise l’instance du composant existant et sort.</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>prevRenderedElement<span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token operator">===</span> nextRenderedElement<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      prevRenderedComponent<span class="token punctuation">.</span><span class="token method function property-access">receive</span><span class="token punctuation">(</span>nextRenderedElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ...</span></code></pre>
        <p>Cependant, si l’élément mis à jour a un <code>type</code> différent de celui affiché jusqu'ici, nous ne pouvons pas mettre à jour l’instance interne. Un <code>&#x3C;button></code> ne peut pas simplement « devenir » un <code>&#x3C;input></code>.</p>
        <p>Dans ce cas, nous devons démonter l'instance interne existante et monter la nouvelle correspondant au type du nouvel élément. Par exemple, voici ce qui se produit lorsqu'un composant ayant précédemment affiché un <code>&#x3C;button /></code> affiche désormais un <code>&#x3C;input /></code> :</p>
        <pre class="language-js"><code class="language-js">    <span class="token comment">// ...</span>

    <span class="token comment">// Si nous arrivons jusqu’ici, nous devons démonter le composant</span>
    <span class="token comment">// précédemment monté, monter le nouveau et échanger leurs nœuds.</span>

    <span class="token comment">// Récupère l’ancien nœud car il devra être remplacé</span>
    <span class="token keyword">var</span> prevNode <span class="token operator">=</span> prevRenderedComponent<span class="token punctuation">.</span><span class="token method function property-access">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Démonte l’ancien élément enfant et en monte un nouveau</span>
    prevRenderedComponent<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nextRenderedComponent <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>nextRenderedElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nextNode <span class="token operator">=</span> nextRenderedComponent<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Remplace la référence à l’enfant</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span> <span class="token operator">=</span> nextRenderedComponent<span class="token punctuation">;</span>

    <span class="token comment">// Remplace l’ancien nœud par le nouveau.</span>
    <span class="token comment">// Remarque : il s’agit d’un code spécifique au moteur de rendu et</span>
    <span class="token comment">// idéalement il devrait vivre en dehors de CompositeComponent :</span>
    prevNode<span class="token punctuation">.</span><span class="token property-access">parentNode</span><span class="token punctuation">.</span><span class="token method function property-access">replaceChild</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">,</span> prevNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>En résumé, lorsqu'un composant composite reçoit un nouvel élément, il peut soit déléguer la mise à jour à son instance interne issue du rendu précédent, soit la démonter et en monter une nouvelle en remplacement.</p>
        <p>Il existe un autre cas dans lequel un composant va être remonté plutôt que de recevoir un élément : lorsque la <code>key</code> de cet élément a été modifiée. Nous ne voyons pas la gestion des <code>key</code> dans ce document, car elle ajoute une complexité supplémentaire à un tutoriel déjà velu.</p>
        <p>Remarquez que nous devons encore ajouter une méthode appelée <code>getHostNode()</code> à l'instance interne afin qu'il soit possible de localiser le nœud spécifique à la plate-forme et de le remplacer lors de la mise à jour. Son implémentation est simple pour les deux classes :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CompositeComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token function">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Demande au composant issu du rendu de le fournir.</span>
    <span class="token comment">// Ça analysera récursivement tous les composites.</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span><span class="token punctuation">.</span><span class="token method function property-access">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">DOMComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token function">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
      </section>
      <section id="updating-host-components" class="level3">
        <h3>Mise à jour des composants hôtes</h3>
        <p>Les implémentations de composant hôte, comme <code>DOMComponent</code>, font leurs mises à jour différemment. À la réception d’un élément, ils ont besoin de mettre à jour la vue spécifique à la plate-forme sous-jacente. Dans le cas de React DOM, ça implique de mettre à jour les attributs DOM :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">DOMComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token function">receive</span><span class="token punctuation">(</span><span class="token parameter">nextElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevElement <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevProps <span class="token operator">=</span> prevElement<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nextProps <span class="token operator">=</span> nextElement<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span> <span class="token operator">=</span> nextElement<span class="token punctuation">;</span>

    <span class="token comment">// Supprime les anciens attributs.</span>
    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">propName</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>propName <span class="token operator">!==</span> <span class="token string">'children'</span> <span class="token operator">&#x26;&#x26;</span> <span class="token operator">!</span>nextProps<span class="token punctuation">.</span><span class="token method function property-access">hasOwnProperty</span><span class="token punctuation">(</span>propName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span><span class="token method function property-access">removeAttribute</span><span class="token punctuation">(</span>propName<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Initialise les nouveaux attributs.</span>
    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">propName</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>propName <span class="token operator">!==</span> <span class="token string">'children'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span><span class="token method function property-access">setAttribute</span><span class="token punctuation">(</span>propName<span class="token punctuation">,</span> nextProps<span class="token punctuation">[</span>propName<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// ...</span></code></pre>
        <p>Ensuite, les composants hôtes doivent mettre à jour leurs enfants. Contrairement aux composants composites, ils peuvent posséder plusieurs enfants.</p>
        <p>Dans cet exemple simplifié, nous utilisons un tableau d'instances internes et itérons dessus. Si le <code>type</code> reçu des instances internes correspond au <code>type</code> précédent, nous les mettons à jour, sinon nous les remplaçons. Le vrai réconciliateur prend également en compte la <code>key</code> de l'élément et détecte les déplacements en plus des insertions et des suppressions, mais nous omettons cette logique.</p>
        <p>Nous collectons les opérations DOM sur les enfants dans une liste, afin de pouvoir les exécuter par lot :</p>
        <pre class="language-js"><code class="language-js">    <span class="token comment">// ...</span>

    <span class="token comment">// Ce sont des tableaux d’éléments React :</span>
    <span class="token keyword">var</span> prevChildren <span class="token operator">=</span> prevProps<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      prevChildren <span class="token operator">=</span> <span class="token punctuation">[</span>prevChildren<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> nextChildren <span class="token operator">=</span> nextProps<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nextChildren <span class="token operator">=</span> <span class="token punctuation">[</span>nextChildren<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Ce sont des tableaux d’instances internes :</span>
    <span class="token keyword">var</span> prevRenderedChildren <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedChildren</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nextRenderedChildren <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// Au fil de l’itération sur les enfants, nous ajouterons des opérations dans le tableau.</span>
    <span class="token keyword">var</span> operationQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// Remarque : la section ci-dessous est extrêmement simplifiée !</span>
    <span class="token comment">// Elle ne gère pas le réordonnancement, les enfants avec des trous ou les clés (`key`).</span>
    <span class="token comment">// Elle existe uniquement pour illustrer le flux général, pas les détails.</span>

    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> nextChildren<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Essaie de récupérer une instance interne existante pour cet enfant</span>
      <span class="token keyword">var</span> prevChild <span class="token operator">=</span> prevRenderedChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

      <span class="token comment">// S’il n’y a aucune instance interne pour cet index,</span>
      <span class="token comment">// c’est qu’un enfant a été ajouté à la fin. Nous créons une nouvelle</span>
      <span class="token comment">// instance interne, nous la montons, et nous utilisons son nœud.</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prevChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> nextChild <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> node <span class="token operator">=</span> nextChild<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Enregistre le besoin d'ajouter un nœud</span>
        operationQueue<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'ADD'</span><span class="token punctuation">,</span> node<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nextRenderedChildren<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>nextChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">continue</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// Nous ne pouvons mettre à jour l’instance que si le type de son élément est identique.</span>
      <span class="token comment">// Par exemple, &#x3C;Button size="small" /> peut être mis à jour par</span>
      <span class="token comment">// &#x3C;Button size="large" /> mais pas par un &#x3C;App />.</span>
      <span class="token keyword">var</span> canUpdate <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token operator">===</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>

      <span class="token comment">// Si nous ne pouvons pas mettre à jour une instance existante, nous devons la démonter</span>
      <span class="token comment">// et monter une nouvelle à la place.</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>canUpdate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> prevNode <span class="token operator">=</span> prevChild<span class="token punctuation">.</span><span class="token method function property-access">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        prevChild<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">var</span> nextChild <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> nextNode <span class="token operator">=</span> nextChild<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Enregistre le besoin de remplacer un nœud</span>
        operationQueue<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'REPLACE'</span><span class="token punctuation">,</span> prevNode<span class="token punctuation">,</span> nextNode<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nextRenderedChildren<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>nextChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">continue</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// Si nous pouvons mettre à jour une instance existante,</span>
      <span class="token comment">// laissons-la simplement recevoir l’élément cible et gérer sa propre mise à jour.</span>
      prevChild<span class="token punctuation">.</span><span class="token method function property-access">receive</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      nextRenderedChildren<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>prevChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Enfin, démonte tous les enfants qui n’existent pas :</span>
    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> nextChildren<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> j <span class="token operator">&#x3C;</span> prevChildren<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> prevChild <span class="token operator">=</span> prevRenderedChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> node <span class="token operator">=</span> prevChild<span class="token punctuation">.</span><span class="token method function property-access">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      prevChild<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// Enregistre le besoin de supprimer un nœud</span>
      operationQueue<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'REMOVE'</span><span class="token punctuation">,</span> node<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Actualise la liste des enfants issus du rendu.</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedChildren</span> <span class="token operator">=</span> nextRenderedChildren<span class="token punctuation">;</span>

    <span class="token comment">// ...</span></code></pre>
        <p>Pour finir, nous exécutons les opérations sur le DOM. Encore une fois, le vrai code du réconciliateur est plus complexe car il gère également les déplacements :</p>
        <pre class="language-js"><code class="language-js">    <span class="token comment">// ...</span>

    <span class="token comment">// Traite les opérations dans la file d’attente</span>
    <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span>operationQueue<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> operation <span class="token operator">=</span> operationQueue<span class="token punctuation">.</span><span class="token method function property-access">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">switch</span> <span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">'ADD'</span><span class="token operator">:</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token string">'REPLACE'</span><span class="token operator">:</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">.</span><span class="token method function property-access">replaceChild</span><span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token property-access">nextNode</span><span class="token punctuation">,</span> operation<span class="token punctuation">.</span><span class="token property-access">prevNode</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token string">'REMOVE'</span><span class="token operator">:</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">.</span><span class="token method function property-access">removeChild</span><span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>Et c'est tout pour la mise à jour des composants hôtes.</p>
      </section>
      <section id="top-level-updates" class="level3">
        <h3>Mise à jour de la racine</h3>
        <p>Maintenant que <code>CompositeComponent</code> et <code>DOMComponent</code> implémentent la méthode <code>receive(nextElement)</code>, nous pouvons modifier la fonction racine <code>mountTree()</code> pour l’utiliser lorsque le <code>type</code> de l’élément est identique à celui de la dernière fois :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> containerNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Vérifie l'existence d’un arbre</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>containerNode<span class="token punctuation">.</span><span class="token property-access">firstChild</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> prevNode <span class="token operator">=</span> containerNode<span class="token punctuation">.</span><span class="token property-access">firstChild</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevRootComponent <span class="token operator">=</span> prevNode<span class="token punctuation">.</span><span class="token property-access">_internalInstance</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevElement <span class="token operator">=</span> prevRootComponent<span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">;</span>

    <span class="token comment">// Si possible, réutilise le composant racine existant</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>prevElement<span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token operator">===</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      prevRootComponent<span class="token punctuation">.</span><span class="token method function property-access">receive</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Autrement, démonte l’arborescence existante</span>
    <span class="token function">unmountTree</span><span class="token punctuation">(</span>containerNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// ...</span>

<span class="token punctuation">}</span></code></pre>
        <p>Désormais, appeler deux fois <code>mountTree()</code> avec le même type n’est plus destructif :</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">var</span> rootEl <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Réutilise le DOM existant :</span>
<span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>Et voilà les bases du fonctionnement interne de React.</p>
      </section>
      <section id="what-we-left-out" class="level3">
        <h3>Ce que nous avons laissé de côté</h3>
        <p>Ce document est simplifié par rapport au vrai code. Il y a quelques aspects importants que nous n'avons pas abordés :</p>
        <ul>
          <li>Les composants peuvent faire un rendu à <code>null</code> et le réconciliateur peut gérer des « emplacements vides » dans les tableaux et le résultat du rendu.</li>
          <li>Le réconciliateur lit également la <code>key</code> des éléments, et l'utilise pour déterminer quelle instance interne correspond à quel élément dans un tableau. Une grande partie de la complexité de la véritable implémentation de React est liée à ça.</li>
          <li>En plus des classes d’instance interne composite et hôte, il existe également des classes pour les composants « texte » et « vide ». Ils représentent des nœuds de texte et des « emplacements vides » que vous obtenez en faisant un rendu <code>null</code>.</li>
          <li>Les moteurs de rendu utilisent l'<a href="./codebase-overview.html#dynamic-injection">injection</a> pour passer la classe interne hôte au réconciliateur. Par exemple, React DOM indique au réconciliateur d'utiliser <code>ReactDOMComponent</code> pour l'implémentation de l'instance interne hôte.</li>
          <li>La logique de mise à jour de la liste des enfants est extraite dans un <em>mixin</em> appelé <code>ReactMultiChild</code>, utilisé par les implémentations de la classe d'instance interne hôte dans React DOM comme dans React Native.</li>
          <li>Le réconciliateur implémente également la prise en charge de <code>setState()</code> dans les composants composites. Les mises à jour d'état multiples dans les gestionnaires d'événements sont regroupées en lot pour une mise à jour unique.</li>
          <li>Le réconciliateur prend également en charge l’attachement et le détachement des refs aux composants composites et aux nœuds hôtes.</li>
          <li>Les méthodes de cycle de vie appelées une fois que le DOM est prêt, telles que <code>componentDidMount()</code> et <code>componentDidUpdate()</code>, sont rassemblées dans des « files d'attente de fonctions de rappel » et exécutées en un seul lot.</li>
          <li>React stocke les informations sur la mise à jour en cours dans un objet interne appelé « transaction ». Les transactions sont utiles pour garder trace de la liste des méthodes de cycle de vie en attente, de l'imbrication actuelle du DOM pour les avertissements et de tout ce qui est « global » à une mise à jour spécifique. Les transactions garantissent également que React « nettoie tout » après les mises à jour. Par exemple, la classe de transaction fournie par React DOM restaure après toute mise à jour l’éventuelle sélection d'une saisie.</li>
        </ul>
      </section>
      <section id="jumping-into-the-code" class="level3">
        <h3>Sauter dans le code</h3>
        <ul>
          <li>
            <p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/dom/client/ReactMount.js"><code>ReactMount</code></a> est l'endroit où réside le code équivalent aux <code>mountTree()</code> et <code>unmountTree()</code> de ce tutoriel. Il s'occupe du montage et du démontage des composants racines. <a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/native/ReactNativeMount.js"><code>ReactNativeMount</code></a> est son homologue pour React Native.</p>
          </li>
          <li>
            <p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/dom/shared/ReactDOMComponent.js"><code>ReactDOMComponent</code></a> est l'équivalent de <code>DOMComponent</code> dans ce tutoriel. Il implémente la classe de composant hôte pour le moteur de rendu de React DOM. <a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/native/ReactNativeBaseComponent.js"><code>ReactNativeBaseComponent</code></a> est son équivalent React Native.</p>
          </li>
          <li>
            <p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js"><code>ReactCompositeComponent</code></a> est l'équivalent de <code>CompositeComponent</code> dans ce tutoriel. Il gère l'appel des composants définis par l'utilisateur et la maintenance de leur état local.</p>
          </li>
          <li>
            <p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/instantiateReactComponent.js"><code>instantiateReactComponent</code></a> contient le code qui sélectionne la classe d'instance interne appropriée pour construire un élément. C'est l'équivalent de <code>instantiateComponent()</code> dans ce tutoriel.</p>
          </li>
          <li>
            <p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/ReactReconciler.js"><code>ReactReconciler</code></a> est un enrobage avec les méthodes <code>mountComponent()</code>, <code>receiveComponent()</code> et <code>unmountComponent()</code>. Il appelle les implémentations sous-jacentes des instances internes, mais contient en prime du code de gestion partagé par toutes ces implémentations.</p>
          </li>
          <li>
            <p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/ReactChildReconciler.js"><code>ReactChildReconciler</code></a> implémente la logique de montage, de mise à jour et de démontage des enfants en fonction de la <code>key</code> de leurs éléments.</p>
          </li>
          <li>
            <p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/ReactMultiChild.js"><code>ReactMultiChild</code></a> implémente le traitement de la file d'attente des opérations pour les insertions, les suppressions et les déplacements d'enfants indépendamment du moteur de rendu.</p>
          </li>
          <li>
            <p><code>mount()</code>, <code>receive()</code> et <code>unmount()</code> sont nommées en réalité <code>mountComponent()</code>, <code>receiveComponent()</code> et <code>unmountComponent()</code> dans la base de code React pour des raisons historiques, mais elles reçoivent des éléments.</p>
          </li>
          <li>
            <p>Les propriétés des instances internes commencent par un tiret bas <em>(underscore, NdT)</em>, par exemple <code>_currentElement</code>. Elles sont considérées dans la base de code comme des champs publics en lecture seule.</p>
          </li>
        </ul>
      </section>
      <section id="future-directions" class="level3">
        <h3>Orientations futures</h3>
        <p>Le réconciliateur <em>“stack”</em> a des limitations intrinsèques, comme le fait qu'il soit synchrone et incapable d'interrompre le travail ou de le découper en plusieurs morceaux. Le <a href="./codebase-overview.html#fiber-reconciler">nouveau réconciliateur <em>“fiber”</em></a> a une <a href="https://github.com/acdlite/react-fiber-architecture">architecture complètement différente</a>. À partir de React 16, il remplace le réconciliateur <em>“stack”</em>.</p>
      </section>
      <section id="next-steps" class="level3">
        <h3>Prochaines étapes</h3>
        <p>
          Lisez la <a href="./design-principles.html">page suivante</a> pour en apprendre davantage sur les principes de conception que nous utilisons pour le développement de React.
          <span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span>
        </p>
      </section>
    </section>
  </body>
</html>
