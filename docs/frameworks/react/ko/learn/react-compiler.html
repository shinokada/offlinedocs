<!doctype html><html lang="ko"><meta charset="utf-8"><title>React 컴파일러</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"type="text/css"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="react-컴파일러"><h1 id="react-컴파일러">React 컴파일러</h1><intro>이 페이지는 새로운 실험적 React 컴파일러에 대한 소개와 이를 성공적으로 시도하는 방법을 제공합니다.</intro><wip>이 문서는 아직 작업 중입니다. 더 많은 정보는 [React 컴파일러 워킹 그룹 저장소](https://github.com/reactwg/react-compiler/discussions)에서 확인할 수 있으며, React 컴파일러가 더 안정화되면 이 문서에 반영될 것입니다.</wip><youwilllearn><ul><li>컴파일러 시작하기<li>컴파일러 및 eslint 플러그인 설치<li>문제 해결</ul></youwilllearn><note>React 컴파일러는 커뮤니티로부터 초기 피드백을 받기 위해 오픈소스로 공개된 새로운 실험적 컴파일러입니다. 아직 안정적이지 않으며 프로덕션 환경에서는 완전히 준비되지 않았습니다.<p>React 컴파일러는 React 19 RC를 필요로 합니다. React 19로 업그레이드할 수 없는 경우 <a href="https://github.com/reactwg/react-compiler/discussions/6">워킹 그룹</a>에 설명된 대로 사용자 공간 캐시 함수 구현을 시도해 볼 수 있습니다. 그러나 이 방법은 권장하지 않으며 가능한 한 React 19로 업그레이드하는 것이 좋습니다.<p>React 컴파일러는 빌드 타임 전용 도구로 React 앱을 자동으로 최적화합니다. 순수 JavaScript로 동작하며 <a href="/reference/rules">React의 규칙</a>을 이해하므로 코드를 다시 작성할 필요가 없습니다.<p>컴파일러에는 에디터 내에서 분석 결과를 보여주는 <a href="#installing-eslint-plugin-react-compiler">eslint 플러그인</a>도 포함되어 있습니다. 이 플러그인은 컴파일러와 독립적으로 실행되며, 앱에서 컴파일러를 사용하지 않는 경우에도 사용할 수 있습니다. 모든 React 개발자에게 코드베이스의 품질을 향상하기 위해 이 eslint 플러그인을 사용할 것을 권장합니다.<section class="level3"aria-labelledby="컴파일러는-무엇을-하나요-what-does-the-compiler-do"><h3 id="컴파일러는-무엇을-하나요-what-does-the-compiler-do">컴파일러는 무엇을 하나요? {/<em>what-does-the-compiler-do</em>/}</h3><p>React 컴파일러는 애플리케이션을 최적화하기 위해 코드를 자동으로 메모이제이션합니다. 이미 <code>useMemo</code>, <code>useCallback</code>, <code>React.memo</code>와 같은 API를 통해 적용하는 메모이제이션에 익숙할 것입니다. 이러한 API를 사용하면 React에 입력이 변경되지 않았다면 특정 부분을 다시 계산할 필요가 없다고 알릴 수 있어 업데이트 시 작업을 줄일 수 있습니다. 이 방법은 강력하지만 메모이제이션을 적용하는 것을 잊거나 잘못 적용할 수도 있습니다. 이 경우 React가 <em>의미 있는</em> 변경 사항이 없는 UI 일부를 확인해야 하므로 효율적이지 않을 수 있습니다.<p>컴파일러는 JavaScript와 React의 규칙에 대한 지식을 활용하여 자동으로 컴포넌트와 Hooks 내의 값 또는 값 그룹을 메모이제이션 합니다. 규칙 위반을 감지할 경우 해당 컴포넌트 또는 Hooks를 건너뛰고 다른 코드를 안전하게 컴파일합니다.<p>이미 코드베이스에 메모이제이션이 잘 되어 있다면, 컴파일러를 통해 주요 성능 향상을 기대하기 어려울 수 있습니다. 그러나 실제로 성능 문제를 일으키는 올바른 의존성을 메모이제이션 하는 것은 수작업으로 처리하기 까다로울 수 있습니다.</p><deepdive>#### React Compiler은 어떤 것을 메모이제이션 하나요? {/*what-kind-of-memoization-does-react-compiler-add*/}<p>React 컴파일러의 초기 릴리즈는 주로 <strong>업데이트 성능 개선</strong>(기존 컴포넌트의 리렌더링)에 초점을 맞추었으므로 다음 두 가지 사용 사례에 중점을 두고 있습니다.<ol><li><strong>컴포넌트의 연쇄적인 리렌더링 건너뛰기</strong><ul><li><code>&#x3C;Parent /></code>를 리렌더링하면 <code>&#x3C;Parent /></code>만이 변경되었음에도 불구하고 그 컴포넌트 트리 내의 많은 컴포넌트가 리렌더링되는 경우</ul><li><strong>React 외부에서의 비용이 많이 드는 계산 건너뛰기</strong><ul><li>데이터가 필요한 컴포넌트나 Hook 내에서 <code>expensivelyProcessAReallyLargeArrayOfObjects()</code>를 호출하는 경우</ul></ol><section class="level4"aria-labelledby="리렌더링-최적화-optimizing-re-renders"><h4 id="리렌더링-최적화-optimizing-re-renders">리렌더링 최적화 {/<em>optimizing-re-renders</em>/}</h4><p>React는 props, state, context와 같은 현재 state에 대한 함수로 UI를 표현할 수 있도록 해줍니다. <code>useMemo()</code>, <code>useCallback()</code>, <code>React.memo()</code>로 수동 메모이제이션을 적용하지 않은 경우에 현재 구현에서 컴포넌트의 state가 변경되면, React는 해당 컴포넌트와 <em>하위 모든 자식 컴포넌트</em> 를 리렌더링합니다. 예를 들어 다음 예시에서는 <code>&#x3C;FriendList></code>의 state가 변경될 때마다 <code>&#x3C;MessageButton></code>이 리렌더링됩니다.<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">FriendList</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> friends <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> onlineCount <span class="token operator">=</span> <span class="token function">useFriendOnlineCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>friends<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">NoFriends</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>span<span class="token operator">></span><span class="token punctuation">{</span>onlineCount<span class="token punctuation">}</span> online<span class="token operator">&#x3C;</span><span class="token operator">/</span>span<span class="token operator">></span>
      <span class="token punctuation">{</span>friends<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">friend</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span>
        <span class="token operator">&#x3C;</span><span class="token maybe-class-name">FriendListCard</span> key<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">}</span> friend<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">MessageButton</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><a href="https://playground.react.dev/#N4Igzg9grgTgxgUxALhAMygOzgFwJYSYAEAYjHgpgCYAyeYOAFMEWuZVWEQL4CURwADrEicQgyKEANnkwIAwtEw4iAXiJQwCMhWoB5TDLmKsTXgG5hRInjRFGbXZwB0UygHMcACzWr1ABn4hEWsYBBxYYgAeADkIHQ4uAHoAPksRbisiMIiYYkYs6yiqPAA3FMLrIiiwAAcAQ0wU4GlZBSUcbklDNqikusaKkKrgR0TnAFt62sYHdmp+VRT7SqrqhOo6Bnl6mCoiAGsEAE9VUfmqZzwqLrHqM7ubolTVol5eTOGigFkEMDB6u4EAAhKA4HCEZ5DNZ9ErlLIWYTcEDcIA"><em>React 컴파일러 플레이그라운드에서 이 예시를 확인하세요</em></a><p>React 컴파일러는 상태 변경 시 앱에서 관련된 부분만 리렌더링되도록 수동 메모이제이션과 동등한 기능을 자동으로 적용합니다. 이를 "세분화된 반응성(fine-grained reactivity)"이라고도 부릅니다. 위 예시에서 React 컴파일러는 <code>friends</code>가 변경되더라도 <code>&#x3C;FriendListCard /></code>의 반환 값이 재사용될 수 있음을 결정하고, JSX를 재생성하지 않고 <code>&#x3C;MessageButton></code>의 리렌더링도 피할 수 있습니다.</section><section class="level4"aria-labelledby="비용이-많이-드는-계산-메모이제이션-expensive-calculations-also-get-memoized"><h4 id="비용이-많이-드는-계산-메모이제이션-expensive-calculations-also-get-memoized">비용이 많이 드는 계산 메모이제이션 {/<em>expensive-calculations-also-get-memoized</em>/}</h4><p>컴파일러는 렌더링 도중 비용이 많이 드는 계산에 대해 자동으로 메모이제이션을 적용할 수도 있습니다.<pre class="language-js"><code class="language-js"><span class="token comment">// 컴포넌트나 Hook이 아니기 때문에 React 컴파일러에 의해 **메모이제이션 되지 않습니다**</span>
<span class="token keyword">function</span> <span class="token function">expensivelyProcessAReallyLargeArrayOfObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token comment">// 컴포넌트이기 때문에 React 컴파일러에 의해 메모이제이션 됩니다</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">TableContainer</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> items <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 이 함수 호출은 메모이제이션 될 것입니다</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">expensivelyProcessAReallyLargeArrayOfObjects</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p><a href="https://playground.react.dev/#N4Igzg9grgTgxgUxALhAejQAgFTYHIQAuumAtgqRAJYBeCAJpgEYCemASggIZyGYDCEUgAcqAGwQwANJjBUAdokyEAFlTCZ1meUUxdMcIcIjyE8vhBiYVECAGsAOvIBmURYSonMCAB7CzcgBuCGIsAAowEIhgYACCnFxioQAyXDAA5gixMDBcLADyzvlMAFYIvGAAFACUmMCYaNiYAHStOFgAvk5OGJgAshTUdIysHNy8AkbikrIKSqpaWvqGIiZmhE6u7p7ymAAqXEwSguZcCpKV9VSEFBodtcBOmAYmYHz0XIT6ALzefgFUYKhCJRBAxeLcJIsVIZLI5PKFYplCqVa63aoAbm6u0wMAQhFguwAPPRAQA+YAfL4dIloUmBMlODogDpAA"><em>React 컴파일러 플레이그라운드에서 이 예시를 확인하세요</em></a><p>그러나 <code>expensivelyProcessAReallyLargeArrayOfObjects</code>가 실제로 비용이 많이 드는 함수라면 다음과 같은 이유로 React 외부에서 해당 함수의 별도 메모이제이션을 고려해야 할 수도 있습니다.<ul><li>React 컴파일러는 React 컴포넌트와 Hooks만 메모이제이션 하며, 모든 함수를 메모이제이션 하지 않습니다.<li>React 컴파일러의 메모이제이션은 여러 컴포넌트나 Hooks 사이에서 공유되지 않습니다.</ul><p>따라서 <code>expensivelyProcessAReallyLargeArrayOfObjects</code>가 여러 다른 컴포넌트에서 사용되고 있다면 동일한 아이템이 전달되더라도 비용이 많이 드는 계산이 반복적으로 실행될 수 있습니다. 코드를 더 복잡하게 만들기 전에 먼저 <a href="https://ko.react.dev/reference/react/useMemo#how-to-tell-if-a-calculation-is-expensive">프로파일링</a>을 통해 해당 계산이 실제로 비용이 많이 드는지 확인하는 것이 좋습니다.</section></deepdive></section><section class="level3"aria-labelledby="컴파일러는-무엇을-가정하나요-what-does-the-compiler-assume"><h3 id="컴파일러는-무엇을-가정하나요-what-does-the-compiler-assume">컴파일러는 무엇을 가정하나요? {/<em>what-does-the-compiler-assume</em>/}</h3><p>React 컴파일러는 다음과 같이 가정합니다.<ol><li>올바르고 의미 있는 JavaScript 코드로 작성되었습니다.<li>nullable/optional 값과 속성에 접근하기 전에 그 값이 정의되어 있는지 테스트합니다. TypeScript를 사용하는 경우 <a href="https://www.typescriptlang.org/ko/tsconfig/#strictNullChecks"><code>strictNullChecks</code></a>을 활성화하여 수행합니다. 예를 들어 <code>if (object.nullableProperty) { object.nullableProperty.foo }</code>와 같이 처리하거나, 옵셔널 체이닝을 사용하여 <code>object.nullableProperty?.foo</code>와 같이 처리합니다.<li><a href="https://ko.react.dev/reference/rules">React의 규칙</a>을 따릅니다.</ol><p>React 컴파일러는 React의 많은 규칙을 정적으로 검증할 수 있으며, 에러가 감지되면 안전하게 컴파일을 건너뜁니다. 에러를 확인하려면 <a href="https://www.npmjs.com/package/eslint-plugin-react-compiler"><code>eslint-plugin-react-compiler</code></a>의 설치를 권장합니다.</section><section class="level3"aria-labelledby="컴파일러를-시도해-봐야-하나요-should-i-try-out-the-compiler"><h3 id="컴파일러를-시도해-봐야-하나요-should-i-try-out-the-compiler">컴파일러를 시도해 봐야 하나요? {/<em>should-i-try-out-the-compiler</em>/}</h3><p>컴파일러가 여전히 실험적이며 다양한 결함이 있다는 점을 유의하세요. Meta와 같은 회사에서는 이미 프로덕션 환경에서 사용하였지만, 앱의 프로덕션에 컴파일러를 점진적으로 도입할지는 코드베이스의 건강 상태와 <a href="/reference/rules">React의 규칙</a>을 얼마나 잘 따랐는지에 따라 다를 것입니다.<p><strong>지금 당장 컴파일러를 사용하기에 급급할 필요는 없습니다. 안정적인 릴리즈에 도달할 때까지 기다려도 괜찮습니다.</strong> 하지만 앱에서 작은 실험을 통해 컴파일러를 시도해 보고 <a href="#reporting-issues">피드백을 제공</a>하여 컴파일러 개선에 도움을 줄 수 있습니다.</section><section class="level2"aria-labelledby="시작하기-getting-started"><h2 id="시작하기-getting-started">시작하기 {/<em>getting-started</em>/}</h2><p>이 문서 외에도 <a href="https://github.com/reactwg/react-compiler">React 컴파일러 워킹 그룹</a>을 확인하여 컴파일러에 대한 추가 정보와 논의를 참조하는 것을 권장합니다.<section class="level3"aria-labelledby="호환성-확인-checking-compatibility"><h3 id="호환성-확인-checking-compatibility">호환성 확인 {/<em>checking-compatibility</em>/}</h3><p>컴파일러를 설치하기 전에, 먼저 코드베이스가 호환되는지 확인할 수 있습니다.</p><terminalblock>npx react-compiler-healthcheck@experimental</terminalblock><p>이 스크립트는 다음 작업을 수행합니다.<ul><li>성공적으로 최적화할 수 있는 컴포넌트 수 확인: 숫자가 높을수록 좋습니다.<li><code>&#x3C;StrictMode></code> 사용 여부 확인: 이를 활성화하고 준수할 경우 <a href="/reference/rules">React의 규칙</a>을 잘 따르는 가능성이 높습니다.<li>호환되지 않는 라이브러리 사용 여부 확인: 알려진 라이브러리 중에서 컴파일러와 호환되지 않는 라이브러리를 확인합니다.</ul><p>예시:</p><terminalblock>Successfully compiled 8 out of 9 components. StrictMode usage not found. Found no usage of incompatible libraries.</terminalblock></section><section class="level3"aria-labelledby="eslint-plugin-react-compiler-설치-installing-eslint-plugin-react-compiler"><h3 id="eslint-plugin-react-compiler-설치-installing-eslint-plugin-react-compiler"><code>eslint-plugin-react-compiler</code> 설치 {/<em>installing-eslint-plugin-react-compiler</em>/}</h3><p>React 컴파일러는 eslint 플러그인도 지원합니다. eslint 플러그인은 컴파일러와 <strong>독립적으로</strong> 사용할 수 있습니다. 즉 컴파일러를 사용하지 않더라도 eslint 플러그인을 사용할 수 있습니다.</p><terminalblock>npm install eslint-plugin-react-compiler@experimental</terminalblock><p>그런 다음, eslint 구성 파일에 추가하세요.<pre class="language-js"><code class="language-js">module<span class="token punctuation">.</span><span class="token property-access">exports</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">'eslint-plugin-react-compiler'</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string-property property">'react-compiler/react-compiler'</span><span class="token operator">:</span> <span class="token string">"error"</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></code></pre><p>eslint 플러그인은 에디터에서 React 규칙 위반 사항을 표시합니다. 이 경우 컴파일러가 해당 컴포넌트나 Hook의 최적화를 건너뛰었음을 의미합니다. 이것은 완전히 정상적인 동작이며, 컴파일러는 이를 복구하고 코드베이스의 다른 컴포넌트를 계속해서 최적화할 수 있습니다.<p><strong>모든 eslint 위반 사항을 즉시 수정할 필요는 없습니다.</strong> 자신의 속도에 맞춰 해결하면서 최적화되는 컴포넌트와 Hooks의 수를 늘릴 수 있지만, 컴파일러를 사용하기 전에 모든 것을 수정해야 할 필요는 없습니다.</section><section class="level3"aria-labelledby="코드베이스에-컴파일러-적용하기-using-the-compiler-effectively"><h3 id="코드베이스에-컴파일러-적용하기-using-the-compiler-effectively">코드베이스에 컴파일러 적용하기 {/<em>using-the-compiler-effectively</em>/}</h3><section class="level4"aria-labelledby="기존-프로젝트-existing-projects"><h4 id="기존-프로젝트-existing-projects">기존 프로젝트 {/<em>existing-projects</em>/}</h4><p>컴파일러는 <a href="/reference/rules">React의 규칙</a>을 따르는 함수 컴포넌트와 Hooks를 컴파일하는 것을 목표로 설계되었습니다. 또한 이러한 규칙을 위반하는 코드도 해당 컴포넌트나 Hooks를 건너뛰는 방식으로 처리할 수 있습니다. 그러나 JavaScript의 유연한 특성으로 인해 컴파일러가 가능한 모든 위반 사항을 잡아내지는 못하며, 가끔 거짓 양성(false positive)으로 컴파일할 수 있습니다. 즉 컴파일러는 React의 규칙을 위반하는 컴포넌트나 Hook을 실수로 컴파일할 수 있어 정의되지 않은 동작으로 이어질 수 있습니다.<p>따라서 기존 프로젝트에서 컴파일러를 성공적으로 도입하려면, 먼저 제품 코드의 작은 디렉터리에서 실행해 보는 것이 좋습니다. 이를 위해 컴파일러를 특정 디렉터리 세트에서만 실행하도록 구성할 수 있습니다.<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">ReactCompilerConfig</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">sources</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">filename</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> filename<span class="token punctuation">.</span><span class="token method function property-access">indexOf</span><span class="token punctuation">(</span><span class="token string">'src/path/to/dir'</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>드물지만 때에 따라서는 <code>compilationMode: "annotation"</code> 옵션을 사용하여 컴파일러를 "opt-in" 모드로 설정할 수도 있습니다. 이 모드에서는 컴파일러가 <code>"use memo"</code> 지시어로 주석 처리된 컴포넌트와 Hooks만 컴파일합니다. <code>annotation</code> 모드는 초기 사용자를 돕기 위한 임시 모드로, <code>"use memo"</code> 지시어를 장기적으로 사용할 의도는 없음을 유의하세요.<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">ReactCompilerConfig</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">compilationMode</span><span class="token operator">:</span> <span class="token string">"annotation"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// src/app.jsx</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">App</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">"use memo"</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>컴파일러를 도입하는 데 더 자신감을 가지게 되면, 다른 디렉터리에 대한 커버리지를 확대하고 점진적으로 전체 앱에 적용할 수 있습니다.</section><section class="level4"aria-labelledby="새로운-프로젝트-new-projects"><h4 id="새로운-프로젝트-new-projects">새로운 프로젝트 {/<em>new-projects</em>/}</h4><p>새 프로젝트를 시작할 경우, 기본 동작으로 전체 코드베이스에 컴파일러를 활성화할 수 있습니다.</section></section></section><section class="level2"aria-labelledby="사용-방법-installation"><h2 id="사용-방법-installation">사용 방법 {/<em>installation</em>/}</h2><section class="level3"aria-labelledby="babel-usage-with-babel"><h3 id="babel-usage-with-babel">Babel {/<em>usage-with-babel</em>/}</h3><terminalblock>npm install babel-plugin-react-compiler@experimental</terminalblock><p>컴파일러에는 빌드 파이프라인에서 사용할 수 있는 Babel 플러그인이 포함되어 있습니다.<p>설치 후에 Babel 구성 파일에 추가하세요. 파이프라인에서 컴파일러가 <strong>먼저</strong> 실행되는 것이 매우 중요합니다.<pre class="language-js"><code class="language-js"><span class="token comment">// babel.config.js</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">ReactCompilerConfig</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">[</span><span class="token string">'babel-plugin-react-compiler'</span><span class="token punctuation">,</span> <span class="token maybe-class-name">ReactCompilerConfig</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 가장 먼저 실행하세요!</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><code>babel-plugin-react-compiler</code>는 다른 Babel 플러그인보다 먼저 실행되어야 합니다. 이는 컴파일러가 사운드 분석(sound analysis)을 위해 입력 소스 정보를 필요로 하기 때문입니다.</section><section class="level3"aria-labelledby="vite-usage-with-vite"><h3 id="vite-usage-with-vite">Vite {/<em>usage-with-vite</em>/}</h3><p>Vite를 사용하고 있다면, <code>vite-plugin-react</code>에 플러그인을 추가할 수 있습니다.<pre class="language-js"><code class="language-js"><span class="token comment">// vite.config.js</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">ReactCompilerConfig</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token function">react</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">babel</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
            <span class="token punctuation">[</span><span class="token string">"babel-plugin-react-compiler"</span><span class="token punctuation">,</span> <span class="token maybe-class-name">ReactCompilerConfig</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
          <span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section><section class="level3"aria-labelledby="nextjs-usage-with-nextjs"><h3 id="nextjs-usage-with-nextjs">Next.js {/<em>usage-with-nextjs</em>/}</h3><p>Next.js에는 React 컴파일러를 활성화하는 실험적인 구성이 있습니다. 이 구성은 자동으로 Babel이 <code>babel-plugin-react-compiler</code>와 함께 설정되도록 보장합니다.<ul><li>React 19 릴리즈 후보 버전을 사용하는 Next.js 카나리(Canary) 버전을 설치하세요.<li><code>babel-plugin-react-compiler</code>를 설치하세요.</ul><terminalblock>npm install next@canary babel-plugin-react-compiler@experimental</terminalblock><p>그런 다음 <code>next.config.js</code>에서 실험적 옵션을 설정하세요.<pre class="language-js"><code class="language-js"><span class="token comment">// next.config.js</span>
<span class="token doc-comment comment">/** <span class="token keyword">@type</span> <span class="token class-name"><span class="token punctuation">{</span><span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'next'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>NextConfig<span class="token punctuation">}</span></span> */</span>
<span class="token keyword">const</span> nextConfig <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">experimental</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">reactCompiler</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span><span class="token property-access">exports</span> <span class="token operator">=</span> nextConfig<span class="token punctuation">;</span></code></pre><p>실험적 옵션을 사용하면 React 컴파일러의 지원을 다음과 같은 곳에서 보장합니다.<ul><li>앱 라우터 (App Router)<li>페이지 라우터 (Pages Router)<li>Webpack (기본)<li>Turbopack (<code>--turbo</code> 옵션을 통해 활성화)</ul></section><section class="level3"aria-labelledby="remix-usage-with-remix"><h3 id="remix-usage-with-remix">Remix {/<em>usage-with-remix</em>/}</h3><p><code>vite-plugin-babel</code>을 설치하고 컴파일러의 Babel 플러그인을 추가하세요.</p><terminalblock>npm install vite-plugin-babel</terminalblock><pre class="language-js"><code class="language-js"><span class="token comment">// vite.config.js</span>
<span class="token keyword module">import</span> <span class="token imports">babel</span> <span class="token keyword module">from</span> <span class="token string">"vite-plugin-babel"</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token maybe-class-name">ReactCompilerConfig</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token function">remix</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token comment">/* ... */</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">babel</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">filter</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.[jt]sx?$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
      <span class="token literal-property property">babelConfig</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">presets</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"@babel/preset-typescript"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// TypeScript를 사용하는 경우</span>
        <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
          <span class="token punctuation">[</span><span class="token string">"babel-plugin-react-compiler"</span><span class="token punctuation">,</span> <span class="token maybe-class-name">ReactCompilerConfig</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section><section class="level3"aria-labelledby="webpack-usage-with-webpack"><h3 id="webpack-usage-with-webpack">Webpack {/<em>usage-with-webpack</em>/}</h3><p>다음과 같이 React 컴파일러를 위한 자체 로더를 만들 수 있습니다.<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">ReactCompilerConfig</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">BabelPluginReactCompiler</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'babel-plugin-react-compiler'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">reactCompilerLoader</span><span class="token punctuation">(</span><span class="token parameter">sourceCode<span class="token punctuation">,</span> sourceMap</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">transformSync</span><span class="token punctuation">(</span>sourceCode<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">BabelPluginReactCompiler</span><span class="token punctuation">,</span> <span class="token maybe-class-name">ReactCompilerConfig</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>result <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">callback</span><span class="token punctuation">(</span>
      <span class="token known-class-name class-name">Error</span><span class="token punctuation">(</span>
        <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Failed to transform "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>options<span class="token punctuation">.</span><span class="token property-access">filename</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span><span class="token template-punctuation string">`</span></span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">callback</span><span class="token punctuation">(</span>
    <span class="token keyword null nil">null</span><span class="token punctuation">,</span>
    result<span class="token punctuation">.</span><span class="token property-access">code</span><span class="token punctuation">,</span>
    result<span class="token punctuation">.</span><span class="token property-access">map</span> <span class="token operator">===</span> <span class="token keyword null nil">null</span> <span class="token operator">?</span> <span class="token keyword nil">undefined</span> <span class="token operator">:</span> result<span class="token punctuation">.</span><span class="token property-access">map</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span><span class="token property-access">exports</span> <span class="token operator">=</span> reactCompilerLoader<span class="token punctuation">;</span></code></pre></section><section class="level3"aria-labelledby="expo-usage-with-expo"><h3 id="expo-usage-with-expo">Expo {/<em>usage-with-expo</em>/}</h3><p>Expo 앱에서 React Compiler 를 활용하거나 사용하기 위해서는 <a href="https://docs.expo.dev/preview/react-compiler/">Expo's docs</a> 를 참고해주세요.</section><section class="level3"aria-labelledby="metro-react-native-usage-with-react-native-metro"><h3 id="metro-react-native-usage-with-react-native-metro">Metro (React Native) {/<em>usage-with-react-native-metro</em>/}</h3><p>React Native는 Metro를 통해 Babel을 사용하므로 설치 지침은 <a href="#usage-with-babel">Babel 사용법</a> 섹션을 참조하세요.</section><section class="level3"aria-labelledby="rspack-usage-with-rspack"><h3 id="rspack-usage-with-rspack">Rspack {/<em>usage-with-rspack</em>/}</h3><p>Rspack 앱에서 React Compiler 를 활용하거나 사용하기 위해서는 <a href="https://rspack.dev/guide/tech/react#react-compiler">Rspack's docs</a> 를 참고해주세요.</section><section class="level3"aria-labelledby="rsbuild-usage-with-rsbuild"><h3 id="rsbuild-usage-with-rsbuild">Rsbuild {/<em>usage-with-rsbuild</em>/}</h3><p>Rsbuild 앱에서 React Compiler 를 활용하거나 사용하기 위해서는 <a href="https://rsbuild.dev/guide/framework/react#react-compiler">Rsbuild's docs</a> 를 참고해주세요.</section></section><section class="level2"aria-labelledby="troubleshooting-troubleshooting"><h2 id="troubleshooting-troubleshooting">Troubleshooting {/<em>troubleshooting</em>/}</h2><p>문제를 보고하려면 먼저 <a href="https://playground.react.dev/">React 컴파일러 플레이그라운드</a>에서 최소한의 재현 사례를 만들어 버그 보고서에 포함하세요. <a href="https://github.com/facebook/react/issues">facebook/react</a> 저장소에서 이슈를 열 수 있습니다.<p>React 컴파일러 워킹 그룹에서도 회원으로 신청하여 피드백을 제공할 수 있습니다. <a href="https://github.com/reactwg/react-compiler">가입에 대한 자세한 내용은 README</a>에서 확인하세요.<section class="level3"aria-labelledby="0--_c-is-not-a-function-에러-0--_c-is-not-a-function-error"><h3 id="0--_c-is-not-a-function-에러-0--_c-is-not-a-function-error"><code>(0 , _c) is not a function</code> 에러 {/<em>0--_c-is-not-a-function-error</em>/}</h3><p>이 에러는 React 19 RC 이상을 사용하지 않을 경우 발생합니다. 이 문제를 해결하려면 먼저 <a href="https://ko.react.dev/blog/2024/04/25/react-19-upgrade-guide">React 19 RC로 앱을 업그레이드</a>하세요.<p>React 19로 업그레이드할 수 없는 경우, <a href="https://github.com/reactwg/react-compiler/discussions/6">워킹 그룹</a>에서 설명한 대로 사용자 공간 캐시 함수 구현을 시도해 볼 수 있습니다. 그러나 가능하면 React 19로 업그레이드하는 것을 권장합니다.</section><section class="level3"aria-labelledby="컴포넌트가-최적화되었는지-어떻게-알-수-있을까요-how-do-i-know-my-components-have-been-optimized"><h3 id="컴포넌트가-최적화되었는지-어떻게-알-수-있을까요-how-do-i-know-my-components-have-been-optimized">컴포넌트가 최적화되었는지 어떻게 알 수 있을까요? {/<em>how-do-i-know-my-components-have-been-optimized</em>/}</h3><p><a href="/learn/react-developer-tools">React Devtools</a> (v5.0+)에는 React 컴파일러를 내장 지원하며, 컴파일러에 의해 최적화된 컴포넌트 옆에 "Memo ✨" 배지를 표시합니다.</section><section class="level3"aria-labelledby="컴파일-후-작동하지-않는-문제-something-is-not-working-after-compilation"><h3 id="컴파일-후-작동하지-않는-문제-something-is-not-working-after-compilation">컴파일 후 작동하지 않는 문제 {/<em>something-is-not-working-after-compilation</em>/}</h3><p><code>eslint-plugin-react-compiler</code>을 설치한 경우, 컴파일러는 에디터에서 React 규칙 위반 사항을 표시합니다. 이 경우 컴파일러가 해당 컴포넌트나 Hook의 최적화를 건너뛰었음을 의미합니다. 이것은 완전히 정상적인 동작이며, 컴파일러는 이를 복구하고 코드베이스의 다른 컴포넌트를 계속해서 최적화할 수 있습니다. <strong>모든 eslint 위반 사항을 즉시 수정할 필요는 없습니다.</strong> 자신의 속도에 맞춰 해결하면서 최적화되는 컴포넌트와 Hooks의 수를 점진적으로 늘릴 수 있습니다.<p>그러나 JavaScript의 유연하고 동적인 특성 때문에 모든 경우를 철저하게 감지하는 것은 불가능합니다. 이러면 버그나 무한 루프와 같은 정의되지 않은 동작이 발생할 수 있습니다.<p>컴파일 후 앱이 제대로 작동하지 않고 eslint 에러도 보이지 않는다면, 컴파일러가 코드를 잘못 컴파일한 것일 수 있습니다. 이를 확인하려면 관련된 컴포넌트나 Hook을 <a href="#opt-out-of-the-compiler-for-a-component"><code>"use no memo"</code> 지시어</a>를 통해 강력하게 제외해 문제를 해결하려고 시도해 보세요.<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">SuspiciousComponent</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">"use no memo"</span><span class="token punctuation">;</span> <span class="token comment">// 컴포넌트가 React 컴파일러에 의해 컴파일되지 않도록 제외합니다.</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><note>#### `"use no memo"` {/*use-no-memo*/}<p><code>"use no memo"</code>는 React 컴파일러에 의해 컴파일되지 않도록 컴포넌트와 Hooks를 선택적으로 제외할 수 있는 <em>임시</em> 탈출구입니다. 이 지시어는 <a href="/reference/rsc/use-client"><code>"use client"</code></a>와 같이 장기적으로 사용하지 않을 임시방편입니다.<p>이 지시어는 필요한 경우가 아니면 사용을 권장하지 않습니다. 한 번 컴포넌트나 Hook을 제외하면 해당 지시어가 제거될 때까지 영구적으로 컴파일에서 제외합니다. 이는 코드를 수정해도 컴파일러가 해당 부분을 여전히 건너뛸 것을 의미합니다.<p>문제를 해결했을 때 지시어를 제거하면 문제가 다시 발생하는지 확인하세요. 그런 다음 <a href="https://playground.react.dev">React 컴파일러 플레이그라운드</a>를 활용하여 문제를 최소한의 재현 가능한 예시로 단순화해 보거나, 오픈 소스 코드라면 전체 소스 코드를 붙여 넣어 버그 보고서를 공유해주세요. 이를 통해 문제를 파악하고 해결하는 데 도움을 드릴 수 있습니다.</p></note></section><section class="level3"aria-labelledby="기타-문제-other-issues"><h3 id="기타-문제-other-issues">기타 문제 {/<em>other-issues</em>/}</h3><p>자세한 내용은 <a href="https://github.com/reactwg/react-compiler/discussions/7">https://github.com/reactwg/react-compiler/discussions/7</a> 를 참조해 주세요. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section></note></section>