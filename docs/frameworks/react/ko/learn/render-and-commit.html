<!doctype html><html lang="ko"><meta charset="utf-8"><title>렌더링 그리고 커밋</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"type="text/css"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="렌더링-그리고-커밋"><h1 id="렌더링-그리고-커밋">렌더링 그리고 커밋</h1><intro><p>컴포넌트를 화면에 표시하기 이전에 React에서 렌더링을 해야 합니다. 해당 과정의 단계를 이해하면 코드가 어떻게 실행되는지 이해할 수 있고 React 렌더링 동작에 관해 설명하는데 도움이 됩니다.</p></intro><youwilllearn><ul><li>React에서 렌더링의 의미<li>React가 컴포넌트를 언제, 왜 렌더링 하는지<li>화면에 컴포넌트를 표시하는 단계<li>렌더링이 항상 DOM 업데이트를 하지 않는 이유</ul></youwilllearn><p>주방에서 요리사가 컴포넌트를 재료로 맛있는 요리를 한다고 상상해보세요. 이 시나리오에서 React는 고객들의 요청을 받고 주문을 가져오는 웨이터입니다. 이 과정에는 UI를 요청하고 제공하는 세 가지 단계가 있습니다.<ol><li>렌더링 <strong>트리거</strong> (손님의 주문을 주방으로 전달)<li>컴포넌트 <strong>렌더링</strong> (주방에서 주문 준비하기)<li>DOM에 <strong>커밋</strong> (테이블에 주문한 요리 내놓기)</ol><illustrationblock sequential=""><illustration caption="Trigger"alt="React as a server in a restaurant, fetching orders from the users and delivering them to the Component Kitchen."src.=""docs=""illustrations=""i_render-and-commit1.png&#x22;=""><illustration caption="Render"alt="The Card Chef gives React a fresh Card component."src.=""docs=""illustrations=""i_render-and-commit2.png&#x22;=""><illustration caption="Commit"alt="React delivers the Card to the user at their table."src.=""docs=""illustrations=""i_render-and-commit3.png&#x22;=""></illustration></illustration></illustration></illustrationblock><section class="level2"aria-labelledby="1단계-렌더링-트리거-step-1-trigger-a-render"><h2 id="1단계-렌더링-트리거-step-1-trigger-a-render">1단계: 렌더링 트리거 {/<em>step-1-trigger-a-render</em>/}</h2><p>컴포넌트 렌더링이 일어나는 데에는 두 가지 이유가 있습니다.<ol><li>컴포넌트의 <strong>초기 렌더링인 경우</strong><li>컴포넌트의 <strong>state가 업데이트된 경우</strong></ol><section class="level3"aria-labelledby="초기-렌더링-initial-render"><h3 id="초기-렌더링-initial-render">초기 렌더링 {/<em>initial-render</em>/}</h3><p>앱을 시작할 때 초기 렌더링을 트리거해야 합니다. 프레임워크와 샌드박스는 때때로 이 코드를 숨기곤 하지만, 대상 DOM 노드와 함께 <a href="/reference/react-dom/client/createRoot"><code>createRoot</code></a>를 호출한 다음 해당 컴포넌트로 <code>render</code> 메서드를 호출하면 이 작업이 완료됩니다.</p><sandpack><pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Image</span></span> <span class="token keyword module">from</span> <span class="token string">'./Image.js'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> createRoot <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react-dom/client'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">createRoot</span><span class="token punctuation">(</span><span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
root<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Image</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>img
      src<span class="token operator">=</span><span class="token string">"https://i.imgur.com/ZF6s192.jpg"</span>
      alt<span class="token operator">=</span><span class="token string">"'Floralis Genérica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"</span>
    <span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></sandpack><p><code>root.render()</code> 호출을 주석 처리하고 컴포넌트가 사라지는 것을 확인하세요!</section><section class="level3"aria-labelledby="state-업데이트-시-리렌더링-re-renders-when-state-updates"><h3 id="state-업데이트-시-리렌더링-re-renders-when-state-updates">State 업데이트 시 리렌더링 {/<em>re-renders-when-state-updates</em>/}</h3><p>컴포넌트가 처음으로 렌더링 된 후에는 <a href="/reference/react/useState#setstate"><code>set</code> 함수</a>를 통해 상태를 업데이트하여 추가적인 렌더링을 트리거할 수 있습니다. 컴포넌트의 상태를 업데이트하면 자동으로 렌더링 대기열에 추가됩니다. (이것은 레스토랑의 손님이 첫 주문 이후에 갈증이나 배고픔의 상태에 따라 차, 디저트 등의 메뉴를 주문하는 것으로 상상해 볼 수 있습니다.)</p><illustrationblock sequential=""><illustration caption="State update..."alt="React as a server in a restaurant, serving a Card UI to the user, represented as a patron with a cursor for their head. They patron expresses they want a pink card, not a black one!"src.=""docs=""illustrations=""i_rerender1.png&#x22;=""><illustration caption="...triggers..."alt="React returns to the Component Kitchen and tells the Card Chef they need a pink Card."src.=""docs=""illustrations=""i_rerender2.png&#x22;=""><illustration caption="...render!"alt="The Card Chef gives React the pink Card."src.=""docs=""illustrations=""i_rerender3.png&#x22;=""></illustration></illustration></illustration></illustrationblock></section></section><section class="level2"aria-labelledby="2단계-react-컴포넌트-렌더링-step-2-react-renders-your-components"><h2 id="2단계-react-컴포넌트-렌더링-step-2-react-renders-your-components">2단계: React 컴포넌트 렌더링 {/<em>step-2-react-renders-your-components</em>/}</h2><p>렌더링을 트리거한 후 React는 컴포넌트를 호출하여 화면에 표시할 내용을 파악합니다. <strong>"렌더링"은 React에서 컴포넌트를 호출하는 것입니다.</strong><ul><li><strong>초기 렌더링에서</strong> React는 루트 컴포넌트를 호출합니다.<li><strong>이후 렌더링에서</strong> React는 state 업데이트가 일어나 렌더링을 트리거한 컴포넌트를 호출합니다.</ul><p>재귀적 단계: 업데이트된 컴포넌트가 다른 컴포넌트를 반환하면 React는 다음으로 <em>해당</em> 컴포넌트를 렌더링하고 해당 컴포넌트도 컴포넌트를 반환하면 <em>반환된</em> 컴포넌트를 다음에 렌더링하는 방식입니다. 중첩된 컴포넌트가 더 이상 없고 React가 화면에 표시되어야 하는 내용을 정확히 알 때까지 이 단계는 계속됩니다.<p>다음 예시에서 React는 <code>Gallery()</code>와 <code>Image()</code>를 여러 번 호출합니다.</p><sandpack><pre class="language-js"><code class="language-js"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Gallery</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>section<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token maybe-class-name">Inspiring</span> <span class="token maybe-class-name">Sculptures</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Image</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Image</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Image</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>section<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>img
      src<span class="token operator">=</span><span class="token string">"https://i.imgur.com/ZF6s192.jpg"</span>
      alt<span class="token operator">=</span><span class="token string">"'Floralis Genérica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"</span>
    <span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Gallery</span></span> <span class="token keyword module">from</span> <span class="token string">'./Gallery.js'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> createRoot <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react-dom/client'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">createRoot</span><span class="token punctuation">(</span><span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
root<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Gallery</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class="language-css"><code class="language-css"><span class="token selector">img</span> <span class="token punctuation">{</span> <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">10</span><span class="token unit">px</span> <span class="token number">10</span><span class="token unit">px</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></sandpack><ul><li><strong>초기 렌더링 하는 동안</strong> React는 <code>&#x3C;section></code>, <code>&#x3C;h1></code> 그리고 3개의 <code>&#x3C;img></code> 태그에 대한 <a href="https://developer.mozilla.org/docs/Web/API/Document/createElement">DOM 노드를 생성</a>합니다.<li><strong>리렌더링하는 동안</strong> React는 이전 렌더링 이후 변경된 속성을 계산합니다. 다음 단계인 커밋 단계까지는 해당 정보로 아무런 작업도 수행하지 않습니다.</ul><pitfall><p>렌더링은 항상 <a href="/learn/keeping-components-pure">순수한 계산</a>:<ul><li><strong>동일한 입력에는 동일한 출력을 해야합니다.</strong> 동일한 입력이 주어지면 컴포넌트는 항상 동일한 JSX를 반환해야 합니다. (누군가 토마토 샐러드를 주문하면 그들은 양파가 있는 샐러드를 받으면 안 됩니다!)<li><strong>이전의 state를 변경해서는 안됩니다.</strong> 렌더링 전에 존재했던 객체나 변수를 변경해서는 안 됩니다. (누군가의 주문이 다른 사람의 주문을 변경해서는 안 됩니다.)</ul><p>그렇지 않으면 코드베이스가 복잡해짐에 따라 혼란스러운 버그와 예측할 수 없는 동작이 발생할 수 있습니다. "Strict Mode"에서 개발할 때 React는 각 컴포넌트의 함수를 두 번 호출하여 순수하지 않은 함수로 인한 실수를 표면화하는데 도움을 받을 수 있습니다.</p></pitfall><deepdive><section class="level4"aria-labelledby="성능-최적화-optimizing-performance"><h4 id="성능-최적화-optimizing-performance">성능 최적화 {/<em>optimizing-performance</em>/}</h4><p>업데이트된 컴포넌트 내에 중첩된 모든 컴포넌트를 렌더링하는 기본 동작은 업데이트된 컴포넌트가 트리에서 매우 높은 곳에 있는 경우 성능 최적화되지 않습니다. 성능 문제가 발생하는 경우 <a href="https://ko.legacy.reactjs.org/docs/optimizing-performance.html">성능</a> 섹션에 설명된 몇 가지 옵트인 방식으로 문제를 해결 할 수 있습니다. <strong>성급하게 최적화하지 마세요!</strong></section></deepdive></section><section class="level2"aria-labelledby="3단계-react가-dom에-변경사항을-커밋-step-3-react-commits-changes-to-the-dom"><h2 id="3단계-react가-dom에-변경사항을-커밋-step-3-react-commits-changes-to-the-dom">3단계: React가 DOM에 변경사항을 커밋 {/<em>step-3-react-commits-changes-to-the-dom</em>/}</h2><p>컴포넌트를 렌더링(호출)한 후 React는 DOM을 수정합니다.<ul><li><strong>초기 렌더링의 경우</strong> React는 <a href="https://developer.mozilla.org/docs/Web/API/Node/appendChild"><code>appendChild()</code></a> DOM API를 사용하여 생성한 모든 DOM 노드를 화면에 표시합니다.<li><strong>리렌더링의 경우</strong> React는 필요한 최소한의 작업(렌더링하는 동안 계산된 것!)을 적용하여 DOM이 최신 렌더링 출력과 일치하도록 합니다.</ul><p><strong>React는 렌더링 간에 차이가 있는 경우에만 DOM 노드를 변경합니다.</strong> 예를 들어 매초 부모로부터 전달된 다른 props로 다시 렌더링하는 컴포넌트가 있습니다. <code>&#x3C;input></code>에 텍스트를 입력하여 <code>value</code>를 업데이트 하지만 컴포넌트가 리렌더링될 때 텍스트가 사라지지 않습니다.</p><sandpack><pre class="language-js"><code class="language-js"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Clock</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> time <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token punctuation">{</span>time<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>input <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Clock</span></span> <span class="token keyword module">from</span> <span class="token string">'./Clock.js'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">useTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>time<span class="token punctuation">,</span> setTime<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">setTime</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> time<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">App</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> time <span class="token operator">=</span> <span class="token function">useTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Clock</span> time<span class="token operator">=</span><span class="token punctuation">{</span>time<span class="token punctuation">.</span><span class="token method function property-access">toLocaleTimeString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></sandpack><p>마지막 단계에서 React가 <code>&#x3C;h1></code>의 내용만 새로운 <code>time</code>으로 업데이트하기 때문입니다. <code>&#x3C;input></code>이 JSX에서 이전과 같은 위치로 확인되므로 React는 <code>&#x3C;input></code> 또는 <code>value</code>를 건드리지 않습니다! ## 에필로그: 브라우저 페인트 {/<em>epilogue-browser-paint</em>/}<p>렌더링이 완료되고 React가 DOM을 업데이트한 후 브라우저는 화면을 다시 그립니다. 이 단계를 "브라우저 렌더링"이라고 하지만 이 문서의 나머지 부분에서 혼동을 피하고자 "페인팅"이라고 부를 것입니다.<p>&#x3C;Illustration alt="A browser painting 'still life with card element'." src./docs/illustrations/i_browser-paint.png" /></p><recap><ul><li>React 앱의 모든 화면 업데이트는 세 단계로 이루어집니다.<ol><li>트리거<li>렌더링<li>커밋</ol><li>Strict Mode를 사용하여 컴포넌트에서 실수를 찾을 수 있습니다.<li>렌더링 결과가 이전과 같으면 React는 DOM을 건드리지 않습니다.</ul></recap><span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>