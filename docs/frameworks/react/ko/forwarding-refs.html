<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <title>Ref 전달하기</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="ref-전달하기" class="level1">
      <h1>Ref 전달하기</h1>
      <p>ref 전달은 컴포넌트를 통해 자식 중 하나에 <a href="./refs-and-the-dom.html">ref</a>를 자동으로 전달하는 기법입니다. 일반적으로 애플리케이션 대부분의 컴포넌트에 필요하지는 않습니다. 그렇지만, 특히 재사용 가능한 컴포넌트 라이브러리와 같은 어떤 컴포넌트에서는 유용할 수 있습니다. 가장 보편적인 시나리오를 아래에 설명하겠습니다.</p>
      <section id="forwarding-refs-to-dom-components" class="level2">
        <h2>DOM 에 refs 전달하기</h2>
        <p>
          기본 <code>button</code> DOM 요소를 렌더링하는 <code>FancyButton</code> 컴포넌트를 가정해 봅시다.
          <code>embed:forwarding-refs/fancy-button-simple.js</code>
        </p>
        <p><code>FancyButton</code>를 사용하는 다른 컴포넌트들은 <strong>일반적으로</strong> 내부 <code>button</code> DOM 요소에 대한 <a href="./refs-and-the-dom.html">ref를 얻을</a> 필요가 없습니다. 이는 컴포넌트들이 서로의 DOM 구조에 지나치게 의존하지 않기 때문에 괜찮습니다.</p>
        <p>이런 캡슐화는 <code>FeedStory</code>나 <code>Comment</code> 같은 애플리케이션 레벨의 컴포넌트에서는 바람직하지만, <code>FancyButton</code>이나 <code>MyTextInput</code>과 같은 재사용성이 높은 "말단" 요소에서는 불편할 수도 있습니다. 이런 컴포넌트들은 일반적인 DOM <code>button</code>, <code>input</code>과 유사한 방법으로 애플리케이션 전체에 걸쳐 사용되는 경향이 있습니다. 그리고 포커스, 선택, 애니메이션을 관리하기 위해서는 이런 DOM 노드에 접근하는 것이 불가피할 수 있습니다.</p>
        <p><strong>Ref 전달하기는 일부 컴포넌트가 수신한 <code>ref</code>를 받아 조금 더 아래로 전달(즉, "전송")할 수 있는 옵트인 기능입니다.</strong></p>
        <p>아래의 예에서 <code>FancyButton</code>은 <code>React.forwardRef</code>를 사용하여 전달된 <code>ref</code>를 얻고, 그것을 렌더링 되는 DOM <code>button</code>으로 전달합니다.</p>
        <p><code>embed:forwarding-refs/fancy-button-simple-ref.js</code></p>
        <p>이런 방법으로 <code>FancyButton</code>을 사용하는 컴포넌트들은 <code>button</code> DOM 노드에 대한 참조를 가져올 수 있고, 필요한 경우 DOM <code>button</code>을 직접 사용하는 것처럼 접근할 수 있습니다.</p>
        <p>위의 예시에서 어떤 일이 일어나는지 단계별로 설명하겠습니다.</p>
        <ol>
          <li><code>React.createRef</code>를 호출해서 <a href="./refs-and-the-dom.html">React ref</a>를 생성하고 <code>ref</code> 변수에 할당합니다.</li>
          <li><code>ref</code>를 JSX 속성으로 지정해서 <code>&#x3C;FancyButton ref={ref}></code>로 전달합니다.</li>
          <li>React는 이 <code>ref</code>를 <code>forwardRef</code> 내부의 <code>(props, ref) => ...</code> 함수의 두 번째 인자로 전달합니다.</li>
          <li>이 <code>ref</code>를 JSX 속성으로 지정해서 <code>&#x3C;button ref={ref}></code>으로 전달합니다.</li>
          <li>ref가 첨부되면 <code>ref.current</code>는 <code>&#x3C;button></code> DOM 노드를 가리키게 됩니다.</li>
        </ol>
        <blockquote>
          <p>알아두기</p>
          <p>두 번째 <code>ref</code> 인자는 <code>React.forwardRef</code>와 같이 호출된 컴포넌트를 정의했을 때에만 생성됩니다. 일반 함수나 클래스 컴포넌트는 <code>ref</code> 인자를 받지도 않고 props에서 사용할 수도 없습니다.</p>
          <p>Ref 전달은 DOM 컴포넌트에만 한정적이지 않습니다. 클래스 컴포넌트 인스턴스에도 전달할 수 있습니다.</p>
        </blockquote>
      </section>
      <section id="note-for-component-library-maintainers" class="level2">
        <h2>컴포넌트 라이브러리 유지관리자를 위한 주의사항</h2>
        <p><strong>컴포넌트 라이브러리에서 <code>forwardRef</code>를 사용하기 시작할 때 이것을 변경사항으로 간주하고 라이브러리의 새로운 중요 버전을 릴리즈 해야 합니다.</strong> 이는 라이브러리에 주목할 만하게 (ref가 할당되는 것이 무엇이며 내보내는 유형은 무엇인가와 같은) 다른 동작을 할 가능성이 높고 이전 동작에 의존하는 앱이나 다른 라이브러리들이 손상될 가능성이 크기 때문입니다.</p>
        <p>조건적으로 <code>React.forwardRef</code>가 존재할 때 조건부로 적용하는 것도 같은 이유로 권장하지 않습니다: 라이브러리가 동작하는 방식을 변경하고 React 그 자체를 업데이트할 때 사용자 앱을 손상시킬 수도 있습니다.</p>
      </section>
      <section id="forwarding-refs-in-higher-order-components" class="level2">
        <h2>고차원 컴포넌트에서의 ref 전달하기</h2>
        <p>
          이 기술은 (HOC로 알려진) <a href="./higher-order-components.html">고차원 컴포넌트</a>에서 부분적으로 유용할 수 있습니다. 콘솔에 컴포넌트 props를 로깅 하는 HOC 예시로 설명을 시작해 보겠습니다.
          <code>embed:forwarding-refs/log-props-before.js</code>
        </p>
        <p>
          "logProps" HOC는 모든 <code>props</code>를 래핑하는 컴포넌트로 전달하므로 렌더링 된 결과가 동일하게 됩니다. 예를 들어, 이 HOC를 사용해서 "fancy button" 컴포넌트로 전달하는 모든 props를 기록 할 수 있습니다.
          <code>embed:forwarding-refs/fancy-button.js</code>
        </p>
        <p>위 예시에서 한 가지 주의사항이 있습니다: refs는 전달되지 않는다는 것입니다. 그것은 <code>ref</code>는 prop이 아니기 때문입니다. <code>key</code>와 마찬가지로 <code>ref</code>는 React에서 다르게 처리합니다. HOC에 ref를 추가하면 ref는 래핑 된 컴포넌트가 아니라 가장 바깥쪽 컨테이너 컴포넌트를 참조합니다.</p>
        <p>
          <code>FancyButton</code> 컴포넌트를 위한 refs가 실제로는 <code>LogProps</code> 컴포넌트에 첨부된다는 것을 의미합니다.
          <code>embed:forwarding-refs/fancy-button-ref.js</code>
        </p>
        <p>
          다행히도 <code>React.forwardRef</code> API를 사용하여 내부 <code>FancyButton</code> 컴포넌트에 대한 refs를 명시적으로 전달할 수 있습니다. <code>React.forwardRef</code>는 <code>props</code>와 <code>ref</code> 파라미터를 받아 React 노드를 반환하는 렌더링 함수를 받습니다. 예를 들어:
          <code>embed:forwarding-refs/log-props-after.js</code>
        </p>
      </section>
      <section id="displaying-a-custom-name-in-devtools" class="level2">
        <h2>DevTools에 사용자 정의 이름 표시하기</h2>
        <p><code>React.forwardRef</code>는 렌더링 함수를 받습니다. React DevTools는 이 함수를 사용하여 ref 전달 컴포넌트에 대해서 무엇을 표시할 것인지 정의합니다.</p>
        <p>예로, 다음의 컴포넌트는 DevTools에 "<em>ForwardRef</em>"로 나타날 것입니다.</p>
        <p><code>embed:forwarding-refs/wrapped-component.js</code></p>
        <p>렌더링 함수를 지정하면 DevTools에 해당 이름도 포함됩니다. (예, "<em>ForwardRef(myFunction)</em>")</p>
        <p><code>embed:forwarding-refs/wrapped-component-with-function-name.js</code></p>
        <p>감싸고 있는 컴포넌트를 포함하도록 함수의 <code>displayName</code> 속성을 설정할 수도 있습니다.</p>
        <p>
          <code>embed:forwarding-refs/customized-display-name.js</code>
          <span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span>
        </p>
      </section>
    </section>
  </body>
</html>
