<!doctype html><html lang="ko"><meta charset="utf-8"><title>React 최상위 API</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="react-최상위-api"class="level1"><h1>React 최상위 API</h1><p><code>React</code>는 React 라이브러리의 진입점입니다. <code>&#x3C;script></code> 태그를 사용하여 React를 불러오게 되면 전역 객체 <code>React</code>를 통하여 최상위 API를 사용할 수 있습니다. npm에서 ES6를 사용하는 경우, <code>import React from 'react'</code>를 작성하면 됩니다. npm에서 ES5를 사용하는 경우, <code>var React = require('react')</code>를 작성하면 됩니다.<section id="overview"class="level2"><h2>개요</h2><section id="components"class="level3"><h3>컴포넌트</h3><p>React 컴포넌트를 사용하면 UI를 독립적이고 재사용할 수 있는 부분으로 나누고 각 부분을 분리하여 생각할 수 있습니다. React 컴포넌트는 <code>React.Component</code> 또는 <code>React.PureComponent</code>로 세부적으로 나누어 정의할 수 있습니다.<ul><li><a href="#reactcomponent"><code>React.Component</code></a><li><a href="#reactpurecomponent"><code>React.PureComponent</code></a></ul><p>ES6 class를 사용하지 않는다면, <code>create-react-class</code> 모듈을 대신 사용해도 됩니다. 자세한 정보는 <a href="./react-without-es6.html">ES6 없이 React를 사용하기</a> 문서에서 확인할 수 있습니다.<p>React 컴포넌트를 정의할 때 래핑될 수 있는 함수의 형태로 할 수도 있습니다.<ul><li><a href="#reactmemo"><code>React.memo</code></a></ul></section><section id="creating-react-elements"class="level3"><h3>React 엘리먼트 생성하기</h3><p>UI의 형태를 설명하는 데에 <a href="./introducing-jsx.html">JSX를 사용할 것</a>을 권장합니다. 각 JSX 엘리먼트는 단지 <a href="#createelement"><code>React.createElement()</code></a>를 호출하는 편리한 문법에 불과합니다. JSX를 사용할 경우 아래의 메서드들을 직접 호출하는 일은 거의 없습니다.<ul><li><a href="#createelement"><code>createElement()</code></a><li><a href="#createfactory"><code>createFactory()</code></a></ul><p>자세한 정보는 <a href="./react-without-jsx.html">JSX 없이 React 사용하기</a> 문서에서 확인할 수 있습니다.</section><section id="transforming-elements"class="level3"><h3>엘리먼트 변환하기</h3><p><code>React</code>는 엘리먼트를 조작하는 API들을 제공합니다.<ul><li><a href="#cloneelement"><code>cloneElement()</code></a><li><a href="#isvalidelement"><code>isValidElement()</code></a><li><a href="#reactchildren"><code>React.Children</code></a></ul></section><section id="fragments"class="level3"><h3>Fragments</h3><p>또한 <code>React</code>는 래퍼 없이 여러 엘리먼트를 렌더링할 수 있는 컴포넌트를 제공합니다.<ul><li><a href="#reactfragment"><code>React.Fragment</code></a></ul></section><section id="refs"class="level3"><h3>Refs</h3><ul><li><a href="#reactcreateref"><code>React.createRef</code></a><li><a href="#reactforwardref"><code>React.forwardRef</code></a></ul></section><section id="suspense"class="level3"><h3>Suspense</h3><p>Suspense를 사용하면 컴포넌트가 렌더링하기 전에 다른 작업이 먼저 이루어지도록 "대기합니다". 현재 Suspense는 단 하나의 사용 사례 <a href="./code-splitting.html#reactlazy"><code>React.lazy</code>를 사용하여 컴포넌트를 동적으로 불러오기</a>만 지원합니다. 나중에는 데이터 불러오기와 같은 사용 사례를 지원할 계획입니다.<ul><li><a href="#reactlazy"><code>React.lazy</code></a><li><a href="#reactsuspense"><code>React.Suspense</code></a></ul></section><section id="transitions"class="level3"><h3>Transitions</h3><p><em>Transitions</em>는 React 18에 도입된 새로운 동시(concurrent) 기능입니다. 이는 업데이트를 transitions으로 표시할 수 있게 하여 React에게 중단될 수 있음을 알리고, 이미 보이는 콘텐츠에 대해 Suspense Fallback으로 가는 것을 방지할 수 있습니다.<ul><li><a href="#starttransition"><code>React.startTransition</code></a><li><a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a></ul></section><section id="hooks"class="level3"><h3>Hooks</h3><p><em>Hooks</em>는 React 16.8에 새로 추가되었습니다. Hooks를 사용하면 class를 사용하지 않아도 state와 React 기능들을 사용할 수 있도록 해줍니다. Hooks만을 다루는 <a href="./hooks-intro.html">문서</a>와 API 문서가 존재합니다.<ul><li><a href="./hooks-reference.html#basic-hooks">기본적인 Hooks</a><ul><li><a href="./hooks-reference.html#usestate"><code>useState</code></a><li><a href="./hooks-reference.html#useeffect"><code>useEffect</code></a><li><a href="./hooks-reference.html#usecontext"><code>useContext</code></a></ul><li><a href="./hooks-reference.html#additional-hooks">추가적인 Hooks</a><ul><li><a href="./hooks-reference.html#usereducer"><code>useReducer</code></a><li><a href="./hooks-reference.html#usecallback"><code>useCallback</code></a><li><a href="./hooks-reference.html#usememo"><code>useMemo</code></a><li><a href="./hooks-reference.html#useref"><code>useRef</code></a><li><a href="./hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a><li><a href="./hooks-reference.html#uselayouteffect"><code>useLayoutEffect</code></a><li><a href="./hooks-reference.html#usedebugvalue"><code>useDebugValue</code></a><li><a href="./hooks-reference.html#usedeferredvalue"><code>useDeferredValue</code></a><li><a href="./hooks-reference.html#usetransition"><code>useTransition</code></a><li><a href="./hooks-reference.html#useid"><code>useId</code></a></ul><li><a href="./hooks-reference.html#library-hooks">Library Hooks</a><ul><li><a href="./hooks-reference.html#usesyncexternalstore"><code>useSyncExternalStore</code></a><li><a href="./hooks-reference.html#useinsertioneffect"><code>useInsertionEffect</code></a></ul></ul><hr></section></section><section id="reference"class="level2"><h2>Reference</h2><section id="reactcomponent-reactcomponent"class="level3"><h3><code>React.Component</code> {#reactcomponent}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/Component"><code>Component</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><p><code>React.Component</code>는 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6 class</a>를 사용하여 React 컴포넌트를 정의할 때에 기초가 되는 class입니다.<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Greeting</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token maybe-class-name">Hello</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p><code>React.Component</code> 기초 class와 관련된 메서드와 속성 목록은 <a href="./react-component.html">React.Component API Reference</a>에서 확인할 수 있습니다.<hr></section><section id="reactpurecomponent-reactpurecomponent"class="level3"><h3><code>React.PureComponent</code> {#reactpurecomponent}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/PureComponent"><code>PureComponent</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><p><code>React.PureComponent</code>는 <a href="#reactcomponent"><code>React.Component</code></a>와 비슷합니다. <a href="#reactcomponent"><code>React.Component</code></a>는 <a href="./react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a>를 구현하지 않지만, <code>React.PureComponent</code>는 props와 state를 이용한 얕은 비교를 구현한다는 차이점만이 존재합니다.<p>React 컴포넌트의 <code>render()</code> 함수가 동일한 props와 state에 대하여 동일한 결과를 렌더링한다면, <code>React.PureComponent</code>를 사용하여 경우에 따라 성능 향상을 누릴 수 있습니다.<blockquote><p>주의<p><code>React.PureComponent</code>의 <code>shouldComponentUpdate()</code>는 컴포넌트에 대하여 얕은 비교만을 수행합니다. 따라서 컴포넌트에 복잡한 자료 구조가 포함되어있다면, 깊은 차이가 존재함에도 불구하고 차이가 없다고 판단하는 잘못된 결과를 만들어낼 수 있습니다. props와 state의 구조가 간단할 것으로 예상될 때에만 <code>PureComponent</code>를 상속하고, 깊은 자료 구조의 변화가 있다면 <a href="./react-component.html#forceupdate"><code>forceUpdate()</code></a>를 사용하세요. 또는 중첩된 데이터들을 빠르게 비교할 수 있도록 하려면 <a href="https://facebook.github.io/immutable-js/">불변 객체</a>의 사용을 검토해보세요.<p>더 나아가 <code>React.PureComponent</code>의 <code>shouldComponentUpdate()</code>는 컴포넌트의 하위 트리에 대한 props 갱신 작업을 수행하지 않습니다. 자식 컴포넌트들이 "순수"한지 꼭 확인하기 바랍니다.</blockquote><hr></section><section id="reactmemo-reactmemo"class="level3"><h3><code>React.memo</code> {#reactmemo}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/memo"><code>memo</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token maybe-class-name">MyComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* props를 사용하여 렌더링 */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>React.memo</code>는 <a href="./higher-order-components.html">고차 컴포넌트(Higher Order Component)</a>입니다.<p>컴포넌트가 동일한 props로 동일한 결과를 렌더링해낸다면, <code>React.memo</code>를 호출하고 결과를 메모이징(Memoizing)하도록 래핑하여 경우에 따라 성능 향상을 누릴 수 있습니다. 즉, React는 컴포넌트를 렌더링하지 않고 마지막으로 렌더링된 결과를 재사용합니다.<p><code>React.memo</code>는 props 변화에만 영향을 줍니다. <code>React.memo</code>로 감싸진 함수 컴포넌트 구현에 <a href="./hooks-state.html"><code>useState</code></a>, <a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> 또는 <a href="./hooks-reference.html#usecontext"><code>useContext</code></a> 훅을 사용한다면, 여전히 state나 context가 변할 때 다시 렌더링됩니다.<p>props가 갖는 복잡한 객체에 대하여 얕은 비교만을 수행하는 것이 기본 동작입니다. 다른 비교 동작을 원한다면, 두 번째 인자로 별도의 비교 함수를 제공하면 됩니다.<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* props를 사용하여 렌더링 */</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">areEqual</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*
  nextProps가 prevProps와 동일한 값을 가지면 true를 반환하고, 그렇지 않다면 false를 반환
  */</span>
<span class="token punctuation">}</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token maybe-class-name">MyComponent</span><span class="token punctuation">,</span> areEqual<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>이 메서드는 오직 <strong><a href="./optimizing-performance.html">성능 최적화</a></strong>를 위하여 사용됩니다. 렌더링을 "방지"하기 위하여 사용하지 마세요. 버그를 만들 수 있습니다.<blockquote><p>주의<p>class 컴포넌트의 <a href="./react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a> 메서드와 달리, <code>areEqual</code> 함수는 props들이 서로 같으면 <code>true</code>를 반환하고, props들이 서로 다르면 <code>false</code>를 반환합니다. 이것은 <code>shouldComponentUpdate</code>와 정반대의 동작입니다.</blockquote><hr></section><section id="createelement-createelement"class="level3"><h3><code>createElement()</code> {#createelement}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/createElement"><code>createElement</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">createElement</span><span class="token punctuation">(</span>
  type<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>props<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token spread operator">...</span>children<span class="token punctuation">]</span>
<span class="token punctuation">)</span></code></pre><p>인자로 주어지는 타입에 따라 새로운 <a href="./rendering-elements.html">React 엘리먼트</a>를 생성하여 반환합니다. type 인자로는 태그 이름 문자열(<code>'div'</code> 또는 <code>'span'</code> 등), <a href="./components-and-props.html">React 컴포넌트</a> 타입, 또는 <a href="#reactfragment">React Fragment</a> 타입 중 하나가 올 수 있습니다.<p>JSX로 작성된 코드는 <code>React.createElement()</code>를 사용하는 형태로 변환됩니다. JSX를 사용할 경우 <code>React.createElement()</code>를 직접 호출하는 일은 거의 없습니다. 자세한 정보는 <a href="./react-without-jsx.html">JSX 없이 React 사용하기</a> 문서에서 확인할 수 있습니다.<hr></section><section id="cloneelement-cloneelement"class="level3"><h3><code>cloneElement()</code> {#cloneelement}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/cloneElement"><code>cloneElement</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><pre class="language-text"><code class="language-text">React.cloneElement(
  element,
  [config],
  [...children]
)</code></pre><p><code>element</code>를 기준으로 새로운 React 엘리먼트를 복사하고 반환합니다. <code>config</code>는 <code>key</code>와 <code>ref</code> 그리고 모든 새로운 props를 포함합니다. 새로운 엘리먼트에는 원본 엘리먼트가 가졌던 props가 새로운 props와 얕게 합쳐진 뒤 주어집니다. 새로운 자식들은 기존의 자식들을 대체합니다. <code>config</code>에 <code>key</code>와 <code>ref</code>가 없다면 원본 엘리먼트의 <code>key</code>와 <code>ref</code>는 그대로 유지됩니다.<p><code>React.cloneElement()</code>는 아래의 구문과 거의 동등합니다.<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span>element<span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>props<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token operator">></span></code></pre><p>그렇지만 <code>ref</code>들이 유지된다는 점이 다릅니다. 즉 조상이 가지고 있을 <code>ref</code>를 사용하여 자식 엘리먼트에 접근하는 것이 허용됩니다. 새로운 엘리먼트에 덧붙여지는 것과 동일한 <code>ref</code>를 얻을 수 있습니다. 새로운 <code>ref</code> 또는 <code>key</code>가 있다면 이전 값을 대체합니다.<p>이 API는 더 이상 사용되지 않는 <code>React.addons.cloneWithProps()</code>를 대체합니다.<hr></section><section id="createfactory-createfactory"class="level3"><h3><code>createFactory()</code> {#createfactory}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/createFactory"><code>createFactory</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">createFactory</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span></code></pre><p>주어진 타입의 React 엘리먼트를 만들어내는 함수를 반환합니다. <a href="#createelement"><code>React.createElement()</code></a>와 마찬가지로 type 인자는 태그 이름 문자열(<code>'div'</code> 또는 <code>'span'</code> 등), <a href="./components-and-props.html">React 컴포넌트</a> 타입, 또는 <a href="#reactfragment">React Fragment</a> 타입 중 하나가 올 수 있습니다.<p>이 헬퍼 함수는 레거시 기능으로 간주되며, 대신 JSX 문법을 사용하거나 <code>React.createElement()</code>를 직접 사용하는 것이 좋습니다.<p>JSX를 사용할 경우 <code>React.createFactory()</code>를 직접 호출하는 일은 거의 없습니다. 자세한 정보는 <a href="./react-without-jsx.html">JSX 없이 React 사용하기</a> 문서에서 확인할 수 있습니다.<hr></section><section id="isvalidelement-isvalidelement"class="level3"><h3><code>isValidElement()</code> {#isvalidelement}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/isValidElement"><code>isValidElement</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">isValidElement</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span></code></pre><p>객체가 React 엘리먼트인지 확인합니다. <code>true</code> 또는 <code>false</code>를 반환합니다.<hr></section><section id="reactchildren-reactchildren"class="level3"><h3><code>React.Children</code> {#reactchildren}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/Children"><code>Children</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><p><code>React.Children</code>는 불투명(Opaque) 자료 구조인 <code>this.props.children</code>를 다루는 유틸리티 함수들을 제공합니다.<section id="reactchildrenmap-reactchildrenmap"class="level4"><h4><code>React.Children.map</code> {#reactchildrenmap}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">[</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><code>children</code>에 포함된 각 자식에 대하여 <code>this</code>를 <code>thisArg</code>의 값으로 설정한 함수를 호출합니다. <code>children</code>이 배열일 경우, 이 배열의 각 자식에 대하여 함수가 호출됩니다. <code>children</code>이 <code>null</code> 또는 <code>undefined</code>일 경우, 이 메서드는 배열이 아니라 <code>null</code> 또는 <code>undefined</code>를 반환합니다.<blockquote><p>주의<p><code>children</code>이 <code>Fragment</code>일 경우, <code>children</code>은 단일 자식으로 취급되어 순회하지 않습니다.</blockquote></section><section id="reactchildrenforeach-reactchildrenforeach"class="level4"><h4><code>React.Children.forEach</code> {#reactchildrenforeach}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">[</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><a href="#reactchildrenmap"><code>React.Children.map()</code></a>와 비슷하지만, 배열을 반환하지 않습니다.</section><section id="reactchildrencount-reactchildrencount"class="level4"><h4><code>React.Children.count</code> {#reactchildrencount}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">count</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p><code>children</code>에 포함된 컴포넌트의 개수를 반환합니다. <code>map</code> 또는 <code>forEach</code>로 전달된 콜백이 호출된 횟수와 동일한 값입니다.</section><section id="reactchildrenonly-reactchildrenonly"class="level4"><h4><code>React.Children.only</code> {#reactchildrenonly}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">only</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p><code>children</code>이 단 하나의 자식(React 엘리먼트)를 갖는지 확인하고 해당 자식 엘리먼트를 반환합니다. 그렇지 않을 경우 오류를 발생시킵니다.<blockquote><p>주의<p><code>React.Children.only()</code>는 <a href="#reactchildrenmap"><code>React.Children.map()</code></a>의 반환값을 허용하지 않는데, 왜냐하면 반환값이 React 엘리먼트가 아니라 배열이기 때문입니다.</blockquote></section><section id="reactchildrentoarray-reactchildrentoarray"class="level4"><h4><code>React.Children.toArray</code> {#reactchildrentoarray}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">toArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p>각 자식에 <code>key</code>가 할당된 배열을 <code>children</code> 불투명(opaque) 자료 구조로 반환합니다. <code>render()</code> 메서드에서 <code>children</code>의 집합을 다루고 싶을 때, 특히 <code>this.props.children</code>을 하부로 전달하기 전에 다시 정렬하거나 일부만 잘라내고 싶을 때에 유용합니다.<blockquote><p>주의<p><code>React.Children.toArray()</code>는 <code>children</code>을 평평하게(Flatten) 만들 때, 중첩된 배열들의 의미를 보존하기 위하여 <code>key</code>를 변경합니다. 즉, <code>toArray</code>는 반환되는 배열에 <code>key</code> 값을 덧붙여서 각 엘리먼트가 갖는 <code>key</code>가 평평해진 배열 내에서만 유효한 범위를 형성하도록 해줍니다.</blockquote><hr></section></section><section id="reactfragment-reactfragment"class="level3"><h3><code>React.Fragment</code> {#reactfragment}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/Fragment"><code>Fragment</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><p><code>React.Fragment</code> 컴포넌트를 사용하면 <code>render()</code> 메서드 안에서 추가적인 DOM 엘리먼트를 생성하지 않아도 여러 엘리먼트를 반환할 수 있습니다.<pre class="language-javascript"><code class="language-javascript"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Fragment</span></span><span class="token operator">></span>
      <span class="token maybe-class-name">Some</span> text<span class="token punctuation">.</span>
      <span class="token operator">&#x3C;</span>h2<span class="token operator">></span><span class="token constant">A</span> heading<span class="token operator">&#x3C;</span><span class="token operator">/</span>h2<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Fragment</span></span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>축약형인 <code>&#x3C;>&#x3C;/></code> 문법으로도 동일하게 사용할 수 있습니다. 자세한 정보는 <a href="/blog/2017/11/28/react-v16.2.0-fragment-support.html">React v16.2.0: Fragment에 대한 향상된 지원</a>에서 확인할 수 있습니다.</section><section id="reactcreateref-reactcreateref"class="level3"><h3><code>React.createRef</code> {#reactcreateref}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/createRef"><code>createRef</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><p><code>React.createRef</code>는 React 엘리먼트에 <code>ref</code> 어트리뷰트로 붙일 수 있는 <a href="./refs-and-the-dom.html">ref</a>를 생성합니다. <code>embed:16-3-release-blog-post/create-ref-example.js</code></section><section id="reactforwardref-reactforwardref"class="level3"><h3><code>React.forwardRef</code> {#reactforwardref}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/forwardRef"><code>forwardRef</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><p><code>React.forwardRef</code>는 전달받은 <a href="./refs-and-the-dom.html"><code>ref</code></a> 어트리뷰트를 하부 트리 내의 다른 컴포넌트로 전달하는 React 컴포넌트를 생성합니다. 이 기법은 잘 사용되지 않지만, 아래의 두 시나리오에서는 특히 유용합니다.<ul><li><a href="./forwarding-refs.html#forwarding-refs-to-dom-components">DOM 엘리먼트로 ref 전달하기</a><li><a href="./forwarding-refs.html#forwarding-refs-in-higher-order-components">고차 컴포넌트(Higher Order Component)로 ref 전달하기</a></ul><p><code>React.forwardRef</code>는 렌더링에 사용될 함수를 인자로 받을 수 있습니다. React는 이 함수를 두 개 인자 <code>props</code>와 <code>ref</code>를 사용하여 호출하고, 이 함수는 React 노드를 반환합니다.<p><code>embed:reference-react-forward-ref.js</code><p>위의 예시에서 React는 <code>&#x3C;FancyButton ref={ref}></code> 엘리먼트에 주어진 <code>ref</code>를 <code>React.forwardRef</code> 호출시 렌더링 함수에 2번째 인자로 전달합니다. 이 렌더링 함수는 <code>ref</code>를 <code>&#x3C;button ref={ref}></code> 엘리먼트에 전달합니다.<p>따라서 React가 해당 ref를 붙이고 난 뒤, <code>ref.current</code>는 <code>&#x3C;button></code> DOM 엘리먼트 인스턴스를 직접 가리키게 됩니다.<p>자세한 정보는 <a href="./forwarding-refs.html">ref 전달하기</a>에서 확인할 수 있습니다.</section><section id="reactlazy-reactlazy"class="level3"><h3><code>React.lazy</code> {#reactlazy}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/lazy"><code>lazy</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><p><code>React.lazy()</code>를 사용하면 동적으로 불러오는 컴포넌트를 정의할 수 있습니다. 그러면 번들의 크기를 줄이고, 초기 렌더링에서 사용되지 않는 컴포넌트를 불러오는 작업을 지연시킬 수 있습니다.<p>사용 방법은 <a href="./code-splitting.html#reactlazy">Code Splitting</a> 문서에서 익힐 수 있습니다. 또한 사용 방법을 자세히 다룬 <a href="https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d">이 글</a>을 읽어보는 것도 좋습니다.<pre class="language-js"><code class="language-js"><span class="token comment">// 이 컴포넌트는 동적으로 불러옵니다</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">SomeComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./SomeComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>lazy</code>한 컴포넌트를 렌더링하려면 렌더링 트리 상위에 <code>&#x3C;React.Suspense></code> 컴포넌트가 존재해야 한다는 점에 유의하세요. 이를 활용하여 로딩 지시기(Loading indicator)를 나타낼 수 있습니다.</section><section id="reactsuspense-reactsuspense"class="level3"><h3><code>React.Suspense</code> {#reactsuspense}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/Suspense"><code>Suspense</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><p><code>React.Suspense</code> lets you specify the loading indicator in case some components in the tree below it are not yet ready to render. In the future we plan to let <code>Suspense</code> handle more scenarios such as data fetching. You can read about this in <a href="/blog/2018/11/27/react-16-roadmap.html">our roadmap</a>.<p><code>React.Suspense</code>는 트리 하단에 있는 일부 컴포넌트가 아직 렌더링할 준비가 되지 않은 경우 로딩 지시기 (Loading indicator)를 나타낼 수 있도록 해줍니다. 향후에는 <code>Suspense</code>가 데이터 가져오기(fetching)등의 더 많은 시나리오를 처리할 수 있도록 할 계획입니다. 이에 대한 내용은 <a href="/blog/2018/11/27/react-16-roadmap.html">로드맵</a>에서 확인할 수 있습니다.<p>현재 <code>&#x3C;React.Suspense></code>가 지원하는 <strong>유일한</strong> 사용 사례는 lazy loading 컴포넌트입니다.<pre class="language-js"><code class="language-js"><span class="token comment">// 이 컴포넌트는 동적으로 불러옵니다</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">OtherComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./OtherComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token comment">// Displays &#x3C;Spinner> until OtherComponent loads</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Suspense</span></span> fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Spinner</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
        <span class="token operator">&#x3C;</span><span class="token maybe-class-name">OtherComponent</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Suspense</span></span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>관련된 내용을 <a href="./code-splitting.html#reactlazy">Code Splitting 가이드</a> 문서에서 설명하고 있습니다. <code>lazy</code>한 컴포넌트는 <code>Suspense</code> 트리 내의 깊숙한 곳에 위치할 수 있다는 점에 유의하세요. 즉, <code>Suspense</code>가 모든 컴포넌트를 감쌀 필요는 없다는 것입니다. 가장 좋은 사용법은 로딩 지시기를 보여주고 싶은 지점에 <code>&#x3C;Suspense></code>를 작성하는 것이지만, Code Splitting을 하고자 하는 지점 어디서든지 <code>lazy()</code>를 써야 할 것입니다.<blockquote><p>주의<p>사용자에게 이미 표시된 콘텐츠의 경우, 다시 로딩 지시기(Loading Indicator)로 전환되는 것은 혼란을 야기할 수 있습니다. 때로는 새로운 UI가 준비되는 동안 "기존의" UI를 보여주는 것이 더 나을 수 있습니다. 이를 위해, 새로운 transition API인 <a href="#starttransition"><code>startTransition</code></a>과 <a href="./hooks-reference.html#usetransition"><code>useTransition</code></a>를 사용하여 수정된 내용을 transition으로 표시하고 예상치 못한 fallback을 방지할 수 있습니다.</blockquote><section id="서버-사이드-렌더링에서의-reactsuspense-reactsuspense-in-server-side-rendering"class="level4"><h4>서버 사이드 렌더링에서의 <code>React.Suspense</code> {#reactsuspense-in-server-side-rendering}</h4><p>서버 사이드 렌더링 중에 Suspense 경계(Suspense Boundaries)를 사용하면 어플리케이션을 일시 중단하여 더 작은 덩어리로 렌더링할 수 있습니다. 컴포넌트 렌더링이 일시 중단되면 가장 가까운 Suspense boundary의 fallback을 렌더링하기 위해 우선 순위가 낮은 작업을 예약합니다. Fallback을 렌더링 하기 전에 컴포넌트 렌더링이 재개된다면(unsuspends) 실제 콘텐츠를 보여주고 fallback을 제거합니다.</section><section id="reactsuspense-during-hydration"class="level4"><h4><code>React.Suspense</code> during hydration</h4><p>Suspense boundaries depend on their parent boundaries being hydrated before they can hydrate, but they can hydrate independently from sibling boundaries. Events on a boundary before it is hydrated will cause the boundary to hydrate at a higher priority than neighboring boundaries. <a href="https://github.com/reactwg/react-18/discussions/130">Read more</a></section></section><section id="reactstarttransition-starttransition"class="level3"><h3><code>React.startTransition</code> {#starttransition}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/startTransition"><code>startTransition</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><pre class="language-js"><code class="language-js"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">startTransition</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span></code></pre><p><code>React.startTransition</code> 는 제공된 콜백의 내부를 transition으로 표시할 수 있게합니다. 해당 메서드는 <a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a> 를 사용할 수 없는 경우에 사용하도록 설계되었습니다.<blockquote><p>주의<p>Transition 업데이트는 click과 같은 우선순위가 높은 업데이트에 순서를 양보합니다.<p>Transition 중 일어나는 업데이트는 다시 일시 중단된(re-suspended) 콘텐츠에 대한 fallback을 표시하지 않으므로, 사용자가 업데이트를 렌더링하는 동안 계속하여 상호 작용 할 수 있도록 해줍니다.<p><code>React.startTransition</code>는 <code>isPending</code> 플래그를 제공하지 않습니다. Transition의 대기 상태(pending status)를 추적하려면 <a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a>를 참고하세요. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></blockquote></section></section></section>