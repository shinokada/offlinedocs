<!doctype html><html lang="ko"><meta charset="utf-8"><title>useInsertionEffect</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="useinsertioneffect"><h1 id="useinsertioneffect">useInsertionEffect</h1><pitfall><p><code>useInsertionEffect</code>는 CSS-in-JS 라이브러리 작성자를 위한 것입니다. CSS-in-JS 라이브러리 작업 중에 스타일을 주입할 위치가 필요한 것이 아니라면, <a href="/reference/react/useEffect"><code>useEffect</code></a> 또는 <a href="/reference/react/useLayoutEffect"><code>useLayoutEffect</code></a>를 사용하세요.</p></pitfall><intro><p><code>useInsertionEffect</code>는 layout effects 가 실행되기 전에 전체 요소를 DOM 에 주입 할 수 있습니다.<pre class="language-js"><code class="language-js"><span class="token function">useInsertionEffect</span><span class="token punctuation">(</span>setup<span class="token punctuation">,</span> dependencies<span class="token operator">?</span><span class="token punctuation">)</span></code></pre></intro><inlinetoc><section class="level2"aria-labelledby="레퍼런스-reference"><h2 id="레퍼런스-reference">레퍼런스 {/<em>reference</em>/}</h2><section class="level3"aria-labelledby="useinsertioneffectsetup-dependencies-useinsertioneffect"><h3 id="useinsertioneffectsetup-dependencies-useinsertioneffect"><code>useInsertionEffect(setup, dependencies?)</code> {/<em>useinsertioneffect</em>/}</h3><p><code>useInsertionEffect</code>를 호출하여 layout 을 읽어야하는 effects 가 호출 되기 전에 스타일을 주입할 수 있습니다.<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> useInsertionEffect <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token comment">// CSS-in-JS 라이브러리 안에서</span>
<span class="token keyword">function</span> <span class="token function">useCSS</span><span class="token punctuation">(</span><span class="token parameter">rule</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useInsertionEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// ... &#x3C;style> 태그를 여기에서 주입하세요 ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> rule<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><a href="#usage">더 많은 예시 보기</a><section class="level4"aria-labelledby="매개변수-parameters"><h4 id="매개변수-parameters">매개변수 {/<em>parameters</em>/}</h4><ul><li><p><code>setup</code>: effects의 로직이 포함된 함수입니다. setup 함수는 선택적으로 <em>cleanup</em> 함수를 반환할 수도 있습니다. 컴포넌트가 DOM에 추가되기 전에, layout effects 가 실행되기 전에, React는 setup 함수를 실행합니다. dependencies가 변경되어 다시 렌더링할 때마다, React는 먼저 이전 값으로 cleanup 함수(제공한 경우)를 실행한 다음 새 값으로 setup 함수를 실행합니다. 컴포넌트가 DOM에서 제거되기 전에 React는 cleanup 함수를 한 번 더 실행합니다.<li><p><strong>선택사항</strong> <code>dependencies</code>: <code>setup</code> 코드 내에서 참조된 모든 반응형 값의 목록입니다. 반응형 값에는 props, state, 그리고 컴포넌트 본문에 직접 선언된 모든 변수와 함수가 포함됩니다. linter가 <a href="/learn/editor-setup#linting">React용으로 설정된</a> 경우, 모든 반응형 값이 의존성으로 올바르게 지정되었는지 확인합니다. 의존성 목록에는 일정한 수의 항목이 있어야 하며 <code>[dep1, dep2, dep3]</code>와 같이 작성해야 합니다. React는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is</code></a> 비교 알고리즘을 사용하여 각 의존성을 이전 값과 비교합니다. 의존성을 전혀 지정하지 않으면 컴포넌트를 다시 렌더링할 때마다 Effect가 다시 실행됩니다.</ul></section><section class="level4"aria-labelledby="반환-값-returns"><h4 id="반환-값-returns">반환 값 {/<em>returns</em>/}</h4><p><code>useInsertionEffect</code>는 <code>undefined</code>를 반환합니다.</section><section class="level4"aria-labelledby="주의사항-caveats"><h4 id="주의사항-caveats">주의사항 {/<em>caveats</em>/}</h4><ul><li>이펙트는 클라이언트에서만 실행됩니다. 서버 렌더링 중에는 실행되지 않습니다.<li><code>useInsertionEffect</code> 내부에서는 상태를 업데이트할 수 없습니다.<li><code>useInsertionEffect</code>가 실행되는 시점에 ref는 아직 연결되지 않습니다.<li><code>useInsertionEffect</code> 는 DOM 의 업데이트 전 또는 후에 실행됩니다. DOM 이 업데이트 되는 특정시점에 의존해서는 안됩니다.<li>매번 모든 cleanup 을 실행하고 setup 하는 다른 Effects 와 달리, <code>useInsertionEffect</code> 는 하나의 컴포넌트에 대해 cleanup 과 setup 을 모두 실행합니다. 그 결과 cleanup 과 setup 이 'interleaving' 됩니다.</ul></section></section></section><section class="level2"aria-labelledby="사용법-usage"><h2 id="사용법-usage">사용법 {/<em>usage</em>/}</h2><section class="level3"aria-labelledby="css-in-js-라이브러리에서-동적-스타일-주입하기-injecting-dynamic-styles-from-css-in-js-libraries"><h3 id="css-in-js-라이브러리에서-동적-스타일-주입하기-injecting-dynamic-styles-from-css-in-js-libraries">CSS-in-JS 라이브러리에서 동적 스타일 주입하기 {/<em>injecting-dynamic-styles-from-css-in-js-libraries</em>/}</h3><p>전통적으로 plain CSS를 사용해 React 컴포넌트의 스타일을 지정했습니다.<pre class="language-js"><code class="language-js"><span class="token comment">// JS 파일 안에서</span>
<span class="token operator">&#x3C;</span>button className<span class="token operator">=</span><span class="token string">"success"</span> <span class="token operator">/</span><span class="token operator">></span>

<span class="token comment">// CSS 파일 안에서</span>
<span class="token punctuation">.</span><span class="token property-access">success</span> <span class="token punctuation">{</span> <span class="token literal-property property">color</span><span class="token operator">:</span> green<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>일부 팀은 CSS 파일을 작성하는 대신 자바스크립트 코드에서 직접 스타일을 작성하는 것을 선호합니다. 이 경우 일반적으로 CSS-in-JS 라이브러리 또는 도구를 사용해야 합니다. CSS-in-JS에는 세 가지 일반적인 접근 방식이 있습니다:<ol><li>컴파일러를 사용하여 CSS 파일로 정적 추출<li>인라인 스타일, 예: <code>&#x3C;div style={{ opacity: 1 }}></code><li>런타임에 <code>&#x3C;style></code> 태그 주입</ol><p>CSS-in-JS를 사용하는 경우 처음 두 가지 접근 방식(정적 스타일의 경우 CSS 파일, 동적 스타일의 경우 인라인 스타일)을 조합하여 사용하는 것이 좋습니다. <strong>런타임 <code>&#x3C;style></code> 태그 주입은 다음 두 가지 이유로 권장하지 않습니다.</strong><ol><li>런타임 주입은 브라우저에서 스타일을 훨씬 더 자주 다시 계산하도록 합니다.<li>런타임 주입이 React 생명주기 중에 잘못된 시점에 발생하면 속도가 매우 느려질 수 있습니다.</ol><p>첫 번째 문제는 해결할 수 없지만 <code>useInsertionEffect</code>를 사용하면 두 번째 문제를 해결할 수 있습니다.<p><code>useInsertionEffect</code>를 호출하여 layout effects 가 발생하기 전에 스타일을 주입합니다:<pre class="language-js"><code class="language-js"><span class="token comment">// CSS-in-JS 라이브러리 안에서</span>
<span class="token keyword">let</span> isInserted <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">useCSS</span><span class="token punctuation">(</span><span class="token parameter">rule</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useInsertionEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// 앞서 설명했듯이 &#x3C;style> 태그의 런타임 주입은 권장하지 않습니다.</span>
    <span class="token comment">// 하지만 꼭 주입해야 한다면 useInsertionEffect에서 주입하는 것이 중요합니다.</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isInserted<span class="token punctuation">.</span><span class="token method function property-access">has</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isInserted<span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">head</span><span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span><span class="token function">getStyleForRule</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> rule<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Button</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> className <span class="token operator">=</span> <span class="token function">useCSS</span><span class="token punctuation">(</span><span class="token string">'...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>div className<span class="token operator">=</span><span class="token punctuation">{</span>className<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><code>useEffect</code>와 마찬가지로 <code>useInsertionEffect</code>는 서버에서 실행되지 않습니다. 서버에서 어떤 CSS 규칙이 사용되었는지 수집해야 하는 경우 렌더링 중에 수집할 수 있습니다:<pre class="language-js"><code class="language-js"><span class="token keyword">let</span> collectedRulesSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">useCSS</span><span class="token punctuation">(</span><span class="token parameter">rule</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token dom variable">window</span> <span class="token operator">===</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    collectedRulesSet<span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">useInsertionEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> rule<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><a href="https://github.com/reactwg/react-18/discussions/110">런타임 인젝션이 있는 CSS-in-JS 라이브러리를 <code>useInsertionEffect</code>로 업그레이드하는 방법에 대해 자세히 알아보세요.</a></p><deepdive><section class="level4"aria-labelledby="이것이-렌더링-중에-스타일을-주입하거나-uselayouteffect를-사용하는-것보다-어떻게-더-나은가요-how-is-this-better-than-injecting-styles-during-rendering-or-uselayouteffect"><h4 id="이것이-렌더링-중에-스타일을-주입하거나-uselayouteffect를-사용하는-것보다-어떻게-더-나은가요-how-is-this-better-than-injecting-styles-during-rendering-or-uselayouteffect">이것이 렌더링 중에 스타일을 주입하거나 useLayoutEffect를 사용하는 것보다 어떻게 더 나은가요? {/<em>how-is-this-better-than-injecting-styles-during-rendering-or-uselayouteffect</em>/}</h4><p>렌더링 중에 스타일을 주입하고 React가 <a href="/reference/react/useTransition#marking-a-state-update-as-non-blocking-transition">non-blocking update</a>를 처리하는 경우 브라우저는 컴포넌트 트리를 렌더링하는 동안 매 프레임마다 스타일을 다시 계산하므로 <strong>매우 느릴 수 있습니다.</strong><p><code>useInsertionEffect</code>는 컴포넌트에서 다른 Effect가 실행될 때 <code>&#x3C;style></code> 태그가 주입되어 있음을 보장하기 때문에 <a href="/reference/react/useLayoutEffect"><code>useLayoutEffect</code></a> 또는 <a href="/reference/react/useEffect"><code>useEffect</code></a>로 스타일을 주입하는 것보다 낫습니다. 그렇지 않으면 오래된 스타일로 인해 일반 Effects의 레이아웃 계산이 잘못될 수 있습니다.</p><span style="float:footnote"><a href="../../index.html#toc">Go to TOC</a></span></section></deepdive></section></section></inlinetoc></section>