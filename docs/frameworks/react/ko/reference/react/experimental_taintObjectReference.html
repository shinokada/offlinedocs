<!doctype html><html lang="ko"><meta charset="utf-8"><title>experimental_taintObjectReference</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="experimental_taintobjectreference"><h1 id="experimental_taintobjectreference">experimental_taintObjectReference</h1><wip><p><strong>이 API는 실험적이며 React 안정 버전에서는 아직 사용할 수 없습니다.</strong><p>이 API를 사용하려면 React 패키지를 가장 최근의 실험적인 버전으로 업그레이드해야 합니다.<ul><li><code>react@experimental</code><li><code>react-dom@experimental</code><li><code>eslint-plugin-react-hooks@experimental</code></ul><p>실험적인 버전의 React에는 버그가 있을 수 있습니다. 프로덕션에서는 사용하지 마세요.<p>이 API는 React 서버 컴포넌트에서만 사용할 수 있습니다.</p></wip><intro><p><code>taintObjectReference</code>를 사용하면 <code>user</code> 객체와 같은 특정한 객체 인스턴스를 클라이언트 컴포넌트로 전송하는 것을 방지할 수 있습니다.<pre class="language-js"><code class="language-js"><span class="token function">experimental_taintObjectReference</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>키, 해시 또는 토큰이 전달되는 것을 방지하는 방법은 <a href="/reference/react/experimental_taintUniqueValue"><code>taintUniqueValue</code></a>를 참고하세요.</p></intro><inlinetoc><section class="level2"aria-labelledby="레퍼런스-reference"><h2 id="레퍼런스-reference">레퍼런스 {/<em>reference</em>/}</h2><section class="level3"aria-labelledby="taintobjectreferencemessage-object-taintobjectreference"><h3 id="taintobjectreferencemessage-object-taintobjectreference"><code>taintObjectReference(message, object)</code> {/<em>taintobjectreference</em>/}</h3><p>클라이언트로 전달되지 않아야 할 객체를 <code>taintObjectReference</code>와 함께 호출하여 React에 등록합니다.<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>experimental_taintObjectReference<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token function">experimental_taintObjectReference</span><span class="token punctuation">(</span>
  <span class="token string">'환경 변수는 클라이언트로 전달하지 마세요.'</span><span class="token punctuation">,</span>
  process<span class="token punctuation">.</span><span class="token property-access">env</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a href="#usage">더 많은 예제를 아래에서 볼 수 있습니다.</a><section class="level4"aria-labelledby="매개변수-parameters"><h4 id="매개변수-parameters">매개변수 {/<em>parameters</em>/}</h4><ul><li><p><code>message</code>: 객체가 클라이언트 컴포넌트로 전달될 때 표시할 메시지. 객체가 클라이언트 컴포넌트로 전달될 때 발생하는 에러 객체에 포함되어 나타나는 메시지입니다.<li><p><code>object</code>: 오염(taint)될 객체. 함수와 클래스 인스턴스도 <code>object</code>로서 <code>taintObjectReference</code>에 전달될 수 있습니다. 함수와 클래스는 클라이언트 컴포넌트로 전달되지 않도록 이미 막혀있지만 React의 기본 에러 메시지 대신 <code>message</code>에 설정한 메시지를 보여줄 수 있습니다. 타입 배열(Typed Array)의 인스턴스를 <code>object</code>로서 <code>taintObjectReference</code>에 전달하면 같은 타입 배열의 다른 인스턴스가 오염되지 않습니다.</ul></section><section class="level4"aria-labelledby="반환값-returns"><h4 id="반환값-returns">반환값 {/<em>returns</em>/}</h4><p><code>experimental_taintObjectReference</code>는 <code>undefined</code>를 반환합니다.</section><section class="level4"aria-labelledby="주의사항-caveats"><h4 id="주의사항-caveats">주의사항 {/<em>caveats</em>/}</h4><ul><li>오염된 객체를 다시 작성하거나 복제하면 오염되지 않은 객체가 새로 만들어집니다. 새로 만들어진 객체는 민감한 데이터를 포함할 수 있습니다. 예를 들어, 오염된 <code>user</code> 객체가 있다고 할 때, <code>const userInfo = {name: user.name, ssn: user.ssn}</code> 혹은 <code>{...user}</code>를 실행하면 오염되지 않은 새로운 객체를 작성합니다. <code>taintObjectReference</code>는 객체가 변경되지 않은 상태에서 클라이언트 컴포넌트로 그대로 전달되는 것만 방지합니다.</ul><pitfall><p><strong>보안을 오염에만 의존하지 마세요.</strong> 객체를 오염시켰다고 해서 모든 누출 가능성을 막을 수는 없습니다. 예를 들어 오염된 객체를 복제하면 오염되지 않은 새로운 객체가 만들어집니다. 오염된 객체에서 가져온 데이터를 사용하여(예. <code>{secret: taintedObj.secret}</code>) 작성된 새 값이나 객체는 오염되지 않습니다. 오염은 한 겹의 보호 장치일 뿐입니다. 보안성이 높은 애플리케이션은 여러 겹의 보호 장치와 잘 설계된 API를 마련해 두고 격리 패턴을 따릅니다.</p></pitfall></section></section></section><section class="level2"aria-labelledby="사용법-usage"><h2 id="사용법-usage">사용법 {/<em>usage</em>/}</h2><section class="level3"aria-labelledby="사용자-데이터가-의도하지-않게-클라이언트로-전달되는-것을-방지하기-prevent-user-data-from-unintentionally-reaching-the-client"><h3 id="사용자-데이터가-의도하지-않게-클라이언트로-전달되는-것을-방지하기-prevent-user-data-from-unintentionally-reaching-the-client">사용자 데이터가 의도하지 않게 클라이언트로 전달되는 것을 방지하기 {/<em>prevent-user-data-from-unintentionally-reaching-the-client</em>/}</h3><p>클라이언트 컴포넌트에는 민감한 데이터를 담은 객체가 전달되어서는 안 됩니다. 이상적으로, 데이터 페치 함수는 현재 사용자가 접근할 수 없는 데이터를 노출하면 안 됩니다. 하지만 리팩토링 도중 가끔 실수가 발생하기도 합니다. 데이터 API에서 사용자 객체를 "오염(taint)"시켜서 이러한 실수를 방지할 수 있습니다.<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>experimental_taintObjectReference<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword control-flow">await</span> db<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">SELECT * FROM users WHERE id = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token function">experimental_taintObjectReference</span><span class="token punctuation">(</span>
    <span class="token string">'user 객체 전체를 클라이언트로 전달하지 마세요.'</span> <span class="token operator">+</span>
      <span class="token string">'필요하다면 일부 특정한 프로퍼티만 뽑아서 사용하는 것이 좋습니다.'</span><span class="token punctuation">,</span>
    user<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> user<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>이제 누군가 이 객체를 클라이언트 컴포넌트로 전달하려고 하면 전달된 에러 메시지와 함께 에러가 발생됩니다.</p><deepdive><section class="level4"aria-labelledby="데이터-페치에서-누출-방지하기-protecting-against-leaks-in-data-fetching"><h4 id="데이터-페치에서-누출-방지하기-protecting-against-leaks-in-data-fetching">데이터 페치에서 누출 방지하기 {/<em>protecting-against-leaks-in-data-fetching</em>/}</h4><p>민감한 데이터에 접근할 수 있는 서버 컴포넌트 환경을 실행하고 있다면 객체를 그대로 전달할 때 주의를 기울여야 합니다.<pre class="language-js"><code class="language-js"><span class="token comment">// api.js</span>
<span class="token keyword module">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword control-flow">await</span> db<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">SELECT * FROM users WHERE id = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> user<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> getUser <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'api.js'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">InfoCard</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'components.js'</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Profile</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">getUser</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">userId</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// DO NOT DO THIS</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">InfoCard</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token comment">// components.js</span>
<span class="token string">"use client"</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">InfoCard</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> user <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>div<span class="token operator">></span><span class="token punctuation">{</span>user<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>이상적으로, <code>getUser</code>는 현재 사용자가 접근할 수 없는 데이터를 노출하지 않아야 합니다. <code>user</code> 객체가 클라이언트 컴포넌트로 전달되는 것을 방지하려면 사용자 객체를 "오염(taint)"시켜야 합니다.<pre class="language-js"><code class="language-js"><span class="token comment">// api.js</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>experimental_taintObjectReference<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword control-flow">await</span> db<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">SELECT * FROM users WHERE id = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token function">experimental_taintObjectReference</span><span class="token punctuation">(</span>
    <span class="token string">'user 객체 전체를 클라이언트로 전달하지 마세요. '</span> <span class="token operator">+</span>
      <span class="token string">'필요하다면 일부 특정한 프로퍼티만 뽑아서 사용하는 것이 좋습니다.'</span><span class="token punctuation">,</span>
    user<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> user<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>이제 누군가 <code>user</code> 객체를 클라이언트 컴포넌트로 전달하려고 하면 설정한 에러 메시지와 함께 에러가 발생합니다.</p><span style="float:footnote"><a href="../../index.html#toc">Go to TOC</a></span></section></deepdive></section></section></inlinetoc></section>