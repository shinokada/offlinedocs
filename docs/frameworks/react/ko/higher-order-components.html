<!doctypehtml><html lang="ko"><meta charset="utf-8"><title>고차 컴포넌트</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="고차-컴포넌트"class="level1"><h1>고차 컴포넌트</h1><p>고차 컴포넌트(HOC, Higher Order Component)는 컴포넌트 로직을 재사용하기 위한 React의 고급 기술입니다. 고차 컴포넌트(HOC)는 React API의 일부가 아니며, React의 구성적 특성에서 나오는 패턴입니다.<p>구체적으로, <strong>고차 컴포넌트는 컴포넌트를 가져와 새 컴포넌트를 반환하는 함수입니다.</strong><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">higherOrderComponent</span><span class="token punctuation">(</span><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>컴포넌트는 props를 UI로 변환하는 반면에, 고차 컴포넌트는 컴포넌트를 새로운 컴포넌트로 변환합니다.<p>고차 컴포넌트(HOC)는 Redux의 <a href="https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect"><code>connect</code></a>와 Relay의 <a href="https://relay.dev/docs/v10.1.3/fragment-container/#createfragmentcontainer"><code>createFragmentContainer</code></a>와 같은 서드 파티 React 라이브러리에서 흔하게 볼 수 있습니다.<p>이 문서에서는 고차 컴포넌트가 유용한 이유를 보여주고, 직접 작성하는 방법에 대해 알아보겠습니다.<section id="use-hocs-for-cross-cutting-concerns"class="level2"><h2>횡단 관심사(Cross-Cutting Concerns)에 고차 컴포넌트 사용하기</h2><blockquote><p><strong>주의</strong><p>이전에는 횡단 관심사 문제를 제어하기 위해 mixin 사용을 권장했습니다. 하지만 mixin을 사용하는 것은 더 많은 문제를 일으킨다는 것을 알게 되었습니다. 우리가 mixin을 더 이상 권장하지 않는 이유와 기존 컴포넌트를 어떻게 변환하는지에 대해서 <a href="/blog/2016/07/13/mixins-considered-harmful.html">이 글</a>을 읽어보세요.</blockquote><p>컴포넌트는 React에서 코드 재사용의 기본 단위입니다. 그러나 어떤 패턴은 기존 컴포넌트에 잘 적용되지 않을 수 있습니다.<p>외부로부터 데이터를 구독하여 댓글 목록을 렌더링하는 <code>CommentList</code> 컴포넌트를 예로 들겠습니다.<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CommentList</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">handleChange</span><span class="token punctuation">.</span><span class="token method function property-access">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token comment">// "DataSource" 는 글로벌 데이터 소스입니다.</span>
      <span class="token literal-property property">comments</span><span class="token operator">:</span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getComments</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 변화감지를 위해 리스너를 추가합니다.</span>
    <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">addChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 리스너를 제거합니다.</span>
    <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">removeChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 데이터 소스가 변경될때 마다 comments를 업데이트합니다.</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">comments</span><span class="token operator">:</span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getComments</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
        <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">comments</span><span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">comment</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span>
          <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Comment</span> comment<span class="token operator">=</span><span class="token punctuation">{</span>comment<span class="token punctuation">}</span> key<span class="token operator">=</span><span class="token punctuation">{</span>comment<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>그리고 블로그 포스트를 구독하기 위해 위와 비슷한 패턴으로 컴포넌트를 작성합니다.<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">BlogPost</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">handleChange</span><span class="token punctuation">.</span><span class="token method function property-access">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">blogPost</span><span class="token operator">:</span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getBlogPost</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">addChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">removeChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">blogPost</span><span class="token operator">:</span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getBlogPost</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">TextBlock</span> text<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">blogPost</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p><code>CommentList</code>와 <code>BlogPost</code> 컴포넌트는 동일하지 않습니다. 두 컴포넌트는 <code>DataSource</code>에서 서로 다른 메서드를 호출하며 다른 렌더링 결과를 보여줍니다. 하지만 대부분의 구현체는 동일합니다.<ul><li>컴포넌트가 마운트되면, change 리스너를 <code>DataSource</code>에 추가합니다.<li>리스너 안에서, 데이터 소스가 변경되면 <code>setState</code>를 호출합니다.<li>컴포넌트가 마운트 해제되면 change 리스너를 제거합니다.</ul><p>규모가 큰 애플리케이션에서 <code>DataSource</code>를 구독하고 <code>setState</code> 를 호출하는 동일한 패턴이 반복적으로 발생한다고 가정해봅시다. 그렇게 된다면 이 로직을 한 곳에서 정의하고 많은 컴포넌트에서 로직을 공유할 수 있게 하는 추상화가 필요하게 됩니다. 이러한 경우에 고차 컴포넌트를 사용하면 좋습니다.<p><code>DataSource</code> 를 구독하는 <code>CommentList</code> 나 <code>BlogPost</code> 같은 컴포넌트를 생성하는 함수를 작성할 수 있습니다. 구독한 데이터를 prop으로 전달받는 자식 컴포넌트를 파라미터 중 하나로 받는 함수를 만듭니다. 이 함수를 <code>withSubscription</code> 라고 합시다.<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">CommentListWithSubscription</span> <span class="token operator">=</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span>
  <span class="token maybe-class-name">CommentList</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">DataSource</span></span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getComments</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token maybe-class-name">BlogPostWithSubscription</span> <span class="token operator">=</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span>
  <span class="token maybe-class-name">BlogPost</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">DataSource</span><span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getBlogPost</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>첫 번째 파라미터는 래핑된 컴포넌트입니다. 두 번째 파라미터에는 <code>DataSource</code>와 현재 props를 가지고 컴포넌트에서 관심 있는 데이터를 검색합니다.<p><code>CommentListWithSubscription</code> 과 <code>BlogPostWithSubscription</code> 가 렌더링될 때 <code>CommentList</code> 와 <code>BlogPost</code> 는 <code>DataSource</code> 에서 가장 최근에 검색된 데이터를 <code>data</code> prop으로 전달합니다.<pre class="language-js"><code class="language-js"><span class="token comment">// 이 함수는 컴포넌트를 매개변수로 받고..</span>
<span class="token keyword">function</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">,</span> selectData</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...다른 컴포넌트를 반환하는데...</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Component</span></span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">handleChange</span><span class="token punctuation">.</span><span class="token method function property-access">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token function">selectData</span><span class="token punctuation">(</span><span class="token maybe-class-name">DataSource</span><span class="token punctuation">,</span> props<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ... 구독을 담당하고...</span>
      <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">addChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">removeChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token function">selectData</span><span class="token punctuation">(</span><span class="token maybe-class-name">DataSource</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ... 래핑된 컴포넌트를 새로운 데이터로 랜더링 합니다!</span>
      <span class="token comment">// 컴포넌트에 추가로 props를 내려주는 것에 주목하세요.</span>
      <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">WrappedComponent</span> data<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>고차 컴포넌트는 입력된 컴포넌트를 수정하지 않으며 상속을 사용하여 동작을 복사하지도 않습니다. 오히려 고차 컴포넌트는 원본 컴포넌트를 컨테이너 컴포넌트로 <em>포장(Wrapping)</em>하여 <em>조합(compose)</em>합니다. 고차 컴포넌트는 사이드 이펙트가 전혀 없는 순수 함수입니다.<p>이게 전부입니다! 래핑된 컴포넌트는 새로운 props, <code>data</code>와 함께 컨테이너의 모든 props를 전달받으며, 이 데이터들은 출력을 렌더링하는 데 사용됩니다. 고차 컴포넌트는 데이터가 사용되는 이유 및 방법과 연관이 없으며 래핑된 컴포넌트는 데이터가 어디서부터 왔는지와 관련이 없습니다.<p><code>withSubscription</code> 는 일반 함수이기 때문에 원하는 개수의 인수를 추가할 수 있습니다. 예를 들어 래핑된 컴포넌트로부터 고차 컴포넌트를 더 격리시키기 위해 <code>data</code> prop 이름을 설정할 수 있게 만들 수 있습니다. 혹은 <code>shouldComponentUpdate</code> 설정을 위한 인수를 받게 하거나 데이터 소스를 설정하는 인수를 받게할 수도 있습니다. 고차 컴포넌트가 컴포넌트 정의 방법을 완전히 제어할 수 있기 때문에 이런 작업이 모두 가능합니다.<p>컴포넌트와 마찬가지로 <code>withSubscription</code>과 래핑된 컴포넌트 간 계약(contract)은 완전히 props 기반입니다. 이렇게하면 래핑된 컴포넌트에 동일한 props를 제공한다면 다른 고차 컴포넌트를 쉽게 변경할 수 있습니다. 예를 들어 데이터를 가져오는 라이브러리를 변경하는 경우 유용하게 사용할 수 있습니다.</section><section id="dont-mutate-the-original-component-use-composition"class="level2"><h2>원본 컴포넌트를 변경하지 마세요. 조합(Composition)하세요.</h2><p>고차 컴포넌트 내부에서 컴포넌트의 프로토타입을 수정(또는 변경)하지 않도록 합니다.<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">logProps</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">InputComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">InputComponent</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">componentDidUpdate</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">prevProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'Current props: '</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'Previous props: '</span><span class="token punctuation">,</span> prevProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 원본의 입력을 반환한다는 것은 이미 변형되었다는 점을 시사합니다.</span>
  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">InputComponent</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// EnhancedComponent 는 props를 받을 때 마다 log를 남깁니다.</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">logProps</span><span class="token punctuation">(</span><span class="token maybe-class-name">InputComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>여기엔 몇 가지의 문제가 있습니다. 그 중 하나는 입력된 컴포넌트를 확장된(enhanced) 컴포넌트와 별도로 재사용 할 수 없다는 것입니다. 더 중요한 것은, <code>componentDidUpdate</code>를 변형하는 <code>EnhancedComponent</code>에 또 다른 HOC를 적용하면 첫 번째 HOC의 기능은 무시됩니다! 이 HOC는 생명주기 메서드가 없는 함수 컴포넌트에서도 작동하지 않습니다.<p>변경(mutation)된 HOC는 누출된 추상화(leaky abstraction)입니다. Consumer는 다른 HOC와의 충돌을 피하기 위하여 어떻게 구현되어있는지 반드시 알아야 합니다.<p>HOC는 변경(mutation)대신에 입력 컴포넌트를 컨테이너 구성요소로 감싸서 조합(composition)을 사용해야 합니다.<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">logProps</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Component</span></span> <span class="token punctuation">{</span>
    <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'Current props: '</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'Previous props: '</span><span class="token punctuation">,</span> prevProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 들어온 component를 변경하지 않는 container입니다. 좋아요!</span>
      <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">WrappedComponent</span> <span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>위 고차 컴포넌트는 충돌 가능성을 피하면서 프로토타입을 직접 변경하는 버전과 동일하게 작동합니다. 이 방법은 클래스 컴포넌트와 함수 컴포넌트에서도 동일하게 작동합니다. 그리고 순수한 함수이기 때문에 다른 고차 컴포넌트와 같이 조합하거나 심지어 자체적으로 조합할 수 있습니다.<p>고차 컴포넌트와 컨테이너 컴포넌트라 불리는 패턴이 유사하다고 느낄 수 있습니다. 컨테이너 컴포넌트는 high-level과 low-level 관심사를 분리하는 전략 중 하나입니다. 컨테이너는 구독 및 state 같은 것을 관리하고 UI 렌더링 같은 것을 처리하는 컴포넌트에 props를 전달합니다. 고차 컴포넌트는 컨테이너를 그 구현체 중 일부에 사용하고 있습니다. 고차 컴포넌트는 매개변수화된 컨테이너 컴포넌트 정의로 생각할 수 있습니다.</section><section id="convention-pass-unrelated-props-through-to-the-wrapped-component"class="level2"><h2>컨벤션: 래핑된 컴포넌트를 통해 관련없는 Props 전달하기</h2><p>고차 컴포넌트는 컴포넌트에 기능을 추가합니다. 고차 컴포넌트는 정의(contract)를 과감하게 변경해서는 안됩니다. 고차 컴포넌트에서 반환된 컴포넌트는 래핑된 컴포넌트와 비슷한 인터페이스가 있어야합니다.<p>고차 컴포넌트는 특정 관심사와 관련이 없는 props를 활용해야 합니다. 대부분의 고차 컴포넌트에는 다음과 같은 렌더링 메서드가 포함되어있습니다.<pre class="language-js"><code class="language-js"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 이 HOC에만 해당되므로 추가된 props는 걸러내어 이 HOC에 전달되지 않도록 합니다.</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> extraProp<span class="token punctuation">,</span> <span class="token spread operator">...</span>passThroughProps <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>

  <span class="token comment">// 이 Props는 일반적으로 Status값 또는 Instance method 입니다.</span>
  <span class="token keyword">const</span> injectedProp <span class="token operator">=</span> someStateOrInstanceMethod<span class="token punctuation">;</span>

  <span class="token comment">// wrapped component에 props를 전달합니다.</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">WrappedComponent</span>
      injectedProp<span class="token operator">=</span><span class="token punctuation">{</span>injectedProp<span class="token punctuation">}</span>
      <span class="token punctuation">{</span><span class="token spread operator">...</span>passThroughProps<span class="token punctuation">}</span>
    <span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>이 컨벤션은 고차 컴포넌트의 유연성과 재사용성을 보장하는데 도움이 됩니다.</section><section id="convention-maximizing-composability"class="level2"><h2>컨벤션: 조합 가능성(Composability) 끌어올리기</h2><p>고차 컴포넌트는 여러 가지 방법으로 작성할 수 있습니다. 때때로 단일 인수로 래핑된 컴포넌트만 받을 때도 있습니다.<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">NavbarWithRouter</span> <span class="token operator">=</span> <span class="token function">withRouter</span><span class="token punctuation">(</span><span class="token maybe-class-name">Navbar</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>일반적으로 고차 컴포넌트는 추가 인수를 허용합니다. Relay 예시에서 config 객체는 컴포넌트의 데이터 의존성을 지정하기 위해 사용합니다.<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">CommentWithRelay</span> <span class="token operator">=</span> <span class="token maybe-class-name">Relay</span><span class="token punctuation">.</span><span class="token method function property-access">createContainer</span><span class="token punctuation">(</span><span class="token maybe-class-name">Comment</span><span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>고차 컴포넌트에 대한 가장 일반적인 사용은 다음과 같습니다.<pre class="language-js"><code class="language-js"><span class="token comment">// React Redux의 `connect`</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">ConnectedComment</span> <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span>commentSelector<span class="token punctuation">,</span> commentActions<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token maybe-class-name">CommentList</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><em>주목!</em> 위 코드를 분해해보면 어떤 동작을 하는지 쉽게 알 수 있습니다.<pre class="language-js"><code class="language-js"><span class="token comment">// connect는 다른 함수를 반환하는 함수 입니다.</span>
<span class="token keyword">const</span> enhance <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span>commentListSelector<span class="token punctuation">,</span> commentListActions<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 반환된 함수는 Redux store에 연결된 컴포넌트를 반환하는</span>
<span class="token comment">// 고차 함수 컴포넌트 입니다.</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">ConnectedComment</span> <span class="token operator">=</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token maybe-class-name">CommentList</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>다르게 말하면 <code>connect</code> 는 고차 컴포넌트를 반환하는 고차 함수입니다.<p>이 형태는 혼란스럽거나 불필요하게 보일 수 있지만 매우 유용한 속성입니다. <code>connect</code> 함수에 의해 반환된 것과 같은 단일 인수 고차 컴포넌트는 <code>Component => Component</code> 특징을 가지고 있습니다. 출력 타입이 입력 타입과 동일한 함수는 정말 쉽게 조합할 수 있습니다.<pre class="language-js"><code class="language-js"><span class="token comment">// 이렇게 하는 대신에...</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">withRouter</span><span class="token punctuation">(</span><span class="token function">connect</span><span class="token punctuation">(</span>commentSelector<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// ... 함수 구성 유틸리티를 사용할 수 있습니다.</span>
<span class="token comment">// compose(f, g, h)는 (...args) => f(g(h(...args)))와 같습니다.</span>
<span class="token keyword">const</span> enhance <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  <span class="token comment">// 둘 다 단일 매개변수의 HOC입니다.</span>
  withRouter<span class="token punctuation">,</span>
  <span class="token function">connect</span><span class="token punctuation">(</span>commentSelector<span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span></code></pre><p>(이와 동일한 속성을 통해서 실험단계인 <code>connect</code>와 기타 인핸서 스타일의 HOC를 데코레이터로 사용할 수 있습니다.)<p><code>compose</code> 유틸리티 기능(효용 함수)는 lodash (as <a href="https://lodash.com/docs/#flowRight"><code>lodash.flowRight</code></a>), <a href="https://redux.js.org/api/compose">Redux</a>, and <a href="https://ramdajs.com/docs/#compose">Ramda</a>를 포함한 많은 서드 파티 라이브러리에서 제공하고 있습니다.</section><section id="convention-wrap-the-display-name-for-easy-debugging"class="level2"><h2>컨벤션: 간단한 디버깅을 위한 디스플레이 네임 작성 방법</h2><p>다른 구성 요소와 마찬가지로 HOC로 만든 컨테이너 구성 요소도 <a href="https://github.com/facebook/react/tree/main/packages/react-devtools">React Developer Tools</a>에 표시됩니다. 디버깅을 쉽게 하려면 HOC의 결과임을 알리는 디스플레이 네임을 작성합니다.<p>가장 일반적인 방법은 HOC의 이름으로 내부 컴포넌트명을 감싸는 것입니다. 따라서 HOC의 이름이 <code>withSubscription</code>이고, HOC 내부의 컴포넌트의 이름이 <code>CommentList</code> 인 경우, 디스플레이 네임은 <code>WithSubscription(CommentList)</code>을 사용합니다.<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">WithSubscription</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token comment">/* ... */</span><span class="token punctuation">}</span>
  <span class="token maybe-class-name">WithSubscription</span><span class="token punctuation">.</span><span class="token property-access">displayName</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">WithSubscription(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">getDisplayName</span><span class="token punctuation">(</span><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">WithSubscription</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getDisplayName</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">.</span><span class="token property-access">displayName</span> <span class="token operator">||</span> <span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">||</span> <span class="token string">'Component'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></section><section id="caveats"class="level2"><h2>주의사항</h2><p>고차 컴포넌트에는 React가 처음이라면 알아차리기 어려운 몇 가지 주의사항이 있습니다.<section id="dont-use-hocs-inside-the-render-method"class="level3"><h3>render 메서드 안에서 고차 컴포넌트를 사용하지 마세요</h3><p>재조정(reconciliation)으로 알려진 React의 비교 알고리즘은 컴포넌트의 개별성(identity)을 가지고 기존 서브트리를 업데이트 해야 하는지 아니면 버리고 새로운 노드를 마운트 해야 할지 결정합니다. <code>render</code>에서 반환된 컴포넌트가 이전에 렌더링 된 컴포넌트와 동일하다면(<code>===</code>) React가 새로운 서브트리와 비교하여 재귀적으로 서브트리를 업데이트합니다. 동일하지 않다면 이전 서브트리는 완전히 마운트 해제됩니다.<p>일반적으로 위 내용에 대해 생각할 필요는 없습니다. 하지만 컴포넌트의 render 메서드 안에서 고차 컴포넌트를 사용할 수 없기 때문에 고차 컴포넌트를 사용할 때는 위 내용을 짚고 넘어가야 합니다.<pre class="language-js"><code class="language-js"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// render가 호출될 때마다 새로운 버전의 EnhancedComponent가 생성됩니다.</span>
  <span class="token comment">// EnhancedComponent1 !== EnhancedComponent2</span>
  <span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token maybe-class-name">MyComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 때문에 매번 전체 서브트리가 마운트 해제 후 다시 마운트 됩니다!</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>여기서 성능상의 문제뿐만 아니라 컴포넌트가 다시 마운트 되면서 컴포넌트의 state와 컴포넌트의 하위 항목들이 손실됩니다.<p>대신에 컴포넌트의 정의 바깥에 HOC를 적용하여 컴포넌트가 한 번만 생성되도록 합니다. 그러면 해당 component는 여러번 렌더링이 되더라도 일관성을 유지합니다. 일반적으로 렌더링이 여러번 되어도 바뀌길 원하는 사람은 없을 것이라고 생각합니다.<p>드문 경우로 HOC를 동적으로 적용해야 할 경우에는 컴포넌트의 생명주기 메서드 또는 생성자 내에 작성 할 수 있습니다.</section><section id="static-methods-must-be-copied-over"class="level3"><h3>정적 메서드는 반드시 따로 복사하세요</h3><p>React 컴포넌트에 정적 메서드를 정의하는 것이 유용할 때도 있습니다. 예를 들어 Relay 컨테이너는 GraphQL 구성을 용이하게 하기 위해 정적 메서드 <code>getFragment</code>를 노출합니다.<p>컴포넌트에 HOC를 적용하면, 기존 컴포넌트는 컨테이너의 컴포넌트로 감싸집니다. 즉, 새 컴포넌트는 기존 컴포넌트의 정적 메서드를 가지고 있지 않습니다.<pre class="language-js"><code class="language-js"><span class="token comment">// 정적 함수를 정의합니다</span>
<span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">staticMethod</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
<span class="token comment">// HOC를 적용합니다</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 향상된 컴포넌트에는 정적 메서드가 없습니다.</span>
<span class="token keyword">typeof</span> <span class="token maybe-class-name">EnhancedComponent</span><span class="token punctuation">.</span><span class="token property-access">staticMethod</span> <span class="token operator">===</span> <span class="token string">'undefined'</span> <span class="token comment">// true</span></code></pre><p>이 문제를 해결하려면 메서드를 반환하기 전에 컨테이너에 복사합니다.<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">Enhance</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
  <span class="token comment">// 복사 할 메서드를 정확히 알아야 합니다.</span>
  <span class="token maybe-class-name">Enhance</span><span class="token punctuation">.</span><span class="token property-access">staticMethod</span> <span class="token operator">=</span> <span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">.</span><span class="token property-access">staticMethod</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">Enhance</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>그러나 복사해야 할 메서드를 정확히 알아야 할 필요가 있습니다. <a href="https://github.com/mridgway/hoist-non-react-statics">hoist-non-react-statics</a>를 사용하여 모든 non-React 정적 메서드를 자동으로 복사할 수 있습니다.<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports">hoistNonReactStatic</span> <span class="token keyword module">from</span> <span class="token string">'hoist-non-react-statics'</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">Enhance</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
  <span class="token function">hoistNonReactStatic</span><span class="token punctuation">(</span><span class="token maybe-class-name">Enhance</span><span class="token punctuation">,</span> <span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">Enhance</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>또 다른 해결 방법은 정적 메서드를 컴포넌트와 별도로 내보내는 것입니다.<pre class="language-js"><code class="language-js"><span class="token comment">// 대신에...</span>
<span class="token maybe-class-name">MyComponent</span><span class="token punctuation">.</span><span class="token property-access">someFunction</span> <span class="token operator">=</span> someFunction<span class="token punctuation">;</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token maybe-class-name">MyComponent</span><span class="token punctuation">;</span>

<span class="token comment">// ...메서드를 각각 내보내고...</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span> someFunction <span class="token punctuation">}</span></span><span class="token punctuation">;</span>

<span class="token comment">// ...불러오는 모듈에서 두개를 다 임포트합니다.</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">MyComponent</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> someFunction <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./MyComponent.js'</span><span class="token punctuation">;</span></code></pre></section><section id="refs-arent-passed-through"class="level3"><h3>ref는 전달되지 않는다</h3><p>고차 컴포넌트는 모든 props를 래핑된 컴포넌트에 전달하는 것이 원칙이지만, refs에서는 작동하지 않습니다. 이는 React에서 <code>ref</code>가 실제 prop이 아닌 <code>key</code>처럼 특별하게 취급되기 때문입니다. 컴포넌트가 HOC의 결과인 엘리먼트에 ref를 추가하는 경우, ref는 래핑된 컴포넌트가 아닌 가장 바깥쪽 컨테이너 컴포넌트의 인스턴스를 나타냅니다.<p>이 문제의 해결 방법은 <code>React.forwardRef</code> API를 사용하는 것입니다. (React 16.3에 도입됨) <a href="./forwarding-refs.html">자세한 내용은 Forwarding Refs 섹션을 참조</a>. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section></section>