<!doctype html><html lang="ko"><meta charset="utf-8"><title>구현 참고사항</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="구현-참고사항"class="level1"><h1>구현 참고사항</h1><p>이 부분은 <a href="./codebase-overview.html#stack-reconciler">스택 재조정자(reconciler)</a>에 대한 구현 참고사항입니다.<p>이는 매우 기술적이고 공개된 React API뿐만 아니라 어떻게 코어, 렌더러, 재조정자로 나누어지는지에 대해 깊은 이해가 필요합니다. 아직 React 코드 베이스에 친숙하지 않다면, 먼저 <a href="./codebase-overview.html">the codebase overview</a>를 읽기를 바랍니다.<p>이는 <a href="/blog/2015/12/18/react-components-elements-and-instances.html">React 컴포넌트와 인스턴스 그리고 엘리먼트 사이의 차이점</a>을 이해한다고 가정합니다.<p>스택 재조정자는 React 15와 그 이전 버전에 사용되었습니다. 이는<a href="https://github.com/facebook/react/tree/15-stable/src/renderers/shared/stack/reconciler">src/renderers/shared/stack/reconciler</a>에 위치해 있습니다.<section id="video-building-react-from-scratch"class="level3"><h3>비디오: React 처음부터 만들기</h3><p><a href="https://twitter.com/zpao">Paul O'Shannessy</a>는 이 문서에 크게 영감을 주었던 <a href="https://www.youtube.com/watch?v=_MAD4Oly9yg">building React from scratch</a>에 대해 이야기 하였습니다.<p>이 문서와 그의 말은 모두 현실 코드베이스의 단순화했기 때문에 여러분은 두 가지 모두 친숙해 짐으로써 더 깊은 이해를 가질 것입니다.</section><section id="overview"class="level3"><h3>개요</h3><p>재조정자는 공개된 API를 가지지 않습니다. React DOM과 React Native와 같은 <a href="./codebase-overview.html#renderers">렌더러</a>는 사용자가 쓴, React 컴포넌트에 따른 사용자 인터페이스를 효율적으로 업데이트를 하기 위해서 사용합니다.</section><section id="mounting-as-a-recursive-process"class="level3"><h3>재귀적인 과정으로써의 마운트</h3><p>여러분들이 컴포넌트를 처음 마운트할 때를 고려해 보겠습니다.<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token maybe-class-name">ReactDOM</span><span class="token punctuation">.</span><span class="token method function property-access">createRoot</span><span class="token punctuation">(</span>rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span>
root<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>root.render</code>는 재조정자를 통해 <code>&#x3C;App /></code>를 통과하게 할 것입니다. <code>&#x3C;App /></code>은 React 엘리먼트이며, 렌더링 할 것을 설명해 놓은 것임을 기억합시다. 이것을 평범한 객체로 생각해도 좋습니다.<pre class="language-js"><code class="language-js"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { type: App, props: {} }</span></code></pre><p>재조정자가 <code>App</code>이 class인지 함수인지 확인합니다.<p><code>App</code>이 함수라면, 재조정자는 렌더링 엘리먼트를 가져오기 위해 <code>App(props)</code>를 호출합니다.<p><code>App</code>이 class면, 재조정자는 <code>App</code>을 <code>new App(props)</code>로 인스턴스화 하고, <code>componentWillMount()</code> 생명주기 메서드를 호출한 후, <code>render()</code> 메서드를 호출하여 렌더링 엘리먼트를 가져오게 할 것입니다.<p>어느 경우든, 재조정자는 <code>App</code>이 렌더링 되는 엘리먼트를 학습하게 됩니다.<p>이러한 과정은 재귀적입니다. <code>App</code>은 <code>&#x3C;Greeting /></code>으로 렌더링 될 수도 있고, <code>Greeting</code>은 <code>&#x3C;Button /></code> 또는 다른 곳으로 렌더링 될 수 있습니다. 재조정자는 각 컴포넌트가 무엇을 렌더링하는지 학습할 때 사용자가 정의한 컴포넌트를 재귀적으로 조사합니다.<p>여러분들은 의사코드로 작성된 이 과정을 생각해봅시다.<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isClass</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// React.Component subclasses have this flag</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token known-class-name class-name">Boolean</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">)</span> <span class="token operator">&#x26;&#x26;</span>
    <span class="token known-class-name class-name">Boolean</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">isReactComponent</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// This function takes a React element (e.g. &#x3C;App />)</span>
<span class="token comment">// and returns a DOM or Native node representing the mounted tree.</span>
<span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> props <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>

  <span class="token comment">// We will determine the rendered element</span>
  <span class="token comment">// by either running the type as function</span>
  <span class="token comment">// or creating an instance and calling render().</span>
  <span class="token keyword">var</span> renderedElement<span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isClass</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Component class</span>
    <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Set the props</span>
    publicInstance<span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
    <span class="token comment">// Call the lifecycle if necessary</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">.</span><span class="token property-access">componentWillMount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      publicInstance<span class="token punctuation">.</span><span class="token method function property-access">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Get the rendered element by calling render()</span>
    renderedElement <span class="token operator">=</span> publicInstance<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// Component function</span>
    renderedElement <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// This process is recursive because a component may</span>
  <span class="token comment">// return an element with a type of another component.</span>
  <span class="token keyword control-flow">return</span> <span class="token function">mount</span><span class="token punctuation">(</span>renderedElement<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Note: this implementation is incomplete and recurses infinitely!</span>
  <span class="token comment">// It only handles elements like &#x3C;App /> or &#x3C;Button />.</span>
  <span class="token comment">// It doesn't handle elements like &#x3C;div /> or &#x3C;p /> yet.</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> rootEl <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> node <span class="token operator">=</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
rootEl<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>주의</strong><p>이는 의사코드입니다. 실제 구현과 비슷하지 않습니다. 우리가 이 과정을 언제 멈출 지 결정을 한 적이 없기 때문에 스택 오버플로우 또한 야기할 수 있습니다.</blockquote><p>위의 예에서 몇가지 핵심 아이디어를 요약해 봅시다.<ul><li>React 엘리먼트는 컴포넌트 타입(예: <code>App</code>)과 props를 나타내는 일반 객체입니다.<li>사용자 정의된 컴포넌트(예: <code>App</code>)은 class이거나 함수일 수 있지만 모두 엘리먼트로 렌더링됩니다.<li>"마운팅"은 최상위 React 엘리먼트(예: <code>&#x3C;App /></code>)로부터 DOM 또는 네이티브 트리를 만드는 재귀적인 과정입니다.</ul></section><section id="mounting-host-elements"class="level3"><h3>호스트 엘리먼트 마운팅</h3><p>이 과정은 우리가 스크린에 무언가를 렌더링하지 않는다면 무의미해집니다.<p>사용자 정의된("composite") 컴포넌트 외에도, React 엘리먼트는 플랫폼 특유의("host") 컴포넌트를 나타낼 수 있습니다. 예를 들어, <code>Button</code>은 렌더링된 메서드에서 <code>&#x3C;div /></code>를 리턴할 수 있습니다.<p>엘리먼트의 <code>type</code>이 문자열인 경우, 우리는 호스트 엘리먼트로 처리합니다.<pre class="language-js"><code class="language-js"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span>div <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { type: 'div', props: {} }</span></code></pre><p>이 곳에는 호스트 엘리먼트와 관련된 사용자 정의된 코드가 없습니다.<p>재조정자가 호스트 엘리먼트를 만나게 되면, 렌더러가 호스트 엘리먼트를 마운트할 수 있도록 관리합니다. 예를 들어, React DOM은 DOM 노드를 생성할 것입니다.<p>호스트 엘리먼트가 자식을 가지고 있으면, reconciler가 위와 동일한 알고리즘에 따라 재귀적으로 자식을 마운트합니다. 이는 자식이 호스트(like <code>&#x3C;div>&#x3C;hr />&#x3C;/div></code>)인지 사용자 정의(like <code>&#x3C;div>&#x3C;Button />&#x3C;/div></code>) 되었는지는 상관이 없습니다.<p>자식에 의해 만들어진 DOM 노드는 부모 DOM 노드로 추가되며, 재귀적으로 전체 DOM 구조가 조립됩니다.<blockquote><p><strong>주의</strong><p>재조정자 자체는 DOM에 연결되어 있지 않습니다. 마운트의 정확한 결과(소스 코드에서 "mount image"로 불리는)는 렌더러에 의존하고, DOM 노드(React DOM), 문자열(React DOM Server) 또는 네이티브 뷰어(React Native)를 나타내는 숫자가 될 수도 있습니다.</blockquote><p>호스트 엘리먼트를 다루기 위해 코드를 확장하는 경우, 다음과 같이 보일 수 있습니다.<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isClass</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// React.Component subclasses have this flag</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token known-class-name class-name">Boolean</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">)</span> <span class="token operator">&#x26;&#x26;</span>
    <span class="token known-class-name class-name">Boolean</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">isReactComponent</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// This function only handles elements with a composite type.</span>
<span class="token comment">// For example, it handles &#x3C;App /> and &#x3C;Button />, but not a &#x3C;div />.</span>
<span class="token keyword">function</span> <span class="token function">mountComposite</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> props <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>

  <span class="token keyword">var</span> renderedElement<span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isClass</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Component class</span>
    <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Set the props</span>
    publicInstance<span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
    <span class="token comment">// Call the lifecycle if necessary</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">.</span><span class="token property-access">componentWillMount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      publicInstance<span class="token punctuation">.</span><span class="token method function property-access">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    renderedElement <span class="token operator">=</span> publicInstance<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Component function</span>
    renderedElement <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// This is recursive but we'll eventually reach the bottom of recursion when</span>
  <span class="token comment">// the element is host (e.g. &#x3C;div />) rather than composite (e.g. &#x3C;App />):</span>
  <span class="token keyword control-flow">return</span> <span class="token function">mount</span><span class="token punctuation">(</span>renderedElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// This function only handles elements with a host type.</span>
<span class="token comment">// For example, it handles &#x3C;div /> and &#x3C;p /> but not an &#x3C;App />.</span>
<span class="token keyword">function</span> <span class="token function">mountHost</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> props <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> children <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    children <span class="token operator">=</span> <span class="token punctuation">[</span>children<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  children <span class="token operator">=</span> children<span class="token punctuation">.</span><span class="token method function property-access">filter</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// This block of code shouldn't be in the reconciler.</span>
  <span class="token comment">// Different renderers might initialize nodes differently.</span>
  <span class="token comment">// For example, React Native would create iOS or Android views.</span>
  <span class="token keyword">var</span> node <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">createElement</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">propName</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>propName <span class="token operator">!==</span> <span class="token string">'children'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node<span class="token punctuation">.</span><span class="token method function property-access">setAttribute</span><span class="token punctuation">(</span>propName<span class="token punctuation">,</span> props<span class="token punctuation">[</span>propName<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Mount the children</span>
  children<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">childElement</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// Children may be host (e.g. &#x3C;div />) or composite (e.g. &#x3C;Button />).</span>
    <span class="token comment">// We will also mount them recursively:</span>
    <span class="token keyword">var</span> childNode <span class="token operator">=</span> <span class="token function">mount</span><span class="token punctuation">(</span>childElement<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// This line of code is also renderer-specific.</span>
    <span class="token comment">// It would be different depending on the renderer:</span>
    node<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>childNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Return the DOM node as mount result.</span>
  <span class="token comment">// This is where the recursion ends.</span>
  <span class="token keyword control-flow">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// User-defined components</span>
    <span class="token keyword control-flow">return</span> <span class="token function">mountComposite</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Platform-specific components</span>
    <span class="token keyword control-flow">return</span> <span class="token function">mountHost</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> rootEl <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> node <span class="token operator">=</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
rootEl<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>이는 동작하지만 실제로 재조정자가 구현되는 방식과는 거리가 멉니다. 누락된 핵심 요소는 업데이트에 대한 지원입니다.</section><section id="introducing-internal-instances"class="level3"><h3>내부 인스턴스의 소개</h3><p>React의 가장 큰 특징은 모든 것을 다시 렌더링할 수 있고, DOM을 다시 생성하거나 상태를 초기화시키지 않아도 된다는 점입니다.<pre class="language-js"><code class="language-js">root<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Should reuse the existing DOM:</span>
root<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>그러나, 위의 구현은 초기 트리를 어떻게 마운트 하는지만 알고 있습니다. 모든 <code>publicInstance</code>와 어떤 DOM <code>node</code>가 각 컴포넌트에 대응되는지와 같은 필수 정보를 담고 있지 않기 때문에 업데이트를 할 수 없습니다.<p>스택 재조정자의 코드베이스가 <code>mount()</code> 함수를 메서드로 만들고 class에 배치하여 위와 같은 문제를 해결합니다. 이러한 접근에는 여러 단점이 있고, 현재 우리는 <a href="./codebase-overview.html#fiber-reconciler">재조정자를 다시 작성하고 있으며</a> 스택 재조정자와는 다른 반대 방향으로 나아가고 있습니다. 그렇지만, 스택 재조정자가 지금 작동하는 방식입니다.<p><code>mountHost</code>와 <code>mountComposite</code> 함수를 분리하는 것 대신에, 우리는 <code>DOMComponent</code>와 <code>CompositeComponent</code> 의 두 가지 class를 생성합니다.<p>두 class 모두 <code>element</code>를 받아들이는 생성자 뿐만 아니라 마운트된 노드를 반환해주는 <code>mount()</code> 메서드를 가지고 있습니다. 최상위 <code>mount()</code> 함수를 올바른 class로 인스턴스화 하는 팩토리로 대체합니다.<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// User-defined components</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">CompositeComponent</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Platform-specific components</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">DOMComponent</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>먼저, <code>CompositeComponent</code>을 구현한 것을 봅시다.<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CompositeComponent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">publicInstance</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">getPublicInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// For composite components, expose the class instance.</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">publicInstance</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> element <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> props <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> publicInstance<span class="token punctuation">;</span>
    <span class="token keyword">var</span> renderedElement<span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isClass</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Component class</span>
      publicInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// Set the props</span>
      publicInstance<span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
      <span class="token comment">// Call the lifecycle if necessary</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">.</span><span class="token property-access">componentWillMount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        publicInstance<span class="token punctuation">.</span><span class="token method function property-access">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      renderedElement <span class="token operator">=</span> publicInstance<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Component function</span>
      publicInstance <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
      renderedElement <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Save the public instance</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">publicInstance</span> <span class="token operator">=</span> publicInstance<span class="token punctuation">;</span>

    <span class="token comment">// Instantiate the child internal instance according to the element.</span>
    <span class="token comment">// It would be a DOMComponent for &#x3C;div /> or &#x3C;p />,</span>
    <span class="token comment">// and a CompositeComponent for &#x3C;App /> or &#x3C;Button />:</span>
    <span class="token keyword">var</span> renderedComponent <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>renderedElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span> <span class="token operator">=</span> renderedComponent<span class="token punctuation">;</span>

    <span class="token comment">// Mount the rendered output</span>
    <span class="token keyword control-flow">return</span> renderedComponent<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>이는 이전 <code>mountComposite()</code> 구현과 크게 다르지 않지만,<code>this.currentElement</code>, <code>this.renderedComponent</code>, <code>this.publicInstance</code> 와 같이 업데이트에 사용할 수 있도록 정보를 저장할 수 있습니다.<p><code>CompositeComponent</code>의 인스턴스가 사용자가 제공하는 <code>element.type</code>의 인스턴스와 다르다는 것을 주의해주세요. <code>CompositeComponent</code>는 재조정자의 세부 구현 내용이고, 사용자에게는 노출되지 않습니다. 사용자 정의된 class는 <code>element.type</code>로부터 얻고, <code>CompositeComponent</code>가 이에 대한 인스턴스를 생성합니다.<p>혼동을 막기 위해, <code>CompositeComponent</code>와 <code>DOMComponent</code>의 인스턴스를 "내부 인스턴스"라 부릅니다. 이를 통해 몇 가지 오래 지속되는 데이터를 내부 인스턴스와 연결시킬 수 있습니다. 오직 렌더러와 재조정자만 내부 인스턴스를 알 수 있습니다.<p>반면, 사용자 정의된 class의 인스턴스를 "공개된 인스턴스(public instance)"라고 부릅니다. 공개된 인스턴스는 <code>render()</code>와 사용자가 직접 작성한 여러 메서드에서 <code>this</code>로 표시됩니다.<p><code>DOMComponent</code> class의 <code>mount()</code> 메서드로 리팩터링된 <code>mountHost()</code> 메서드 또한 비슷하게 보입니다.<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">DOMComponent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedChildren</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">getPublicInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// For DOM components, only expose the DOM node.</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> element <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> props <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> children <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      children <span class="token operator">=</span> <span class="token punctuation">[</span>children<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Create and save the node</span>
    <span class="token keyword">var</span> node <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">createElement</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>

    <span class="token comment">// Set the attributes</span>
    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">propName</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>propName <span class="token operator">!==</span> <span class="token string">'children'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span><span class="token method function property-access">setAttribute</span><span class="token punctuation">(</span>propName<span class="token punctuation">,</span> props<span class="token punctuation">[</span>propName<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Create and save the contained children.</span>
    <span class="token comment">// Each of them can be a DOMComponent or a CompositeComponent,</span>
    <span class="token comment">// depending on whether the element type is a string or a function.</span>
    <span class="token keyword">var</span> renderedChildren <span class="token operator">=</span> children<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span>instantiateComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedChildren</span> <span class="token operator">=</span> renderedChildren<span class="token punctuation">;</span>

    <span class="token comment">// Collect DOM nodes they return on mount</span>
    <span class="token keyword">var</span> childNodes <span class="token operator">=</span> renderedChildren<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token arrow operator">=></span> child<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    childNodes<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">childNode</span> <span class="token arrow operator">=></span> node<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>childNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Return the DOM node as mount result</span>
    <span class="token keyword control-flow">return</span> node<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p><code>mountHost()</code>로 리팩터링한 후의 주요 차이점은 <code>this.node</code>와 내부 DOM 컴포넌트 인스턴스와 연결된 <code>this.renderedChildren</code>을 유지한다는 것입니다. 향후 non-destructive 업데이트 적용에도 활용할 예정입니다.<p>결과적으로, 복합 또는 호스트인 각 내부 인스턴스는 이제 자식 내부 인스턴스를 가리킵니다. 이를 시각화하기 위해 함수 <code>&#x3C;App></code> 컴포넌트가 <code>&#x3C;Button></code> class 컴포넌트를 렌더링하고 <code>Button</code> class가 <code>&#x3C;div></code>를 렌더링하는 경우 내부 인스턴스 트리는 다음과 같이 보일 것입니다.<pre class="language-js"><code class="language-js"><span class="token punctuation">[</span>object <span class="token maybe-class-name">CompositeComponent</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">currentElement</span><span class="token operator">:</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span>
  <span class="token literal-property property">publicInstance</span><span class="token operator">:</span> <span class="token keyword null nil">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">renderedComponent</span><span class="token operator">:</span> <span class="token punctuation">[</span>object <span class="token maybe-class-name">CompositeComponent</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">currentElement</span><span class="token operator">:</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Button</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span>
    <span class="token literal-property property">publicInstance</span><span class="token operator">:</span> <span class="token punctuation">[</span>object <span class="token maybe-class-name">Button</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token literal-property property">renderedComponent</span><span class="token operator">:</span> <span class="token punctuation">[</span>object <span class="token maybe-class-name">DOMComponent</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">currentElement</span><span class="token operator">:</span> <span class="token operator">&#x3C;</span>div <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span>
      <span class="token literal-property property">node</span><span class="token operator">:</span> <span class="token punctuation">[</span>object <span class="token maybe-class-name">HTMLDivElement</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token literal-property property">renderedChildren</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>DOM에서는 <code>&#x3C;div></code>만 보일 것입니다. 그러나 내부 인스턴스 트리에는 복합적인 것과 호스트 내부 인스턴스가 모두 포함되어 있습니다.<p>복합 내부 인스턴스는 다음을 저장해야 합니다.<ul><li>현재 엘리먼트<li>엘리먼트 타입이 클래스라면 public 인스턴스<li>단일 렌더링된 내부 인스턴스. <code>DOMComponent</code> 또는 <code>CompositeComponent</code>가 될 수 있습니다.</ul><p>호스트 내부 인스턴스는 다음을 저장해야 합니다.<ul><li>현재 엘리먼트<li>DOM 노드<li>모든 자식 내부 인스턴스. 각 인스턴스는 <code>DOMComponent</code> 또는 <code>CompositeComponent</code>일 수 있습니다.</ul><p>더 복잡한 애플리케이션에서 내부 인스턴스 트리가 어떻게 구성되는지 상상하기 어려울 경우, <a href="https://github.com/facebook/react-devtools">React DevTools</a>는 호스트 인스턴스를 회색 그리고 복합 인스턴스를 보라색으로 강조하므로 가까운 근사치를 줄 수 있습니다.</p><img src="./docs/implementation-notes-tree.png"width="500"style="max-width:100%"alt="React DevTools tree"><p>리팩토링을 완료하기 위해 전체 트리를 컨테이너 노드와 공개 인스턴스에 마운트하는 기능을 소개합니다.<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> containerNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Create the top-level internal instance</span>
  <span class="token keyword">var</span> rootComponent <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Mount the top-level component into the container</span>
  <span class="token keyword">var</span> node <span class="token operator">=</span> rootComponent<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  containerNode<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Return the public instance it provides</span>
  <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> rootComponent<span class="token punctuation">.</span><span class="token method function property-access">getPublicInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> publicInstance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> rootEl <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section><section id="unmounting"class="level3"><h3>마운트 해제</h3><p>이제 자식들과 DOM 노드를 유지하는 내부 인스턴스를 가지고 있으므로, 마운트 해제를 구현할 수 있습니다. 복합 컴포넌트의 경우, 마운트 해제가 생명주기 메서드를 재귀적으로 호출합니다.<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CompositeComponent</span> <span class="token punctuation">{</span>

  <span class="token comment">// ...</span>

  <span class="token function">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Call the lifecycle method if necessary</span>
    <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">publicInstance</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">.</span><span class="token property-access">componentWillUnmount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        publicInstance<span class="token punctuation">.</span><span class="token method function property-access">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Unmount the single rendered component</span>
    <span class="token keyword">var</span> renderedComponent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span><span class="token punctuation">;</span>
    renderedComponent<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p><code>DOMComponent</code>의 경우 마운트 해제는 각 자식에게 마운트 해제를 지시합니다.<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">DOMComponent</span> <span class="token punctuation">{</span>

  <span class="token comment">// ...</span>

  <span class="token function">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Unmount all the children</span>
    <span class="token keyword">var</span> renderedChildren <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedChildren</span><span class="token punctuation">;</span>
    renderedChildren<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token arrow operator">=></span> child<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>실제로 DOM 컴포넌트를 마운트 해제하면 이벤트 리스너가 제거되고 캐시가 일부 지워지지만 이러한 자세한 내용은 넘어가겠습니다.<p>이제 <code>ReactDOM.unmountComponentAtNode()</code>와 유사한 <code>unmountTree(containerNode)</code>라는 새로운 최상위 함수를 추가할 수 있습니다.<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">unmountTree</span><span class="token punctuation">(</span><span class="token parameter">containerNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Read the internal instance from a DOM node:</span>
  <span class="token comment">// (This doesn't work yet, we will need to change mountTree() to store it.)</span>
  <span class="token keyword">var</span> node <span class="token operator">=</span> containerNode<span class="token punctuation">.</span><span class="token property-access">firstChild</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> rootComponent <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token property-access">_internalInstance</span><span class="token punctuation">;</span>

  <span class="token comment">// Unmount the tree and clear the container</span>
  rootComponent<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  containerNode<span class="token punctuation">.</span><span class="token property-access">innerHTML</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>이것이 작동하려면 DOM 노드에서 내부 루트 인스턴스를 읽어야 합니다. <code>_internalInstance</code> 속성을 루트 DOM 노드에 추가하도록 <code>mountTree()</code>를 수정합니다. 또한 <code>mountTree()</code>를 가르쳐 기존 트리를 여러 번 파괴할 수 있도록 할 것입니다.<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> containerNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Destroy any existing tree</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>containerNode<span class="token punctuation">.</span><span class="token property-access">firstChild</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">unmountTree</span><span class="token punctuation">(</span>containerNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Create the top-level internal instance</span>
  <span class="token keyword">var</span> rootComponent <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Mount the top-level component into the container</span>
  <span class="token keyword">var</span> node <span class="token operator">=</span> rootComponent<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  containerNode<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Save a reference to the internal instance</span>
  node<span class="token punctuation">.</span><span class="token property-access">_internalInstance</span> <span class="token operator">=</span> rootComponent<span class="token punctuation">;</span>

  <span class="token comment">// Return the public instance it provides</span>
  <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> rootComponent<span class="token punctuation">.</span><span class="token method function property-access">getPublicInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> publicInstance<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>이제 <code>mountTree()</code> 또는 <code>unmountTree()</code>를 반복적으로 실행하면 오래된 트리가 제거되고 컴포넌트에서 <code>componentWillUnmount()</code> 생명주기 메서드가 실행됩니다.</section><section id="updating"class="level3"><h3>업데이트</h3><p>이전 섹션에서, 마운트 해제를 구현했습니다. 그러나 각각의 prop 변화가 전체 트리를 마운트 해제하고 마운트한다면 React는 그다지 유용하지 않을 것입니다. 조정자의 목표는 DOM과 상태를 보전하기 위해 가능한 경우 기존 인스턴스를 재사용 하는 것입니다.<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> rootEl <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Should reuse the existing DOM:</span>
<span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>내부 인스턴스 계약을 메서드 하나를 추가해서 확장할 것입니다. <code>mount()</code>와 <code>unmount()</code>외에도 , <code>DOMComponent</code> <code>CompositeComponent</code> 모두 <code>receive(nextElement)</code>라고 불리는 새로운 메서드를 구현합니다.<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CompositeComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token function">receive</span><span class="token punctuation">(</span><span class="token parameter">nextElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">DOMComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token function">receive</span><span class="token punctuation">(</span><span class="token parameter">nextElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p><code>nextElement</code>에 의해 제공된 설명을 통해 컴포넌트(또한 어떠한 자식)를 최신 상태로 만들기 위해 필요한 모든 것을 하는게 이 메서드의 일입니다.<p>실제로 일어나는 일은 내부 트리를 반복적으로 순회하고 각 내부 인스턴스가 업데이트를 받도록 하는 것이지만, 이 부분은 종종 "가상 DOM 비교"로 설명됩니다.</section><section id="updating-composite-components"class="level3"><h3>복합 컴포넌트의 업데이트</h3><p>복합 컴포넌트가 새로운 엘리먼트를 받으면 <code>componentWillUpdate()</code> 생명주기 메서드를 실행합니다.<p>그런 다음 새로운 props와 함께 컴포넌트를 다시 렌더링 하고, 다음 렌더링 된 엘리먼트를 얻습니다.<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CompositeComponent</span> <span class="token punctuation">{</span>

  <span class="token comment">// ...</span>

  <span class="token function">receive</span><span class="token punctuation">(</span><span class="token parameter">nextElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> prevProps <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">publicInstance</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevRenderedComponent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevRenderedElement <span class="token operator">=</span> prevRenderedComponent<span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">;</span>

    <span class="token comment">// Update *own* element</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span> <span class="token operator">=</span> nextElement<span class="token punctuation">;</span>
    <span class="token keyword">var</span> type <span class="token operator">=</span> nextElement<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nextProps <span class="token operator">=</span> nextElement<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>

    <span class="token comment">// Figure out what the next render() output is</span>
    <span class="token keyword">var</span> nextRenderedElement<span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isClass</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Component class</span>
      <span class="token comment">// Call the lifecycle if necessary</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">.</span><span class="token property-access">componentWillUpdate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        publicInstance<span class="token punctuation">.</span><span class="token method function property-access">componentWillUpdate</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// Update the props</span>
      publicInstance<span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">=</span> nextProps<span class="token punctuation">;</span>
      <span class="token comment">// Re-render</span>
      nextRenderedElement <span class="token operator">=</span> publicInstance<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Component function</span>
      nextRenderedElement <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ...</span></code></pre><p>그 다음, 렌더링된 엘리먼트의 <code>type</code>을 살펴 볼 수 있습니다. 마지막 렌더링 이후 <code>type</code>이 변경되지 않았다면 아래 컴포넌트도 업데이트할 수 있습니다.<p>예를 들어, 처음에 <code>&#x3C;Button color="red" /></code>를 반환하고 두 번째로 <code>&#x3C;Button color="blue" /></code>를 반환했다면, 대응되는 내부 인스턴스에게 다음 엘리먼트를 <code>receive()</code>하라고 말해줄 수 있습니다.<pre class="language-js"><code class="language-js">    <span class="token comment">// ...</span>

    <span class="token comment">// If the rendered element type has not changed,</span>
    <span class="token comment">// reuse the existing component instance and exit.</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>prevRenderedElement<span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token operator">===</span> nextRenderedElement<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      prevRenderedComponent<span class="token punctuation">.</span><span class="token method function property-access">receive</span><span class="token punctuation">(</span>nextRenderedElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ...</span></code></pre><p>그러나, 다음 렌더링된 엘리먼트가 이전에 렌더링된 엘리먼트와 다른 <code>type</code>을 가지고 있다면, 우리는 내부 인스턴스를 업데이트할 수 없습니다. <code>&#x3C;button></code>은 <code>&#x3C;input></code>이 될 수 없습니다.<p>대신에, 기존 내부 인스턴스를 마운트 해제 하고 렌더링된 엘리먼트 타입에 해당하는 새 인스턴스를 마운트 해야 합니다. 예를 들어 이전에 <code>&#x3C;button /></code>을 렌더링한 컴포넌트가 <code>&#x3C;input /></code>을 렌더링할 때 다음과 같이 됩니다.<pre class="language-js"><code class="language-js">    <span class="token comment">// ...</span>

    <span class="token comment">// If we reached this point, we need to unmount the previously</span>
    <span class="token comment">// mounted component, mount the new one, and swap their nodes.</span>

    <span class="token comment">// Find the old node because it will need to be replaced</span>
    <span class="token keyword">var</span> prevNode <span class="token operator">=</span> prevRenderedComponent<span class="token punctuation">.</span><span class="token method function property-access">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Unmount the old child and mount a new child</span>
    prevRenderedComponent<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nextRenderedComponent <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>nextRenderedElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nextNode <span class="token operator">=</span> nextRenderedComponent<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Replace the reference to the child</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span> <span class="token operator">=</span> nextRenderedComponent<span class="token punctuation">;</span>

    <span class="token comment">// Replace the old node with the new one</span>
    <span class="token comment">// Note: this is renderer-specific code and</span>
    <span class="token comment">// ideally should live outside of CompositeComponent:</span>
    prevNode<span class="token punctuation">.</span><span class="token property-access">parentNode</span><span class="token punctuation">.</span><span class="token method function property-access">replaceChild</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">,</span> prevNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>이를 요약하면 복합 컴포넌트가 새로운 엘리먼트를 수신할 때, 해당 컴포넌트는 렌더링된 내부 인스턴스에 업데이트를 넘기거나, 마운트 해제 하여 그 위치에 컴포넌트를 마운트 할 수 있습니다.<p>엘리먼트를 받는 대신 컴포넌트를 다시 마운트하는 또 다른 조건이 있는데, 엘리먼트의 <code>key</code>가 변경될 때입니다. 이미 복잡한 자습서를 더 복잡하게 만들기 때문에 이 문서에서 <code>key</code> 처리에 대해서는 논의하지 않습니다.<p>특정 플랫폼 관련 노드를 찾아 업데이트하는 동안 교체할 수 있도록 내부 인스턴스 계약에 <code>getHostNode()</code>라는 메서드를 추가해야 한다는 점을 주의해주세요. 구현은 두 클래스 모두에서 간단합니다.<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CompositeComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token function">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Ask the rendered component to provide it.</span>
    <span class="token comment">// This will recursively drill down any composites.</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span><span class="token punctuation">.</span><span class="token method function property-access">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">DOMComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token function">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></section><section id="updating-host-components"class="level3"><h3>호스트 컴포넌트 업데이트</h3><p><code>DOMComponent</code>와 같은 호스트 컴포넌트 구현은 다르게 업데이트 됩니다. 엘리먼트를 수신할 때 특정 플랫폼 관련 뷰를 업데이트해야 합니다. React DOM의 경우 DOM 특성을 업데이트 하는 것을 의미합니다.<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">DOMComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token function">receive</span><span class="token punctuation">(</span><span class="token parameter">nextElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevElement <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevProps <span class="token operator">=</span> prevElement<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nextProps <span class="token operator">=</span> nextElement<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span> <span class="token operator">=</span> nextElement<span class="token punctuation">;</span>

    <span class="token comment">// Remove old attributes.</span>
    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">propName</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>propName <span class="token operator">!==</span> <span class="token string">'children'</span> <span class="token operator">&#x26;&#x26;</span> <span class="token operator">!</span>nextProps<span class="token punctuation">.</span><span class="token method function property-access">hasOwnProperty</span><span class="token punctuation">(</span>propName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span><span class="token method function property-access">removeAttribute</span><span class="token punctuation">(</span>propName<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Set next attributes.</span>
    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">propName</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>propName <span class="token operator">!==</span> <span class="token string">'children'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span><span class="token method function property-access">setAttribute</span><span class="token punctuation">(</span>propName<span class="token punctuation">,</span> nextProps<span class="token punctuation">[</span>propName<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// ...</span></code></pre><p>그리고 나서 호스트 컴포넌트는 자식들을 업데이트 할 필요가 있습니다. 복합 컴포넌트와 다르게 둘 이상의 자식이 포함될 수 있습니다.<p>단순화된 예시에서 내부 인스턴스 배열을 사용하며, 수신된 <code>type</code>과 이전 <code>type</code>의 일치 여부에 따라 내부 인스턴스를 업데이트하거나 교체하는 방식으로 순회합니다. 실제 재조정자는 삽입과 삭제 외에 엘리먼트의 <code>key</code>를 가진 뒤 변경 여부를 추적하지만 여기서는 관련 코드를 생략했습니다.<p>리스트에서 자식에 대한 DOM 연산을 수집하여 일괄적으로 실행할 수 있도록 합니다.<pre class="language-js"><code class="language-js">    <span class="token comment">// ...</span>

    <span class="token comment">// These are arrays of React elements:</span>
    <span class="token keyword">var</span> prevChildren <span class="token operator">=</span> prevProps<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      prevChildren <span class="token operator">=</span> <span class="token punctuation">[</span>prevChildren<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> nextChildren <span class="token operator">=</span> nextProps<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nextChildren <span class="token operator">=</span> <span class="token punctuation">[</span>nextChildren<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// These are arrays of internal instances:</span>
    <span class="token keyword">var</span> prevRenderedChildren <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedChildren</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nextRenderedChildren <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// As we iterate over children, we will add operations to the array.</span>
    <span class="token keyword">var</span> operationQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// Note: the section below is extremely simplified!</span>
    <span class="token comment">// It doesn't handle reorders, children with holes, or keys.</span>
    <span class="token comment">// It only exists to illustrate the overall flow, not the specifics.</span>

    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> nextChildren<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Try to get an existing internal instance for this child</span>
      <span class="token keyword">var</span> prevChild <span class="token operator">=</span> prevRenderedChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

      <span class="token comment">// If there is no internal instance under this index,</span>
      <span class="token comment">// a child has been appended to the end. Create a new</span>
      <span class="token comment">// internal instance, mount it, and use its node.</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prevChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> nextChild <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> node <span class="token operator">=</span> nextChild<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Record that we need to append a node</span>
        operationQueue<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'ADD'</span><span class="token punctuation">,</span> node<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nextRenderedChildren<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>nextChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">continue</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// We can only update the instance if its element's type matches.</span>
      <span class="token comment">// For example, &#x3C;Button size="small" /> can be updated to</span>
      <span class="token comment">// &#x3C;Button size="large" /> but not to an &#x3C;App />.</span>
      <span class="token keyword">var</span> canUpdate <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token operator">===</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>

      <span class="token comment">// If we can't update an existing instance, we have to unmount it</span>
      <span class="token comment">// and mount a new one instead of it.</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>canUpdate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> prevNode <span class="token operator">=</span> prevChild<span class="token punctuation">.</span><span class="token method function property-access">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        prevChild<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">var</span> nextChild <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> nextNode <span class="token operator">=</span> nextChild<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Record that we need to swap the nodes</span>
        operationQueue<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'REPLACE'</span><span class="token punctuation">,</span> prevNode<span class="token punctuation">,</span> nextNode<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nextRenderedChildren<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>nextChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">continue</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// If we can update an existing internal instance,</span>
      <span class="token comment">// just let it receive the next element and handle its own update.</span>
      prevChild<span class="token punctuation">.</span><span class="token method function property-access">receive</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      nextRenderedChildren<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>prevChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Finally, unmount any children that don't exist:</span>
    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> nextChildren<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> j <span class="token operator">&#x3C;</span> prevChildren<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> prevChild <span class="token operator">=</span> prevRenderedChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> node <span class="token operator">=</span> prevChild<span class="token punctuation">.</span><span class="token method function property-access">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      prevChild<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// Record that we need to remove the node</span>
      operationQueue<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'REMOVE'</span><span class="token punctuation">,</span> node<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Point the list of rendered children to the updated version.</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedChildren</span> <span class="token operator">=</span> nextRenderedChildren<span class="token punctuation">;</span>

    <span class="token comment">// ...</span></code></pre><p>마지막 단계로, DOM 연산을 실행합니다. 또한, 실제 재조정자 코드는 이동도 처리하기 때문에 매우 복잡합니다.<pre class="language-js"><code class="language-js">    <span class="token comment">// ...</span>

    <span class="token comment">// Process the operation queue.</span>
    <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span>operationQueue<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> operation <span class="token operator">=</span> operationQueue<span class="token punctuation">.</span><span class="token method function property-access">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">switch</span> <span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">'ADD'</span><span class="token operator">:</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token string">'REPLACE'</span><span class="token operator">:</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">.</span><span class="token method function property-access">replaceChild</span><span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token property-access">nextNode</span><span class="token punctuation">,</span> operation<span class="token punctuation">.</span><span class="token property-access">prevNode</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token string">'REMOVE'</span><span class="token operator">:</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">.</span><span class="token method function property-access">removeChild</span><span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>그리고 그것은 호스트 컴포넌트를 업데이트하기 위한 것입니다.</section><section id="top-level-updates"class="level3"><h3>최상위 업데이트</h3><p>이제 <code>CompositeComponent</code>와 <code>DOMComponent</code> 모두 <code>receive(nextElement)</code> 메서드를 구현하므로 엘리먼트 <code>type</code>이 이전과 같을 때 사용하도록 최상위 <code>mountTree()</code> 함수를 변경할 수 있습니다.<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> containerNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Check for an existing tree</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>containerNode<span class="token punctuation">.</span><span class="token property-access">firstChild</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> prevNode <span class="token operator">=</span> containerNode<span class="token punctuation">.</span><span class="token property-access">firstChild</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevRootComponent <span class="token operator">=</span> prevNode<span class="token punctuation">.</span><span class="token property-access">_internalInstance</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevElement <span class="token operator">=</span> prevRootComponent<span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">;</span>

    <span class="token comment">// If we can, reuse the existing root component</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>prevElement<span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token operator">===</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      prevRootComponent<span class="token punctuation">.</span><span class="token method function property-access">receive</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Otherwise, unmount the existing tree</span>
    <span class="token function">unmountTree</span><span class="token punctuation">(</span>containerNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// ...</span>

<span class="token punctuation">}</span></code></pre><p>이제 동일한 타입으로 <code>mountTree()</code>를 두 번 호출해도 파괴적이지 않습니다.<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> rootEl <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Reuses the existing DOM:</span>
<span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>These are the basics of how React works internally.</section><section id="what-we-left-out"class="level3"><h3>우리가 놓치고 간 것들</h3><p>이 문서는 실제 코드베이스에 비해 단순합니다. 우리가 다루지 않은 몇 가지 중요한 측면들이 있습니다.<ul><li><p>컴포넌트는 <code>null</code>을 렌더링할 수 있으며, 재조정자는 배열 및 렌더링된 출력에서 "빈 슬롯"을 처리할 수 있습니다.<li><p>재조정자는 또한 엘리먼트에서 <code>key</code>를 읽고, 이를 사용하여 배열의 엘리먼트와 일치하는 내부 인스턴스를 설정합니다. 실제 React 구현의 많은 복잡성은 이와 관련이 있습니다.<li><p>복합 및 호스트 내부 인스턴스 class 외에도 "text" 및 "empty" 컴포넌트에 대한 class도 있습니다. 텍스트 노드와 <code>null</code>을 렌더링해서 얻는 "empty slots"을 나타냅니다.<li><p>렌더러는 <a href="./codebase-overview.html#dynamic-injection">주입</a>을 사용하여 재조정자에게 호스트 내부 class를 전달합니다. 예를 들어, React DOM은 재조정자에게 호스트 내부 인스턴스 구현으로 <code>ReactDOMComponent</code>를 사용하도록 지시합니다.<li><p>자식 목록을 업데이트하는 논리는 React DOM과 React Native에서 호스트 내부 인스턴스 class 구현에 사용되는 <code>ReactMultiChild</code>라는 mixin으로 추출됩니다.<li><p>재조정자는 복합 컴포넌트의 <code>setState()</code>에 대한 지원도 구현합니다. 이벤트 핸들러 내부의 여러 업데이트가 단일 업데이트로 일괄 처리됩니다.<li><p>재조정자는 또한 복합 컴포넌트 및 호스트 노드에 ref를 연결 및 분리하는 작업을 수행합니다.<li><p><code>componentDidMount()</code> 및 <code>componentDidUpdate()</code>와 같이 DOM이 준비된 후 호출되는 생명주기 메서드는 "콜백 큐"로 수집되어 단일 배치로 실행됩니다.<li><p>React는 현재 업데이트에 대한 정보를 "트랜잭션"이라고 하는 내부 객체에 넣습니다. 트랜잭션은 보류 중인 생명주기 메서드 대기열의 추적, 현재 DOM 중첩에 대한 경고 및 특정 업데이트에 "전역적인" 다른 모든 것을 추적하는 데 유용합니다. 또한 트랜잭션는 업데이트 후 React가 모든 것을 정리하도록 보장합니다. 예를 들어 React DOM에서 제공하는 트랜잭션 class는 업데이트 후 입력 선택을 복원합니다.</ul></section><section id="jumping-into-the-code"class="level3"><h3>코드에 대해 알아보기</h3><ul><li><p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/dom/client/ReactMount.js"><code>ReactMount</code></a>는 이 자습서에서 <code>mountTree()</code> 및 <code>unmountTree()</code>와 같은 코드가 사용되는 곳입니다. 최상위 컴포넌츠의 마운트과 마운트 해제을 관리합니다. <a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/native/ReactNativeMount.js"><code>ReactNativeMount</code></a> 는 React Native 아날로그입니다.<li><p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/dom/shared/ReactDOMComponent.js"><code>ReactDOMComponent</code></a>는 본 자습서의 <code>DOMComponent</code>와 동등합니다. React DOM 렌더러에 대한 호스트 컴포넌트 class를 구현합니다. <a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/native/ReactNativeBaseComponent.js"><code>ReactNativeBaseComponent</code></a>는 React Native 아날로그 입니다.<li><p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js"><code>ReactCompositeComponent</code></a>는 본 자습서의 <code>CompositeComponent</code>와 동등한 것입니다. 사용자 정의 컴포넌트 호출 및 상태 유지 관리 작업을 처리합니다.<li><p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/instantiateReactComponent.js"><code>instantiateReactComponent</code></a>에는 엘리먼트에 대해 구성할 올바른 내부 인스턴스 class를 선택하는 스위치가 포함되어 있습니다. 이 자습서에서는 <code>instantiateComponent()</code>와 같습니다.<li><p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/ReactReconciler.js"><code>ReactReconciler</code></a>는 <code>mountComponent()</code>, <code>receiveComponent()</code>및 <code>unmountComponent()</code> 메서드가 있는 wrapper입니다. 내부 인스턴스에 대한 기본 구현을 호출하지만, 또한 모든 내부 인스턴스 구현에 의해 공유되는 그들 주변의 일부 코드를 포함합니다.<li><p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/ReactChildReconciler.js"><code>ReactChildReconciler</code></a>는 자식의 엘리먼트 <code>key</code>에 따라 자식을 마운트, 업데이트 및 마운트 해제하는 코드를 구현합니다.<li><p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/ReactMultiChild.js"><code>ReactMultiChild</code></a>는 자식 삽입, 삭제 및 렌더러와 독립적으로 이동하기 위한 작업 대기열 처리를 구현합니다.<li><p>레거시를 위해 react codebase에 <code>mount()</code>, <code>receive()</code> 및 <code>unmount()</code>를 실제로 각각 <code>mountComponent()</code>, <code>receiveComponent()</code>, <code>unmountComponent()</code>라고 불러지지만, 엘리먼트를 받습니다.<li><p>내부 인스턴스의 속성은 <code>_currentElement</code>와 같이 밑줄로 시작합니다. 코드베이스 전체에 걸쳐 읽기 전용 퍼블릭 필드로 간주됩니다.</ul></section><section id="future-directions"class="level3"><h3>미래의 방향</h3><p>스택 재조정자는 작업을 중단하거나 청크로 분할할 수 없는 것과 같은 타고난 한계가 있습니다. <a href="https://github.com/acdlite/react-fiber-architecture">완전히 다른 아키텍처</a>를 가진 <a href="./codebase-overview.html#fiber-reconciler">새로운 Fiber 재조정자</a>에 대한 작업이 진행 중입니다. 향후, 스택 재조정자를 이것으로 대체하려고 하지만, 현재는 피쳐 패리티와는 거리가 멉니다.</section><section id="next-steps"class="level3"><h3>다음 단계</h3><p><a href="./design-principles.html">다음 섹션</a>을 읽고 React 개발에 사용하는 설계 원칙에 대해 알아봅시다. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>