<!doctypehtml><html lang="ko"><meta charset="utf-8"><title>컴포넌트 State</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="컴포넌트-state"class="level1"><h1>컴포넌트 State</h1><section id="what-does-setstate-do"class="level3"><h3><code>setState</code>는 어떤 일을 하나요?</h3><p><code>setState()</code>는 컴포넌트의 <code>state</code> 객체에 대한 업데이트를 실행합니다. state가 변경되면, 컴포넌트는 리렌더링됩니다.</section><section id="what-is-the-difference-between-state-and-props"class="level3"><h3><code>state</code>와 <code>props</code>의 차이점은 무엇인가요?</h3><p><a href="./components-and-props.html"><code>props</code></a> ("properties"의 줄임말) 와 <a href="./state-and-lifecycle.html"><code>state</code></a> 는 일반 JavaScript 객체입니다. 두 객체 모두 렌더링 결과물에 영향을 주는 정보를 갖고 있는데, 한 가지 중요한 방식에서 차이가 있습니다. <code>props</code>는 (함수 매개변수처럼) 컴포넌트<em>에</em> 전달되는 반면 <code>state</code>는 (함수 내에 선언된 변수처럼) 컴포넌트 <em>안에서</em> 관리됩니다.<p>언제 <code>props</code>와 <code>state</code>를 사용하는지 더 알고 싶다면 아래의 자료를 확인해보세요.<ul><li><a href="https://github.com/uberVU/react-guide/blob/master/props-vs-state.md">Props vs State</a><li><a href="https://lucybain.com/blog/2016/react-state-vs-pros/">ReactJS: Props vs. State</a></ul></section><section id="why-is-setstate-giving-me-the-wrong-value"class="level3"><h3>왜 <code>setState</code>가 잘못된 값을 주는 걸까요?</h3><p>React에서 <code>this.props</code>와 <code>this.state</code>는 모두 <em>렌더링된</em> 값을 나타냅니다. 다시 말해 현재 화면에 보이는 것을 말합니다.<p><code>setState</code> 호출은 비동기적으로 이뤄집니다. 따라서 <code>setState</code> 호출 직후 새로운 값이 <code>this.state</code> 에 반영될 거라고 믿어서는 안 됩니다. 이전 state 값을 기준으로 값을 계산해야 한다면 객체 대신 updater 함수를 전달하세요. (자세한 내용은 아래를 확인하세요.)<p>예시 코드는 예상대로 동작하지 <em>않을 것</em>입니다.<pre class="language-jsx"><code class="language-jsx"><span class="token function">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 주의: 이 코드는 예상대로 동작하지 *않을 것*입니다.</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">handleSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// `this.state.count`가 0에서 시작한다고 해봅시다.</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// React가 컴포넌트를 리렌더링할 때 `this.state.count`는 3이 될 것 같은 예상과 달리 1이 됩니다.</span>

  <span class="token comment">// 이것은 `incrementCount()` 함수가 `this.state.count`에서 값을 읽어 오는데</span>
  <span class="token comment">// React는 컴포넌트가 리렌더링될 때까지 `this.state.count`를 갱신하지 않기 때문입니다.</span>
  <span class="token comment">// 그러므로 `incrementCount()`는 매번 `this.state.count`의 값을 0으로 읽은 뒤에 이 값을 1로 설정합니다.</span>

  <span class="token comment">// 이 문제의 해결 방법은 아래에 설명되어 있습니다.</span>
<span class="token punctuation">}</span></code></pre><p>이 문제를 어떻게 해결하는지 알아봅시다.</section><section id="how-do-i-update-state-with-values-that-depend-on-the-current-state"class="level3"><h3>어떻게 하면 이전 state 값을 기준으로 state 값을 업데이트할 수 있나요?</h3><p>항상 <code>setState</code> 가 가장 최신의 state 값을 사용하도록 보장하기 위해서는 <code>setState</code> 에 객체 대신 함수를 전달하세요. (아래를 참조하세요.)</section><section id="what-is-the-difference-between-passing-an-object-or-a-function-in-setstate"class="level3"><h3><code>setState</code>에 객체를 전달하는 것과 함수를 전달하는 것은 어떤 차이가 있나요?</h3><p>updater 함수를 전달하면 updater 함수 안에서 이전 state 값에 접근할 수 있습니다. <code>setState</code> 호출은 일괄적으로 처리되기 때문에 여러 업데이트 사항이 충돌 없이 차례대로 반영되도록 합니다.<pre class="language-jsx"><code class="language-jsx"><span class="token function">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// 중요: 값을 업데이트할 때 `this.state` 대신 `state` 값을 읽어옵니다.</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">handleSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// `this.state.count`가 0에서 시작한다고 해봅시다.</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 지금 `this.state.count` 값을 읽어 보면 이 값은 여전히 0일 것입니다.</span>
  <span class="token comment">// 하지만 React가 컴포넌트를 리렌더링하게 되면 이 값은 3이 됩니다.</span>
<span class="token punctuation">}</span></code></pre><p><a href="./react-component.html#setstate">setState에 대해 더 알아보기</a></section><section id="when-is-setstate-asynchronous"class="level3"><h3>언제 <code>setState</code> 가 비동기적인가요?</h3><p>현재 <code>setState</code> 는 이벤트 핸들러 내에서 비동기적입니다.<p>이로 인해 <code>부모</code>와 <code>자식</code>이 모두 click 이벤트에서 <code>setState</code>를 호출한다면 <code>자식</code>은 두 번 렌더링되지 않습니다. 대신 React는 브라우저 이벤트가 끝날 시점에 state를 일괄적으로 업데이트합니다. 이는 더 큰 규모의 앱에서 뚜렷한 성능 향상을 만들어냅니다.<p>이것은 구현 세부사항이므로 전적으로 의존해선 안됩니다. 추후 React는 기본적으로 더 많은 경우에서 일괄적으로 업데이트를 처리할 예정입니다.</section><section id="why-doesnt-react-update-thisstate-synchronously"class="level3"><h3>왜 React는 <code>this.state</code> 를 동기적으로 업데이트하지 않나요?</h3><p>이전 절에서 설명했듯이 모든 컴포넌트가 자신의 이벤트 핸들러에서 <code>setState()</code>를 호출할 때까지 React는 리렌더링을 하지 않고 내부적으로 "기다리고 있습니다". 이를 통해 불필요한 렌더링을 방지하면서 성능을 향상시킵니다.<p>그러나 왜 React는 리렌더링 대신 즉시 <code>this.state</code>를 업데이트하지 않는지 여전히 궁금해 하실 수도 있습니다.<p>여기에는 두 가지 중요한 이유가 존재합니다.<ul><li><code>props</code> 와 <code>state</code> 사이의 일관성을 해칠 수 있으며 이것은 디버깅하기 매우 힘든 이슈를 일으킬 수 있기 때문입니다.<li>현재 작업 중인 새로운 기능들을 구현하기 힘들게 만들 수 있기 때문입니다.</ul><p>이 <a href="https://github.com/facebook/react/issues/11527#issuecomment-360199710">GitHub 코멘트</a>에서 더욱 자세한 예시를 확인할 수 있습니다.</section><section id="should-i-use-a-state-management-library-like-redux-or-mobx"class="level3"><h3>Redux 나 MobX 같은 상태('state') 관리 라이브러리를 사용해야 하나요?</h3><p><a href="https://redux.js.org/faq/general#when-should-i-use-redux">아마 필요할 수도 있습니다.</a><p>추가적인 라이브러리를 사용하기 전에 먼저 React에 익숙해지는 게 좋습니다. React만으로도 꽤 복잡한 애플리케이션을 만들 수 있습니다. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>