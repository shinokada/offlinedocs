<!doctypehtml><html lang="de"><meta charset="utf-8"><title>Fehlergrenzen</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="fehlergrenzen"class="level1"><h1>Fehlergrenzen</h1><p>In der Vergangenheit, führten JavaScript-Fehler in Komponenten zu einem fehlerhaften Zustand innerhalb von React, welcher ein <a href="https://github.com/facebook/react/issues/4026">Auftreten</a> <a href="https://github.com/facebook/react/issues/6895">kryptischer</a> <a href="https://github.com/facebook/react/issues/8579">Fehlermeldungen</a> in den folgenden Render-Vorgängen verursachte. Diese Fehler wurden immer von einem zuvor aufgetretenen Fehler in der Anwendung verursacht, jedoch war seitens React keine Möglichkeit bereitgestellt, um mit Fehlern in Komponenten elegant umzugehen.<section id="introducing-error-boundaries"class="level2"><h2>Einführung zu Fehlergrenzen</h2><p>Ein JavaScript-Fehler in einem Teil der UI sollte nicht die ganze Anwendung zerstören. Um eine Lösung für dieses Problem bereitzustellen, wurde mit React 16 das Konzept einer "Fehlergrenze" vorgestellt.<p>Fehlergrenzen sind React-Komponenten die <strong>JavaScript-Fehler in ihrem ganzen Kind-Komponenten Baum abfangen, diese loggen und eine Fallback-UI</strong>, anstatt eines zerstörten Komponenten-Baums anzeigen. Fehlergrenzen fangen Fehler während des Renderings, in Lifecycle-Methoden und in Konstruktoren des ganzen Komponenten-Baums darunter.<blockquote><p>Hinweis<p>Fehlergrenzen fangen in folgenden Fällen <strong>keine</strong> Fehler ab :<ul><li>Event-Handler (<a href="#how-about-event-handlers">Lies mehr dazu</a>)<li>Asynchroner Code (z.B. <code>setTimeout</code> oder <code>requestAnimationFrame</code> Callbacks)<li>Serverseitiges Rendering<li>Fehler die in der Fehlergrenze selbst und nicht in dessen Kind-Komponenten auftreten</ul></blockquote><p>Eine Klassen-Komponente wird zu einer Fehlergrenze wenn es eine oder beide der folgenden Lifecycle-Methoden definiert <a href="./react-component.html#static-getderivedstatefromerror"><code>static getDerivedStateFromError()</code></a> oder <a href="./react-component.html#componentdidcatch"><code>componentDidCatch()</code></a>. Benutze <code>static getDerivedStateFromError()</code> um eine Fallback-UI zu rendern, nachdem ein Fehler aufgetreten ist. Benutze <code>componentDidCatch()</code> um Informationen über den Fehler zu loggen.<pre class="language-js{7-10,12-15,18-21}"><code class="language-js{7-10,12-15,18-21}">class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Update den State damit beim nächsten Render-Vorgang die Fallback-UI angezeigt wird.
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Du kannst den Fehler auch zu einem Fehlermonitoring-Service loggen
    logErrorToMyService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // Du kannst eine beliebige Fallback-UI rendern
      return &#x3C;h1>Etwas ist schiefgelaufen.&#x3C;/h1>;
    }

    return this.props.children;
  }
}</code></pre><p>Die Fehlergrenze kann wie eine reguläre Komponente genutzt werden:<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">ErrorBoundary</span><span class="token operator">></span>
  <span class="token operator">&#x3C;</span><span class="token maybe-class-name">MyWidget</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">ErrorBoundary</span><span class="token operator">></span></code></pre><p>Fehlergrenzen funktionieren wie das <code>catch {}</code> in JavaScript, nur für Komponenten. Die Definition der Fehlergrenze als Klassenkomponente ist Voraussetzung. In der Praxis wirst du wahrscheinlich die Fehlergrenze-Komponente ein einziges mal deklarieren und diese dann durchgehend in deiner Anwendung benutzen.<p>Beachte dass <strong>Fehlergrenzen nur Fehler in den Komponenten abfangen, die sich im Komponenten-Baum unter dieser befinden</strong>. Eine Fehlergrenze kann keine Fehler abfangen, die innerhalb der Fehlergrenze selbst aufgetreten sind. Wenn die Fehlergrenze den in ihr aufgetretenen Fehler nicht verarbeiten kann, wird dieser zur nächstgelegenen Fehlergrenze nach oben weitergereicht. Dies ist ebenso ähnlich der Funktionalität eines <code>catch {}</code> Blocks in JavaScript.</section><section id="live-demo"class="level2"><h2>Live Demo</h2><p>Schau dir <a href="https://codepen.io/gaearon/pen/wqvxGa?editors=0010">folgendes Beispiel für die Deklaration und Nutzung einer Fehlergrenze</a>.</section><section id="where-to-place-error-boundaries"class="level2"><h2>Wo platziert man Fehlergrenzen</h2><p>Über die Granularität der Fehlergrenzen kannst du frei entscheiden. Du kannst die top-level Route-Komponenten umschließen, um dem User eine "Etwas ist schiefgelaufen" Meldung anzuzeigen, diese Variante wird oft von serverseitigen Frameworks zur Fehlerbehandlung eingesetzt. Du kannst aber auch individuelle Widgets mit einer Fehlergrenze umschließen, um zu verhindern, dass diese den Rest der Anwendung zum Absturz bringen.</section><section id="new-behavior-for-uncaught-errors"class="level2"><h2>Neues Verhalten für nicht abgefangene Fehlermeldungen</h2><p>Diese Änderung hat eine wesentliche Auswirkung. <strong>Mit React 16 führen Fehler, die nicht von einer Fehlergrenze abgefangen wurden, zum Unmounten des gesamten React Komponenten-Baums.</strong><p>Wir haben über diese Entscheidung diskutiert, unserer Erfahrung nach ist es jedoch schlimmer eine fehlerhafte UI anzuzeigen, anstatt diese komplett zu entfernen. Zum Beispiel in einem Produkt wie einem Messenger, wäre es möglich, dass durch das Anzeigen einer fehlerhaften UI, die Nachricht an eine falsche Person verschickt werden könnte. Ebenso ist es in einer Zahlunganwendung schlimmer einen falschen Betrag anzuzeigen, statt einfach nichts zu rendern.<p>Diese Änderung bedeutet, dass sobald du auf React 16 migrierst, wirst du höchstwahrscheinlich einige zuvor unbemerkte Fehler in deiner Anwendung entdecken. Wenn etwas schief läuft, gibt das Hinzufügen von Fehlergrenzen dir die Möglichkeit, eine bessere Nutzererfahrung zu gewährleisten.<p>Zum Beispiel, der Facebook Messenger umschließt den Inhalt der Seitenleiste, des Informationspanels, des Unterhaltungsverlaufs und der Nachrichteneingabe mit separaten Fehlergrenzen. Wenn eines dieser UI-Bereiche abstürzt, bleibt der Rest interaktiv.<p>Des Weiteren raten wir dir ein Fehlermonitoring-Service zu nutzen (oder dein eigenes zu implementieren), damit du über die am Live-System aufgetretenen Fehler informiert bist und diese beheben kannst.</section><section id="component-stack-traces"class="level2"><h2>Strack-Trace von Komponenten</h2><p>React 16 gibt alle Fehlermeldungen in der Konsole aus, die im Zuge des Renderingvorgangs während der Entwicklung aufgetreten sind. Dies passiert auch dann, wenn die Anwendung die Fehlermeldungen unabsichtlich unterdrückt. Zusätzlich zu den Fehlermeldungen und dem JavaScript-Stack, werden auch die Komponenten Stack-Traces ausgegeben. Somit kannst du genau sehen, wo im Komponenten-Baum der Fehler zuerst aufgetreten ist:</p><img src="./docs/error-boundaries-stack-trace.png"style="max-width:100%"alt="Fehler der durch eine Fehlergrenzen-Komponente abgefangen wurde"><p>Du kannst auch die Dateinamen und Zeilennummern im Komponenten Stack-Trace sehen. Dies funktionert standardmäßig in <a href="https://github.com/facebookincubator/create-react-app">Create React App</a> Projekten:</p><img src="./docs/error-boundaries-stack-trace-line-numbers.png"style="max-width:100%"alt="Fehler der durch eine Fehlregrenze-Komponente abgefangen wurde, mit Angabe zur Zeilennummern"><p>Wenn du Create React App nicht verwendest, kannst du <a href="https://www.npmjs.com/package/@babel/plugin-transform-react-jsx-source">folgende Erweiterung</a> manuell zu deiner Babel-Konfiguration hinzufügen. Bedenke, dass dies nur für den Einsatz während des Entwicklungsprozesses und <strong>im Live-System deaktiviert werden muss</strong>.<blockquote><p>Hinweis<p>Namen von Komponenten die im Stack-Trace angezeigt werden, hängen von der <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name"><code>Function.name</code></a> Eigenschaft ab. Wenn du ältere Browser und Endgeräte unterstützen möchtest, welche diese Eigenschaft noch nicht unterstützen (z.B. IE 11), könntest du den Einsatz eines <code>Function.name</code> Polyfills wie <a href="https://github.com/JamesMGreene/Function.name"><code>function.name-polyfill</code></a> in deiner gebündelten Anwendung, in Erwägung ziehen. Alternativ, kannst du auch die <a href="./react-component.html#displayname"><code>displayName</code></a> Eigenschaft explizit für alle deine Komponenten definieren.</blockquote></section><section id="how-about-trycatch"class="level2"><h2>Wie sieht es mit try/catch aus?</h2><p><code>try</code> / <code>catch</code> ist großartig, funktioniert jedoch nur bei imperativen Code:<pre class="language-js"><code class="language-js"><span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>
  <span class="token function">showButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword control-flow">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>React-Komponenten sind deklarativ und spezifizieren <em>was</em> gerendert werden soll:<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Button</span> <span class="token operator">/</span><span class="token operator">></span></code></pre><p>Fehlergrenzen bewahren die deklarative Natur von React bei und verhalten sich so wie du es erwarten würdest. Auch, wenn beispielsweise ein Fehler in einer <code>componentDidUpdate</code> Methode auftritt, der von einem <code>setState</code> irgendwo tief im Komponenten-Baum verursacht wurde. Dieser Fehler wird trotzdem zur nächstgelegenen Fehlergrenze weitergeleitet.</section><section id="how-about-event-handlers"class="level2"><h2>Wie sieht es mit Event-Handler aus?</h2><p>Fehlergrenzen fangen <strong>keine</strong> Fehler innerhalb der Event-Handler ab.<p>React braucht keine Fehlergrenzen um sich von Fehlern innerhalb von Event-Handlern zu erholen. Im Gegensatz zu Render- und Lifecycle-Methoden finden Event-Handler nicht während des Renderings statt. Das heißt, im Falle eines Fehlers weiß React noch immer, was angezeigt werden soll.<p>Wenn du einen Fehler innerhalb von Event-Handlern abfangen möchtest, nutze das normale <code>try</code> / <code>catch</code> JavaScript-Statement:<pre class="language-js{9-13,17-20}"><code class="language-js{9-13,17-20}">class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { error: null };
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    try {
      // Mache etwas, was zu einem Fehler führt
    } catch (error) {
      this.setState({ error });
    }
  }

  render() {
    if (this.state.error) {
      return &#x3C;h1>Ein Fehler wurde abgefangen.&#x3C;/h1>
    }
    return &#x3C;button onClick={this.handleClick}>Klick mich&#x3C;/button>
  }
}</code></pre><p>Hinweis: Das Beispiel oben demonstriert das normale JavaScript-Verhalten und setzt keine Fehlergrenzen ein.</section><section id="naming-changes-from-react-15"class="level2"><h2>Änderung von Benennungen in React 15</h2><p>React 15 besaß einen sehr limitierten Support für Fehlergrenzen unter dem Methodennamen: <code>unstable_handleError</code>. Diese Methode funktioniert nicht mehr und muss stattdessen im Quellcode durch <code>componentDidCatch</code>, angefangen beim ersten 16 Beta-Release, ersetzt werden.<p>Für diese Änderungen, stellen wir einen <a href="https://github.com/reactjs/react-codemod#error-boundaries">Codemod</a> zur Verfügung, um die Migration in deinem Quellcode automatisch vorzunehmen. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>