<!doctype html><html lang="de"><meta charset="utf-8"><title>Profiler API</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="profiler-api"class="level1"><h1>Profiler API</h1><p>Der <code>Profiler</code> misst, wie oft eine React-Anwendung rendert und wie hoch die "Kosten" des Renderns sind. Sein Zweck besteht darin, Teile einer Anwendung zu identifizieren, die langsam sind und von <a href="./hooks-faq.html#how-to-memoize-calculations">Optimierungen wie Memoisierung</a> profitieren könnten.<blockquote><p>Hinweis:<p>Profiling fügt zusätzlichen Overhead hinzu, sodass <strong>es im <a href="./optimizing-performance.html#use-the-production-build">Produktions-Build</a> deaktiviert ist</strong>.<p>Um sich für Profiling in der Produktion zu entscheiden, bietet React einen speziellen Produktions-Build mit aktiviertem Profiling. Lesen Sie mehr über die Verwendung dieses Builds unter <a href="https://fb.me/react-profiling">fb.me/react-profiling</a></blockquote><section id="usage"class="level2"><h2>Verwendung</h2><p>Ein <code>Profiler</code> kann überall in einem Reactbaum hinzugefügt werden, um die Kosten für das Rendern dieses Teils des Baums zu messen. Es erfordert zwei Props: eine <code>id</code> (String) und einen <code>onRender</code>-Callback (Funktion), die React jedes Mal aufruft, wenn eine Komponente innerhalb des Baums ein Update "committet".<p>Zum Beispiel, um ein Profil einer <code>Navigation</code>-Komponente und ihrer Nachkommen zu erstellen:<pre class="language-js{3}"><code class="language-js{3}">render(
  &#x3C;App>
    &#x3C;Profiler id="Navigation" onRender={callback}>
      &#x3C;Navigation {...props} />
    &#x3C;/Profiler>
    &#x3C;Main {...props} />
  &#x3C;/App>
);</code></pre><p>Mehrere <code>Profiler</code>-Komponenten können verwendet werden, um verschiedene Teile einer Anwendung zu messen:<pre class="language-js{3,6}"><code class="language-js{3,6}">render(
  &#x3C;App>
    &#x3C;Profiler id="Navigation" onRender={callback}>
      &#x3C;Navigation {...props} />
    &#x3C;/Profiler>
    &#x3C;Profiler id="Main" onRender={callback}>
      &#x3C;Main {...props} />
    &#x3C;/Profiler>
  &#x3C;/App>
);</code></pre><p><code>Profiler</code>-Komponenten können auch verschachtelt werden, um verschiedene Komponenten innerhalb desselben Unterbaums zu messen:<pre class="language-js{3,5,8}"><code class="language-js{3,5,8}">render(
  &#x3C;App>
    &#x3C;Profiler id="Panel" onRender={callback}>
      &#x3C;Panel {...props}>
        &#x3C;Profiler id="Content" onRender={callback}>
          &#x3C;Content {...props} />
        &#x3C;/Profiler>
        &#x3C;Profiler id="PreviewPane" onRender={callback}>
          &#x3C;PreviewPane {...props} />
        &#x3C;/Profiler>
      &#x3C;/Panel>
    &#x3C;/Profiler>
  &#x3C;/App>
);</code></pre><blockquote><p>Hinweis<p>Obwohl <code>Profiler</code> eine leichtgewichtige Komponente ist, sollte sie nur bei Bedarf verwendet werden. Jede Verwendung fügt einer Anwendung etwas CPU- und Speicher-Overhead hinzu.</blockquote></section><section id="onrender-callback"class="level2"><h2><code>onRender</code> Callback</h2><p>Der <code>Profiler</code> benötigt eine <code>onRender</code>-Funktion als Prop. React ruft diese Funktion jedes Mal auf, wenn eine Komponente innerhalb des profilierten Baums eine Aktualisierung "übergibt". Es erhält Parameter, die beschreiben, was gerendert wurde und wie lange es gedauert hat.<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">onRenderCallback</span><span class="token punctuation">(</span>
  id<span class="token punctuation">,</span> <span class="token comment">// the "id" prop of the Profiler tree that has just committed</span>
  phase<span class="token punctuation">,</span> <span class="token comment">// either "mount" (if the tree just mounted) or "update" (if it re-rendered)</span>
  actualDuration<span class="token punctuation">,</span> <span class="token comment">// time spent rendering the committed update</span>
  baseDuration<span class="token punctuation">,</span> <span class="token comment">// estimated time to render the entire subtree without memoization</span>
  startTime<span class="token punctuation">,</span> <span class="token comment">// when React began rendering this update</span>
  commitTime<span class="token punctuation">,</span> <span class="token comment">// when React committed this update</span>
  interactions <span class="token comment">// the Set of interactions belonging to this update</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Aggregate or log render timings...</span>
<span class="token punctuation">}</span></code></pre><p>Schauen wir uns die einzelnen Props genauer an:<p>Das 'id'-Prop des <code>Profiler</code>-Baums, der gerade übergeben wurde. Dies kann verwendet werden, um zu identifizieren, welcher Teil des Baums festgeschrieben wurde, wenn Sie mehrere Profiler verwenden.<ul><li><strong><code>phase: "mount" | "update"</code></strong> - Gibt an, ob der Baum gerade zum ersten Mal gemountet oder aufgrund einer Änderung der Props, des Status oder der Hooks neu gerendert wurde.<li><strong><code>actualDuration: number</code></strong> - Zeit, die für das Rendern des <code>Profiler</code> und seiner Nachkommen für das aktuelle Update aufgewendet wurde. Dies zeigt an, wie gut der Teilbaum von Memoization Gebrauch macht (z. B. <a href="./react-api.html#reactmemo"><code>React.memo</code></a>, <a href="./hooks-reference.html#usememo"><code>useMemo</code></a>, <a href="./hooks-faq.html#how-do-i-implement-shouldcomponentupdate"><code>shouldComponentUpdate</code></a>). Idealerweise sollte dieser Wert nach dem anfänglichen Einhängen deutlich sinken, da viele der Nachkommen nur erneut rendern müssen, wenn sich ihre spezifischen Props ändern.<li><strong><code>baseDuration: number</code></strong> - Dauer der letzten <code>render</code>-Zeit für jede einzelne Komponente innerhalb des <code>Profiler</code>-Baums. Dieser Wert schätzt die Kosten des Renderns im schlimmsten Fall (z. B. das anfängliche Einhängen oder ein Baum ohne Memoisierung).<li><strong><code>startTime: number</code></strong> - Zeitstempel, wann React mit dem Rendern des aktuellen Updates begonnen hat.<li><strong><code>commitTime: number</code></strong> - Zeitstempel, als React das aktuelle Update committed hat. Dieser Wert wird von allen Profilern in einem Commit gemeinsam genutzt, sodass sie bei Bedarf gruppiert werden können.<li><strong><code>interactions: Set</code></strong> - Satz von <a href="https://fb.me/react-interaction-tracing">"Interaktionen"</a>, die nachverfolgt wurden, als das Update geplant wurde (z. B. wenn <code>render</code> oder <code>setState</code> aufgerufen wurden).</ul><blockquote><p>Hinweis<p>Interaktionen können verwendet werden, um die Ursache eines Updates zu identifizieren, obwohl die API zu ihrer Verfolgung noch experimentell ist.<p>Erfahren Sie mehr darüber unter <a href="https://fb.me/react-interaction-tracing">fb.me/react-interaction-tracing</a> <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></blockquote></section></section>