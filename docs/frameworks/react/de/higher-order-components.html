<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8">
    <title>Higher-Order Components</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="higher-order-components" class="level1">
      <h1>Higher-Order Components</h1>
      <p>Ein Higher-Order-Component (HOC) ist eine moderne Technologie zur Wiederverwendung von Komponentenlogik in React. HOCs sind kein Teil der React API an sich, sondern ein Schema welches sich aus der Kompositionstechnik von React ergibt.</p>
      <p>Konkret ist <strong>ein Higher-Order Component eine Funktion, die eine Komponente übernimmt und eine neue Komponente zurückgibt.</strong></p>
      <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">higherOrderComponent</span><span class="token punctuation">(</span><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      <p>Während eine Komponente alle Props in UI umwandelt, wandelt die Higher-Order-Komponente eine Komponente in eine andere Komponente um.</p>
      <p>HOCs finden sich häufig in React-Bibliotheken von Drittanbietern, als Beispiele dafür gelten <a href="https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect"><code>connect</code></a> von Redux und <a href="https://relay.dev/docs/v10.1.3/fragment-container/#createfragmentcontainer"><code>createFragmentContainer</code></a> von Relay.</p>
      <p>In diesem Dokument, werden wir erörtern, warum Higher-Order-Komponenten nützlich sind und wie du deine eigene schreiben kannst.</p>
      <section id="use-hocs-for-cross-cutting-concerns" class="level2">
        <h2>Nutze HOCs für übergreifende Belangen</h2>
        <blockquote>
          <p><strong>Hinweis</strong></p>
          <p>Früher haben wir Mixins für die Handhabung von übergreifenden Belangen empfohlen. Seither hat sich allerdings herausgestellt, dass Mixins mehr Probleme als Nutzen bereiten. <a href="/blog/2016/07/13/mixins-considered-harmful.html">Lese darüber</a> warum wir uns von Mixins abgewandt haben und wie du deine existierenden Komponenten umwandeln kannst.</p>
        </blockquote>
        <p>Komponenten sind die primäre Einheit der Quellcode-Wiederverwendbarkeit in React. Nichtsdestotrotz, wirst du feststellen, dass manche Patterns nicht immer für eine traditionelle Komponente geeignet sind.</p>
        <p>Als Beispiel nehmen wir eine <code>CommentList</code> Komponente, die eine externe Datenequelle nutzt, um eine Liste mit Kommentaren zu rendern:</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CommentList</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">handleChange</span><span class="token punctuation">.</span><span class="token method function property-access">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token comment">// "DataSource" ist irgendeine globale Datenquelle</span>
      <span class="token literal-property property">comments</span><span class="token operator">:</span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getComments</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// "Höre" falls Änderungen auftreten sollten</span>
    <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">addChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Aufräumen</span>
    <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">removeChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Update den Zustand der Komponente, jedes mal wenn die Datenquelle eine Änderung bekanntgibt</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">comments</span><span class="token operator">:</span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getComments</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
        <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">comments</span><span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">comment</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span>
          <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Comment</span> comment<span class="token operator">=</span><span class="token punctuation">{</span>comment<span class="token punctuation">}</span> key<span class="token operator">=</span><span class="token punctuation">{</span>comment<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>Später, erstellst du eine Komponente die auf Änderungen in einem Blog-Eintrag "hört" und ein ähnliches Pattern einsetzt:</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">BlogPost</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">handleChange</span><span class="token punctuation">.</span><span class="token method function property-access">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">blogPost</span><span class="token operator">:</span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getBlogPost</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">addChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">removeChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">blogPost</span><span class="token operator">:</span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getBlogPost</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">TextBlock</span> text<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">blogPost</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p><code>CommentList</code> und <code>BlogPost</code> sind nicht identisch - sie rufen unterschiedliche Methoden von <code>DataSource</code> auf und sie rendern unterschiedlichen Output. Jedoch ist die Mehrheit der Implementierung gleich:</p>
        <ul>
          <li>Wenn die Komponente gemountet ist, füge einen Listener für Änderungen in <code>DataSource</code> hinzu.</li>
          <li>Innerhalb des Listeners, rufe <code>setState</code> auf, sobald sich die Datenquelle ändert.</li>
          <li>Wenn die Komponente unmountet wird, entferne den Listener.</li>
        </ul>
        <p>Du kannst dir nun vorstellen, dass in einer großen Applikation, dieses Pattern sehr oft vorkommen wird. Wir wollen eine Abstraktion, die uns erlaubt diese Logik an einem Platz zu definieren und diese dann Komponentenübergreifend zu nutzen. Dies ist der Fall, wo sich die Higher-Order Komponenten auszeichnen.</p>
        <p>Wir können eine Funktion schreiben, die Komponenten erstellt, sowie <code>CommentList</code> und <code>BlogPost</code>, die <code>DataSource</code> als Datenquelle nutzt. Die Funktion akzeptiert als einer der Argumente eine Kind-Komponente, die Daten aus der Datenquelle als Eigenschaft erhält. Lass uns die Funktion <code>withSubscription</code> nennen:</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">CommentListWithSubscription</span> <span class="token operator">=</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span>
  <span class="token maybe-class-name">CommentList</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">DataSource</span></span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getComments</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token maybe-class-name">BlogPostWithSubscription</span> <span class="token operator">=</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span>
  <span class="token maybe-class-name">BlogPost</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">DataSource</span><span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">getBlogPost</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>Der erste Parameter ist die umschlossene Komponente. Der zweite Parameter erhält die Daten, an denen wir interessiert sind, dies wird durch <code>DataSource</code> und aktuelle Props sichergestellt.</p>
        <p>Wenn <code>CommentListWithSubscription</code> und <code>BlogPostWithSubscription</code> gerendert werden, wird eine <code>data</code> Eigenschaft an <code>CommentList</code> und <code>BlogPost</code> übermittelt, diese enthält die aktuellsten Daten, die von <code>DataSource</code> erhalten wurden.</p>
        <pre class="language-js"><code class="language-js"><span class="token comment">// Diese Funktion nimmt eine Komponente...</span>
<span class="token keyword">function</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">,</span> selectData</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...und gibt eine andere Komponente zurück...</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Component</span></span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">handleChange</span><span class="token punctuation">.</span><span class="token method function property-access">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token function">selectData</span><span class="token punctuation">(</span><span class="token maybe-class-name">DataSource</span><span class="token punctuation">,</span> props<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ... Das stellt sicher, dass Datenänderungen bearbeitet werden...</span>
      <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">addChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token maybe-class-name">DataSource</span><span class="token punctuation">.</span><span class="token method function property-access">removeChangeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleChange</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token function">selectData</span><span class="token punctuation">(</span><span class="token maybe-class-name">DataSource</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ... rendern der umschlossenen Komponente mit aktuellsten Daten!</span>
      <span class="token comment">// Beachte, dass wir jegliche zusätzliche Props weiterleiten</span>
      <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">WrappedComponent</span> data<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
        <p>Beachte, dass eine HOC die übergebene Komponente nicht modifiziert, des Weiteren findet auch keine Vererbung statt um dessen Verhalten zu kopieren. Stattdessen <em>setzt</em> eine HOC die ursprüngliche Komponente zusammen, in dem sie diese mit einer Container-Komponente <em>umschließt</em>. Eine HOC ist eine reine Funktion ohne Nebenwirkungen.</p>
        <p>Das ist alles! Die umschlossene Komponente erhält alle Eigenschaften des Containers, zusammen mit einer neuen Eigenschaft, <code>data</code>, die für das Rendern des Outputs verwendet wird. Die HOC ist nicht dafür zuständig, das Wie oder Warum bei der Datenverwendung zu beantworten, ebenso wie die umschlossene Komponente nicht über die Herkunft der Daten zuständig ist.</p>
        <p>Da <code>withSubscription</code> eine normale Funktion ist, kannst du beliebig viele, oder beliebig wenige Argumente übergeben. Zum Beispiel, du möchtest den Namen der <code>data</code> Eigenschaft konfigurierbar machen, um die HOC mehr von der umschlossenen Komponente zu isolieren. Oder du könntest ein Argument hinzufügen, welches <code>shouldComponentUpdate</code> konfiguriert, oder eines welches die Datenquelle konfiguriert. All das ist möglich, weil die HOC die volle Kontroll darübere hat, wie eine Komponente definiert wird.</p>
        <p>Wie bei den Komponenten, ist die Abhängigkeit zwischen <code>withSubscription</code> und der umschlossenen Komponente rein Eigenschaftenbasiert. Dies ermöglicht einen einfachen Austausch einer bestehenden HOC durch eine andere, so lange diese die gleichen Eigenschaften an die umschlossene Komponente bereitstellen. Dies kann nützlich sein, wenn du zum Beispiel die Bibliothek für das Abrufen von Daten änderst.</p>
      </section>
      <section id="dont-mutate-the-original-component-use-composition" class="level2">
        <h2>Verändere nicht die usprüngliche Komponente. Verwende Komposition.</h2>
        <p>Widerstehe der Versuchung den Prototype einer Komponente innerhalb einer HOC zu modifizieren (oder anderweitig zu verändern).</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">logProps</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">InputComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">InputComponent</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">componentDidUpdate</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">prevProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'Aktuelle Props: '</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'Vorherige Props: '</span><span class="token punctuation">,</span> prevProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// Die Tatsache, dass wir die originale Eingang-Komponente zurückgeben, ist ein Hinweis</span>
  <span class="token comment">// dass diese verändert wurde.</span>
  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">InputComponent</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// EnhancedComponent wird bei jedem Erhalt der Eigenschaften in die Konsole loggen</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">logProps</span><span class="token punctuation">(</span><span class="token maybe-class-name">InputComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>Es gibt einige Probleme hier. Zum einen kann die Eingang-Komponente nicht abseits der erweiterten Komponente wiederverwendet werden. Des Weiteren, wenn du eine andere HOC auf die <code>EnhancedComponent</code> anwendest die <em>ebenso</em> <code>componentWillReceiveProps</code> verändert, wird die erste Funktionalität der HOC überschrieben! Diese HOC kann auch nicht auf funktionale Komponenten angewandt werden, da diese keine Lifecycle-Methoden besitzen.</p>
        <p>Verändernde HOCs sind eine schlecht isolierte Abstraktion - der Anwender muss über die Implementierungsdetails bescheidwissen, um Konflikte mit anderen HOCs zu vermeiden.</p>
        <p>Statt der Veränderung, sollte der Grundsatz der Komposition bei HOCs angewandt werden, in dem die Eingang-Komponente mit einer Container-Komponente umgeben wird:</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">logProps</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Component</span></span> <span class="token punctuation">{</span>
    <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'Aktuelle Props: '</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'Neue Props: '</span><span class="token punctuation">,</span> prevProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Umschließt die Eingang-Kompnente in ein Container, ohne diese zu verändern. Gut so!</span>
      <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">WrappedComponent</span> <span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>Diese HOC hat die gleiche Funktionalität wie die verändernde Version, jedoch ohne der potenziellen Gefahr für Konflikte. Es funktioniert gleich gut mit klassenbasierten und funktionalen Komponenten. Und da es eine reine Funktion ist, kann sie mit anderen HOCs, oder sogar mit sich selbst zusammengesetzt werden.</p>
        <p>Vielleicht sind dir die Gemeinsamkeiten zwischen HOCs und dem <strong>Container Komponenten</strong> Pattern aufgefallen. Container Komponenten sind ein Teil der Strategie, in der eine Trennung der Zuständigkeiten zwischen übergreifenden und untergeordneten Anliegen vorgenommen wird. Container verwalten Dinge wie Abonnements und Zustand, des Weiteren geben die Eigenschaften an Komponenten weiter, die für das Rendering der UI zuständig sind. HOCs verwenden Container als Teil der Implementierung. Du kannst HOCs mit einer parametrisierten Container-Komponenten Definition vergleichen.</p>
      </section>
      <section id="convention-pass-unrelated-props-through-to-the-wrapped-component" class="level2">
        <h2>Konvention: Übergeben von unzusammenhängenden Eigenschaften durch die umgschlossene Komponente</h2>
        <p>HOCs fügt Features zu einer Komponente hinzu. Diese sollten keine drastische Veränderungen an dessen Abhängigkeit vornehmen. Es wird erwartet, dass die von der HOC zurückgegebene Komponente ein ähnliches Interface besitzt, wie die umschlossene Komponente.</p>
        <p>HOCs sollten Eigenschaften durchleiten, die keine Bedeutung für dessen Zweck besitzen. Die meisten HOCs besitzen eine Render-Methode die folgend aussieht:</p>
        <pre class="language-js"><code class="language-js"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Filtere die extra Eigenschaften raus, die spezifisch für diese HOC sind</span>
  <span class="token comment">// und nicht weitergeleitet werden sollen</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> extraProp<span class="token punctuation">,</span> <span class="token spread operator">...</span>passThroughProps <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>

  <span class="token comment">// Injiziere Eigeschaften in die umschlossene Komponente. In den meisten Fällen</span>
  <span class="token comment">// sind es Zustandswerte oder Instanzenmethoden</span>
  <span class="token keyword">const</span> injectedProp <span class="token operator">=</span> someStateOrInstanceMethod<span class="token punctuation">;</span>

  <span class="token comment">// Übergebe die Eigenschaften an die umschlossene Komponente</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">WrappedComponent</span>
      injectedProp<span class="token operator">=</span><span class="token punctuation">{</span>injectedProp<span class="token punctuation">}</span>
      <span class="token punctuation">{</span><span class="token spread operator">...</span>passThroughProps<span class="token punctuation">}</span>
    <span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
        <p>Diese Konvention hilft sicherzustellen, dass HOCs flexibel und wiederverwendbar sind.</p>
      </section>
      <section id="convention-maximizing-composability" class="level2">
        <h2>Konvention: Maximierung der Zusammensetzbarkeit</h2>
        <p>Nicht alle HOCs sehen gleich aus. Manchmal nehmen diese nur ein einziges Argument an, die umschlossene Komponente:</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">NavbarWithRouter</span> <span class="token operator">=</span> <span class="token function">withRouter</span><span class="token punctuation">(</span><span class="token maybe-class-name">Navbar</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>Normalerweise, akzeptieren HOCs zusätzliche Argumente. In diesem Beispiel von Relay, wird ein Konfigurationsobjekt verwendet um die Datenabhängigkeiten einer Komponente zu definieren:</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">CommentWithRelay</span> <span class="token operator">=</span> <span class="token maybe-class-name">Relay</span><span class="token punctuation">.</span><span class="token method function property-access">createContainer</span><span class="token punctuation">(</span><span class="token maybe-class-name">Comment</span><span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>Die häufigste Signatur für HOCs sieht wie folgt aus:</p>
        <pre class="language-js"><code class="language-js"><span class="token comment">// React Redux's `connect`</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">ConnectedComment</span> <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span>commentSelector<span class="token punctuation">,</span> commentActions<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token maybe-class-name">CommentList</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p><em>Was?!</em> Wenn man es auseinanderbricht, ist es ersichtlicher was hier passiert.</p>
        <pre class="language-js"><code class="language-js"><span class="token comment">// connect ist eine Funktion die eine andere Funktion zurückgibt</span>
<span class="token keyword">const</span> enhance <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span>commentListSelector<span class="token punctuation">,</span> commentListActions<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Die zurückgegebene Funktion ist eine HOC, die eine Komponente zurückgibt die</span>
<span class="token comment">// mit dem Redux Store verbunden ist</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">ConnectedComment</span> <span class="token operator">=</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token maybe-class-name">CommentList</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>In anderen Worten, <code>connect</code> ist eine Higher-Order Funktion die eine Higher-Order Komponente zurückgibt!</p>
        <p>Diese Form kann verwirrend oder unnötig erscheinen, es hat jedoch eine nützliche Eigenschaft. HOCs mit einzigem Argument, wie die, die von der <code>connect</code> Funktion zurückgegeben werden besitzen die Signatur <code>Component => Component</code>. Funktionen dessen Ausgabetyp dem Eingabetyp gleicht, können sehr einfach zusammengesetzt werden.</p>
        <pre class="language-js"><code class="language-js"><span class="token comment">// Anstatt folgendes zu machen...</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">withRouter</span><span class="token punctuation">(</span><span class="token function">connect</span><span class="token punctuation">(</span>commentSelector<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// ... kannst du ein Utility zur Zusammensetzung der Funktion nutzen</span>
<span class="token comment">// compose(f, g, h) ist gleichzusetzen mit (...args) => f(g(h(...args)))</span>
<span class="token keyword">const</span> enhance <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  <span class="token comment">// Dies sind HOCs mit einem einzelnen Argument</span>
  withRouter<span class="token punctuation">,</span>
  <span class="token function">connect</span><span class="token punctuation">(</span>commentSelector<span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span></code></pre>
        <p>(Diese Eigenschaft ermöglicht die Verwendung von <code>connect</code> und anderen Enhancer-basierten HOCs als Dekoratoren, welche ein experimentelles JavaScript Entwurf darstellen.)</p>
        <p>Die <code>componse</code> Utility-Funktion wird von vielen Drittanbieter-Bibliotheken wie lodash (als <a href="https://lodash.com/docs/#flowRight"><code>lodash.flowRight</code></a>), <a href="https://redux.js.org/api/compose">Redux</a> und <a href="https://ramdajs.com/docs/#compose">Ramda</a> angeboten.</p>
      </section>
      <section id="convention-wrap-the-display-name-for-easy-debugging" class="level2">
        <h2>Konvention: Umschließe den Anzeigenamen für ein einfaches Debugging</h2>
        <p>Die Container Komponenten die von HOCs erstellt werden, erscheinen in den <a href="https://github.com/facebook/react/tree/main/packages/react-devtools">React Developer Tools</a> wie jede andere Komponente. Um das Debugging zu erleichtern, wähle einen Anzeigenamen aus, der mitteilt, dass es ein Ergebnis einer HOC ist.</p>
        <p>Das Umschließen des Anzeigenamens der umzuschließenden Komponente ist ein gebräuchlicher Ansatz. Wenn deine Higher-Order Komponente <code>withSubscription</code> heißt und der Name der umschlossenen Komponente ist <code>CommentList</code>, nutze <code>WithSubscription(CommentList)</code> als Anzeigenamen:</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">WithSubscription</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token comment">/* ... */</span><span class="token punctuation">}</span>
  <span class="token maybe-class-name">WithSubscription</span><span class="token punctuation">.</span><span class="token property-access">displayName</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">WithSubscription(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">getDisplayName</span><span class="token punctuation">(</span><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">WithSubscription</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getDisplayName</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">.</span><span class="token property-access">displayName</span> <span class="token operator">||</span> <span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">||</span> <span class="token string">'Component'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </section>
      <section id="caveats" class="level2">
        <h2>Vorbehalte</h2>
        <p>Higher-Order Komponenten kommen mit einigen Vorbehalten, die nicht sofort ersichtlich sind wenn du dich erst mit React vertraut machst.</p>
        <section id="dont-use-hocs-inside-the-render-method" class="level3">
          <h3>Vermeide die Nutzung von HOCs innerhalb der Render-Methode</h3>
          <p>Der Differenzierungsalgorithmus von React (auch <a href="./reconciliation.html">Abgleich (engl. Reconciliation)</a> genannt) nutzt die Identität der Komponente, um zu bestimmen, ob der existierende Teilbaum aktualisiert, oder weggeworfen werden soll und ob das Mounten eines neuen Teilbaums notwendig ist. Wenn die von der <code>render</code>-Methode zurückgegebene Komponente identisch (<code>===</code>) zu der vorher zurückgegebenen Komponente ist, wird der Teilbaum rekursiv von React geupdatet, in dem eine Differenzierung des alten Teilbaums mit dem neuen Teilbaum stattfindet. Wenn die beiden ungleich sind, wird der vorherige Teilbaum zur Gänze unmounted.</p>
          <p>Normalerweise, solltest du keine Gedanken darüber verlieren. Jedoch spielt dies eine wesentliche Rolle für HOCs, da dies bedeutet, dass du eine HOC auf eine Komponente innerhalb der Render-Methode einer Komponente nicht anwenden kannst:</p>
          <pre class="language-js"><code class="language-js"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Eine neue Version von EnhancedComponent wird bei jedem Render-Vorgang erstellt</span>
  <span class="token comment">// EnhancedComponent1 !== EnhancedComponent2</span>
  <span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token maybe-class-name">MyComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Dies bewirkt dass jedesmal ein Unmounten/Remounten des ganzen Teilbaus stattfindet</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
          <p>Das Problem hier ist nicht nur die Performance - das Remounten einer Komponente führt zum Verlust des Zustandes sowohl bei der Komponente selbst, als auch bei all ihren Kind-Komponenten.</p>
          <p>Stattdessen, solltest du die HOCs außerhalb der Definition einer Komponente anwenden, um sicherzustellen, dass die Komponente nur ein einziges Mal erstellt wird. Nur dann ist dessen Identität konsistent und übergreifend zwischen den einzelnen Rendervorgängen sichergestellt. Normalerweise ist dies sowieso das, was du willst.</p>
          <p>In den seltenen Fällen wo du eine HOC dynamisch anwenden möchtest, kannst du dies innerhalb der Lifecycle-Methoden einer Komponente oder im Konstruktor machen.</p>
        </section>
        <section id="static-methods-must-be-copied-over" class="level3">
          <h3>Statische Methoden müssen kopiert werden</h3>
          <p>Manchmal ist es nützlich eine statische Methode in einer React Komponente zu definieren. Zum Beispiel, Relay Kontainer stellen eine statische Methode <code>getFragment</code> zur Verfügung, um die Zusammensetzung der GraphQL Fragmente zu erleichtern.</p>
          <p>Wenn du jedoch eine HOC auf eine Komponente anwendest, wird die ursprüngliche Komponente mit einer Container-Komponente umgeben. Dies bedeutet, dass die neue Komponente keine der statischen Methoden der usprünglichen Komponente besitzt.</p>
          <pre class="language-js"><code class="language-js"><span class="token comment">// Definiere eine statische Methode</span>
<span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">staticMethod</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
<span class="token comment">// Nun wende eine HOC an</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">EnhancedComponent</span> <span class="token operator">=</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Die erweiterte Komponente hat keine statische Methode</span>
<span class="token keyword">typeof</span> <span class="token maybe-class-name">EnhancedComponent</span><span class="token punctuation">.</span><span class="token property-access">staticMethod</span> <span class="token operator">===</span> <span class="token string">'undefined'</span> <span class="token comment">// true</span></code></pre>
          <p>Um dies zu lösen, kannst du die Methoden in den Container kopieren, bevor du diesen zurückgibst</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">Enhance</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
  <span class="token comment">// Du musst genau wissen, welche Methode(n) du kopieren möchtest :(</span>
  <span class="token maybe-class-name">Enhance</span><span class="token punctuation">.</span><span class="token property-access">staticMethod</span> <span class="token operator">=</span> <span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">.</span><span class="token property-access">staticMethod</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">Enhance</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
          <p>Dennoch, dies erfordert dass du genau weißt welche Methoden kopiert werden müssen. Du kannst <a href="https://github.com/mridgway/hoist-non-react-statics">hoist-non-react-statics</a> nutzen, um automatisch alle statische Methoden die nicht zu React gehören zu kopieren:</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports">hoistNonReactStatic</span> <span class="token keyword module">from</span> <span class="token string">'hoist-non-react-statics'</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">WrappedComponent</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">Enhance</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>
  <span class="token function">hoistNonReactStatic</span><span class="token punctuation">(</span><span class="token maybe-class-name">Enhance</span><span class="token punctuation">,</span> <span class="token maybe-class-name">WrappedComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">Enhance</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
          <p>Eine andere mögliche Lösung wäre das Exportieren der statischen Methode unabhängig von der Komponente.</p>
          <pre class="language-js"><code class="language-js"><span class="token comment">// Statt...</span>
<span class="token maybe-class-name">MyComponent</span><span class="token punctuation">.</span><span class="token property-access">someFunction</span> <span class="token operator">=</span> someFunction<span class="token punctuation">;</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token maybe-class-name">MyComponent</span><span class="token punctuation">;</span>

<span class="token comment">// ...exportiere die Methode separat...</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span> someFunction <span class="token punctuation">}</span></span><span class="token punctuation">;</span>

<span class="token comment">// ...importiere beide in die gewünschte Komponente</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">MyComponent</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> someFunction <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./MyComponent.js'</span><span class="token punctuation">;</span></code></pre>
        </section>
        <section id="refs-arent-passed-through" class="level3">
          <h3>Refs werden nicht weitergeleitet</h3>
          <p>Obwohl die Konvention für Higher-Order Komponente besagt, dass alle Eigenschaften an die umschlossene Komponente weiteregeleitet werden sollen, funktioniert dieser Ansatz für Refs nicht. Das kommt daher, weil <code>ref</code> nicht wirklich eine Eigenschaft ist - wie <code>key</code>, wird es besonders von React behandelt. Wenn du eine Ref zu einem Element hinzufügen möchtest, welches das Ergebnis einer HOC ist, wird das Ref auf die Instanz der äußersten Container-Komponente zeigen und nicht auf die umschlossene Komponente.</p>
          <p>
            Die Lösung für dieses Problem ist die Verwendung von <code>React.forwardRef</code> API (eingeführt mit React 16.3). <a href="./forwarding-refs.html">Learn more about it in the forwarding refs section</a>.
            <span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span>
          </p>
        </section>
      </section>
    </section>
  </body>
</html>
