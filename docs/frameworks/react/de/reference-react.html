<!doctype html><html lang="de"><meta charset="utf-8"><title>React Top-Level API</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="react-top-level-api"class="level1"><h1>React Top-Level API</h1><p><code>React</code> ist der Zugangspunkt zur React-Bibliothek. Falls du React von einem <code>&#x3C;script></code>-Tag heraus lädst, sind diese Top-Level APIs im globalen <code>React</code>-Objekt verfügbar. Solltest du ES6 mit npm verwenden, kannst du <code>import React from 'react'</code> schreiben. Wenn du ES5 mit npm verwendest, kannst du <code>var React = require('react')</code> schreiben.<section id="overview"class="level2"><h2>Übersicht</h2><section id="components"class="level3"><h3>Komponenten</h3><p>Mit React-Komponenten kann die Benutzeroberfläche in unabhängige, wiederverwendbare Bestandteile aufgeteilt werden, die jeweils isoliert betrachtet werden können. React-Komponenten können als Unterklassen von <code>React.Component</code> oder <code>React.PureComponent</code> definiert werden.<ul><li><a href="#reactcomponent"><code>React.Component</code></a><li><a href="#reactpurecomponent"><code>React.PureComponent</code></a></ul><p>Solltest du keine ES6-Klassen benutzen, kannst du stattdessen das <code>create-react-class</code>-Modul verwenden. Siehe <a href="./react-without-es6.html">React ohne ES6</a> für mehr Informationen.<p>React-Komponenten können auch als Funktionen definiert werden, die ummantelt werden können:<ul><li><a href="#reactmemo"><code>React.memo</code></a></ul></section><section id="creating-react-elements"class="level3"><h3>React-Elemente erstellen</h3><p>Um zu beschreiben, wie die Benutzeroberfläche aussehen soll, empfehlen wir, <a href="./introducing-jsx.html">JSX</a> zu verwenden. Ein JSX-Element ist eine alternative Schreibweise für das Aufrufen von <a href="#createelement"><code>React.createElement()</code></a>. Wenn du JSX verwendest, rufst du die folgenden Methoden normalerweise nicht direkt auf:<ul><li><a href="#createelement"><code>createElement()</code></a><li><a href="#createfactory"><code>createFactory()</code></a></ul><p>Siehe <a href="./react-without-jsx.html">React ohne JSX</a> für mehr Informationen.</section><section id="transforming-elements"class="level3"><h3>Elemente verändern</h3><p><code>React</code> stellt mehrere APIs zur Verfügung, um Elemente zu manipulieren:<ul><li><a href="#cloneelement"><code>cloneElement()</code></a><li><a href="#isvalidelement"><code>isValidElement()</code></a><li><a href="#reactchildren"><code>React.Children</code></a></ul></section><section id="fragments"class="level3"><h3>Fragmente</h3><p><code>React</code> stellt auch eine Komponente zu Verfügung, mit der mehrere Elemente ohne Wrapper gerendert werden können:<ul><li><a href="#reactfragment"><code>React.Fragment</code></a></ul></section><section id="refs"class="level3"><h3>Refs</h3><ul><li><a href="#reactcreateref"><code>React.createRef</code></a><li><a href="#reactforwardref"><code>React.forwardRef</code></a></ul></section><section id="suspense"class="level3"><h3>Suspense</h3><p>Mit Suspense können Komponenten vor dem Rendern auf etwas "warten". Momentan unterstützt Suspense nur einen Anwendungsfall: <a href="./code-splitting.html#reactlazy">Komponenten dynamisch laden mit <code>React.lazy</code></a>. In Zukunft wird es auch andere Anwendungsfälle wie z.B. das Abrufen von Daten unterstützen.<ul><li><a href="#reactlazy"><code>React.lazy</code></a><li><a href="#reactsuspense"><code>React.Suspense</code></a></ul></section><section id="transitions"class="level3"><h3>Transitions</h3><p><em>Transitions</em> are a new concurrent feature introduced in React 18. They allow you to mark updates as transitions, which tells React that they can be interrupted and avoid going back to Suspense fallbacks for already visible content.<ul><li><a href="#starttransition"><code>React.startTransition</code></a><li><a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a></ul></section><section id="hooks"class="level3"><h3>Hooks</h3><p><em>Hooks</em> sind neu in React 16.8. Sie erlauben die Verwendung von State und anderen React-Features ohne Klassen. Hooks haben einen <a href="./hooks-intro.html">eigenen Bereich in der Dokumentation</a> und eine eigene API-Referenz:<ul><li><a href="./hooks-reference.html#basic-hooks">Grundlegende Hooks</a><ul><li><a href="./hooks-reference.html#usestate"><code>useState</code></a><li><a href="./hooks-reference.html#useeffect"><code>useEffect</code></a><li><a href="./hooks-reference.html#usecontext"><code>useContext</code></a></ul><li><a href="./hooks-reference.html#additional-hooks">Weitere Hooks</a><ul><li><a href="./hooks-reference.html#usereducer"><code>useReducer</code></a><li><a href="./hooks-reference.html#usecallback"><code>useCallback</code></a><li><a href="./hooks-reference.html#usememo"><code>useMemo</code></a><li><a href="./hooks-reference.html#useref"><code>useRef</code></a><li><a href="./hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a><li><a href="./hooks-reference.html#uselayouteffect"><code>useLayoutEffect</code></a><li><a href="./hooks-reference.html#usedebugvalue"><code>useDebugValue</code></a><li><a href="./hooks-reference.html#usedeferredvalue"><code>useDeferredValue</code></a><li><a href="./hooks-reference.html#usetransition"><code>useTransition</code></a><li><a href="./hooks-reference.html#useid"><code>useId</code></a></ul><li><a href="./hooks-reference.html#library-hooks">Library Hooks</a><ul><li><a href="./hooks-reference.html#usesyncexternalstore"><code>useSyncExternalStore</code></a><li><a href="./hooks-reference.html#useinsertioneffect"><code>useInsertionEffect</code></a></ul></ul><hr></section></section><section id="reference"class="level2"><h2>Referenz</h2><section id="reactcomponent-reactcomponent"class="level3"><h3><code>React.Component</code> {#reactcomponent}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/Component"><code>Component</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><p><code>React.Component</code> ist die Basis-Klasse für React-Komponenten, die mit <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6-Klassen</a> definiert werden:<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Greeting</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token maybe-class-name">Hello</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Unter <a href="./react-component.html">React.Component API-Referenz</a> gibt es eine Liste der Methoden und Eigenschaften, die sich auf die <code>React.Component</code>-Basisklasse beziehen.<hr></section><section id="reactpurecomponent-reactpurecomponent"class="level3"><h3><code>React.PureComponent</code> {#reactpurecomponent}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/PureComponent"><code>PureComponent</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><p><code>React.PureComponent</code> ähnelt <a href="#reactcomponent"><code>React.Component</code></a>, unterscheidet sich aber dahingehend, dass <a href="./react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a> von <a href="#reactcomponent"><code>React.Component</code></a> nicht implementiert wird, während <code>React.PureComponent</code> es durch das oberflächliche Vergleichen von Props und State implementiert.<p>Wenn die <code>render()</code>-Funktion einer React-Komponente bei Gleichbleiben von Props und State das gleiche Ergebnis rendert, kann die Nutzung von <code>React.PureComponent</code> in manchen Fällen die Performance verbessern.<blockquote><p>Hinweis<p><code>shouldComponentUpdate()</code> von <code>React.PureComponent</code> vergleicht Objekte nur oberflächlich. Falls diese komplexe Datenstrukturen enthalten, könnte es für tiefer gelegene Unterschiede zu falschen Negativbefunden kommen. Benutze <code>PureComponent</code> nur dann, wenn Props und State einfach sind, oder verwende <a href="./react-component.html#forceupdate"><code>forceUpdate()</code></a> wenn du weißt, dass tiefergelegene Datenstrukturen sich verändert haben. Oder überlege dir, <a href="https://immutable-js.com/">unveränderliche (immutable) Objekte</a> zu verwenden, um das schnelle Vergleichen geschachtelter Daten zu erleichtern.<p>Darüber hinaus überspringt <code>shouldComponentUpdate()</code> von <code>React.PureComponent</code> den kompletten der Komponente untergeordneten Teilbaum. Es sollte also sichergestellt werden, dass alle Kind-Komponenten auch "pur" sind.</blockquote><hr></section><section id="reactmemo-reactmemo"class="level3"><h3><code>React.memo</code> {#reactmemo}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/memo"><code>memo</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token maybe-class-name">MyComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* rendere mit Props */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>React.memo</code> ist eine <a href="./higher-order-components.html">Higher-Order-Komponente</a>.<p>Wenn deine Komponente das gleiche Ergebnis mit den gleichen Props liefert, kannst du es mit <code>React.memo</code> umschließen um in einigen Fällen die Performance zu verbessern, in dem sich das Ergebnis gemerkt wird. Das bedeutet, dass React das Rendern der Komponente überspringt und stattdessen das zuletzt gerenderte Ergebnis wiederverwendet.<p><code>React.memo</code> betrifft nur Änderungen von Props. Wenn deine Funktionskomponente von <code>React.memo</code> umschloßen ist, eine <a href="./hooks-state.html"><code>useState</code></a>, <a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> oder <a href="./hooks-reference.html#usecontext"><code>useContext</code></a> Hook in ihrer Implementierung hat, wird sie immer noch gerendert, wenn sich der State oder der Context ändert.<p>Standardmäßig wird es nur oberflächlich komplexe Objekte im Props-Objekt vergleichen. Wenn du die Kontrolle über den Vergleich haben möchtest, kannst du auch eine benutzerdefinierte Vergleichsfunktion als zweites Argument angeben.<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* rendere mit Props */</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">areEqual</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*
  Gib 'true' zurück, wenn nextProps das gleiche Ergebnis rendern würde 
  wie prevProps, ansonsten gib 'false' zurück
  */</span>
<span class="token punctuation">}</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token maybe-class-name">MyComponent</span><span class="token punctuation">,</span> areEqual<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Diese Methode existiert nur zur <strong><a href="./optimizing-performance.html">Performance-Optimierung</a>.</strong> Verlasse dich nicht auf sie, um das Rendern zu "verhindern", da dadurch Bugs entstehen können.<blockquote><p>Hinweis<p>Im Gegensatz zur <a href="./react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a>-Methode in Klassen-Komponenten gibt die <code>areEqual</code>-Funktion <code>true</code> zurück, wenn die Props gleich sind und <code>false</code>, wenn die Props unterschiedlich sind, also genau andersherum als <code>shouldComponentUpdate</code>.</blockquote><hr></section><section id="createelement-createelement"class="level3"><h3><code>createElement()</code> {#createelement}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/createElement"><code>createElement</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">createElement</span><span class="token punctuation">(</span>
  type<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>props<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token spread operator">...</span>children<span class="token punctuation">]</span>
<span class="token punctuation">)</span></code></pre><p>Erzeugt und gibt ein neues <a href="./rendering-elements.html">React-Element</a> eines bestimmten Typs zurück. Das Typ-Argument kann entweder ein Tag-Name als String (z.B. <code>'div'</code> oder <code>'span'</code>), ein <a href="./components-and-props.html">React-Komponenten</a>-Typ (eine Klasse oder eine Funktion) oder ein <a href="#reactfragment">React-Fragment</a>-Typ sein.<p>In <a href="./introducing-jsx.html">JSX</a> geschriebener Code wird konvertiert, um <code>React.createElement()</code> zu benutzen. Wenn du JSX verwendest, rufst du <code>React.createElement()</code> normalerweise nicht direkt auf. Siehe <a href="./react-without-jsx.html">React ohne JSX</a> für mehr Informationen.<hr></section><section id="cloneelement-cloneelement"class="level3"><h3><code>cloneElement()</code> {#cloneelement}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/cloneElement"><code>cloneElement</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><pre class="language-text"><code class="language-text">React.cloneElement(
  element,
  [config],
  [...children]
)</code></pre><p>Klone und gebe ein neues React-Element mit <code>element</code> als Ausgangspunkt zurück. <code>config</code> sollte alle neuen Props, <code>key</code>s oder <code>ref</code>s enthalten. Das resultierende Element hat die Props des ursprünglichen Elements, in die die neuen Props oberflächlich eingefügt werden. Neue Kinder ersetzen die existierenden Kinder. <code>key</code> und <code>ref</code> des ursprünglichen Elements bleiben erhalten, wenn kein <code>key</code> und <code>ref</code> in der <code>config</code> vorhanden sind.<p><code>React.cloneElement()</code> ist fast äquivalent zu:<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span>element<span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>props<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token operator">></span></code></pre><p>Es bewahrt jedoch auch die Refs. Das bedeutet, wenn du ein Kind mit einem Ref erhälst, dieses nicht versehentlich vom Vorgänger stiehlst. Du bekommst das selbe Ref an dein neues Element angehängt. Das neue Ref oder der neue Key ersetzt die alten, falls vorhanden.<p>Diese API wurde als Ersatz für das veraltete <code>React.addons.cloneWithProps()</code> eingeführt.<hr></section><section id="createfactory-createfactory"class="level3"><h3><code>createFactory()</code> {#createfactory}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/createFactory"><code>createFactory</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">createFactory</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span></code></pre><p>Gibt eine Funktion zurück, die React-Elemente eines bestimmten Typs erzeugt. Wie bei <a href="#createelement"><code>React.createElement()</code></a> kann das Typ-Argument entweder ein Tag-Name als String (z.B. <code>'div'</code> oder <code>'span'</code>), ein <a href="./components-and-props.html">React-Komponenten</a>-Typ (eine Klasse oder eine Funktion) oder ein <a href="#reactfragment">React-Fragment</a>-Typ sein.<p>Dieser Helfer gilt als veraltet, und wir empfehlen, entweder JSX oder <code>React.createElement()</code> direkt zu verwenden.<p>Wenn du JSX verwendest, rufst du <code>React.createFactory()</code> normalerweise nicht direkt auf. Siehe <a href="./react-without-jsx.html">React ohne JSX</a> für mehr Informationen.<hr></section><section id="isvalidelement-isvalidelement"class="level3"><h3><code>isValidElement()</code> {#isvalidelement}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/isValidElement"><code>isValidElement</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">isValidElement</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span></code></pre><p>Überprüft, ob das Objekt ein React-Element ist. Gibt <code>true</code> oder <code>false</code> zurück.<hr></section><section id="reactchildren-reactchildren"class="level3"><h3><code>React.Children</code> {#reactchildren}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/Children"><code>Children</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><p><code>React.Children</code> bietet Hilfsmittel, um mit der eher undurchschaubaren Datenstruktur von <code>this.props.children</code> umzugehen.<section id="reactchildrenmap-reactchildrenmap"class="level4"><h4><code>React.Children.map</code> {#reactchildrenmap}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">[</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>Ruft für jedes unmittelbare Kind aus <code>children</code> eine Funktion auf, bei der <code>this</code> auf <code>thisArg</code> gesetzt ist. Wenn <code>children</code> ein Array ist, wird dieses durchlaufen und die Funktion wird für jedes Kind im Array aufgerufen. Falls <code>children</code> <code>null</code> oder <code>undefined</code> ist, gibt diese Methode statt einem Array <code>null</code> oder <code>undefined</code> zurück.<blockquote><p>Hinweis<p>Falls <code>children</code> ein <code>Fragment</code> ist, wird es wie ein einziges Kind behandelt und nicht durchlaufen.</blockquote></section><section id="reactchildrenforeach-reactchildrenforeach"class="level4"><h4><code>React.Children.forEach</code> {#reactchildrenforeach}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">[</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>Wie <a href="#reactchildrenmap"><code>React.Children.map()</code></a>, gibt jedoch kein Array zurück.</section><section id="reactchildrencount-reactchildrencount"class="level4"><h4><code>React.Children.count</code> {#reactchildrencount}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">count</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p>Gibt die Gesamtzahl der Komponenten in <code>children</code> zurück, und gleicht der Anzahl der Callbacks, die mit der <code>map</code>- oder <code>forEach</code>-Methode aufgerufen werden würden.</section><section id="reactchildrenonly-reactchildrenonly"class="level4"><h4><code>React.Children.only</code> {#reactchildrenonly}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">only</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p>Überprüft, ob <code>children</code> nur ein Kind (ein React-Element) hat und gibt es zurück. Ansonsten wirft diese Methode einen Fehler.<blockquote><p>Hinweis:<p><code>React.Children.only()</code> akzeptiert nicht den Rückgabewert von <a href="#reactchildrenmap"><code>React.Children.map()</code></a>, da dieser ein Array ist und kein React-Element.</blockquote></section><section id="reactchildrentoarray-reactchildrentoarray"class="level4"><h4><code>React.Children.toArray</code> {#reactchildrentoarray}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">toArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p>Gibt die eher undurchschaubare <code>children</code>-Datenstruktur als flaches Array zurück, wobei jedem Kind ein Key zugeordnet ist. Nützlich, falls in render-Methoden Kinder-Ansammlungen manipuliert werden sollen, insbesondere beim Umordnen oder Slicen von <code>this.props.children</code>, bevor diese weitergegeben werden.<blockquote><p>Hinweis:<p><code>React.Children.toArray()</code> ändert Keys, um die Semantik verschachtelter Arrays zu erhalten, während Listen von Kindern geflattet werden. Das bedeutet, dass <code>toArray</code> ein Präfix vor jeden Key des zurückgegebenen Arrays setzt, damit der Key jedes Elements dem Input-Array, dem es angehört, zugeordnet ist.</blockquote><hr></section></section><section id="reactfragment-reactfragment"class="level3"><h3><code>React.Fragment</code> {#reactfragment}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/Fragment"><code>Fragment</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><p>Die <code>React.Fragment</code>-Komponente erlaubt dir, mehrere Elemente in einer <code>render()</code>-Methode zurückzugeben, ohne ein zusätzliches DOM-Element zu kreieren:<pre class="language-javascript"><code class="language-javascript"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Fragment</span></span><span class="token operator">></span>
      <span class="token maybe-class-name">Irgendein</span> <span class="token maybe-class-name">Text</span><span class="token punctuation">.</span>
      <span class="token operator">&#x3C;</span>h2<span class="token operator">></span><span class="token maybe-class-name">Eine</span> Überschrift<span class="token operator">&#x3C;</span><span class="token operator">/</span>h2<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Fragment</span></span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Du kannst auch die Kurzschreibweise <code>&#x3C;>&#x3C;/></code> verwenden. Für mehr Informationen siehe <a href="/blog/2017/11/28/react-v16.2.0-fragment-support.html">React v16.2.0: Verbesserte Unterstützung für Fragmente</a>.<hr></section><section id="reactcreateref-reactcreateref"class="level3"><h3><code>React.createRef</code> {#reactcreateref}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/createRef"><code>createRef</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><p><code>React.createRef</code> erstellt eine <a href="./refs-and-the-dom.html">Referenz</a>, die über das <code>ref</code>-Attribut an React-Elemente angehängt werden kann. <code>embed:16-3-release-blog-post/create-ref-example.js</code><hr></section><section id="reactforwardref-reactforwardref"class="level3"><h3><code>React.forwardRef</code> {#reactforwardref}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/forwardRef"><code>forwardRef</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><p><code>React.forwardRef</code> erstellt eine React-Komponente, die das <a href="./refs-and-the-dom.html">ref</a>-Attribut, das sie erhält, an eine ihr in der Baumstruktur untergeordnete Komponente weitergibt. Diese Technik ist nicht sehr verbreitet, ist jedoch in zwei Fällen besonders nützlich:<ul><li><a href="./forwarding-refs.html#forwarding-refs-to-dom-components">Refs an DOM-Komponenten weitergeben</a><li><a href="./forwarding-refs.html#forwarding-refs-in-higher-order-components">Refs and Higher-Order-Komponenten weitergeben</a></ul><p><code>React.forwardRef</code> akzeptiert eine render-Funktion als Argument. React ruft diese Funktion mit den zwei Argumenten <code>props</code> und <code>ref</code> auf und sollte einen React-Knoten zurückgeben.<p><code>embed:reference-react-forward-ref.js</code><p>Im obigen Beispiel übergibt React eine <code>ref</code>, die dem <code>&#x3C;FancyButton ref={ref}></code>-Element gegeben wurde, als zweites Argument an die render-Funktion innerhalb des <code>React.forwardRef</code>-Aufrufs. Diese render-Funktion gibt die <code>ref</code> an das <code>&#x3C;button ref={ref}></code>-Element weiter.<p>Dadurch zeigt <code>ref.current</code> direkt auf die <code>&#x3C;button></code>-DOM-Element-Instanz, nachdem React die <code>ref</code> eingefügt hat.<p>Für mehr Informationen siehe <a href="./forwarding-refs.html">Refs weitergeben</a>.<hr></section><section id="reactlazy-reactlazy"class="level3"><h3><code>React.lazy</code> {#reactlazy}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/lazy"><code>lazy</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><p><code>React.lazy()</code> lässt dich eine Komponente definieren, die dynamisch geladen wird. Das hilft, die Bundlegröße zu reduzieren, indem das Laden von Komponenten, die im ursprünglichen Render nicht benutzt werden, verzögert wird.<p>In unserer <a href="./code-splitting.html#reactlazy">Code-Splitting-Dokumentation</a> kannst du lernen, wie es benutzt wird. Du kannst auch <a href="https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d">diesen Artikel</a> lesen, in dem die Verwendung im Detail erläutert wird.<pre class="language-js"><code class="language-js"><span class="token comment">// Diese Komponente wird dynamisch geladen</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">SomeComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./SomeComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Beachte, dass das Rendern von <code>lazy</code>-Komponenten ein <code>&#x3C;React.Suspense></code> weiter oben im Rendering-Baum benötigt. Damit wird ein Lade-Indikator bestimmt.<blockquote><p><strong>Hinweis</strong><p>Die Verwendung von <code>React.lazy</code> mit dynamischen Imports setzt voraus, dass in der JS-Umgebung <code>Promises</code> verfügbar sind. Hierzu braucht man ein Polyfill für IE11 und darunter.</blockquote><hr></section><section id="reactsuspense-reactsuspense"class="level3"><h3><code>React.Suspense</code> {#reactsuspense}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/Suspense"><code>Suspense</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><p><code>React.Suspense</code> lässt dich den Lade-Indikator bestimmen, der angezeigt wird, falls einige Komponenten weiter unten im Rendering-Baum noch nicht render-bereit sind. In the future we plan to let <code>Suspense</code> handle more scenarios such as data fetching. You can read about this in <a href="/blog/2018/11/27/react-16-roadmap.html">our roadmap</a>.<p>Momentan ist das Laden von <code>lazy</code>-Komponenten der <strong>einzige</strong> Anwendungsfall, den <code>&#x3C;React.Suspense></code> unterstützt:<pre class="language-js"><code class="language-js"><span class="token comment">// Diese Komponente wird dynamisch geladen</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">OtherComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./OtherComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token comment">// Zeigt &#x3C;Spinner>, bis OtherComponent geladen ist</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Suspense</span></span> fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Spinner</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
        <span class="token operator">&#x3C;</span><span class="token maybe-class-name">OtherComponent</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Suspense</span></span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Das ist in unserem <a href="./code-splitting.html#reactlazy">Code-Splitting-Guide</a> dokumentiert. Beachte, dass sich <code>lazy</code>-Komponenten tief im <code>Suspense</code>-Baum befinden können -- es muss nicht jede einzelne davon ummantelt werden. Es wird empfohlen, <code>&#x3C;Suspense></code> dort zu verwenden, wo ein Lade-Indikator angezeigt werden soll, und <code>lazy(</code>) dort zu verwenden, wo Code-Splitting stattfinden soll.<blockquote><p>Note<p>For content that is already shown to the user, switching back to a loading indicator can be disorienting. It is sometimes better to show the "old" UI while the new UI is being prepared. To do this, you can use the new transition APIs <a href="#starttransition"><code>startTransition</code></a> and <a href="./hooks-reference.html#usetransition"><code>useTransition</code></a> to mark updates as transitions and avoid unexpected fallbacks.</blockquote><section id="reactsuspense-in-server-side-rendering"class="level4"><h4><code>React.Suspense</code> in Server Side Rendering</h4><p>During server side rendering Suspense Boundaries allow you to flush your application in smaller chunks by suspending. When a component suspends we schedule a low priority task to render the closest Suspense boundary's fallback. If the component unsuspends before we flush the fallback then we send down the actual content and throw away the fallback.</section><section id="reactsuspense-during-hydration"class="level4"><h4><code>React.Suspense</code> during hydration</h4><p>Suspense boundaries depend on their parent boundaries being hydrated before they can hydrate, but they can hydrate independently from sibling boundaries. Events on a boundary before it is hydrated will cause the boundary to hydrate at a higher priority than neighboring boundaries. <a href="https://github.com/reactwg/react-18/discussions/130">Read more</a></section></section><section id="reactstarttransition-starttransition"class="level3"><h3><code>React.startTransition</code> {#starttransition}</h3><blockquote><p>Try the new React documentation for <a href="https://beta.reactjs.org/reference/react/startTransition"><code>startTransition</code></a>.<p>The new docs will soon replace this site, which will be archived. <a href="https://github.com/reactjs/reactjs.org/issues/3308">Provide feedback.</a></blockquote><pre class="language-js"><code class="language-js"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">startTransition</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span></code></pre><p><code>React.startTransition</code> lets you mark updates inside the provided callback as transitions. This method is designed to be used when <a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a> is not available.<blockquote><p>Note:<p>Updates in a transition yield to more urgent updates such as clicks.<p>Updates in a transition will not show a fallback for re-suspended content, allowing the user to continue interacting while rendering the update.<p><code>React.startTransition</code> does not provide an <code>isPending</code> flag. To track the pending status of a transition see <a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a>. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></blockquote></section></section></section>