<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8">
    <title>In React denken</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="in-react-denken" class="level1">
      <h1>In React denken</h1>
      <ul>
        <li>'blog/2013/11/05/thinking-in-react.html'</li>
        <li>'docs/thinking-in-react-zh-CN.html'</li>
      </ul>
      <p>React ist unserer Meinung nach der beste Weg, um große, schnelle Web-Anwendungen mit JavaScript zu erstellen. Es hat sich für uns bei Facebook und Instagram sehr gelohnt.</p>
      <p>Einer der vielen großartigen Teile von React ist, wie es dich zum Nachdenken über die Anwendungen bringt, während du sie erstellst. In diesem Dokument führen wir dich durch den Denkprozess, wie man eine durchsuchbare Produktdatentabelle mit React erstellt.</p>
      <section id="start-with-a-mock" class="level2">
        <h2>Beginne mit einem Mock-Up</h2>
        <p>Stell dir vor, dass wir bereits eine JSON API und ein Mock-Up unseres Designers haben. Das Mock-Up sieht so aus:</p>
        <figure>
          <img src="../images/blog/thinking-in-react-mock.png" alt="Mockup">
          <figcaption aria-hidden="true">Mockup</figcaption>
        </figure>
        <p>Unsere JSON API gibt uns Daten zurück, die folgendermaßen aussehen:</p>
        <pre class="language-text"><code class="language-text">[
];</code></pre>
      </section>
      <section id="step-1-break-the-ui-into-a-component-hierarchy" class="level2">
        <h2>Schritt 1: Zerlege die Benutzeroberfläche in eine Komponentenhierarchie</h2>
        <p>Zuerst solltest du um jede Komponente (und Unterkomponente) des Mock-Ups eine Box zeichnen und jeder einen Name geben. Falls du mit einem Designer zusammenarbeitest, hat er das vielleicht schon getan, also geh und frage ihn! Die Namen der Photoshop-Ebenen könnten letztendlich die Namen deiner React-Komponenten sein!</p>
        <p>Aber woher weißt du, was eine eigene Komponente sein sollte? Verwende einfach die gleichen Techniken, die du auch verwendest, um zu entscheiden, ob du eine neue Funktion oder ein neues Objekt anlegen möchtest. Eine dieser Techniken ist das<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Prinzip</a>, d.h. eine Komponente sollte idealerweise nur eine Aufgabe erledigen. Sobald sie wächst, sollte sie in kleinere Teilkomponenten zerlegt werden.</p>
        <p>Da du einem Benutzer häufig ein JSON Datenmodell präsentieren wirst, wirst du feststellen, dass, falls dein Datenmodell korrekt aufgebaut wurde, deine Benutzeroberfläche (und damit auch deine Komponentenstruktur) gut dazu zusammenpasst. Das liegt daran, dass Benutzeroberfläche und Datenmodell tendenziell der gleichen <em>Informationsarchitektur</em> folgen, was bedeutet, dass es oft trivial ist, deine Benutzeroberfläche in Komponenten aufzuteilen. Zerlege sie einfach in Komponenten, die genau ein Stück deines Datenmodells darstellen.</p>
        <figure>
          <img src="../images/blog/thinking-in-react-components.png" alt="Diagram welches verschachtelte Komponenten zeigt">
          <figcaption aria-hidden="true">Diagram welches verschachtelte Komponenten zeigt</figcaption>
        </figure>
        <p>Du siehst hier, dass wir fünf Komponenten in unserer einfachen Anwendung haben. Wir haben die Daten, die von jeder Komponente repräsentiert werden, kursiv dargestellt. Die Zahlen im Bild entsprechen den folgenden Zahlen.</p>
        <ol>
          <li><strong><code>FilterableProductTable</code> (orange):</strong> enthält das gesamte Beispiel</li>
          <li><strong><code>SearchBar</code> (blau):</strong> empfängt alle <em>Benutzereingaben</em></li>
          <li><strong><code>ProductTable</code> (grün):</strong> zeigt und filtert die <em>Daten</em> basierend auf <em>Benutzereingaben</em> an</li>
          <li><strong><code>ProductCategoryRow</code> (türkis):</strong> zeigt eine Überschrift für jede <em>Kategorie</em> an</li>
          <li><strong><code>ProductRow</code> (rot):</strong> zeigt eine Zeile für jedes <em>Produkt</em> an</li>
        </ol>
        <p>Wenn du dir <code>ProductTable</code> anschaust, wirst du feststellen, dass der Tabellenkopf (mit den Bezeichnungen "Name" und "Price") keine eigene Komponente ist. Das ist eine Frage der Präferenz und es gibt Argumente für beide Seiten. Für dieses Beispiel haben wir ihn als Teil von <code>ProductTable</code> gelassen, da er Teil der Darstellung der <em>Daten</em> ist, die in der Verantwortung von <code>ProductTable</code> liegt. Wenn diese Kopfzeile jedoch immer komplexer werden sollte (d.h. falls wir beispielsweise eine Sortierung hinzufügen würden), wäre es sicherlich sinnvoll, diese Kopfzeile zu einer eigenen <code>ProductTableHeader</code>-Komponente zu machen.</p>
        <p>Lass uns nachdem wir nun die Komponenten in unserem Mock-Up identifiziert haben, sie in eine Hierarchie einordnen. Das ist einfach. Komponenten, die innerhalb einer anderen Komponente im Mock-Up erscheinen, sollten als Kind in der Hierarchie erscheinen:</p>
        <ul>
          <li><code>FilterableProductTable</code>
            <ul>
              <li><code>SearchBar</code></li>
              <li><code>ProductTable</code>
                <ul>
                  <li><code>ProductCategoryRow</code></li>
                  <li><code>ProductRow</code></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </section>
      <section id="step-2-build-a-static-version-in-react" class="level2">
        <h2>Schritt 2: Erstelle eine statische Version in React</h2>
        <p data-height="600" data-theme-id="0" data-slug-hash="BwWzwm" data-default-tab="js" data-user="lacker" data-embed-version="2" class="codepen">See the Pen <a href="https://codepen.io/gaearon/pen/BwWzwm">Thinking In React: Step 2</a> on <a href="https://codepen.io">CodePen</a>.</p>
        <script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
        <p>Jetzt, da du deine Komponentenhierarchie hast, ist es an der Zeit, die Anwendung zu implementieren. Der einfachste Weg ist, eine Version zu erstellen, die dein Datenmodell verwendet und die Benutzeroberfläche rendert, aber keine Interaktivität hat. Es ist am besten, diese Prozesse zu entkoppeln, denn die Erstellung einer statischen Version erfordert viel Tippen und weniger Nachdenken, und das Hinzufügen von Interaktivität erfordert viel Nachdenken und weniger Tippen. Wir werden sehen, warum.</p>
        <p>Um eine statische Version deiner Anwendung zu erstellen, die dein Datenmodell rendert, solltest du Komponenten erstellen, die andere Komponenten wiederverwenden und Daten per <em>Props</em> weitergeben. <em>Props</em> sind eine Möglichkeit, Daten von Eltern zu Kind zu übertragen. Wenn du mit dem Konzept von <em>state</em> vertraut bist, verwende <strong>state hierfür noch nicht</strong>, um diese statische Version zu erstellen. State ist nur für Interaktivität reserviert, d.h. Daten, die sich im Laufe der Zeit ändern. Da es sich um eine statische Version der Anwendung handelt, benötigst du ihn nicht.</p>
        <p>Du kannst von oben nach unten (top-down) oder von unten nach oben (bottom-up) vorgehen. Das heißt, du kannst entweder mit dem Aufbau der Komponenten von oben in der Hierarchie beginnen (d.h. mit <code>FilterableProductTable</code>) oder mit denjenigen weiter unten (<code>ProductRow</code>). In simpleren Beispielen ist es in der Regel einfacher, von oben nach unten zu gehen, und bei größeren Projekten ist es einfacher, beim Erstellen von unten nach oben zu gehen und gleichzeitig Tests zu schreiben.</p>
        <p>Am Ende dieses Schrittes steht dir eine Ansammlung von wiederverwendbaren Komponenten zur Verfügung, die dein Datenmodell darstellt. Die Komponenten haben jeweils nur eine <code>render()</code> Methode, da es sich um eine statische Version deiner Anwendung handelt. Die Komponente an der Spitze der Hierarchie (<code>FilterableProductTable</code>) nimmt dein Datenmodell als Prop. Wenn du eine Änderung an deinem zugrunde liegenden Datenmodell vornimmst und <code>root.render()</code> erneut aufrufst, wird die Benutzeroberfläche aktualisiert. Es ist leicht zu erkennen, wie deine Benutzeroberfläche aktualisiert wird und wo Änderungen vorgenommen werden können, da nichts kompliziertes vor sich geht. React's <strong>One-Way-Data Flow</strong> (Daten fließen nur in eine Richtung) (auch <em>One-Way-Binding</em> genannt) hält alles modular und schnell.</p>
        <p>Wenn du Hilfe bei der Ausführung dieses Schrittes benötigst, schaue einfach in die <a href="./getting-started.html">React docs</a>.</p>
        <section id="a-brief-interlude-props-vs-state" class="level3">
          <h3>Ein kurzer Einschub: Props vs State</h3>
          <p>Es gibt zwei Arten von Daten(model) in React: Props und State. Es ist wichtig, den Unterschied zwischen den beiden zu verstehen; durchforste <a href="./state-and-lifecycle.html">die offiziellen React-Docs</a>, wenn du dir nicht sicher bist, was der Unterschied ist. Schaue auch ins <a href="./faq-state.html#what-is-the-difference-between-state-and-props">FAQ: Was ist der Unterschied zwischen State und Props?</a></p>
        </section>
      </section>
      <section id="step-3-identify-the-minimal-but-complete-representation-of-ui-state" class="level2">
        <h2>Schritt 3: Identifiziere die minimale (aber vollständige) Darstellung des Zustandes der Benutzeroberfläche</h2>
        <p>Um deine Benutzeroberfläche interaktiv zu machen, musst du in der Lage sein, Änderungen an deinem zugrunde liegenden Datenmodell auszulösen. React macht dies mit <strong>state</strong> einfach.</p>
        <p>Um deine Anwendung korrekt zu erstellen, musst du zunächst an den minimalen Satz von veränderbaren <strong>states</strong> denken, die deine Anwendung benötigt. Der Schlüssel dazu ist<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY: <em>Don't Repeat Yourself</em></a>. Finde die absolut minimale Darstellung des <strong>states</strong>, den deine Anwendung benötigt und berechne bei Bedarf alles andere, was du benötigst. Wenn du beispielsweise eine TODO-Liste erstellst, nutze einfach einen Array für die TODO-Elemente; nutze keine separate <strong>state</strong>-Variable für die Anzahl der Elemente. Möchtest du die Anzahl an TODO-Elementen darstellen, nimm einfach die Länge des TODO-Arrays.</p>
        <p>Denke an alle Daten in unserer Beispielanwendung. Wir haben:</p>
        <ul>
          <li>die ursprüngliche Liste der Produkte</li>
          <li>den vom Benutzer eingegebenen Suchtext</li>
          <li>der Wert des Auswahlfeldes</li>
          <li>die gefilterte Liste der Produkte</li>
        </ul>
        <p>Lass uns jeden einzelnen Punkt durchgehen und herausfinden, welcher davon <strong>state</strong> ist. Stelle einfach drei Fragen zu jedem Datenelement:</p>
        <ol>
          <li>Wird es von einem Elternteil über <strong>props</strong> weitergegeben? Wenn ja, dann ist es wahrscheinlich kein <strong>state</strong>.</li>
          <li>Bleibt es im Laufe der Zeit unverändert? Wenn ja, dann ist es wahrscheinlich kein <strong>state</strong>.</li>
          <li>Kann es basierend auf einem anderen <strong>state</strong> oder <strong>props</strong> berechnet werden? Wenn ja, dann ist es kein <strong>state</strong>.</li>
        </ol>
        <p>Die ursprüngliche Liste der Produkte wird als <strong>props</strong> übergeben, also ist dies kein <strong>state</strong>. Der Suchtext und das Auswahlfeld scheinen <strong>state</strong> zu sein, da sie sich im Laufe der Zeit ändern und aus nichts berechnet werden können. Und schließlich ist die gefilterte Liste der Produkte kein <strong>state</strong>, da sie berechnet werden kann, indem man die ursprüngliche Liste der Produkte mit dem Suchtext und dem Wert des Auswahlfeldes kombiniert.</p>
        <p>Letztendlich sieht unser <strong>state</strong> folgendermaßen aus:</p>
        <ul>
          <li>der vom Benutzer eingegebene Suchtext</li>
          <li>der Wert des Auswahlfeldes</li>
        </ul>
      </section>
      <section id="step-4-identify-where-your-state-should-live" class="level2">
        <h2>Schritt 4: Identifiziere, wo dein <strong>state</strong> leben soll</h2>
        <p data-height="600" data-theme-id="0" data-slug-hash="qPrNQZ" data-default-tab="js" data-user="lacker" data-embed-version="2" class="codepen">Schau dir <a href="https://codepen.io/gaearon/pen/qPrNQZ">In React denken: Schritt 4</a> auf <a href="https://codepen.io">CodePen</a> an.</p>
        <p>OK, wir haben also herausgefunden, was die minimalste Menge des <strong>state</strong>s der Anwendung ist. Als Nächstes müssen wir herausfinden, welche Komponente diesen <strong>state</strong> verändert oder <em>besitzt</em>.</p>
        <p>Denk daran: Bei React geht es um den einseitigen Datenfluss (One-Way-Data Flow) entlang der Komponentenhierarchie. Es ist möglicherweise nicht sofort klar, welche Komponente welchen <strong>state</strong> besitzen soll. <strong>Dies ist oft der am schwierigsten zu verstehende Teil für Neueinsteiger, </strong>also folge diesen Schritten, um es herauszufinden:</p>
        <p>Für jedes Stück <strong>state</strong> in deiner Anwendung:</p>
        <ul>
          <li>Identifiziere jede Komponente, die etwas rendert, das auf diesem <strong>state</strong> basiert.</li>
          <li>Suche eine gemeinsame "Eigentümer"-Komponente (eine einzelne Komponente, die oberhalb der untersuchten Komponenten liegt, die den <strong>state</strong> benötigen).</li>
          <li>Entweder der gemeinsame Eigentümer oder eine andere Komponente, die in der Hierarchie oberhalb liegt, sollte den <strong>state</strong> besitzen.</li>
          <li>Kannst du keine Komponente finden, für die es sinnvoll ist, den <strong>state</strong> zu besitzen, erstelle eine neue Komponente, nur um den <strong>state</strong> zu halten, und füge sie irgendwo in der Hierarchie über der gemeinsamen Eigentümer-Komponente hinzu.</li>
        </ul>
        <p>Lass uns diese Strategie für unsere Anwendung durchgehen:</p>
        <ul>
          <li><code>ProductTable</code> muss die Produktliste basierend auf <strong>state</strong> filtern und <code>SearchBar</code> muss den Suchtext und den Zustand des Auswahlfeldes anzeigen.</li>
          <li>Die gemeinsame Eigentümer-Komponente ist <code>FilterableProductTable</code>.</li>
          <li>Es ist konzeptionell sinnvoll, dass der Filtertext und der Zustand des Auswahlfeldes in <code>FilterableProductTable</code> leben.</li>
        </ul>
        <p>Cool, wir haben uns also dazu entschieden, dass unser <strong>state</strong> in <code>FilterableProductTable</code> lebene wird. Füge zuerst <code>this.state = {filterText: '', inStockOnly: false}</code> zu <code>FilterableProductTable</code>'s <code>constructor</code> hinzu, um den initialen <strong>state</strong> (initial state) deiner Anwendung darzustellen. Sende dann <code>filterText</code> und <code>inStockOnly</code> zu <code>ProductTable</code> und <code>SearchBar</code> als <strong>prop</strong>. Verwende schließlich diese <strong>props</strong>, um die Zeilen in <code>ProductTable</code> zu filtern und die Werte der Formularfelder in <code>SearchBar</code> einzustellen.</p>
        <p>Du wirst sehen können, wie sich deine Anwendung verhalten wird: Setze <code>filterText</code> auf <code>"ball"</code> und aktualisiere deine Anwendung. Du wirst sehen, dass die Tabelle korrekt aktualisiert wurde.</p>
      </section>
      <section id="step-5-add-inverse-data-flow" class="level2">
        <h2>Schritt 5: Füge inversen Datenfluss hinzu</h2>
        <p data-height="600" data-theme-id="0" data-slug-hash="LzWZvb" data-default-tab="js,result" data-user="rohan10" data-embed-version="2" data-pen-title="Thinking In React: Step 5" class="codepen">Schau dir <a href="https://codepen.io/gaearon/pen/LzWZvb">In React denken: Schritt 4</a> auf <a href="https://codepen.io">CodePen</a> an.</p>
        <p>Bisher haben wir eine Anwendung entwickelt, die in Abhängigkeit von <strong>props</strong> und <strong>state</strong>, die in der Hierarchie nach unten fließen, korrekt gerendert wird. Jetzt ist es an der Zeit, den Datenfluss in die andere Richtung zu unterstützen: Die Formular-Komponenten tief in der Hierarchie müssen den <strong>state</strong> in <code>FilterableProductTable</code> aktualisieren.</p>
        <p>React macht diesen Datenfluss explizit, um es leicht verständlich zu machen, wie dein Programm funktioniert, aber es erfordert ein wenig mehr Tippen als herkömmliches <strong>Two-Way-Binding</strong> (Daten fließen in beide Richtungen).</p>
        <p>Wenn du versuchst, das Kästchen in der vorherigen Version des Beispiels (Schritt 4) einzugeben oder zu markieren, wirst du sehen, dass React deine Eingabe ignoriert. Dies ist beabsichtigt, da wir das <code>value</code>-Prop des <code>input</code> so eingestellt haben, dass es immer gleich dem <code>state</code> ist, der von <code>filterableProductTable</code> übergeben wurde.</p>
        <p>Lass uns darüber nachdenken, was wir erreichen wollen. Wir möchten sicherstellen, dass wir bei jeder Änderung des Formulars durch den Benutzer den <strong>states</strong> aktualisieren, um die Benutzereingaben widerzuspiegeln. Da Komponenten nur ihren eigenen <strong>state</strong> aktualisieren sollten, leitet <code>FilterableProductTable</code> Callbacks an <code>SearchBar</code> weiter, die ausgelöst werden, wenn <strong>state</strong> aktualisiert werden soll. Wir können den <code>onChange</code> Event auf die Eingabefelder anwenden, um darüber informiert zu werden. Die von <code>FilterableProductTable</code> übergebenen Callbacks rufen <code>setState()</code> auf und die Anwendung wird aktualisiert.</p>
        <p>Obwohl das komplex klingt, handelt es sich eigentlich nur um ein paar Zeilen Code. Und es ist sehr explizit dargestellt, wie deine Daten in der Anwendung fließen.</p>
      </section>
      <section id="and-thats-it" class="level2">
        <h2>Und das war's dann auch schon</h2>
        <p>
          Hoffentlich gibt dies dir eine Vorstellung davon, wie du mit React über die Entwicklung von Komponenten und Anwendungen nachdenken kannst. Auch wenn es ein wenig mehr Tippen sein kann, als du es gewohnt bist, denk daran, dass Code viel mehr gelesen als geschrieben wird, und es extrem einfach ist, diesen modularen, expliziten Code zu lesen. Wenn du beginnst, große Bibliotheken von Komponenten zu erstellen, dann wirst du diese Explizität und Modularität zu schätzen wissen und mit der Wiederverwendung von Code wird die Anzahl deiner Codezeilen schrumpfen. :)
          <span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span>
        </p>
      </section>
    </section>
  </body>
</html>
