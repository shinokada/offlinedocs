<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>コンポーネントの state</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="コンポーネントの-state" class="level1">
      <h1>コンポーネントの state</h1>
      <section id="what-does-setstate-do" class="level3">
        <h3><code>setState</code> は何をしているのですか？</h3>
        <p><code>setState()</code> はコンポーネントの <code>state</code> オブジェクト更新をスケジュールします。state が更新されると、コンポーネントはそれに再レンダーで応じます。</p>
      </section>
      <section id="what-is-the-difference-between-state-and-props" class="level3">
        <h3><code>state</code> と <code>props</code> の違いは何ですか？</h3>
        <p><a href="./components-and-props.html"><code>props</code></a>（"properties" を短くしたもの）と <a href="./state-and-lifecycle.html"><code>state</code></a> は、両方ともプレーンな JavaScript のオブジェクトです。どちらもレンダー結果に影響を及ぼす情報を持ってはいますが、ある重要な一点が異なっています。つまり、<code>props</code> は（関数引数のように）コンポーネント<em>へ</em>渡されるのに対し、<code>state</code> は（関数内で宣言された変数のように）コンポーネント<em>の内部</em>で制御されます。</p>
        <p><code>props</code> と <code>state</code> のどちらをいつ使うべきかについて、こちらでより詳しく読むことができます。</p>
        <ul>
          <li><a href="https://github.com/uberVU/react-guide/blob/master/props-vs-state.md">Props vs State</a></li>
          <li><a href="https://lucybain.com/blog/2016/react-state-vs-pros/">ReactJS: Props vs. State</a></li>
        </ul>
      </section>
      <section id="why-is-setstate-giving-me-the-wrong-value" class="level3">
        <h3><code>setState</code> が誤った値を返すのはなぜですか？</h3>
        <p>React では、<code>this.props</code> と <code>this.state</code> のいずれも、<em>レンダーされた</em>もの、つまりスクリーン上の値を表しています。</p>
        <p><code>setState</code> 呼び出しは非同期です。呼び出し直後から <code>this.state</code> が新しい値を反映することを期待しないでください。もし現在の state に基づいた値を計算する必要がある場合は、オブジェクトの代わりに更新関数を渡してください（詳しくは以下を参照）。</p>
        <p>このコード例は期待した通りには<em>動きません</em>。</p>
        <pre class="language-jsx"><code class="language-jsx"><span class="token function">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 補足：これは意図通りに*動きません*</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">handleSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// `this.state.count` は 0 から始まるとします。</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// React がコンポーネントを再レンダーしても、`this.state.count` は意図通りの 3 ではなく 1 になります。</span>

  <span class="token comment">// これは、上記の `incrementCount()` 関数は `this.state.count` の値を読むのですが、</span>
  <span class="token comment">// しかしコンポーネントが再レンダーされるまで React が `this.state.count` を更新しないためです。</span>
  <span class="token comment">// そして `incrementCount()` は値が 0 のままの `this.state.count` を毎回読み、そして 1 をセットしてしまいます。</span>

  <span class="token comment">// 対処法は下で説明していますよ！</span>
<span class="token punctuation">}</span></code></pre>
        <p>この問題を解決するには以下を見てください。</p>
      </section>
      <section id="how-do-i-update-state-with-values-that-depend-on-the-current-state" class="level3">
        <h3>どうやって現在の state に依存する値を更新したらいいですか？</h3>
        <p><code>setState</code> へオブジェクトを渡す代わりに関数を渡してください。その関数は常に最新の状態の state を使って呼ばれることが保証されています（次項参照）。</p>
      </section>
      <section id="what-is-the-difference-between-passing-an-object-or-a-function-in-setstate" class="level3">
        <h3><code>setState</code> へオブジェクトを渡すのと関数を渡すのとのでは何が違いますか？</h3>
        <p>更新関数を渡すと、その関数内で現在の state の値へアクセスできるようになります。<code>setState</code> 呼び出しはバッチ処理されるため、更新処理を連結して、それぞれの更新が競合せずに順序だって動作することが保証されます。</p>
        <pre class="language-jsx"><code class="language-jsx"><span class="token function">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// 重要：更新には `this.state` ではなく `state` を使います。</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">handleSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// `this.state.count` は 0 から始まるとします。</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ここで `this.state.count` を読んでもまだ 0 のままです。</span>
  <span class="token comment">// しかし React がコンポーネントを再レンダーするとき、値は 3 になります。</span>
<span class="token punctuation">}</span></code></pre>
        <p><a href="./react-component.html#setstate">setState についてもっと学ぶ</a></p>
      </section>
      <section id="when-is-setstate-asynchronous" class="level3">
        <h3>いつ <code>setState</code> は非同期になりますか？</h3>
        <p>現在、<code>setState</code> はイベントハンドラの内側では非同期です。</p>
        <p>例えばクリックイベントの間に <code>Parent</code> と <code>Child</code> の両方が <code>setState</code> を呼ぶとき、非同期処理のおかげで <code>Child</code> が 2 度レンダーされないことが保証されます。その代わりに React はブラウザイベントの最後に state の更新を「フラッシュ (flush)」します。これにより大規模アプリのパフォーマンスが大幅に向上します。</p>
        <p>これは実装の詳細ですので、この仕組みに直接依存しないようにしてください。将来のバージョンにおいて、React はより多くの場合にバッチ更新するようになります。</p>
      </section>
      <section id="why-doesnt-react-update-thisstate-synchronously" class="level3">
        <h3>どうして React は <code>this.state</code> を同期的に更新しないのですか？</h3>
        <p>前項で説明したように、全てのコンポーネントがそのイベントハンドラ内で <code>setState()</code> を呼ぶまで、React は再レンダー前に意図的に「待つ」ようになっています。これにより不必要な再レンダーが防がれ、パフォーマンスが向上します。</p>
        <p>とはいえ、React がどうして再レンダーなしに <code>this.state</code> を即時更新しないのか、まだ疑問に思っているかもしれません。</p>
        <p>これには主に 2 つの理由があります。</p>
        <ul>
          <li>同期的更新が <code>props</code> と <code>state</code> の間の一貫性を破壊し、非常にデバッグが難しい問題を引き起こしうるため。</li>
          <li>同期的更新が、我々が取り組んでいる新機能のいくつかを実装不可能にしうるため。</li>
        </ul>
        <p>この <a href="https://github.com/facebook/react/issues/11527#issuecomment-360199710">GitHub コメント</a>は特定の例について詳しく解説しています。</p>
      </section>
      <section id="should-i-use-a-state-management-library-like-redux-or-mobx" class="level3">
        <h3>Redux や MobX のような state 管理ライブラリを使うべきでしょうか？</h3>
        <p><a href="https://redux.js.org/faq/general#when-should-i-use-redux">時には必要かもしれません。</a></p>
        <p>
          まずは他のライブラリを追加する前に React を理解することをお勧めします。React だけでも非常に複雑なアプリケーションを作り上げることができます。
          <span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span>
        </p>
      </section>
    </section>
  </body>
</html>
