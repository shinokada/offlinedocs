<!doctype html><html lang="ja"><meta charset="utf-8"><title>useInsertionEffect</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="useinsertioneffect"><h1 id="useinsertioneffect">useInsertionEffect</h1><pitfall><p><code>useInsertionEffect</code> は CSS-in-JS ライブラリの作者向けです。CSS-in-JS ライブラリの開発をしておりスタイルを挿入する場所を必要としているのでない限り、おそらく <a href="/reference/react/useEffect"><code>useEffect</code></a> または <a href="/reference/react/useLayoutEffect"><code>useLayoutEffect</code></a> の方が適切です。</p></pitfall><intro><p><code>useInsertionEffect</code> はレイアウトエフェクトが発火する前に DOM に要素を挿入するために使用します。<pre class="language-js"><code class="language-js"><span class="token function">useInsertionEffect</span><span class="token punctuation">(</span>setup<span class="token punctuation">,</span> dependencies<span class="token operator">?</span><span class="token punctuation">)</span></code></pre></intro><inlinetoc><section class="level2"aria-labelledby="リファレンス-reference"><h2 id="リファレンス-reference">リファレンス {/<em>reference</em>/}</h2><section class="level3"aria-labelledby="useinsertioneffectsetup-dependencies-useinsertioneffect"><h3 id="useinsertioneffectsetup-dependencies-useinsertioneffect"><code>useInsertionEffect(setup, dependencies?)</code> {/<em>useinsertioneffect</em>/}</h3><p><code>useInsertionEffect</code> を呼び出して、レイアウトを読み取る可能性があるエフェクトが実行される前にスタイルの挿入を行います。<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> useInsertionEffect <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token comment">// Inside your CSS-in-JS library</span>
<span class="token keyword">function</span> <span class="token function">useCSS</span><span class="token punctuation">(</span><span class="token parameter">rule</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useInsertionEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// ... inject &#x3C;style> tags here ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> rule<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><a href="#usage">さらに例を見る</a><section class="level4"aria-labelledby="引数-parameters"><h4 id="引数-parameters">引数 {/<em>parameters</em>/}</h4><ul><li><p><code>setup</code>: エフェクトのロジックが記述された関数です。このセットアップ関数は、オプションで<em>クリーンアップ</em>関数を返すことができます。コンポーネントが初めて DOM に追加された後、レイアウトエフェクトが発火する前に、React はセットアップ関数を実行します。依存配列 (dependencies) が変更された再レンダー時には、React はまず古い値を使ってクリーンアップ関数（あれば）を実行し、次に新しい値を使ってセットアップ関数を実行します。コンポーネントが DOM から削除された後、React はクリーンアップ関数を最後にもう一度実行します。<li><p><strong>省略可能</strong> <code>dependencies</code>: <code>setup</code> コード内で参照されるすべてのリアクティブな値のリストです。リアクティブな値には、props、state、コンポーネント本体に直接宣言されたすべての変数および関数が含まれます。リンタが <a href="/learn/editor-setup#linting">React 用に設定されている場合</a>、すべてのリアクティブな値が依存値として正しく指定されているか確認できます。依存値のリストは要素数が一定である必要があり、<code>[dep1, dep2, dep3]</code> のようにインラインで記述する必要があります。React は、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is</code></a> を使った比較で、それぞれの依存値を以前の値と比較します。この引数を省略すると、エフェクトはコンポーネントの毎回のレンダー後に再実行されます。</ul></section><section class="level4"aria-labelledby="返り値-returns"><h4 id="返り値-returns">返り値 {/<em>returns</em>/}</h4><p><code>useInsertionEffect</code> は <code>undefined</code> を返します。</section><section class="level4"aria-labelledby="注意点-caveats"><h4 id="注意点-caveats">注意点 {/<em>caveats</em>/}</h4><ul><li>エフェクトはクライアント上でのみ実行されます。サーバレンダリング中には実行されません。<li><code>useInsertionEffect</code> の内部から state を更新することはできません。<li><code>useInsertionEffect</code> が実行される時点では、まだ ref はアタッチされていません。<li><code>useInsertionEffect</code> は DOM の更新前に実行される場合も後に実行される場合もあります。タイミングに関わらず、DOM が更新されていることを前提としてはいけません。<li>他の種類のエフェクトはすべてのエフェクトにクリーンアップを実行してからすべてのエフェクトにセットアップを行います。一方で <code>useInsertionEffect</code> はコンポーネントごとにクリーンアップとセットアップをまとめて行います。結果的にクリーンアップとセットアップが「交互に実行される」ような挙動になります。</ul></section></section></section><section class="level2"aria-labelledby="使用法-usage"><h2 id="使用法-usage">使用法 {/<em>usage</em>/}</h2><section class="level3"aria-labelledby="css-in-js-ライブラリからの動的スタイル注入-injecting-dynamic-styles-from-css-in-js-libraries"><h3 id="css-in-js-ライブラリからの動的スタイル注入-injecting-dynamic-styles-from-css-in-js-libraries">CSS-in-JS ライブラリからの動的スタイル注入 {/<em>injecting-dynamic-styles-from-css-in-js-libraries</em>/}</h3><p>従来、React コンポーネントのスタイル付けはプレーンな CSS を使用して行われていました。<pre class="language-js"><code class="language-js"><span class="token comment">// In your JS file:</span>
<span class="token operator">&#x3C;</span>button className<span class="token operator">=</span><span class="token string">"success"</span> <span class="token operator">/</span><span class="token operator">></span>

<span class="token comment">// In your CSS file:</span>
<span class="token punctuation">.</span><span class="token property-access">success</span> <span class="token punctuation">{</span> <span class="token literal-property property">color</span><span class="token operator">:</span> green<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>チームによっては、CSS ファイルを書く代わりに JavaScript コード内で直接スタイルを記述することを好む場合があります。これには通常、CSS-in-JS ライブラリやツールが必要です。CSS-in-JS には以下の 3 つの一般的なアプローチがあります。<ol><li>コンパイラを使用した CSS ファイルへの静的な抽出<li>インラインスタイル、例えば <code>&#x3C;div style={{ opacity: 1 }}></code><li><code>&#x3C;style></code> タグのランタイム時の注入</ol><p>CSS-in-JS を使用する場合、最初の 2 つのアプローチの組み合わせ（静的スタイルには CSS ファイル、動的スタイルにはインラインスタイル）を推奨します。<strong>ランタイム時の <code>&#x3C;style></code> タグの注入は、以下の 2 つの理由から推奨しません：</strong><ol><li>ランタイム時の注入は、ブラウザにスタイルの再計算を頻繁に強制します。<li>ランタイム時の注入は、React ライフサイクル中の間違ったタイミングで行われると非常に遅くなることがあります。</ol><p>このうち最初の問題は解決不可能ですが、<code>useInsertionEffect</code> は 2 つ目の問題を解決するのに役立ちます。<p>レイアウトエフェクトの発火前にスタイルを挿入するために <code>useInsertionEffect</code> を呼び出しましょう。<pre class="language-js"><code class="language-js"><span class="token comment">// Inside your CSS-in-JS library</span>
<span class="token keyword">let</span> isInserted <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">useCSS</span><span class="token punctuation">(</span><span class="token parameter">rule</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useInsertionEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// As explained earlier, we don't recommend runtime injection of &#x3C;style> tags.</span>
    <span class="token comment">// But if you have to do it, then it's important to do in useInsertionEffect.</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isInserted<span class="token punctuation">.</span><span class="token method function property-access">has</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isInserted<span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">head</span><span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span><span class="token function">getStyleForRule</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> rule<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Button</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> className <span class="token operator">=</span> <span class="token function">useCSS</span><span class="token punctuation">(</span><span class="token string">'...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>div className<span class="token operator">=</span><span class="token punctuation">{</span>className<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><code>useEffect</code> と同様に、<code>useInsertionEffect</code> はサーバ上では実行されません。サーバ上でどの CSS ルールが使用されたかを収集する必要がある場合、レンダー中に行うことができます。<pre class="language-js"><code class="language-js"><span class="token keyword">let</span> collectedRulesSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">useCSS</span><span class="token punctuation">(</span><span class="token parameter">rule</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token dom variable">window</span> <span class="token operator">===</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    collectedRulesSet<span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">useInsertionEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> rule<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><a href="https://github.com/reactwg/react-18/discussions/110"><code>useInsertionEffect</code> でランタイム時にスタイルを注入するよう CSS-in-JS ライブラリをアップグレードする場合の詳細</a></p><deepdive><section class="level4"aria-labelledby="この手法がレンダー中や-uselayouteffect-でスタイルを注入するより優れている理由-how-is-this-better-than-injecting-styles-during-rendering-or-uselayouteffect"><h4 id="この手法がレンダー中や-uselayouteffect-でスタイルを注入するより優れている理由-how-is-this-better-than-injecting-styles-during-rendering-or-uselayouteffect">この手法がレンダー中や useLayoutEffect でスタイルを注入するより優れている理由 {/<em>how-is-this-better-than-injecting-styles-during-rendering-or-uselayouteffect</em>/}</h4><p>レンダー中、React が<a href="/reference/react/useTransition#marking-a-state-update-as-a-non-blocking-transition">非ブロッキング更新</a>を処理している最中にスタイルを挿入すると、ブラウザはコンポーネントツリーのレンダー中に毎フレームスタイルを再計算することになり、これは<strong>非常に遅くなる</strong>ことがあります。<p><code>useInsertionEffect</code> は、<a href="/reference/react/useLayoutEffect"><code>useLayoutEffect</code></a> や <a href="/reference/react/useEffect"><code>useEffect</code></a> でスタイルを挿入するよりも優れています。なぜなら、他のエフェクトがあなたのコンポーネントで実行される時点で <code>&#x3C;style></code> タグがすでに挿入されていることが保証されるからです。さもないと、古くなったスタイルにより、通常のエフェクトでのレイアウト計算が正しくなくなってしまいます。</p><span style="float:footnote"><a href="../../index.html#toc">Go to TOC</a></span></section></deepdive></section></section></inlinetoc></section>