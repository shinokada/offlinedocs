<!doctype html><html lang="ja"><meta charset="utf-8"><title>React のルール</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"type="text/css"href="../../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="react-のルール"><h1 id="react-のルール">React のルール</h1><intro>様々な概念を表現する方法がプログラミング言語によってそれぞれ異なるように、React にも、理解しやすい方法でパターンを表現し高品質なアプリケーションを産み出すための慣用的な記法、ないしルールが存在します。</intro><inlinetoc><note>React で UI を表現する方法についてさらに学びたい場合は、[React の流儀](/learn/thinking-in-react)を読むことをお勧めします。</note><p>このセクションでは、自然な React コードを書くために従うべきルールを説明します。自然な React コードを書くことで、安全で整理されており、組み合わせ可能なアプリケーションを作成することができます。以下に挙げる特性により、アプリは変更に対して頑健になり、他の開発者やライブラリやツールと連携しやすくなります。<p>以下のルールは <strong>React のルール</strong>として知られています。これらを守っていないならアプリにバグがある可能性が高い、という意味で、これらは単なるガイドラインではなくルールです。またこれらを守らない場合、あなたのコードは不自然で、理解や推測が難しいものになるでしょう。<p>React のルールを守るため、React の <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">ESLint プラグイン</a> と <a href="/reference/react/StrictMode">Strict Mode</a> を併用して利用することを強くお勧めします。React のルールに従うことにより、バグを見つけて対処し、アプリケーションを保守可能に保つことができます。<section class="level2"aria-labelledby="コンポーネントとフックを純粋に保つ-components-and-hooks-must-be-pure"><h2 id="コンポーネントとフックを純粋に保つ-components-and-hooks-must-be-pure">コンポーネントとフックを純粋に保つ {/<em>components-and-hooks-must-be-pure</em>/}</h2><p><a href="/reference/rules/components-and-hooks-must-be-pure">コンポーネントとフックを純粋に保つこと</a>は、アプリを予測可能にし、デバッグしやすくし、React がコードを自動的に最適化できるようにするための、React の重要なルールです。<ul><li><a href="/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent">コンポーネントとフックを冪等にする</a> - React コンポーネントは、入力（props、state、およびコンテクスト）に対して常に同じ出力を返すことが前提となっています。<li><a href="/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render">副作用はレンダーの外で実行する</a> - 副作用はレンダー内で実行するべきではありません。React は最適なユーザ体験を実現するために複数回コンポーネントをレンダーすることがあるからです。<li><a href="/reference/rules/components-and-hooks-must-be-pure#props-and-state-are-immutable">props と state はイミュータブル</a> - コンポーネントの props と state は、単一のレンダー内においては不変のスナップショットです。直接書き換えてはいけません。<li><a href="/reference/rules/components-and-hooks-must-be-pure#return-values-and-arguments-to-hooks-are-immutable">フックの引数と返り値はイミュータブル</a> - 一度フックに値を渡したならそれを書き換えてはいけません。JSX の props と同様、フックに渡された値はイミュータブルになります。<li><a href="/reference/rules/components-and-hooks-must-be-pure#values-are-immutable-after-being-passed-to-jsx">JSX に渡された後の値はイミュータブル</a> - JSX で使用した後に値を書き換えてはいけません。書き換えのロジックは JSX を作成する前に行います。</ul></section><section class="level2"aria-labelledby="コンポーネントやフックを呼び出すのは-react-react-calls-components-and-hooks"><h2 id="コンポーネントやフックを呼び出すのは-react-react-calls-components-and-hooks">コンポーネントやフックを呼び出すのは React {/<em>react-calls-components-and-hooks</em>/}</h2><p><a href="/reference/rules/react-calls-components-and-hooks">ユーザ体験を最適化するために必要に応じてコンポーネントやフックを呼び出すというのは React 自身の責務です</a>。React は宣言型 (declarative) です。あなたは何 (what) をレンダーしたいのかだけを React に伝え、それをどうやって (how) ユーザにうまく表示するのかについては React が考えます。<ul><li><a href="/reference/rules/react-calls-components-and-hooks#never-call-component-functions-directly">コンポーネント関数を直接呼び出さない</a> – コンポーネントは JSX 内でのみ使用します。通常の関数として呼び出してはいけません。<li><a href="/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values">フックを通常の値として取り回さない</a> – フックはコンポーネント内で呼び出すだけにします。通常の値のようにコード内で取り回してはいけません。</ul></section><section class="level2"aria-labelledby="フックのルール-rules-of-hooks"><h2 id="フックのルール-rules-of-hooks">フックのルール {/<em>rules-of-hooks</em>/}</h2><p>フックは再利用可能な UI ロジックを表す JavaScript の関数として定義されており、呼び出せる場所に関する制約があります。フックを使用する際には、<a href="/reference/rules/rules-of-hooks">フックのルール</a>に従う必要があります。<ul><li><a href="/reference/rules/rules-of-hooks#only-call-hooks-at-the-top-level">フックはトップレベルでのみ呼び出す</a> – ループ、条件分岐、ネストされた関数の内部でフックを呼び出してはいけません。代わりに、フックは常に React 関数のトップレベルで、早期 return を行う前に行います。<li><a href="/reference/rules/rules-of-hooks#only-call-hooks-from-react-functions">フックは React の関数からのみ呼び出す</a> – 通常の JavaScript 関数からフックを呼び出してはいけません。</ul><p><span style="float:footnote"><a href="../../index.html#toc">Go to TOC</a></span></section></inlinetoc></section>