<!doctype html><html lang="ja"><meta charset="utf-8"><title>コンポーネントやフックを呼び出すのは React</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"type="text/css"href="../../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="コンポーネントやフックを呼び出すのは-react"><h1 id="コンポーネントやフックを呼び出すのは-react">コンポーネントやフックを呼び出すのは React</h1><intro>ユーザ体験を最適化するために必要に応じてコンポーネントやフックを呼び出すというのは React 自身の責務です。React は宣言型 (declarative) です。あなたは*何 (what)* をレンダーしたいのかだけを React に伝え、それを*どうやって (how)* ユーザにうまく表示するのかについては React が考えます。</intro><inlinetoc><section class="level2"aria-labelledby="コンポーネント関数を直接呼び出さない-never-call-component-functions-directly"><h2 id="コンポーネント関数を直接呼び出さない-never-call-component-functions-directly">コンポーネント関数を直接呼び出さない {/<em>never-call-component-functions-directly</em>/}</h2><p>コンポーネントは JSX 内でのみ使用すべきです。通常の関数として呼び出してはいけません。呼び出すのは React です。<p><a href="/reference/rules/components-and-hooks-must-be-pure#how-does-react-run-your-code">レンダー中</a>にコンポーネント関数をいつ呼び出すかを決定する必要があるのは React です。React では、これを JSX を使用して行います。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">BlogPost</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Layout</span><span class="token operator">></span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Article</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Layout</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// ✅ Good: Only use components in JSX</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">BlogPost</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Layout</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token function"><span class="token maybe-class-name">Article</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Layout</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// 🔴 Bad: Never call them directly</span>
<span class="token punctuation">}</span></code></pre><p>コンポーネントにフックが含まれている場合、ループや条件内でコンポーネントを直接呼び出すと、<a href="/reference/rules/rules-of-hooks">フックのルール</a>にいとも簡単に違反してしまいます。<p>React にレンダーの指揮権を与えることで、多くの利点が得られます。<ul><li><strong>コンポーネントが単なる関数以上のものになる</strong>。ツリー内のコンポーネントの同一性に基づいた処理を行うフックを通じて、React は<em>ローカル state</em> などの機能を追加できます。<li><strong>コンポーネントの型情報を差分検出処理時に利用できる</strong>。React にコンポーネントの呼び出しを任せることで、ツリーの概念的構造について React はより多くの情報を得られます。たとえば <code>&#x3C;Feed></code> から <code>&#x3C;Profile></code> ページへとレンダーが移行するとき、React はそれらを再利用しようとせずに済みます。<li><strong>React がユーザ体験を向上させられる</strong>。たとえば、大きなコンポーネントツリーの再レンダーがメインスレッドをブロックしないよう、複数のコンポーネントのレンダーの合間にブラウザに一部の作業を行わせることができます。<li><strong>より良いデバッグ体験</strong>。ライブラリがコンポーネントのことを基本部品として認識していれば、開発中の調査のためのリッチな開発者ツールを構築できます。<li><strong>より効率的な差分検出処理</strong>。React は、ツリー内のどのコンポーネントを再レンダーすべきか正確に把握し、残りをスキップします。これによりアプリの動作は高速でキビキビとしたものになります。</ul></section><section class="level2"aria-labelledby="フックを通常の値として取り回さない-never-pass-around-hooks-as-regular-values"><h2 id="フックを通常の値として取り回さない-never-pass-around-hooks-as-regular-values">フックを通常の値として取り回さない {/<em>never-pass-around-hooks-as-regular-values</em>/}</h2><p>フックはコンポーネントまたはフックの内部でのみ呼び出すべきです。通常の値のように取り回してはいけません。<p>フックは、コンポーネントに React の機能を加えるために使用します。常に関数として呼び出すだけにし、通常の値のように取りまわしてはいけません。これにより<em>ローカル・リーズニング</em>が可能に、すなわち開発者がそのコンポーネントだけを見てコンポーネントにできることをすべて理解できるようになります。<p>このルールを破ると、React はコンポーネントを自動的に最適化することができなくなります。<section class="level3"aria-labelledby="フックを動的に変更しない-dont-dynamically-mutate-a-hook"><h3 id="フックを動的に変更しない-dont-dynamically-mutate-a-hook">フックを動的に変更しない {/<em>dont-dynamically-mutate-a-hook</em>/}</h3><p>フックは可能な限り「静的」であるべきです。つまり、動的に変更してはいけません。たとえば、高階 (higher-order) フックを書くべきではありません。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ChatInput</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> useDataWithLogging <span class="token operator">=</span> <span class="token function">withLogging</span><span class="token punctuation">(</span>useData<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 Bad: don't write higher order Hooks</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">useDataWithLogging</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>フックはイミュータブルであるべきで、動的に変更するべきではありません。フックを動的に変更する代わりに、望ましい機能を持つ静的なバージョンのフックを作成してください。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ChatInput</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">useDataWithLogging</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ Good: Create a new version of the Hook</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">useDataWithLogging</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... Create a new version of the Hook and inline the logic here</span>
<span class="token punctuation">}</span></code></pre></section><section class="level3"aria-labelledby="フックを動的に使用しない-dont-dynamically-use-hooks"><h3 id="フックを動的に使用しない-dont-dynamically-use-hooks">フックを動的に使用しない {/<em>dont-dynamically-use-hooks</em>/}</h3><p>フックを動的に使用してはいけません。例えば以下のように、フックそのものを値としてコンポーネントに渡して依存性注入を行わないようにしてください。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ChatInput</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Button</span> useData<span class="token operator">=</span><span class="token punctuation">{</span>useDataWithLogging<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span> <span class="token comment">// 🔴 Bad: don't pass Hooks as props</span>
<span class="token punctuation">}</span></code></pre><p>代わりにコンポーネント内でインラインでフックをコールし、そこでロジックを処理するべきです。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ChatInput</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Button</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Button</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">useDataWithLogging</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ Good: Use the Hook directly</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">useDataWithLogging</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// If there's any conditional logic to change the Hook's behavior, it should be inlined into</span>
  <span class="token comment">// the Hook</span>
<span class="token punctuation">}</span></code></pre><p>こうすることで <code>&#x3C;Button /></code> を理解しデバッグするのがずっと簡単になります。フックを動的に使用すると、アプリの複雑さが大幅に増し、ローカル・リーズニングを妨げ、長期的にはチームの生産性を低下させます。また、条件付きでフックを呼び出すべきではないという<a href="/reference/rules/rules-of-hooks">フックのルール</a>を誤って破る可能性も高まります。テストのためにコンポーネントをモックする必要がある場合は、代わりにサーバをモックして固定データで応答する方が良いでしょう。可能であれば、end-to-end テストでアプリをテストする方が通常はより効果的です。<p><span style="float:footnote"><a href="../../index.html#toc">Go to TOC</a></span></section></section></inlinetoc></section>