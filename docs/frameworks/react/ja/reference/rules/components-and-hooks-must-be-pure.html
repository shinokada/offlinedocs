<!doctype html><html lang="ja"><meta charset="utf-8"><title>コンポーネントとフックを純粋に保つ</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"type="text/css"href="../../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="コンポーネントとフックを純粋に保つ"><h1 id="コンポーネントとフックを純粋に保つ">コンポーネントとフックを純粋に保つ</h1><intro>純関数 (pure function) とは計算を行うだけで、それ以上のことはしない関数です。これによりコードの理解やデバッグが容易になり、React が自動的にコンポーネントとフックを最適化できるようになります。</intro><note>このリファレンスページで扱うのは高度なトピックです。あらかじめ[コンポーネントを純粋に保つ](/learn/keeping-components-pure)で説明されている概念に精通していることが必要です。</note><inlinetoc><section class="level3"aria-labelledby="純粋性が重要である理由-why-does-purity-matter"><h3 id="純粋性が重要である理由-why-does-purity-matter">純粋性が重要である理由 {/<em>why-does-purity-matter</em>/}</h3><p>React を React たらしめる重要な概念のひとつが<em>純粋性 (purity)</em> です。純粋なコンポーネントやフックとは、以下のような特徴を持つものです。<ul><li><strong>冪等 (idempotent) であること</strong> – 同じ入力で実行するたびに<a href="/learn/keeping-components-pure#purity-components-as-formulas">常に同じ結果が得られる</a>こと。コンポーネントの入力とは props と state とコンテクスト。フックの入力とはその引数。<li><strong>レンダー時に副作用がない</strong> – 副作用 (side effect) を伴うコードは<a href="#how-does-react-run-your-code"><strong>レンダーとは別に実行</strong></a>する必要がある。例えばユーザが UI を操作しそれによって UI が更新される場合は<a href="/learn/responding-to-events">イベントハンドラ</a>として、またはレンダー直後に動作させる場合は<a href="/reference/react/useEffect">エフェクト</a>として実行する。<li><strong>ローカルな値以外を変更しない</strong>：コンポーネントとフックは、レンダー中に<a href="#mutation">ローカルに作成されたものではない値を決して変更してはならない</a>。</ul><p>レンダーが純粋に保たれていれば、React はどの更新を優先してユーザに最初に提示すべきか理解することができます。これができるのはレンダーの純粋性のお陰です。コンポーネントが<a href="#how-does-react-run-your-code">レンダー時</a>に副作用を持たないなら、React は更新がそれほど重要でないコンポーネントのレンダー処理を一時停止し、後で必要になったときに再開できます。<p>具体的にはこれは、React がユーザに快適な体験を提供できるよう、レンダーのロジックが複数回実行されることがあるという意味です。しかしコンポーネントが<a href="#how-does-react-run-your-code">レンダー時</a>に React が把握できない副作用、例えばグローバル変数の書き換えのようなことを行っている場合、React がレンダーコードを再実行した際にその副作用が望ましくない形でトリガされることになります。これはしばしば予期せぬバグを引き起こし、ユーザ体験を悪化させます。<a href="/learn/keeping-components-pure#side-effects-unintended-consequences">「コンポーネントを純粋に保つ」のこちらの例</a>を参照してください。<section class="level4"aria-labelledby="react-はどのようにコードを実行するのか-how-does-react-run-your-code"><h4 id="react-はどのようにコードを実行するのか-how-does-react-run-your-code">React はどのようにコードを実行するのか {/<em>how-does-react-run-your-code</em>/}</h4><p>React は宣言型 (declarative) です。あなたは<em>何 (what)</em> をレンダーしたいのかだけを React に伝え、それを<em>どうやって (how)</em> ユーザにうまく表示するのかについては React が考えます。これを実現するため、React は複数のフェーズに分けてコードを実行します。React を使いこなすためにこれらのフェーズすべてを知っておく必要はありません。しかしどのコードが<em>レンダー</em>中に実行され、どのコードがそれ以外のタイミングで実行されるのかについては、概要を知っておくべきです。<p><em>レンダー</em>とは、UI の次のバージョンとして何が見えるべきかを計算する作業を指します。レンダーの後、<a href="/reference/react/useEffect">エフェクト</a>が<em>フラッシュ (flush)</em>（つまり未処理分がなくなるまで実行）され、それらがレイアウトに影響を与える場合は計算の更新を行います。React はこの新しい計算結果を受け取り、UI の以前のバージョンを作成する際に使われた計算結果と比較し、最新バージョンに追いつくために必要な最小限の変更を <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">DOM</a>（ユーザが目にするもの）に<em>コミット (commit)</em> します。</p><deepdive></deepdive></section><section class="level4"aria-labelledby="コードがレンダー中に走るかどうか判断する方法-how-to-tell-if-code-runs-in-render"><h4 id="コードがレンダー中に走るかどうか判断する方法-how-to-tell-if-code-runs-in-render">コードがレンダー中に走るかどうか判断する方法 {/<em>how-to-tell-if-code-runs-in-render</em>/}</h4><p>コードがレンダー中に走るかどうかを判断する簡単な方法は、そのコードがどこに書かれているかを見ることです。以下の例のようにトップレベルに書かれている場合、レンダー中に実行される可能性が高いでしょう。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Dropdown</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> selectedItems <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// created during render</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>イベントハンドラやエフェクトはレンダー中には実行されません。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Dropdown</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> selectedItems <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">onSelect</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// this code is in an event handler, so it's only run when the user triggers this</span>
    selectedItems<span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Dropdown</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> selectedItems <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// this code is inside of an Effect, so it only runs after rendering</span>
    <span class="token function">logForAnalytics</span><span class="token punctuation">(</span>selectedItems<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>selectedItems<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></section></section><section class="level2"aria-labelledby="コンポーネントとフックを冪等にする-components-and-hooks-must-be-idempotent"><h2 id="コンポーネントとフックを冪等にする-components-and-hooks-must-be-idempotent">コンポーネントとフックを冪等にする {/<em>components-and-hooks-must-be-idempotent</em>/}</h2><p>コンポーネントは、その入力である props、state、およびコンテクストに対して常に同じ出力を返さなければなりません。これを<em>冪等性 (idempotency)</em> と呼びます。<a href="https://en.wikipedia.org/wiki/Idempotence">冪等性</a>は関数型プログラミングで広まった用語であり、同じ入力でそのコードを実行するたびに<a href="learn/keeping-components-pure">常に同じ結果が得られる</a>という考え方を指します。<p>これは、<a href="#how-does-react-run-your-code">レンダー</a>中に実行される<em>あらゆる</em>コードは冪等でなければならないという意味です。例えば以下のコードは冪等ではありません（したがって、コンポーネントも冪等ではありません）。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Clock</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> time <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 Bad: always returns a different result!</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>span<span class="token operator">></span><span class="token punctuation">{</span>time<span class="token punctuation">.</span><span class="token method function property-access">toLocaleString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>span<span class="token operator">></span>
<span class="token punctuation">}</span></code></pre><p><code>new Date()</code> は常に現在の日時を返し、呼び出すたびに結果が変わるため、冪等ではありません。上記のコンポーネントをレンダーすると、画面に表示される時間はコンポーネントがレンダーされた瞬間の時間に固定されます。同様に、<code>Math.random()</code> のような関数も冪等ではありません。なぜなら、入力が同じでも呼び出すたびに異なる結果を返すからです。<p>これは、<code>new Date()</code> のような冪等ではない関数を<em>絶対に</em>使用してはならないという意味ではありません。<a href="#how-does-react-run-your-code">レンダー</a>中にだけは使用できないということです。上記の場合、最新の日付をこのコンポーネントと<em>同期</em>するために、<a href="/reference/react/useEffect">エフェクト</a>が使用できます。</p><sandpack><pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">useTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1. Keep track of the current date's state. `useState` receives an initializer function as its</span>
  <span class="token comment">//    initial state. It only runs once when the hook is called, so only the current date at the</span>
  <span class="token comment">//    time the hook is called is set first.</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>time<span class="token punctuation">,</span> setTime<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// 2. Update the current date every second using `setInterval`.</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">setTime</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ Good: non-idempotent code no longer runs in render</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3. Return a cleanup function so we don't leak the `setInterval` timer.</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> time<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Clock</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> time <span class="token operator">=</span> <span class="token function">useTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>span<span class="token operator">></span><span class="token punctuation">{</span>time<span class="token punctuation">.</span><span class="token method function property-access">toLocaleString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></sandpack><p>非冪等な <code>new Date()</code> の呼び出しをエフェクトでラップすることで、その計算を<a href="#how-does-react-run-your-code">レンダーの外側</a>に移動させているのです。<p>React と外部状態を同期する必要がなく、ユーザの操作に応じて更新を行うだけの場合は、<a href="/learn/responding-to-events">イベントハンドラ</a>の使用を考慮してください。</section><section class="level2"aria-labelledby="副作用はレンダーの外で実行する-side-effects-must-run-outside-of-render"><h2 id="副作用はレンダーの外で実行する-side-effects-must-run-outside-of-render">副作用はレンダーの外で実行する {/<em>side-effects-must-run-outside-of-render</em>/}</h2><p><a href="/learn/keeping-components-pure#side-effects-unintended-consequences">副作用</a>は<a href="#how-does-react-run-your-code">レンダー中</a>に実行してはいけません。React が最適なユーザ体験のためにコンポーネントを複数回レンダーする可能性があるためです。</p><note>副作用 (side effect) とはエフェクト (Effect) よりも広い概念を指す用語です。エフェクトとは `useEffect` でラップされるコードのみを指す用語であり、副作用とは呼び出し元に値を返すこと以外に観察可能な影響を及ぼすコード全般のことを指す、一般的な用語です。<p>副作用は通常、<a href="/learn/responding-to-events">イベントハンドラ</a>やエフェクトの中に書かれます。レンダーの中には決して書いてはいけません。<p>レンダーは純粋に保つ必要がある一方で、アプリが何か面白いことをするためには、いずれかの時点で副作用が必要です。これには画面に何かを表示することも含まれます！ このルールの大事なところは、副作用は<a href="#how-does-react-run-your-code">レンダー時</a>に起きてはならない、ということです。React がコンポーネントを複数回レンダーすることがあるからです。大抵の場合、副作用は<a href="learn/responding-to-events">イベントハンドラ</a>を使用して処理します。イベントハンドラを使用することで、そのコードはレンダー中に実行しなくてよいと React に明示的に伝えていることになり、レンダーが純粋に保たれます。他の選択肢がない場合に最後の手段としてのみ、<code>useEffect</code> を使用して副作用を処理することもできます。<section class="level3"aria-labelledby="書き換えを行ってもよいタイミング-mutation"><h3 id="書き換えを行ってもよいタイミング-mutation">書き換えを行ってもよいタイミング {/<em>mutation</em>/}</h3><section class="level4"aria-labelledby="ローカルミューテーション-local-mutation"><h4 id="ローカルミューテーション-local-mutation">ローカルミューテーション {/<em>local-mutation</em>/}</h4><p>副作用の一般的な例はミューテーション (mutation) です。JavaScript では、これは非<a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">プリミティブ</a>値の内容を書き換えることを指します。一般的に React では変数の書き換えを避けるべきですが、<em>ローカル</em>変数のミューテーション (local mutation) はまったく問題ありません。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">FriendList</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> friends <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// ✅ Good: locally created</span>
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> friends<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> friend <span class="token operator">=</span> friends<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    items<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Friend</span> key<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">}</span> friend<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ Good: local mutation is okay</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>section<span class="token operator">></span><span class="token punctuation">{</span>items<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>section<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>ローカルミューテーションを避けるために無理にコードを変える必要はありません。<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><code>Array.map</code></a> を使用して短く書くこともできますが、<a href="#how-does-react-run-your-code">レンダー時</a>にローカル配列を作成してアイテムを push していくのでも何ら問題ありません。<p><code>items</code> を書き換えているように見えますが、このコードは<em>ローカルでのみ</em>そうしているという点が重要です。コンポーネントの再レンダー時にこの書き換えは「記憶」されていません。言い換えると、<code>items</code> はコンポーネントの実行の最中にのみ存在します。<code>&#x3C;FriendList /></code> がレンダーされるたびに <code>items</code> は<em>再作成</em>されるので、コンポーネントは常に同じ結果を返します。<p>一方で、<code>items</code> がコンポーネントの外部で作成されている場合、以前の値を保持しつづけることで、変更の記憶が起きてしまいます。<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 Bad: created outside of the component</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">FriendList</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> friends <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> friends<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> friend <span class="token operator">=</span> friends<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    items<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Friend</span> key<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">}</span> friend<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 Bad: mutates a value created outside of render</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>section<span class="token operator">></span><span class="token punctuation">{</span>items<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>section<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><code>&#x3C;FriendList /></code> が再実行されると、このコンポーネントが実行されるたびに <code>friends</code> を <code>items</code> に追加し続け、結果の重複が生じます。この <code>&#x3C;FriendList /></code> には<a href="#how-does-react-run-your-code">レンダー</a>時に外部から観測可能な副作用があり、そのため<strong>ルールに違反</strong>しているというわけです。</section><section class="level4"aria-labelledby="遅延初期化-lazy-initialization"><h4 id="遅延初期化-lazy-initialization">遅延初期化 {/<em>lazy-initialization</em>/}</h4><p>厳密には「純粋」ではありませんが、遅延初期化 (lazy initialization) は問題ありません。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ExpenseForm</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">SuperCalculator</span><span class="token punctuation">.</span><span class="token method function property-access">initializeIfNotReady</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ Good: if it doesn't affect other components</span>
  <span class="token comment">// Continue rendering...</span>
<span class="token punctuation">}</span></code></pre></section><section class="level4"aria-labelledby="dom-の書き換え-changing-the-dom"><h4 id="dom-の書き換え-changing-the-dom">DOM の書き換え {/<em>changing-the-dom</em>/}</h4><p>ユーザに直接見えるような副作用は、React コンポーネントのレンダーロジックでは許可されていません。言い換えると、単にコンポーネント関数を呼び出すこと自体が、画面上の変化を生じさせてはいけません。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ProductDetailPage</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> product <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> product<span class="token punctuation">.</span><span class="token property-access">title</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 Bad: Changes the DOM</span>
<span class="token punctuation">}</span></code></pre><p><code>window.title</code> を更新するという望ましい結果をレンダーの外で達成する方法のひとつは、<a href="/learn/synchronizing-with-effects"><code>window</code> とコンポーネントを同期させる</a>ことです。<p>コンポーネントを複数回呼び出しても安全であり、他のコンポーネントのレンダーに影響を与えないのであれば、React はそれが厳密な関数型プログラミングの意味で 100% 純粋であるかどうかを気にしません。より重要なのは、<a href="/reference/rules/components-and-hooks-must-be-pure">コンポーネントは冪等でなければならない</a>ということです。</section></section></note></section><section class="level2"aria-labelledby="props-と-state-はイミュータブル-props-and-state-are-immutable"><h2 id="props-と-state-はイミュータブル-props-and-state-are-immutable">props と state はイミュータブル {/<em>props-and-state-are-immutable</em>/}</h2><p>コンポーネントの props と state はイミュータブルな<a href="learn/state-as-a-snapshot">スナップショット</a>です。これらは決して直接書き換えてはいけません。代わりに新しい props を渡すか、<code>useState</code> のセッタ関数を使用してください。<p>props と state の値は、レンダーが終わってから更新されるスナップショットと考えることができます。したがって props や state 変数を直接書き換えることはありません。代わりに新しい props を渡すか、あるいはセッタ関数を使用して React に state をコンポーネントの次回レンダー時に更新する必要があると伝えます。<section class="level3"aria-labelledby="props-を書き換えない-props"><h3 id="props-を書き換えない-props">props を書き換えない {/<em>props</em>/}</h3><p>props はイミュータブルです。props を変更すると、アプリケーションが一貫性のない出力を生成し、状況によって動作したりしなかったりするためデバッグが困難になるからです。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Post</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> item <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  item<span class="token punctuation">.</span><span class="token property-access">url</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Url</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token property-access">url</span><span class="token punctuation">,</span> base<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 Bad: never mutate props directly</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Link</span> url<span class="token operator">=</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span><span class="token property-access">url</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>item<span class="token punctuation">.</span><span class="token property-access">title</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Link</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Post</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> item <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Url</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token property-access">url</span><span class="token punctuation">,</span> base<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ Good: make a copy instead</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Link</span> url<span class="token operator">=</span><span class="token punctuation">{</span>url<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>item<span class="token punctuation">.</span><span class="token property-access">title</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Link</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></section><section class="level3"aria-labelledby="state-を書き換えない-state"><h3 id="state-を書き換えない-state">state を書き換えない {/<em>state</em>/}</h3><p><code>useState</code> は state 変数とその state を更新するためのセッタ関数を返します。<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>stateVariable<span class="token punctuation">,</span> setter<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>state 変数はその場で書き換えるのではなく、<code>useState</code> によって返されるセッタ関数を使用して更新する必要があります。state 変数の中身を書き換えてもコンポーネントが更新されるわけではないため、ユーザに古くなった UI が表示されたままになります。セッタ関数を使用することで、state が変更され、UI を更新するため再レンダーをキューに入れる必要があるということを React に伝えます。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Counter</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 Bad: never mutate state directly</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token maybe-class-name">You</span> pressed me <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Counter</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ Good: use the setter function returned by useState</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token maybe-class-name">You</span> pressed me <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></section></section><section class="level2"aria-labelledby="フックの引数と返り値はイミュータブル-return-values-and-arguments-to-hooks-are-immutable"><h2 id="フックの引数と返り値はイミュータブル-return-values-and-arguments-to-hooks-are-immutable">フックの引数と返り値はイミュータブル {/<em>return-values-and-arguments-to-hooks-are-immutable</em>/}</h2><p>一度値がフックに渡されたならそれを書き換えてはいけません。JSX の props と同様、フックに渡された時点でその値はイミュータブルです。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">useIconStyle</span><span class="token punctuation">(</span><span class="token parameter">icon</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span><span class="token maybe-class-name">ThemeContext</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>icon<span class="token punctuation">.</span><span class="token property-access">enabled</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    icon<span class="token punctuation">.</span><span class="token property-access">className</span> <span class="token operator">=</span> <span class="token function">computeStyle</span><span class="token punctuation">(</span>icon<span class="token punctuation">,</span> theme<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 Bad: never mutate hook arguments directly</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> icon<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">useIconStyle</span><span class="token punctuation">(</span><span class="token parameter">icon</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span><span class="token maybe-class-name">ThemeContext</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> newIcon <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span>icon <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// ✅ Good: make a copy instead</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>icon<span class="token punctuation">.</span><span class="token property-access">enabled</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    newIcon<span class="token punctuation">.</span><span class="token property-access">className</span> <span class="token operator">=</span> <span class="token function">computeStyle</span><span class="token punctuation">(</span>icon<span class="token punctuation">,</span> theme<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> newIcon<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>React における重要な原則のひとつは、<em>ローカル・リーズニング</em>、つまりコンポーネントやフックが何をしているのかそのコードだけを見て理解できることです。フックを呼び出す際には中身を「ブラックボックス」として扱うべきです。例えば、カスタムフックが引数を内部で値をメモ化するための依存値として使用していたらどうでしょう。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">useIconStyle</span><span class="token punctuation">(</span><span class="token parameter">icon</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span><span class="token maybe-class-name">ThemeContext</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> newIcon <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span>icon <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>icon<span class="token punctuation">.</span><span class="token property-access">enabled</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newIcon<span class="token punctuation">.</span><span class="token property-access">className</span> <span class="token operator">=</span> <span class="token function">computeStyle</span><span class="token punctuation">(</span>icon<span class="token punctuation">,</span> theme<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> newIcon<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>icon<span class="token punctuation">,</span> theme<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>フックの引数を書き換えた場合、カスタムフック内のメモ化が正しく動作しなくなります。これを避けることが重要です。<pre class="language-js"><code class="language-js">style <span class="token operator">=</span> <span class="token function">useIconStyle</span><span class="token punctuation">(</span>icon<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// `style` is memoized based on `icon`</span>
icon<span class="token punctuation">.</span><span class="token property-access">enabled</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>               <span class="token comment">// Bad: 🔴 never mutate hook arguments directly</span>
style <span class="token operator">=</span> <span class="token function">useIconStyle</span><span class="token punctuation">(</span>icon<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// previously memoized result is returned</span></code></pre><pre class="language-js"><code class="language-js">style <span class="token operator">=</span> <span class="token function">useIconStyle</span><span class="token punctuation">(</span>icon<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// `style` is memoized based on `icon`</span>
icon <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span>icon<span class="token punctuation">,</span> <span class="token literal-property property">enabled</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// Good: ✅ make a copy instead</span>
style <span class="token operator">=</span> <span class="token function">useIconStyle</span><span class="token punctuation">(</span>icon<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// new value of `style` is calculated</span></code></pre><p>同様に、フックからの返り値はメモ化されている可能性があるため、それらを書き換えないことも重要です。</section><section class="level2"aria-labelledby="jsx-に渡された値はイミュータブル-values-are-immutable-after-being-passed-to-jsx"><h2 id="jsx-に渡された値はイミュータブル-values-are-immutable-after-being-passed-to-jsx">JSX に渡された値はイミュータブル {/<em>values-are-immutable-after-being-passed-to-jsx</em>/}</h2><p>JSX で使用された後に値を書き換えてはいけません。ミューテーションは JSX が作成される前に行ってください。<p>式として JSX を使用する際、React はコンポーネントのレンダーが完了する前に JSX を先行して評価してしまうかもしれません。つまり JSX に渡された後で値を変更した場合、React がコンポーネントの出力を更新する必要があることを認識しないため、古い UI が表示され続ける可能性があるということです。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Page</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> colour <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> styles <span class="token operator">=</span> <span class="token punctuation">{</span> colour<span class="token punctuation">,</span> <span class="token literal-property property">size</span><span class="token operator">:</span> <span class="token string">"large"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> header <span class="token operator">=</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Header</span> styles<span class="token operator">=</span><span class="token punctuation">{</span>styles<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
  styles<span class="token punctuation">.</span><span class="token property-access">size</span> <span class="token operator">=</span> <span class="token string">"small"</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 Bad: styles was already used in the JSX above</span>
  <span class="token keyword">const</span> footer <span class="token operator">=</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Footer</span> styles<span class="token operator">=</span><span class="token punctuation">{</span>styles<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token punctuation">{</span>header<span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Content</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token punctuation">{</span>footer<span class="token punctuation">}</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Page</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> colour <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> headerStyles <span class="token operator">=</span> <span class="token punctuation">{</span> colour<span class="token punctuation">,</span> <span class="token literal-property property">size</span><span class="token operator">:</span> <span class="token string">"large"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> header <span class="token operator">=</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Header</span> styles<span class="token operator">=</span><span class="token punctuation">{</span>headerStyles<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> footerStyles <span class="token operator">=</span> <span class="token punctuation">{</span> colour<span class="token punctuation">,</span> <span class="token literal-property property">size</span><span class="token operator">:</span> <span class="token string">"small"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// ✅ Good: we created a new value</span>
  <span class="token keyword">const</span> footer <span class="token operator">=</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Footer</span> styles<span class="token operator">=</span><span class="token punctuation">{</span>footerStyles<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token punctuation">{</span>header<span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Content</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token punctuation">{</span>footer<span class="token punctuation">}</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><span style="float:footnote"><a href="../../index.html#toc">Go to TOC</a></span></section></inlinetoc></section>