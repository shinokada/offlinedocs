<!doctypehtml><html lang="ja"><meta charset="utf-8"><title>フックの導入</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="フックの導入"class="level1"><h1>フックの導入</h1><p><em>フック (hook)</em> は React 16.8 で追加された新機能です。state などの React の機能を、クラスを書かずに使えるようになります。<pre class="language-js{4,5}"><code class="language-js{4,5}">import React, { useState } from 'react';

function Example() {
  // Declare a new state variable, which we'll call "count"
  const [count, setCount] = useState(0);

  return (
    &#x3C;div>
      &#x3C;p>You clicked {count} times&#x3C;/p>
      &#x3C;button onClick={() => setCount(count + 1)}>
        Click me
      &#x3C;/button>
    &#x3C;/div>
  );
}</code></pre><p>この <code>useState</code> という関数が、これから説明する最初のフック (Hook) です。これは単なるチラ見せですので、まだ意味が分からなくても問題ありません！<p><strong><a href="./hooks-overview.html">次のページ</a>からフックについて学び始めることができます。</strong>このページの残りの部分では、我々がなぜ React にフックの仕組みを加えることにしたのか、そして素晴らしいアプリケーションを作るためにどのように便利なのかについて説明していきます。<blockquote><p>補足<p>React 16.8.0 がフックをサポートする最初のバージョンです。アップグレードの際は、React DOM を含むすべてのパッケージの更新を忘れないようにしてください。React Native は <a href="https://reactnative.dev/blog/2019/03/12/releasing-react-native-059">React Native 0.59 リリース</a>以降でフックをサポートします。</blockquote><section id="video-introduction"class="level2"><h2>ビデオによる紹介</h2><p>React Conf 2018 にて Sophie Alpert と Dan Abramov がフックについての発表を行い、続いて Ryan Florence がアプリケーションでフックを使うようにリファクタリングする方法についてのデモを行いました。ビデオは以下で見ることができます：</p><br><iframe width="650"height="366"src="//www.youtube.com/embed/dpw9EHDh2bM"frameborder="0"allowfullscreen></iframe></section><section id="no-breaking-changes"class="level2"><h2>互換性のない変更はありません</h2><p>先に進む前に注意すべきこととして、フックは：<ul><li><strong>完全にオプトイン</strong>です。既存のコードを書き換えずに一部のコンポーネントでフックを試すことができます。またやりたくないのであれば、今すぐに学んだり使ったりする必要もありません。<li><strong>100% 後方互換</strong>です。フックには破壊的な変更は一切含まれていません。<li><strong>今すぐ利用可能</strong>です。フックは v16.8.0 のリリースから利用可能です。</ul><p><strong>React からクラス型コンポーネントを削除する予定はありません。</strong>このページの<a href="#gradual-adoption-strategy">下部</a>で段階的にフックを採用していく方法について読むことができます。<p><strong>フックは既にあなたが知っている React のコンセプトを置き換えるものではありません。</strong>むしろ、フックはあなたが既に知っている props、state、コンテクスト、ref、ライフサイクルといったコンセプトに対してより直接的な API を提供するものです。後でお見せするように、フックによって、これらを組み合わせるパワフルな手段も得ることができます。<p><strong>とにかくフックを学び始めたいという方は、どうぞ<a href="./hooks-overview.html">直接次のページに進んでください</a>！</strong> 以下には、なぜ React にフックを導入することにしたのか、アプリケーションを書き換えずにどのようにしてフックを使い始めることができるのかについて解説しています。</section><section id="motivation"class="level2"><h2>動機</h2><p>フックによって、過去 5 年で何万というコンポーネントを作成・メンテナンスする中で我々が遭遇してきた、一見互いにあまり関係なさそうに見える様々な問題が解決されます。あなたが React を学習中の場合でも、毎日使っている場合でも、似たようなコンポーネントモデルを持つ別のライブラリが好きな場合でも、これらの問題の幾つかを認識しているかもしれません。<section id="its-hard-to-reuse-stateful-logic-between-components"class="level3"><h3>ステートフルなロジックをコンポーネント間で再利用するのは難しい</h3><p>React は再利用可能な振る舞いをコンポーネントに「付加する」方法（例えばストアオブジェクトを connect するなど）を提供していません。React をしばらく使った事があれば、この問題を解決するための<a href="./render-props.html">レンダープロップ</a>や<a href="./higher-order-components.html">高階コンポーネント</a>といったパターンをご存じかもしれません。しかしこれらのパターンを使おうとするとコンポーネントの再構成が必要であり、面倒なうえにコードを追うのが難しくなります。典型的な React アプリを React DevTools で見てみると、おそらくプロバイダやらコンシューマやら高階コンポーネントやらレンダープロップやら、その他諸々の抽象化が多層に積み重なった『ラッパー地獄』を見ることになるでしょう。<a href="https://github.com/facebook/react-devtools/pull/503">DevTools でそれらをフィルタして隠す</a>ことはできますが、この背景にはもっと根本的な問題があるということがわかります：React にはステートフルなロジックを共有するためのよりよい基本機能が必要なのです。<p>フックを使えば、ステートを持ったロジックをコンポーネントから抽出して、単独でテストしたり、また再利用したりすることができます。<strong>フックを使えば、ステートを持ったロジックを、コンポーネントの階層構造を変えることなしに再利用できるのです。</strong>このため、多数のコンポーネント間で、あるいはコミュニティ全体で、フックを共有することが簡単になります。<p>この点については<a href="./hooks-custom.html">独自フックの作成</a>にてより詳しく述べていきます。</section><section id="complex-components-become-hard-to-understand"class="level3"><h3>複雑なコンポーネントは理解しづらくなる</h3><p>我々はよく、最初はシンプルだったのに、state を使うロジックや副作用によって管理不能なごちゃ混ぜ状態に陥ってしまったコンポーネントをメンテナンスさせられてきました。それぞれのライフサイクルメソッドには、しばしば互いに関係のないロジックが混在してしまいます。例えばとあるコンポーネントは <code>componentDidMount</code> と <code>componentDidUpdate</code> で何かデータを取得しているかもしれません。しかし同じ <code>componentDidMount</code> 内には、イベントリスナを登録する何か無関係なロジックがあるかもしれませんし、そのクリーンアップのコードは <code>componentWillUnmount</code> に書かれているかもしれません、といった具合です。一緒に更新されるべき互いに関連したコードがバラバラにされ、一方でまったく無関係なコードが 1 つのメソッド内に書かれています。このような状態は簡単にバグや非整合性を引き起こします。<p>多くの場合、state を使ったロジックはコンポーネント内のあらゆる場所にあるため、小さなコンポーネントに分割することは不可能です。テストも困難になります。これが、多くの人が単体の状態管理ライブラリの利用を好む理由のひとつでもあります。しかし、そのようなライブラリを利用するとしばしば過剰な抽象化を引き起こしたり、様々なファイルにジャンプさせられたり、コンポーネントの再利用がより困難になってしまったりします。<p>この問題を解決するため、関連する機能（例えばデータの購読や取得）をライフサイクルメソッドによって無理矢理分割する代わりに、<strong>フックは関連する機能に基づいて、1 つのコンポーネントを複数の小さな関数に分割することを可能にします。</strong>より state 管理を予測しやすくするため、必要に応じてリデューサ (reducer) を使って管理するようにしてもよいでしょう。<p>これについては<a href="./hooks-effect.html#tip-use-multiple-effects-to-separate-concerns">副作用フックの利用法</a>で詳しく述べます。</section><section id="classes-confuse-both-people-and-machines"class="level3"><h3>クラスは人間と機械の両方を混乱させる</h3><p>コードの再利用や整頓が難しくなるということに加えてクラスについて我々が学んだことは、クラスが React を学ぶ上で障壁となっているということです。JavaScript で <code>this</code> がどのように動作するのか理解しなければなりませんが、それは他の多くの言語での動作とは非常に異なっています。イベントハンドラを <code>bind</code> するよう覚えておく必要があります。<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields#public_instance_fields">ES2022 のパブリッククラスフィールド構文</a>を使わない限り、コードは非常に冗長になってしまいます。開発者は props や state やトップダウンのデータフローについて完璧に理解できても、クラスの部分でつまづいてしまいます。React における関数コンポーネントとクラスコンポーネントの違いや使い分けについては経験のある React 開発者の間でも意見の差異が出てきます。<p>加えて、React は登場から約 5 年が経ちましたが、これからの 5 年間も使える選択肢のままであって欲しいと考えています。<a href="https://svelte.dev/">Svelte</a> や <a href="https://angular.io/">Angular</a> や <a href="https://glimmerjs.com/">Glimmer</a> などのライブラリが示したように、コンポーネントの<a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation">事前コンパイル</a>には大きな将来性があります。特に使用法がテンプレートに限られていない場合はそうです。最近我々は <a href="https://prepack.io/">Prepack</a> を使った <a href="https://github.com/facebook/react/issues/7323">component folding</a> を試しており、有望な初期結果が得られています。しかし、クラスコンポーネントを使うことで、これらの最適化機能が遅い経路にフォールバックしてしまうようなパターンを助長してしまうことが分かりました。クラスは今まさに使われているツール群でも問題を引き起こします。例えば、クラスはあまりよく minify されませんし、ホットリローディングも不安定で信頼できないものになってしまいます。我々は、コードが最適化しやすい状態でいられる可能性を高くできるような API を提示したいのです。<p>これらの問題を解決するため、<strong>フックは、より多くの React の機能をクラスを使わずに利用できるようにします</strong>。コンセプト的には、React のコンポーネントは常に関数に近いものでした。フックは関数を活用しながらも、React の実用性を犠牲にしません。フックは命令型コードへの避難ハッチへのアクセスを提供しますし、複雑な関数型プログラミングやリアクティブプログラミングの技法を学ばせることもありません。<blockquote><p>例<p><a href="./hooks-overview.html">フック早わかり</a>はフックを学び始めるのに良い記事です。</blockquote></section></section><section id="gradual-adoption-strategy"class="level2"><h2>段階的な採用戦略</h2><blockquote><p><strong>TLDR: React からクラスを削除する予定はありません。</strong></blockquote><p>React 開発者はプロダクト開発に注力する必要があり、リリースされるあらゆる新しい API を確かめている時間はない、ということを、我々は理解しています。フックはとても新しい機能ですので、多くの例やチュートリアルが揃うまで、学んだり採用したりするのを待つ方がいいかもしれません。<p>また、React に新しい基本機能を付け加えるハードルが非常に高いということも理解しています。興味ある読者のために我々は<a href="https://github.com/reactjs/rfcs/pull/68">詳しい RFC</a> を用意しています。そこではより詳しく動機を掘り下げており、関連する先行技術や個別の設計上の選択についての概要が述べられています。<p><strong>肝心なことですが、フックは既存のコードと併用することができるので、段階的に採用していくことが可能です。</strong>フックへの移行を急ぐ必要はありません。特に既存の複雑なコンポーネントについては、「大幅な書き換え」は避けることを推奨します。『フックで考えられる』ようになるには若干の思考の転換が必要です。我々の経験上は、あまり重要でない新しいコンポーネントでまずフックの使い方を練習し、チームの全員が慣れるようにすることが最良です。フックを試してみたら、どうぞお気軽に<a href="https://github.com/facebook/react/issues/new">フィードバックを送って</a>ください。ポジティブなものでもネガティブなものでも構いません。<p>クラスコンポーネントのユースケースをすべてフックがカバーできるようにする予定ではいますが、<strong>クラスコンポーネントのサポートも予見可能な将来にわたって続けていきます。</strong>Facebook では何万というコンポーネントがクラスとして書かれており、それらを書き換える予定は全くありません。代わりに、クラスと併用しながら新しいコードでフックを使っていく予定でいます。</section><section id="frequently-asked-questions"class="level2"><h2>よくある質問</h2><p><a href="./hooks-faq.html">Hook の FAQ ページ</a>では、フックに関するよくある質問にお答えしています。</section><section id="next-steps"class="level2"><h2>次のステップ</h2><p>このページを読み終えたことで、フックがどのような問題を解決しようとしているのか大まかに知ることはできたと思いますが、おそらく細かい部分についてはまだ分からないと思います。心配は要りません。<strong><a href="./hooks-overview.html">次のページ</a>に進み、例を使ってフックについて学び始めましょう。</strong> <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>