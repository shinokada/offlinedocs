<!doctypehtml><html lang="ja"><meta charset="utf-8"><title>テスト環境</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="テスト環境"class="level1"><h1>テスト環境</h1><p>このドキュメントではあなたの環境に影響する要素や、いくつかのシナリオにおける推奨事項について概説します。<section id="test-runners"class="level3"><h3>テストランナー</h3><p><a href="https://jestjs.io/">Jest</a>、<a href="https://mochajs.org/">mocha</a>、<a href="https://github.com/avajs/ava">ava</a> のようなテストランナーを使えば、標準的な JavaScript を使ってテストスイートを書き、開発プロセスの一環として実行できるようにできます。加えて、テストスイートは継続的インテグレーションの一部としても実行されます。<ul><li>Jest は React プロジェクトとの広範な互換性を有しており、<a href="#mocking-modules">モジュール</a>や<a href="#mocking-timers">タイマー</a>のモック、<a href="#mocking-a-rendering-surface"><code>jsdom</code></a> のサポートを有しています。<strong>Create React App を使っている場合、Jest は有用なデフォルト値とともに<a href="https://facebook.github.io/create-react-app/docs/running-tests">追加設定なしでインストールされます</a></strong>。<li><a href="https://mochajs.org/#running-mocha-in-the-browser">mocha</a> のようなライブラリは実際のブラウザ環境でうまく動作するため、それが必要なテストでは有用でしょう。<li>End-to-end テストは複数のページにまたがる長いフローのテストに使用され、<a href="#end-to-end-tests-aka-e2e-tests">異なったセットアップ</a>が必要です。</ul></section><section id="mocking-a-rendering-surface"class="level3"><h3>描画画面のモック</h3><p>しばしばテストは、ブラウザのような実際の描画用の画面にアクセスできない環境で実行されます。このような環境では、Node.js 内で実行される軽量のブラウザ実装である <a href="https://github.com/jsdom/jsdom"><code>jsdom</code></a> を使ってブラウザ環境をシミュレートすることをお勧めします。<p>多くの場合、jsdom は普通のブラウザの挙動と同様に動作しますが、<a href="https://github.com/jsdom/jsdom#unimplemented-parts-of-the-web-platform">レイアウトやナビゲーション</a>のような機能は有していません。それでも、個々のテストでブラウザを立ち上げるよりも高速に動作するので、ほとんどのウェブベースのコンポーネントのテストでは有用です。また、jsdom はあなたのテストと同一のプロセスで動作するため、描画された DOM に対して内容を調べたりアサーションを行うコードを書くことができます。<p>本物のブラウザと全く同様に、jsdom ではユーザ操作をモデルすることができます。テストは DOM ノードに対してイベントをディスパッチして、そのアクションに対する副作用を観察したり検証したりすることができます<a href="./testing-recipes.html#events"><small>（例）</small></a>。<p>UI テストの大部分は上記のようなセットアップを行って書くことができます。すなわちテストランナーとして Jest を使い、jsdom にレンダーし、ブラウザイベントの羅列としてユーザ操作を定義し、<code>act()</code> ヘルパを活用します<a href="./testing-recipes.html"><small>（例）</small></a>。例えば、React 自体のテストの多くもこの組み合わせで書かれています。<p>主にブラウザ特有の動作をテストする必要があるライブラリを書いており、レイアウトや本物のユーザ入力などネイティブなブラウザの挙動が必要な場合は、<a href="https://mochajs.org/">mocha</a> のようなフレームワークを利用できます。<p>DOM をシミュレート<em>できない</em>環境（例えば Node.js で React Native のコンポーネントをテストする場合など）では、<a href="./test-utils.html#simulate">イベントシミュレーションヘルパ</a>を使って要素とのインタラクションをシミュレーションできます。あるいは、<a href="https://testing-library.com/docs/react-native-testing-library/intro"><code>@testing-library/react-native</code></a> の <code>fireEvent</code> ヘルパを利用することもできます。<p><a href="https://www.cypress.io/">Cypress</a>、<a href="https://github.com/GoogleChrome/puppeteer">puppeteer</a>、<a href="https://www.seleniumhq.org/projects/webdriver/">webdriver</a> のようなフレームワークは <a href="#end-to-end-tests-aka-e2e-tests">end-to-end テスト</a>を実行するのに有用です。</section><section id="mocking-functions"class="level3"><h3>関数のモック</h3><p>テストを書く際は、テスト環境に同等物がないコード（例えば <code>navigator.onLine</code> の状態を Node.js 内で確認する、など）のモック化をしたくなります。テストではいくつかの関数を監視し、テストの他の部位がその関数とどう作用するのかを観察することもできます。そのような場合に、これらの関数をテストしやすいバージョンで選択的にモック化できれば有用です。<p>これはデータを取得する場面では特に有用です。本物の API エンドポイントからデータを取得することによって遅くなったり不安定になったりするのを避けるため、通常はフェイクデータを利用することが望まれます<a href="./testing-recipes.html#data-fetching"><small>（例）</small></a>。これによりテストが予想可能になります。<a href="https://jestjs.io/">Jest</a> や <a href="https://sinonjs.org/">sinon</a> などのライブラリはモック関数をサポートしています。End-to-end テストの場合、ネットワークのモックはより困難ですが、いずれにせよそのようなテストでは本物の API エンドポイントを使ってテストをしたいでしょう。</section><section id="mocking-modules"class="level3"><h3>モジュールのモック</h3><p>コンポーネントによってはテスト環境でうまく動作しないか、テストにとって本質的ではないモジュールに依存していることがあります。このようなモジュールを選択的にモック化して適切な代替物で置き換えることは有用です<a href="./testing-recipes.html#mocking-modules"><small>（例）</small></a>。<p>Node.js では、Jest のようなテストランナーは<a href="https://jestjs.io/docs/en/manual-mocks">モジュールのモックをサポートしています</a>。<a href="https://www.npmjs.com/package/mock-require"><code>mock-require</code></a> のようなライブラリを使用することもできます。</section><section id="mocking-timers"class="level3"><h3>タイマーのモック</h3><p>コンポーネントは <code>setTimeout</code>、<code>setInterval</code> や <code>Date.now</code> のような時間に依存する関数を使っているかもしれません。テスト環境では、これらの関数をモック版で置き換えて、手動で時間を「進められる」ようにすることが有用です。これはテストを高速に実行させるためにも役立ちます！ タイマーに依存しているテストは順番通りに処理されますが、より高速になるのです<a href="./testing-recipes.html#timers"><small>（例）</small></a>。<a href="https://jestjs.io/docs/en/timer-mocks">Jest</a>、<a href="https://sinonjs.org/releases/latest/fake-timers">sinon</a> や <a href="https://github.com/sinonjs/lolex">lolex</a> を含むほとんどのフレームワークにおいて、テストでモックタイマーを利用できます。<p>時には、タイマーのモックをやりたくない場合があります。例えばアニメーションや、タイミングに依存するエンドポイント（API レートリミッタなど）をテストしているのかもしれません。タイマーのモックが利用できるライブラリでは、テストあるいはスイートごとにモックを有効化・無効化できるようになっているため、どのようにテストを実行するかを明示的に選択できます。</section><section id="end-to-end-tests-aka-e2e-tests"class="level3"><h3>End-to-end テスト</h3><p>End-to-end テストは長いワークフロー、特にあなたの業務にとってとても重要なワークフロー（例えば支払いやサインアップ）をテストするのに有用です。これらのテストをする際は、本物のブラウザがアプリケーション全体をいかに描画し、本物の API エンドポイントからいかにデータを取得し、セッションやクッキーをいかに使い、さまざまなリンク間でいかにナビゲーションするかをすべて試験したいでしょう。また、おそらく DOM の状態だけではなく、バックエンドのデータに対する検証（例えばデータベースに更新が正しく永続化されているかの確認）も行いたいかもしれません。<p>このようなシナリオの場合は、<a href="https://www.cypress.io/">Cypress</a>、<a href="https://playwright.dev">Playwright</a> のようなフレームワークや <a href="https://pptr.dev/">Puppeteer</a> のようなライブラリを使うことで、複数のルート間をナビゲートし、ブラウザのみならず、必要に応じてバックエンド側の副作用についても検証を行うことができるでしょう。 <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>