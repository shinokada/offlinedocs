<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>ReactDOM</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="reactdom" class="level1">
      <h1>ReactDOM</h1>
      <p><code>react-dom</code> パッケージではアプリのトップレベルで使うための DOM 特有のメソッドを提供しています。また必要に応じて React モデルから外に出るための避難ハッチ用メソッドも提供しています。</p>
      <pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> <span class="token maybe-class-name">ReactDOM</span></span> <span class="token keyword module">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span></code></pre>
      <p>npm で ES5 を使っている場合は、以下のように書けます：</p>
      <pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token maybe-class-name">ReactDOM</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'react-dom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      <p><code>react-dom</code> パッケージはクライアント専用モジュールとサーバ専用モジュールも提供しています。</p>
      <ul>
        <li><a href="./react-dom-client.html"><code>react-dom/client</code></a></li>
        <li><a href="./react-dom-server.html"><code>react-dom/server</code></a></li>
      </ul>
      <section id="overview" class="level2">
        <h2>概要</h2>
        <p><code>react-dom</code> パッケージは以下のメソッドをエクスポートしています：</p>
        <ul>
          <li><a href="#createportal"><code>createPortal()</code></a></li>
          <li><a href="#flushsync"><code>flushSync()</code></a></li>
        </ul>
        <p>以下の <code>react-dom</code> メソッドもエクスポートされていますが、これらはレガシーです：</p>
        <ul>
          <li><a href="#render"><code>render()</code></a></li>
          <li><a href="#hydrate"><code>hydrate()</code></a></li>
          <li><a href="#finddomnode"><code>findDOMNode()</code></a></li>
          <li><a href="#unmountcomponentatnode"><code>unmountComponentAtNode()</code></a></li>
        </ul>
        <blockquote>
          <p>補足：</p>
          <p><code>render</code> と <code>hydrate</code> は React 18 でいずれも新しい<a href="./react-dom-client.html">クライアントメソッド</a>に置き換わりました。これらのメソッドを使った場合、React 17 と同様の動作となってしまう、という警告を表示します（詳細は<a href="https://reactjs.org/link/switch-to-createroot">こちら</a>）.</p>
        </blockquote>
        <section id="browser-support" class="level3">
          <h3>ブラウザサポート</h3>
          <p>React はすべてのモダンブラウザをサポートしていますが、古いバージョンを使う場合は<a href="./javascript-environment-requirements.html">いくつかのポリフィルが必要</a>です。</p>
          <blockquote>
            <p>補足</p>
            <p>React は ES5 メソッドやマイクロタスクをサポートしていない Internet Explorer のような古いブラウザをサポートしていません。ページ内に <a href="https://github.com/es-shims/es5-shim">es5-shim や es5-sham</a> のようなポリフィルが含まれている場合、古いブラウザでもアプリケーションが動作することがありますが、この手段を選択するかどうかは自己責任で判断してください。</p>
          </blockquote>
        </section>
      </section>
      <section id="reference" class="level2">
        <h2>リファレンス</h2>
        <section id="createportal-createportal" class="level3">
          <h3><code>createPortal()</code> {#createportal}</h3>
          <pre class="language-javascript"><code class="language-javascript"><span class="token function">createPortal</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> container<span class="token punctuation">)</span></code></pre>
          <p>ポータルを作成します。ポータルは <a href="./portals.html">DOM コンポーネントの階層の外側に存在している DOM ノードに対して子要素をレンダーする</a>方法を提供します。</p>
        </section>
        <section id="flushsync-flushsync" class="level3">
          <h3><code>flushSync()</code> {#flushsync}</h3>
          <pre class="language-javascript"><code class="language-javascript"><span class="token function">flushSync</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span></code></pre>
          <p>渡されたコールバック内の更新をすべて同期的に処理するよう強制します。これにより DOM が即座に更新されることが保証されます。</p>
          <pre class="language-javascript"><code class="language-javascript"><span class="token comment">// Force this state update to be synchronous.</span>
<span class="token function">flushSync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// By this point, DOM is updated.</span></code></pre>
          <blockquote>
            <p>補足：</p>
            <p><code>flushSync</code> はパフォーマンスを有意に低下させうるものです。慎重に使ってください。</p>
            <p><code>flushSync</code> によって保留中のサスペンスバウンダリは強制的に <code>fallback</code> 状態を表示するようになります。</p>
            <p><code>flushSync</code> は return する前に保留中の副作用も実行し、その内部にあるあらゆる更新を同期的に適用します。</p>
            <p><code>flushSync</code> はコールバック内の更新を適用するのに必要であれば渡されたコールバック外の更新も処理する可能性があります。例えば、クリックによって引き起こされた保留中の更新が既に存在する場合、React はコールバック内の更新を処理する前に先にそれらを処理します。</p>
          </blockquote>
        </section>
      </section>
      <section id="legacy-reference" class="level2">
        <h2>レガシーメソッドのリファレンス</h2>
        <section id="render-render" class="level3">
          <h3><code>render()</code> {#render}</h3>
          <pre class="language-javascript"><code class="language-javascript"><span class="token function">render</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> container<span class="token punctuation">[</span><span class="token punctuation">,</span> callback<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>
          <blockquote>
            <p>補足：</p>
            <p><code>render</code> は React 18 で <code>createRoot</code> に置き換わりました。詳細は <a href="./react-dom-client.html#createroot">createRoot</a> を参照してください。</p>
          </blockquote>
          <p>渡された container の DOM に React 要素をレンダーし、コンポーネントへの<a href="./more-about-refs.html">参照</a>（<a href="./components-and-props.html#function-and-class-components">ステートレスコンポーネント</a>の場合は null）を返します。</p>
          <p>React 要素がすでに <code>container</code> にレンダーされている場合は更新を行い、最新の React 要素を反映するために必要な DOM のみを変更します。</p>
          <p>オプションのコールバックが渡されている場合は、コンポーネントがレンダーまたは更新された後に実行されます。</p>
          <blockquote>
            <p>補足:</p>
            <p><code>render()</code> は与えられたコンテナの内容を制御します。コンテナ内部のあらゆる既存の DOM 要素は、最初に呼び出された時に置き換えられます。後続する呼び出しでは効率的な更新のために React の DOM 差分アルゴリズムを使用します。</p>
            <p><code>render()</code> はコンテナノードを変更しません（コンテナの子要素のみ変更します）。既存の子要素を上書きせずにコンポーネントを既存の DOM ノードに挿入することが可能な場合があります。</p>
            <p>
              <code>render()</code> は現時点ではルートの <code>ReactComponent</code> インスタンスへの参照を返します。
              しかし、この戻り値を使用する方法は古く、将来のバージョンの React では一部のケースで非同期にコンポーネントをレンダーするようになる可能性があるため、使用は避けるべきです。
              ルートの <code>ReactComponent</code> インスタンスへの参照が必要な場合は、ルート要素に<a href="./refs-and-the-dom.html#callback-refs">コールバック形式の ref</a> を追加することを推奨します。
            </p>
            <p>サーバで描画されたコンテナをクライアントで再利用するために <code>ReactDOM.render()</code> を使用することは非推奨となっています。代わりに <a href="./react-dom-client.html#hydrateroot"><code>hydrateRoot()</code></a> を使用してください。</p>
          </blockquote>
          <hr>
        </section>
        <section id="hydrate-hydrate" class="level3">
          <h3><code>hydrate()</code> {#hydrate}</h3>
          <pre class="language-javascript"><code class="language-javascript"><span class="token function">hydrate</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> container<span class="token punctuation">[</span><span class="token punctuation">,</span> callback<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>
          <blockquote>
            <p>Note:</p>
            <p><code>hydrate</code> は React 18 で <code>hydrateRoot</code> に置き換わりました。詳細は <a href="./react-dom-client.html#hydrateroot">hydrateRoot</a> を参照してください。</p>
          </blockquote>
          <p><a href="#render"><code>render()</code></a> と同様ですが、<a href="./react-dom-server.html"><code>ReactDOMServer</code></a> により HTML コンテンツが描画されたコンテナをクライアントで再利用する（ハイドレーション）ために使用されます。React は既存のマークアップにイベントリスナをアタッチしようとします。</p>
          <p>React はレンダーされる内容が、サーバ・クライアント間で同一であることを期待します。React はテキストコンテンツの差異を修復することは可能ですが、その不一致はバグとして扱い、修正すべきです。開発用モードでは、React は両者のレンダーの不一致について警告します。不一致がある場合に属性の差異が修復されるという保証はありません。これはパフォーマンス上の理由から重要です。なぜなら、ほとんどのアプリケーションにおいて不一致が発生するということは稀であり、全てのマークアップを検証することは許容不可能なほど高コストになるためです。</p>
          <p>単一要素の属性やテキストコンテンツがサーバ・クライアント間においてやむを得ず異なってしまう場合（例えばタイムスタンプなど）、要素に <code>suppressHydrationWarning={true}</code> を追加することで警告の発生を停止させることが可能です。それは 1 階層下の要素までで機能するものであり、また避難ハッチとして使われるものです。そのため、多用しないでください。テキストコンテンツでない限り、React は修復を試行しようとはしないため、将来の更新まで不整合が残る可能性があります。</p>
          <p>サーバとクライアントで異なるものをレンダーしたい場合は、2 パスレンダーを使用できます。クライアント側で異なるものをレンダーするコンポーネントでは、<code>this.state.isClient</code> のような state 変数を読み込み、<code>componentDidMount()</code> で <code>true</code> を設定することができます。こうすると、最初のレンダーパスではサーバ側と同一の内容を描画して不一致を回避しますが、追加のパスが初回レンダーの直後に同期的に発生します。このアプローチでは 2 回レンダーが発生することによりコンポーネントのパフォーマンスが低下しますので、注意して使用してください。</p>
          <p>低速な接続下でのユーザ体験に留意することを忘れないでください。JavaScript のコードは初回の HTML の描画より大幅に遅れてロードされる可能性があるため、クライアントでのみ何か異なるものを描画した場合、その変化は不快感を与える可能性があります。しかしうまく実行されれば、サーバ上でアプリケーションの「外枠」を描画し、クライアント上でのみ追加のウィジェットを表示することは有益になるかもしれません。マークアップの不一致の問題を発生させずにこれを実行する方法については、前の段落の説明をご参照ください。</p>
          <hr>
        </section>
        <section id="unmountcomponentatnode-unmountcomponentatnode" class="level3">
          <h3><code>unmountComponentAtNode()</code> {#unmountcomponentatnode}</h3>
          <pre class="language-javascript"><code class="language-javascript"><span class="token function">unmountComponentAtNode</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span></code></pre>
          <blockquote>
            <p>補足：</p>
            <p><code>unmountComponentAtNode</code> は React 18 で <code>root.unmount()</code> に置き換わりました。詳細は <a href="./react-dom-client.html#createroot">createRoot</a> を参照してください。</p>
          </blockquote>
          <p>DOM からマウントされた React コンポーネントを削除し、イベントハンドラや state をクリーンアップします。コンテナにコンポーネントがマウントされていない場合、このメソッドを呼び出しても何も行いません。コンポーネントがアンマウントされた場合は <code>true</code> を返し、アンマウントすべきコンポーネントが存在しなかった場合は <code>false</code> を返します。</p>
          <hr>
        </section>
        <section id="finddomnode-finddomnode" class="level3">
          <h3><code>findDOMNode()</code> {#finddomnode}</h3>
          <blockquote>
            <p>補足:</p>
            <p><code>findDOMNode</code> は内在する DOM ノードにアクセスするために使用される避難ハッチです。ほとんどのケースにおいて、この避難ハッチの使用はコンポーネントの抽象化に穴を開けてしまうためおすすめしません。<a href="./strict-mode.html#warning-about-deprecated-finddomnode-usage"><code>StrictMode</code> では非推奨になっています。</a></p>
          </blockquote>
          <pre class="language-javascript"><code class="language-javascript"><span class="token function">findDOMNode</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span></code></pre>
          <p>DOM にこのコンポーネントがマウントされている場合、このメソッドは対応するネイティブブラウザの DOM 要素を返します。このメソッドはフォームフィールドの値や DOM の大きさを計測するのに便利です。<strong>ほとんどのケースにおいて、DOM ノードに ref をアタッチすることで <code>findDOMNode</code> の使用を避けることができます。</strong></p>
          <p>コンポーネントが <code>null</code> や <code>false</code> をレンダーする場合、<code>findDOMNode</code> は <code>null</code> を返します。コンポーネントが文字列をレンダーする場合、<code>findDOMNode</code> はその値を含んだテキスト DOM ノードを返します。React 16 以降、コンポーネントは複数の子要素を含むフラグメントを返すことがありますが、その場合 <code>findDOMNode</code> は最初の空でない子要素に対応する DOM ノードを返します。</p>
          <blockquote>
            <p>補足:</p>
            <p><code>findDOMNode</code> はマウントされたコンポーネントに対してのみ機能します（つまり、DOM に配置されたコンポーネント）。まだマウントされていないコンポーネントにおいてこのメソッドを呼ぼうとする場合（まだ作成されていないコンポーネントにおける <code>render()</code> の中で <code>findDOMNode()</code> を呼びだす場合など）、例外がスローされます。</p>
            <p><code>findDOMNode</code> は関数コンポーネントでは使用できません。</p>
          </blockquote>
          <hr>
          <p><span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span></p>
        </section>
      </section>
    </section>
  </body>
</html>
