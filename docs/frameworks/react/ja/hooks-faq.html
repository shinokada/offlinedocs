<!doctype html><html lang="ja"><meta charset="utf-8"><title>フックに関するよくある質問</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="フックに関するよくある質問"class="level1"><h1>フックに関するよくある質問</h1><p><em>フック (hook)</em> は React 16.8 で追加された新機能です。state などの React の機能を、クラスを書かずに使えるようになります。<p>このページでは<a href="./hooks-overview.html">フック</a>に関するよくある質問にいくつかお答えします。<ul><li><strong><a href="#adoption-strategy">導入の指針</a></strong><ul><li><a href="#which-versions-of-react-include-hooks">フックが使える React のバージョンはどれですか？</a><li><a href="#do-i-need-to-rewrite-all-my-class-components">クラスコンポーネントを全部書き換える必要があるのですか？</a><li><a href="#what-can-i-do-with-hooks-that-i-couldnt-with-classes">クラスではできず、フックでできるようになることは何ですか？</a><li><a href="#how-much-of-my-react-knowledge-stays-relevant">これまでの React の知識はどの程度使えますか？</a><li><a href="#should-i-use-hooks-classes-or-a-mix-of-both">フック、クラスのいずれを使うべきですか、あるいはその両方でしょうか？</a><li><a href="#do-hooks-cover-all-use-cases-for-classes">フックはクラスのユースケースのすべてをカバーしていますか？</a><li><a href="#do-hooks-replace-render-props-and-higher-order-components">フックはレンダープロップや高階コンポーネントを置き換えるものですか？</a><li><a href="#what-do-hooks-mean-for-popular-apis-like-redux-connect-and-react-router">Redux の connect() や React Router といった人気の API はフックによりどうなりますか？</a><li><a href="#do-hooks-work-with-static-typing">フックは静的型付けと組み合わせてうまく動きますか？</a><li><a href="#how-to-test-components-that-use-hooks">フックを使ったコンポーネントはどのようにテストするのですか？</a><li><a href="#what-exactly-do-the-lint-rules-enforce">Lint ルールは具体的に何を強制するのですか？</a></ul><li><strong><a href="#from-classes-to-hooks">クラスからフックへ</a></strong><ul><li><a href="#how-do-lifecycle-methods-correspond-to-hooks">個々のライフサイクルメソッドはフックとどのように対応するのですか？</a><li><a href="#how-can-i-do-data-fetching-with-hooks">フックでデータの取得をどのように行うのですか？</a><li><a href="#is-there-something-like-instance-variables">インスタンス変数のようなものはありますか？</a><li><a href="#should-i-use-one-or-many-state-variables">state 変数は 1 つにすべきですか、たくさん使うべきですか？</a><li><a href="#can-i-run-an-effect-only-on-updates">コンポーネントの更新のときだけ副作用を実行することは可能ですか？</a><li><a href="#how-to-get-the-previous-props-or-state">前回の props や state はどうすれば取得できますか？</a><li><a href="#why-am-i-seeing-stale-props-or-state-inside-my-function">関数内で古い props や state が見えているのはなぜですか？</a><li><a href="#how-do-i-implement-getderivedstatefromprops">どうすれば getDerivedStateFromProps を実装できますか？</a><li><a href="#is-there-something-like-forceupdate">forceUpdate のようなものはありますか？</a><li><a href="#can-i-make-a-ref-to-a-function-component">関数コンポーネントへの ref を作ることは可能ですか？</a><li><a href="#how-can-i-measure-a-dom-node">DOM ノードの位置やサイズの測定はどのように行うのですか？</a><li><a href="#what-does-const-thing-setthing--usestate-mean">const [thing, setThing] = useState() というのはどういう意味ですか？</a></ul><li><strong><a href="#performance-optimizations">パフォーマンス最適化</a></strong><ul><li><a href="#can-i-skip-an-effect-on-updates">更新時に副作用をスキップすることはできますか？</a><li><a href="#is-it-safe-to-omit-functions-from-the-list-of-dependencies">依存の配列から関数を省略しても大丈夫ですか？</a><li><a href="#what-can-i-do-if-my-effect-dependencies-change-too-often">副作用の依存リストが頻繁に変わりすぎる場合はどうすればよいですか？</a><li><a href="#how-do-i-implement-shouldcomponentupdate">どうすれば <code>shouldComponentUpdate</code> を実装できますか？</a><li><a href="#how-to-memoize-calculations">計算結果のメモ化はどのように行うのですか？</a><li><a href="#how-to-create-expensive-objects-lazily">計算量の大きいオブジェクトの作成を遅延する方法はありますか？</a><li><a href="#are-hooks-slow-because-of-creating-functions-in-render">レンダー内で関数を作るせいでフックは遅くなるのではないですか？</a><li><a href="#how-to-avoid-passing-callbacks-down">どうすれば複数のコールバックを深く受け渡すのを回避できますか？</a><li><a href="#how-to-read-an-often-changing-value-from-usecallback">useCallback からの頻繁に変わる値を読み出す方法は？</a></ul><li><strong><a href="#under-the-hood">内部の仕組み</a></strong><ul><li><a href="#how-does-react-associate-hook-calls-with-components">React はフック呼び出しとコンポーネントとをどのように関連付けているのですか？</a><li><a href="#what-is-the-prior-art-for-hooks">フックの先行技術にはどのようなものがありますか？</a></ul></ul><section id="adoption-strategy"class="level2"><h2>導入の指針</h2><section id="which-versions-of-react-include-hooks"class="level3"><h3>フックが使える React のバージョンはどれですか？</h3><p>React バージョン 16.8.0 より、以下においてフックの安定版の実装が含まれています。<ul><li>React DOM<li>React Native<li>React DOM Server<li>React Test Renderer<li>React Shallow Renderer</ul><p><strong>フックを利用するには、すべての React のパッケージが 16.8.0 以上である必要があります</strong>。例えば React DOM の更新を忘れた場合、フックは動作しません。<p>React Native は<a href="https://reactnative.dev/blog/2019/03/12/releasing-react-native-059">バージョン 0.59</a> 以降でフックをサポートします。</section><section id="do-i-need-to-rewrite-all-my-class-components"class="level3"><h3>クラスコンポーネントを全部書き換える必要があるのですか？</h3><p>いいえ。React からクラスを削除する<a href="./hooks-intro.html#gradual-adoption-strategy">予定はありません</a> -- 我々はみなプロダクトを世に出し続ける必要があり、クラスを書き換えている余裕はありません。新しいコードでフックを試すことをお勧めします。</section><section id="what-can-i-do-with-hooks-that-i-couldnt-with-classes"class="level3"><h3>クラスではできず、フックでできるようになることは何ですか？</h3><p>フックにより、コンポーネント間で機能を再利用するためのパワフルで表現力の高い手段が得られます。<a href="./hooks-custom.html">"独自フックの作成"</a>を読めばできることの概要が掴めるでしょう。React のコアチームメンバーによって書かれた<a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889">この記事</a>により、フックによって新たにもたらされる可能性についての洞察が得られます。</section><section id="how-much-of-my-react-knowledge-stays-relevant"class="level3"><h3>これまでの React の知識はどの程度使えますか？</h3><p>フックとは、state やライフサイクル、コンテクストや ref といった、あなたが既に知っている React の機能をより直接的に利用できるようにする手段です。React の動作が根本的に変わるようなものではありませんし、コンポーネントや props、トップダウンのデータの流れについての知識はこれまでと同様に重要です。<p>もちろんフックにはフックなりの学習曲線があります。このドキュメントに足りないことを見つけたら <a href="https://github.com/reactjs/reactjs.org/issues/new">Issue を報告</a>していただければ、お手伝いします。</section><section id="should-i-use-hooks-classes-or-a-mix-of-both"class="level3"><h3>フック、クラスのいずれを使うべきですか、あるいはその両方でしょうか？</h3><p>準備ができしだい、新しいコンポーネントでフックを試すことをお勧めします。チームの全員の準備が完了し、このドキュメントに馴染んでいることを確かめましょう。（例えばバグを直すなどの理由で）何にせよ書き換える予定の場合を除いては、既存のクラスをフックに書き換えることはお勧めしません。<p>クラスコンポーネントの<em>定義内で</em>フックを使うことはできませんが、クラス型コンポーネントとフックを使った関数コンポーネントとを 1 つのコンポーネントツリー内で混在させることは全く問題ありません。あるコンポーネントがクラスで書かれているかフックを用いた関数で書かれているかというのは、そのコンポーネントの実装の詳細です。長期的には、フックが React のコンポーネントを書く際の第一選択となることを期待しています。</section><section id="do-hooks-cover-all-use-cases-for-classes"class="level3"><h3>フックはクラスのユースケースのすべてをカバーしていますか？</h3><p>我々の目標はできるだけ早急にフックがすべてのクラスのユースケースをカバーできるようにすることです。まだ使用頻度の低い <code>getSnapshotBeforeUpdate</code>、<code>getDerivedStateFromError</code> および <code>componentDidCatch</code> についてはフックでの同等物が存在していませんが、すぐに追加する予定です。</section><section id="do-hooks-replace-render-props-and-higher-order-components"class="level3"><h3>フックはレンダープロップや高階コンポーネントを置き換えるものですか？</h3><p>レンダープロップや高階コンポーネントは、ひとつの子だけをレンダーすることがよくあります。フックはこのようなユースケースを実現するより簡単な手段だと考えています。これらのパターンには引き続き利用すべき場面があります（例えば、バーチャルスクローラーコンポーネントは <code>renderItem</code> プロパティを持つでしょうし、コンテナコンポーネントは自分自身の DOM 構造を有しているでしょう）。とはいえ大抵の場合ではフックで十分であり、フックがツリーのネストを減らすのに役立つでしょう。</section><section id="what-do-hooks-mean-for-popular-apis-like-redux-connect-and-react-router"class="level3"><h3>Redux の <code>connect()</code> や React Router といった人気の API はフックによりどうなりますか？</h3><p>これまでと同様に全く同じ API を使用し続けることができます。それらは動作し続けます。<p>React Redux は v7.1.0 より <a href="https://react-redux.js.org/api/hooks">フック API をサポート</a>しており、<code>useDispatch</code> や <code>useSelector</code> といったフックを提供しています。<p>React Router は v5.1 より <a href="https://reacttraining.com/react-router/web/api/Hooks">フック API をサポート</a> しています。<p>他のライブラリも、将来的にフックをサポートするかもしれません。</section><section id="do-hooks-work-with-static-typing"class="level3"><h3>フックは静的型付けと組み合わせてうまく動きますか？</h3><p>フックは静的型付けを念頭に設計されました。フックは関数ですので、高階コンポーネントのようなパターンと比較しても正しく型付けするのは容易です。最新版の Flow と TypeScript における React の型定義には、React のフックについてのサポートが含まれています。<p>重要なことですが、もしより厳密に型付けしたい場合は、カスタムフックを使うことで React API に何らかの制約を加えることが可能です。React は基本部品を提供しますが、最初から提供されているものと違う方法でそれらを様々に組み合わせることができます。</section><section id="how-to-test-components-that-use-hooks"class="level3"><h3>フックを使ったコンポーネントはどのようにテストするのですか？</h3><p>React の観点から見れば、フックを使ったコンポーネントは単なる普通のコンポーネントです。あなたのテストソリューションが React の内部動作に依存しているのでない場合、フックを使ったコンポーネントのテストのやり方は、あなたが普段コンポーネントをテストしているやり方と変わらないはずです。<blockquote><p>補足<p><a href="./testing-recipes.html">テストのレシピ集</a>にコピー・ペーストで使えるたくさんの例が掲載されています。</blockquote><p>例えばこのようなカウンタコンポーネントがあるとしましょう：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Example</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token maybe-class-name">You</span> clicked <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times<span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Click</span> me
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>これを React DOM を使ってテストします。ブラウザでの挙動と確実に合致させるため、これをレンダーしたり更新したりするコードを <a href="./test-utils.html#act"><code>ReactTestUtils.act()</code></a> でラップします：<pre class="language-js{3,20-22,29-31}"><code class="language-js{3,20-22,29-31}">import React from 'react';
import ReactDOM from 'react-dom/client';
import { act } from 'react-dom/test-utils';
import Counter from './Counter';

let container;

beforeEach(() => {
  container = document.createElement('div');
  document.body.appendChild(container);
});

afterEach(() => {
  document.body.removeChild(container);
  container = null;
});

it('can render and update a counter', () => {
  // Test first render and effect
  act(() => {
    ReactDOM.createRoot(container).render(&#x3C;Counter />);
  });
  const button = container.querySelector('button');
  const label = container.querySelector('p');
  expect(label.textContent).toBe('You clicked 0 times');
  expect(document.title).toBe('You clicked 0 times');

  // Test second render and effect
  act(() => {
    button.dispatchEvent(new MouseEvent('click', {bubbles: true}));
  });
  expect(label.textContent).toBe('You clicked 1 times');
  expect(document.title).toBe('You clicked 1 times');
});</code></pre><p><code>act()</code> を呼び出すと内部の副作用も処理されます。<p>カスタムフックをテストしたい場合は、テスト内でコンポーネントを作って中でそのカスタムフックを使うようにしてください。そうすればそのコンポーネントをテストできます。<p>ボイラープレートを減らすため、エンドユーザが使うのと同じ形でコンポーネントを使ってテストが記述できるように設計されている、<a href="https://testing-library.com/react">React Testing Library</a> の利用をお勧めします。<p>詳細については、<a href="./testing-recipes.html">テストのレシピ集</a>をご覧ください。</section><section id="what-exactly-do-the-lint-rules-enforce"class="level3"><h3><a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">Lint ルール</a>は具体的に何を強制するのですか？</h3><p>我々は <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">ESLint プラグイン</a>を提供しており、これにより<a href="./hooks-rules.html">フックのルール</a>を強制してバグを減らすことができます。このルールは、<code>use</code> で始まり大文字が続くような名前の関数はすべてフックであると仮定します。これは不完全な推測手段であり過剰検出があるかもしれないことは認識していますが、エコシステム全体での規約なくしてはフックはうまく動作しません。また名前を長くするとフックを利用したり規約を守ったりしてくれなくなるでしょう。<p>具体的には、このルールは以下を強制します：<ul><li>フックの呼び出しが <code>PascalCase</code> 名の関数内（コンポーネントと見なされます）か、あるいは他の <code>useSomething</code> 式の名前の関数内（カスタムフックと見なされます）にあること。<li>すべてのレンダー間でフックが同じ順番で呼び出されること。</ul><p>これ以外にも幾つかの推測を行っており、また、バグ検出と過剰検出抑制とのバランスを調整していくなかで、これらは将来的に変わる可能性があります。</section></section><section id="from-classes-to-hooks"class="level2"><h2>クラスからフックへ</h2><section id="how-do-lifecycle-methods-correspond-to-hooks"class="level3"><h3>個々のライフサイクルメソッドはフックとどのように対応するのですか？</h3><ul><li><p><code>constructor</code>: 関数コンポーネントはコンストラクタを必要としません。state は <a href="./hooks-reference.html#usestate"><code>useState</code></a> を呼び出すときに初期化します。初期 state の計算が高価である場合、<code>useState</code> に関数を渡すことができます。<li><p><code>getDerivedStateFromProps</code>: <a href="#how-do-i-implement-getderivedstatefromprops">レンダー中に</a>更新をスケジューリングします。<li><p><code>shouldComponentUpdate</code>: ページ<a href="#how-do-i-implement-shouldcomponentupdate">下部の</a> <code>React.memo</code> についての説明を参照してください。<li><p><code>render</code>: これは関数コンポーネントの本体そのものです。<li><p><code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>: これらのあらゆる組み合わせは <a href="./hooks-reference.html#useeffect"><code>useEffect</code> フック</a>で表現できます（<a href="#can-i-skip-an-effect-on-updates">これ</a>や<a href="#can-i-run-an-effect-only-on-updates">これ</a>のような頻度の低いケースも含め）。<li><p><code>getSnapshotBeforeUpdate</code>、<code>componentDidCatch</code> および <code>getDerivedStateFromError</code>: フックによる同等物はまだ存在していませんが、近日中に追加される予定です。</ul></section><section id="how-can-i-do-data-fetching-with-hooks"class="level3"><h3>フックでデータの取得をどのように行うのですか？</h3><p>まずはこちらの<a href="https://codesandbox.io/s/jvvkoo8pq3">小さなデモ</a>をご覧ください。フックを使ってデータの取得をする方法について詳しく学ぶには<a href="https://www.robinwieruch.de/react-hooks-fetch-data/">こちらの記事</a>を参照してください。</section><section id="is-there-something-like-instance-variables"class="level3"><h3>インスタンス変数のようなものはありますか？</h3><p>はい！ <a href="./hooks-reference.html#useref"><code>useRef()</code></a> フックは DOM への参照を保持するためだけにあるのではありません。"ref" オブジェクトは汎用のコンテナであり、その <code>current</code> プロパティの値は書き換え可能かつどのような値でも保持することができますので、クラスのインスタンス変数と同様に利用できます。<p>例えば <code>useEffect</code> 内から "ref" オブジェクトを書き換えることができます。<pre class="language-js{2,8}"><code class="language-js{2,8}">function Timer() {
  const intervalRef = useRef();

  useEffect(() => {
    const id = setInterval(() => {
      // ...
    });
    intervalRef.current = id;
    return () => {
      clearInterval(intervalRef.current);
    };
  });

  // ...
}</code></pre><p>単にインターバルをセットしたいだけであれば（<code>id</code> はこの副作用内でローカルでよいので）この ref は必要ないところですが、もしもイベントハンドラ内でインターバルをクリアしたい場合には便利です：<pre class="language-js{3}"><code class="language-js{3}">  // ...
  function handleCancelClick() {
    clearInterval(intervalRef.current);
  }
  // ...</code></pre><p>概念的には、ref はクラスにおけるインスタンス変数と似たものだと考えることができます。<a href="#how-to-create-expensive-objects-lazily">遅延初期化</a>をしたい場合を除き、レンダーの最中に ref を書き換えることはしないでください。その代わり、通常 ref はイベントハンドラや副作用内でだけ書き換えるようにしましょう。</section><section id="should-i-use-one-or-many-state-variables"class="level3"><h3>state 変数は 1 つにすべきですか、たくさん使うべきですか？</h3><p>これまでクラスを使っていたなら、<code>useState()</code> を 1 回だけ呼んで、1 つのオブジェクト内にすべての state を入れたくなるかもしれません。そうしたければそのようにすることもできます。以下はマウスの動作を追跡するコンポーネントの例です。位置やサイズの情報を 1 つのローカル state に保持しています。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Box</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">left</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">top</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">width</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>ここで例えば、ユーザがマウスを動かしたときに <code>left</code> と <code>top</code> を変更したいとしましょう。この際、これらのフィールドを古い state に手動でマージしないといけないことに注意してください：<pre class="language-js{4,5}"><code class="language-js{4,5}">  // ...
  useEffect(() => {
    function handleWindowMouseMove(e) {
      // Spreading "...state" ensures we don't "lose" width and height
      setState(state => ({ ...state, left: e.pageX, top: e.pageY }));
    }
    // Note: this implementation is a bit simplified
    window.addEventListener('mousemove', handleWindowMouseMove);
    return () => window.removeEventListener('mousemove', handleWindowMouseMove);
  }, []);
  // ...</code></pre><p>これは state 変数を更新する時には変数の値が<em>置換</em>されるからです。これは更新されるフィールドがオブジェクトに<em>マージ</em>されるというクラスでの <code>this.setState</code> の挙動とは異なります。<p>自動マージがないとつらい場合は、<code>useLegacyState</code> のようなカスタムフックを書いてオブジェクト型の state の更新をマージするようにすることはできます。しかし、我々は代わりに、<strong>どの値が一緒に更新されやすいのかに基づいて、state を複数の state 変数に分割することをお勧めします。</strong><p>例えば、コンポーネントの state を <code>position</code> と <code>size</code> という複数のオブジェクトに分割して、マージを行わなくても <code>position</code> を常に新たな値で置換するようにできるでしょう。<pre class="language-js{2,7}"><code class="language-js{2,7}">function Box() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  const [size, setSize] = useState({ width: 100, height: 100 });

  useEffect(() => {
    function handleWindowMouseMove(e) {
      setPosition({ left: e.pageX, top: e.pageY });
    }
    // ...</code></pre><p>互いに独立した state 変数を分割することには別の利点もあります。そうすることで後からそのロジックをカスタムフックに抽出しやすくなるのです。例えば：<pre class="language-js{2,7}"><code class="language-js{2,7}">function Box() {
  const position = useWindowPosition();
  const [size, setSize] = useState({ width: 100, height: 100 });
  // ...
}

function useWindowPosition() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  useEffect(() => {
    // ...
  }, []);
  return position;
}</code></pre><p><code>position</code> の state 変数に対する <code>useState</code> の呼び出しとそれに関連する副作用を、それらのコードを変えずにカスタムフックに移行できたことに注意してください。もしすべての state が単一のオブジェクトに入っていたら、抽出するのはもっと困難だったでしょう。<p>すべての state を 1 つの <code>useState</code> 呼び出しに含めても動作しますし、フィールドごとに別に <code>useState</code> を持たせることでも動作はします。しかしこれらの両極端の間でうまくバランスを取り、少数の独立した state 変数に関連する state をグループ化することで、コンポーネントは最も読みやすくなります。state のロジックが複雑になった場合は、それを<a href="./hooks-reference.html#usereducer">リデューサで管理する</a>か、カスタムフックを書くことをお勧めします。</section><section id="can-i-run-an-effect-only-on-updates"class="level3"><h3>コンポーネントの更新のときだけ副作用を実行することは可能ですか？</h3><p>これは稀なユースケースです。必要であれば、<a href="#is-there-something-like-instance-variables">変更可能な ref</a> を使って、初回レンダー中なのか更新中なのかに対応する真偽値を手動で保持し、副作用内でその値を参照するようにすることができます（このようなことを何度もやる場合は、そのためのカスタムフックを書くことができます）。</section><section id="how-to-get-the-previous-props-or-state"class="level3"><h3>前回の props や state はどうすれば取得できますか？</h3><p>前回の props や state が欲しくなるというケースは 2 つあります。<p>ひとつは、前回の props を<strong>副作用のクリーンアップ</strong>に使用したいという場合です。例えば、<code>userId</code> プロパティに基づいてソケットを購読する副作用を書いている場合などです。<code>userId</code> プロパティが変化した場合、<strong>ひとつ前</strong>の <code>useId</code> の購読を解除して<strong>次</strong>のものを購読したくなるでしょう。ですがこれを実現するのに、特別なことをする必要はありません：<pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToSocket</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">userId</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromSocket</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">userId</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>props<span class="token punctuation">.</span><span class="token property-access">userId</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上記の例では、<code>userId</code> が <code>3</code> から <code>4</code> に変わった場合、<code>ChatAPI.unsubscribeFromSocket(3)</code> が最初に走り、その後に <code>ChatAPI.subscribeToSocket(4)</code> が走ります。クリーンアップ関数は「前回」の <code>userId</code> をクロージャとしてキャプチャしていますので、前回の値を取得する必要はありません。<p>別の場面では、<strong>props や他の state の変更に基づいて state を調整したい</strong>ということがあるかもしれません。これはめったに必要なものではありませんし、通常はコードに重複した冗長な state があるというサインです。しかしこれが必要な稀なパターンでは、<a href="#how-do-i-implement-getderivedstatefromprops">前の state や props を state に保存してレンダー中に更新する</a>ことができます。<p>これまで <code>usePrevious</code> というカスタムフックを使うことを提案していましたが、ほとんどのユースケースは上記の 2 つのパターンのいずれかに当てはまることがわかりました。もしもこのユースケースが当てはまらない場合は、<a href="#is-there-something-like-instance-variables">値を ref に保持</a>し、必要に応じて手作業でアップデートすることができます。レンダー中に ref を読み出したり変更したりするとコンポーネントの挙動を予想・理解するのが難しくなるため、避けるようにしてください。</section><section id="why-am-i-seeing-stale-props-or-state-inside-my-function"class="level3"><h3>関数内で古い props や state が見えているのはなぜですか？</h3><p>イベントハンドラにせよ副作用関数にせよ、コンポーネント内に書かれた関数からは、その関数が作成された時の props や state が「見え」ます。以下のような例を考えてみましょう：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Example</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleAlertClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'You clicked on: '</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token maybe-class-name">You</span> clicked <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times<span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Click</span> me
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleAlertClick<span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Show</span> alert
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>最初に "Show alert" ボタンをクリックして、次にカウンタを増加させた場合、アラートダイアログに表示されるのは <strong>"Show alert" ボタンをクリックした時点での</strong> <code>count</code> 変数の値になります。これにより props や state が変わらないことを前提として書かれたコードによるバグが防止できます。<p>非同期的に実行されるコールバック内で、意図的に state の<em>最新</em>の値を読み出したいという場合は、その値を <a href="./hooks-faq.html#is-there-something-like-instance-variables">ref</a> 内に保持して、それを書き換えたり読み出したりすることができます。<p>最後に、古い props や state が見えている場合に考えられる他の理由は、「依存の配列」による最適化を使った際に正しく依存する値の全部を指定しなかった、というものです。例えば副作用フックの第 2 引数に <code>[]</code> を指定したにも関わらず副作用内で <code>someProps</code> を読み出しているという場合、副作用関数内では <code>someProps</code> の初期値がずっと見え続けることになります。解決方法は依存配列自体を削除するか、配列の中身を修正することです。<a href="#is-it-safe-to-omit-functions-from-the-list-of-dependencies">関数の扱い方</a>、および依存する値の変化を誤って無視することなく副作用の実行回数を減らすための<a href="#what-can-i-do-if-my-effect-dependencies-change-too-often">よくある手法</a>についてもご覧ください。<blockquote><p>補足<p><a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> という ESLint のルールを <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> パッケージの一部として提供しています。依存配列が正しく指定されていない場合に警告し、修正を提案します。</blockquote></section><section id="how-do-i-implement-getderivedstatefromprops"class="level3"><h3>どうすれば <code>getDerivedStateFromProps</code> を実装できますか？</h3><p>おそらくそのようなものは<a href="/blog/2018/06/07/you-probably-dont-need-derived-state.html">必要ない</a>のですが、これが本当に必要になる稀なケースでは（例えば <code>&#x3C;Transition></code> コンポーネントを実装するときなど）、レンダーの最中に state を更新することができます。React は最初のレンダーの終了直後に更新された state を使ってコンポーネントを再実行しますので、計算量は高くなりません。<p>以下の例では、<code>row</code> プロパティの前回の値を state 変数に格納し後で比較できるようにしています：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ScrollView</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>row<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isScrollingDown<span class="token punctuation">,</span> setIsScrollingDown<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>prevRow<span class="token punctuation">,</span> setPrevRow<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>row <span class="token operator">!==</span> prevRow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Row changed since last render. Update isScrollingDown.</span>
    <span class="token function">setIsScrollingDown</span><span class="token punctuation">(</span>prevRow <span class="token operator">!==</span> <span class="token keyword null nil">null</span> <span class="token operator">&#x26;&#x26;</span> row <span class="token operator">></span> prevRow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setPrevRow</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Scrolling down: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isScrollingDown<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>これは最初は奇妙に見えるかもしれませんが、これまでも概念的には <code>getDerivedStateFromProps</code> はレンダー中に更新を行うというのがまさに目的でした。</section><section id="is-there-something-like-forceupdate"class="level3"><h3>forceUpdate のようなものはありますか？</h3><p><code>useState</code> フックと <code>useReducer</code> フックのいずれも、前回と今回で値が同じである場合は<a href="./hooks-reference.html#bailing-out-of-a-state-update">更新を回避</a>します。適当な場所で state を変化させた後に <code>setState</code> を呼び出しても再レンダーは発生しません。<p>通常、React でローカル state を直接変更すべきではありません。しかし避難ハッチとして、カウンターを使って state が変化していない場合でも再レンダーを強制することが可能です。<pre class="language-js"><code class="language-js">  <span class="token keyword">const</span> <span class="token punctuation">[</span>ignored<span class="token punctuation">,</span> forceUpdate<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token arrow operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">forceUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre><p>可能であればこのパターンは避けるようにしてください。</section><section id="can-i-make-a-ref-to-a-function-component"class="level3"><h3>関数コンポーネントへの ref を作ることは可能ですか？</h3><p>このようなことをする必要はあまりないはずですが、命令型のメソッドを親コンポーネントに公開するために <a href="./hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a> フックを利用することができます。</section><section id="how-can-i-measure-a-dom-node"class="level3"><h3>DOM ノードの位置やサイズの測定はどのように行うのですか？</h3><p>DOM ノードの位置やサイズを測定するための基本的な方法として、<a href="./refs-and-the-dom.html#callback-refs">コールバック形式の ref</a> が利用できます。React は ref が異なるノードに割り当てられるたびにコールバックを呼び出します。こちらの<a href="https://codesandbox.io/s/l7m0v5x4v9">小さなデモ</a>をご覧ください。<pre class="language-js{4-8,12}"><code class="language-js{4-8,12}">function MeasureExample() {
  const [height, setHeight] = useState(0);

  const measuredRef = useCallback(node => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  }, []);

  return (
    &#x3C;>
      &#x3C;h1 ref={measuredRef}>Hello, world&#x3C;/h1>
      &#x3C;h2>The above header is {Math.round(height)}px tall&#x3C;/h2>
    &#x3C;/>
  );
}</code></pre><p>この例で <code>useRef</code> を使わなかったのは、オブジェクト型の ref には現在値が変わった時にそれを通知する機能がないためです。コールバック ref を使うことで、<a href="https://codesandbox.io/s/818zzk8m78">子コンポーネントが測定されたノードを（例えばクリックに応じて）後から表示する場合でも</a>、親コンポーネントの側でその変更について通知を受け取り、測定値を反映させることができます。<p><code>useCallback</code> の依存値の配列として <code>[]</code> を渡したことに注意してください。これにより我々の ref コールバックが再レンダーごとに変化しないことが保証され、React が不必要にその関数を呼ばないで済みます。<p>この例では、レンダーされている <code>&#x3C;h1></code> はどの再レンダー間でも同じように存在するため、コールバック ref はコンポーネントのマウント時とアンマウント時にのみ呼び出されます。コンポーネントのリサイズが発生した際に毎回通知を受け取りたい場合は、<a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code>ResizeObserver</code></a> や、これを使って作成されているサードパーティのフックの利用を検討してください。<p>お望みであれば再利用可能なフックとして<a href="https://codesandbox.io/s/m5o42082xy">このロジックを抽出</a>できます。<pre class="language-js{2}"><code class="language-js{2}">function MeasureExample() {
  const [rect, ref] = useClientRect();
  return (
    &#x3C;>
      &#x3C;h1 ref={ref}>Hello, world&#x3C;/h1>
      {rect !== null &#x26;&#x26;
        &#x3C;h2>The above header is {Math.round(rect.height)}px tall&#x3C;/h2>
      }
    &#x3C;/>
  );
}

function useClientRect() {
  const [rect, setRect] = useState(null);
  const ref = useCallback(node => {
    if (node !== null) {
      setRect(node.getBoundingClientRect());
    }
  }, []);
  return [rect, ref];
}</code></pre></section><section id="what-does-const-thing-setthing--usestate-mean"class="level3"><h3><code>const [thing, setThing] = useState()</code> というのはどういう意味ですか？</h3><p>この構文に馴染みがない場合はステートフックのドキュメント内の<a href="./hooks-state.html#tip-what-do-square-brackets-mean">説明</a>をご覧ください。</section></section><section id="performance-optimizations"class="level2"><h2>パフォーマンス最適化</h2><section id="can-i-skip-an-effect-on-updates"class="level3"><h3>更新時に副作用をスキップすることはできますか？</h3><p>はい。<a href="./hooks-reference.html#conditionally-firing-an-effect">条件付きで副作用を実行する</a>を参照してください。これがデフォルトの動作になっていないのは、更新時の対応を忘れることが<a href="./hooks-effect.html#explanation-why-effects-run-on-each-update">バグの元になる</a>からです。</section><section id="is-it-safe-to-omit-functions-from-the-list-of-dependencies"class="level3"><h3>依存の配列から関数を省略しても大丈夫ですか？</h3><p>いいえ、一般的には省略できません。<pre class="language-js{3,8}"><code class="language-js{3,8}">function Example({ someProp }) {
  function doSomething() {
    console.log(someProp);
  }

  useEffect(() => {
    doSomething();
  }, []); // 🔴 This is not safe (it calls `doSomething` which uses `someProp`)
}</code></pre><p>副作用関数の外側にある関数内でどの props や state が使われているのか覚えておくのは大変です。ですので<strong>副作用関数内で使われる関数は副作用関数内で宣言する</strong>のがよいでしょう。そうすればコンポーネントスコープ内のどの値に副作用が依存しているのかを把握するのは容易です。<pre class="language-js{4,8}"><code class="language-js{4,8}">function Example({ someProp }) {
  useEffect(() => {
    function doSomething() {
      console.log(someProp);
    }

    doSomething();
  }, [someProp]); // ✅ OK (our effect only uses `someProp`)
}</code></pre><p>このようにした後で、やはりコンポーネントスコープ内のどの値も使用していないのであれば、<code>[]</code> を指定することは安全です：<pre class="language-js{7}"><code class="language-js{7}">useEffect(() => {
  function doSomething() {
    console.log('hello');
  }

  doSomething();
}, []); // ✅ OK in this example because we don't use *any* values from component scope</code></pre><p>ユースケースによっては、以下に述べるような選択肢もあります。<blockquote><p>補足<p><a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> パッケージの一部として <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> という ESLint のルールを提供しています。更新の一貫性が保たれていないコンポーネントを見つけるのに役立ちます。</blockquote><p>これがなぜ重要なのか説明します。<p><code>useEffect</code>、<code>useLayoutEffect</code>、<code>useMemo</code>、<code>useCallback</code> あるいは <code>useImperativeHandle</code> の最後の引数として<a href="./hooks-reference.html#conditionally-firing-an-effect">依存する値のリスト</a>を渡す場合、コールバック内部で使われ React のデータの流れに関わる値が、すべて含まれている必要があります。すなわち props や state およびそれらより派生するあらゆるものです。<p>関数を依存のリストから安全に省略できるのは、その関数（あるいはその関数から呼ばれる関数）が props、state ないしそれらから派生する値のいずれも含んでいない場合<strong>のみ</strong>です。以下の例にはバグがあります。<pre class="language-js{5,12}"><code class="language-js{5,12}">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);

  async function fetchProduct() {
    const response = await fetch('http://myapi/product/' + productId); // Uses productId prop
    const json = await response.json();
    setProduct(json);
  }

  useEffect(() => {
    fetchProduct();
  }, []); // 🔴 Invalid because `fetchProduct` uses `productId`
  // ...
}</code></pre><p><strong>推奨される修正方法は、この関数を副作用<em>内</em>に移動することです。</strong>これにより、副作用がどの props や state を利用しているのか把握しやすくなり、それらが指定されていることを保証しやすくなります。<pre class="language-js{5-10,13}"><code class="language-js{5-10,13}">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);

  useEffect(() => {
    // By moving this function inside the effect, we can clearly see the values it uses.
    async function fetchProduct() {
      const response = await fetch('http://myapi/product/' + productId);
      const json = await response.json();
      setProduct(json);
    }

    fetchProduct();
  }, [productId]); // ✅ Valid because our effect only uses productId
  // ...
}</code></pre><p>これにより、要らなくなったレスポンスに対して副作用内でローカル変数を使って対処することも可能になります。<pre class="language-js{2,6,10}"><code class="language-js{2,6,10}">  useEffect(() => {
    let ignore = false;
    async function fetchProduct() {
      const response = await fetch('http://myapi/product/' + productId);
      const json = await response.json();
      if (!ignore) setProduct(json);
    }

    fetchProduct();
    return () => { ignore = true };
  }, [productId]);</code></pre><p>副作用内に関数を移動したことで、依存リスト内にこの関数を含めないでよくなりました。<blockquote><p>ヒント<p>フックでデータを取得する方法について<a href="https://codesandbox.io/s/jvvkoo8pq3">こちらの小さなデモ</a>および<a href="https://www.robinwieruch.de/react-hooks-fetch-data/">こちらの記事</a>をご覧ください。</blockquote><p><strong>何らかの理由で副作用内に関数を移動<em>できない</em>という場合、他にとりうる選択肢がいくつかあります。</strong><ul><li><strong>そのコンポーネントの外部にその関数を移動できないか考えましょう</strong>。その場合、関数は props や state を参照していないことが保証されるので、依存のリストに含まずに済むようになります。<li>使おうとしている関数が純粋な計算のみを行い、レンダー中に呼んで構わないものであるなら、その関数を代わりに<strong>副作用の外部で呼ぶ</strong>ようにして、副作用中ではその返り値に依存するようにします。<li>最終手段として、関数を依存リストに加えつつ、<a href="./hooks-reference.html#usecallback"><code>useCallback</code></a> を使って<strong>その定義をラップする</strong>ことが可能です。これにより、<em>関数自体</em>の依存が変わらない限り関数も変化しないことを保証できます。</ul><pre class="language-js{2-5}"><code class="language-js{2-5}">function ProductPage({ productId }) {
  // ✅ Wrap with useCallback to avoid change on every render
  const fetchProduct = useCallback(() => {
    // ... Does something with productId ...
  }, [productId]); // ✅ All useCallback dependencies are specified

  return &#x3C;ProductDetails fetchProduct={fetchProduct} />;
}

function ProductDetails({ fetchProduct }) {
  useEffect(() => {
    fetchProduct();
  }, [fetchProduct]); // ✅ All useEffect dependencies are specified
  // ...
}</code></pre><p>上記の例では関数を依存リストに含める<strong>必要がある</strong>ことに注意してください。これにより <code>ProductPage</code> の <code>productId</code> プロパティが変化した場合に自動的に <code>ProductDetail</code> コンポーネント内でデータの再取得が発生するようになります。</section><section id="what-can-i-do-if-my-effect-dependencies-change-too-often"class="level3"><h3>副作用の依存リストが頻繁に変わりすぎる場合はどうすればよいですか？</h3><p>しばしば、ある副作用がとても頻繁に変化する state を利用しないといけない場合があります。依存のリストからその state を省略したくなるかもしれませんが、通常それはバグになります。<pre class="language-js{6,9}"><code class="language-js{6,9}">function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(count + 1); // This effect depends on the `count` state
    }, 1000);
    return () => clearInterval(id);
  }, []); // 🔴 Bug: `count` is not specified as a dependency

  return &#x3C;h1>{count}&#x3C;/h1>;
}</code></pre><p>依存のリストが空であるということ (<code>[]</code>) は、コンポーネントのマウント時に副作用が一度のみ実行され、毎回の再レンダー時には実行されないということを意味します。ここでの問題は、副作用コールバックが実行された時点で <code>count</code> の値が <code>0</code> に設定されたクロージャを作成したため、<code>setInterval</code> 内のコールバックで <code>count</code> の値が変わらなくなってしまう、ということです。毎秒ごとにこのコールバックは <code>setCount(0 + 1)</code> を呼び出すので、カウントは 1 のまま変わらなくなってしまいます。<p>依存のリストとして <code>[count]</code> を指定すればバグは起きなくなりますが、その場合値が変化するたびにタイマーがリセットされることになります。事実上それぞれの <code>setInterval</code> は一度しか実行されずに（<code>setTimeout</code> のように）クリアされてしまうのです。これは望ましい動作ではありません。これを修正するため、<a href="./hooks-reference.html#functional-updates"><code>setState</code> 関数形式による更新</a>を利用することができます。これにより state の<em>現在値</em>を参照せずに state が<em>どのように</em>更新されるべきかを指定できます。<pre class="language-js{6,9}"><code class="language-js{6,9}">function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + 1); // ✅ This doesn't depend on `count` variable outside
    }, 1000);
    return () => clearInterval(id);
  }, []); // ✅ Our effect doesn't use any variables in the component scope

  return &#x3C;h1>{count}&#x3C;/h1>;
}</code></pre><p>（<code>setCount</code> 関数については同一性が保たれることが保証されているので、省略して構いません）<p>これで、<code>setInterval</code> のコールバックは 1 秒に 1 回実行されますが、内部の <code>setCount</code> は <code>count</code> の最新の値（この例では <code>c</code>）を参照できるようになります。<p>より複雑なケース（ある state が別の state に依存している場合など）においては、state 更新のロジックを <a href="./hooks-reference.html#usereducer"><code>useReducer</code> フック</a>を使って副作用の外部に移動することを考慮してください。<a href="https://adamrackis.dev/state-and-use-reducer/">こちらの記事</a>にこのやり方についての例があります。<strong><code>useReducer</code> から返される <code>dispatch</code> 関数は常に同一性が保たれます</strong>。これはリデューサ (reducer) 関数がコンポーネント内で宣言されており props を読み出している場合でも同様です。<p>最終手段として、クラスにおける <code>this</code> のようなものが欲しい場合は、<a href="./hooks-faq.html#is-there-something-like-instance-variables">ref</a> を使ってミュータブルな値を保持させることができます。そうすればその値を読み書き可能です。例えば：<pre class="language-js{2-6,10-11,16}"><code class="language-js{2-6,10-11,16}">function Example(props) {
  // Keep latest props in a ref.
  const latestProps = useRef(props);
  useEffect(() => {
    latestProps.current = props;
  });

  useEffect(() => {
    function tick() {
      // Read latest props at any time
      console.log(latestProps.current);
    }

    const id = setInterval(tick, 1000);
    return () => clearInterval(id);
  }, []); // This effect never re-runs
}</code></pre><p>ミュータブルな値に依存することでコンポーネントの挙動が予測しづらくなるため、これは代替手段が思いつかない場合にのみ利用してください。うまくフックに移行できないパターンがあった場合は動作するコード例を添えて <a href="https://github.com/facebook/react/issues/new">issue を作成</a>していただければお手伝いします。</section><section id="how-do-i-implement-shouldcomponentupdate"class="level3"><h3>どうすれば <code>shouldComponentUpdate</code> を実装できますか？</h3><p>関数コンポーネントを <code>React.memo</code> でラップして props を浅く比較するようにしてください。<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">Button</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// your component</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>これがフックになっていないのは、フックと違って組み合わせ可能ではないからです。<code>React.memo</code> は <code>PureComponent</code> の同等物ですが、props のみを比較するという違いがあります（新旧の props を受け取るカスタムの比較関数を 2 つめの引数として加えることができます。その関数が true を返した場合はコンポーネントの更新はスキップされます）。<p><code>React.memo</code> は state を比較しませんが、これは比較可能な単一の state オブジェクトが存在しないからです。しかし子コンポーネント側も純粋にしておくことや、<a href="./hooks-faq.html#how-to-memoize-calculations"><code>useMemo</code> を使って個々のコンポーネントを最適化する</a>ことが可能です。</section><section id="how-to-memoize-calculations"class="level3"><h3>計算結果のメモ化はどのように行うのですか？</h3><p><a href="./hooks-reference.html#usememo"><code>useMemo</code></a> フックを使うと、前の計算結果を「記憶」しておくことで、複数のレンダー間で計算結果をキャッシュすることができます。<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">computeExpensiveValue</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>このコードは <code>computeExpensiveValue(a, b)</code> を呼び出します。しかし依存である <code>[a, b]</code> の組み合わせが前回の値と変わっていない場合は、<code>useMemo</code> はこの関数の 2 回目の呼び出しをスキップし、単に前回返したのと同じ値を返します。<p><code>useMemo</code> に渡した関数はレンダー中に実行されるということを覚えておいてください。レンダー中に通常やらないようなことをやらないようにしましょう。例えば副作用は <code>useMemo</code> ではなく <code>useEffect</code> の仕事です。<p><strong><code>useMemo</code> はパフォーマンス最適化のために使うものであり、意味上の保証があるものだと考えないでください。</strong>将来的に React は、例えば画面外のコンポーネント用のメモリを解放する、などの理由で、メモ化された値を「忘れる」ようにする可能性があります。<code>useMemo</code> なしでも動作するコードを書き、パフォーマンス最適化のために <code>useMemo</code> を加えるようにしましょう（値が<em>絶対に</em>再計算されてはいけないというような稀なケースでは、ref の<a href="#how-to-create-expensive-objects-lazily">遅延初期化</a>を行うことができます）。<p>便利なことに、<code>useMemo</code> は子コンポーネントの計算量の高い再レンダーをスキップするのにも使えます：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Parent</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Only re-rendered if `a` changes:</span>
  <span class="token keyword">const</span> child1 <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Child1</span> a<span class="token operator">=</span><span class="token punctuation">{</span>a<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Only re-rendered if `b` changes:</span>
  <span class="token keyword">const</span> child2 <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Child2</span> b<span class="token operator">=</span><span class="token punctuation">{</span>b<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token punctuation">{</span>child1<span class="token punctuation">}</span>
      <span class="token punctuation">{</span>child2<span class="token punctuation">}</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>フック呼び出しはループ内に<a href="./hooks-rules.html">配置できない</a>ため、このアプローチはループ内では動作しないことに注意してください。ただしリストのアイテムの部分を別のコンポーネントに抽出してその中で <code>useMemo</code> を呼び出すことは可能です。</section><section id="how-to-create-expensive-objects-lazily"class="level3"><h3>計算量の大きいオブジェクトの作成を遅延する方法はありますか？</h3><p><code>useMemo</code> を使えば同じ値に依存している<a href="#how-to-memoize-calculations">高価な計算の結果をメモ化</a>することができます。しかしこれはあくまでヒントとして使われるものであり、計算が再実行されないということを<em>保証</em>しません。しかし時にはオブジェクトが一度しか作られないことを保証したい場合があります。<p><strong>まずよくあるユースケースは state の初期値を作成することが高価な場合です。</strong><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Table</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ⚠️ createRows() is called on every render</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>rows<span class="token punctuation">,</span> setRows<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token function">createRows</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>次回以降のレンダーでは無視される初期 state を毎回作成しなおすことを防ぐため、<code>useState</code> に<strong>関数</strong>を渡すことができます。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Table</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ✅ createRows() is only called once</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>rows<span class="token punctuation">,</span> setRows<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">createRows</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>React は初回レンダー時のみこの関数を呼び出します。<a href="./hooks-reference.html#usestate"><code>useState</code> の API リファレンス</a>を参照してください。<p>また、<strong>まれに <code>useRef()</code> の初期値を毎回再作成することを避けたいということもあります。</strong>例えば、命令型で作成するクラスのインスタンスが一度しか作成されないことを保証したいということがあるかもしれません。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ⚠️ IntersectionObserver is created on every render</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>onIntersect<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p><code>useRef</code> は <code>useState</code> のような関数を渡す形式のオーバーロード記法が<strong>使えません</strong>。代わりに、自分で関数を書いて高価なオブジェクトを遅延型で ref に設定することが可能です。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ✅ IntersectionObserver is created lazily once</span>
  <span class="token keyword">function</span> <span class="token function">getObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>onIntersect<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> ref<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// When you need it, call getObserver()</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>これにより、本当に必要になるまで高価なオブジェクトの作成を避けることができます。Flow や TypeScript を使っているなら、<code>getObserver()</code> を non-nullable な型にしておくと便利でしょう。</section><section id="are-hooks-slow-because-of-creating-functions-in-render"class="level3"><h3>レンダー内で関数を作るせいでフックは遅くなるのではないですか？</h3><p>いいえ。モダンブラウザでは、特殊な場合を除いて、クラスと比較してクロージャーの生の性能はそれほど変わりません。<p>しかも、フックの設計は幾つかの点においてはより効率的です。<ul><li><p>フックを使えば、クラスインスタンスの作成や、コンストラクタでのイベントハンドラのバインドといった、クラスの場合に必要な様々なオーバーヘッドを回避できます。<li><p>フックをうまく用いたコードは、高階コンポーネントやレンダープロップやコンテクストを多用するコードベースで見られるような<strong>深いコンポーネントのネストを必要としません</strong>。コンポーネントツリーが小さければ、React がやるべき仕事も減ります。</ul><p>過去には、インライン関数によるパフォーマンスの懸念というのは、レンダー毎に新しいコールバック関数を作って渡すと子コンポーネントでの <code>shouldComponentUpdate</code> による最適化が動かなくなる、という問題と関連していました。フックではこの問題について 3 つの側面から対応します。<ul><li><p><a href="./hooks-reference.html#usecallback"><code>useCallback</code></a> フックを使えば再レンダーをまたいで同じコールバックを保持できるので、<code>shouldComponentUpdate</code> がうまく動作し続けます<pre class="language-js{2}"><code class="language-js{2}">// Will not change unless `a` or `b` changes
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);</code></pre><li><p><a href="./hooks-faq.html#how-to-memoize-calculations"><code>useMemo</code></a> フックを使うことで個々の子コンポーネントをいつ更新するのかを制御しやすくなるため、コンポーネントが純粋である必要性は低くなっています<li><p>最後に、以下で説明されているように、<a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> フックを使えば、複数のコールバックを深い階層に受け渡していく必要があまりなくなります</ul></section><section id="how-to-avoid-passing-callbacks-down"class="level3"><h3>どうすれば複数のコールバックを深く受け渡すのを回避できますか？</h3><p>我々が見たところ、ほとんどの人はコンポーネントツリーの各階層で手作業でコールバックを受け渡ししていく作業が好きではありません。それはより明示的ではありますが、面倒な『配管工事』をしている気分になることがあります。<p>大きなコンポーネントツリーにおいて我々がお勧めする代替手段は、<a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> で <code>dispatch</code> 関数を作って、それをコンテクスト経由で下の階層に渡す、というものです。<pre class="language-js{4,5}"><code class="language-js{4,5}">const TodosDispatch = React.createContext(null);

function TodosApp() {
  // Note: `dispatch` won't change between re-renders
  const [todos, dispatch] = useReducer(todosReducer);

  return (
    &#x3C;TodosDispatch.Provider value={dispatch}>
      &#x3C;DeepTree todos={todos} />
    &#x3C;/TodosDispatch.Provider>
  );
}</code></pre><p><code>TodosApp</code> ツリーの中にいるあらゆる子コンポーネントはこの <code>dispatch</code> 関数を使うことができ、上位にいる <code>TodosApp</code> にアクションを伝えることができます。<pre class="language-js{2,3}"><code class="language-js{2,3}">function DeepChild(props) {
  // If we want to perform an action, we can get dispatch from context.
  const dispatch = useContext(TodosDispatch);

  function handleClick() {
    dispatch({ type: 'add', text: 'hello' });
  }

  return (
    &#x3C;button onClick={handleClick}>Add todo&#x3C;/button>
  );
}</code></pre><p>これは（複数のコールバックを何度も受け渡しする必要がないので）メンテナンスの観点から便利だ、というだけではなく、コールバックにまつわる問題をすべて回避できます。深い更新においてはこのように <code>dispatch</code> を渡すのがお勧めのパターンです。<p>アプリケーションの <strong>state</strong> については、props として渡していくか（より明示的）、あるいはコンテクスト経由で渡すか（深い更新ではより便利）を選ぶ余地が依然あります。もしもコンテクストを使って state も渡すことにする場合は、2 つの別のコンテクストのタイプを使ってください -- <code>dispatch</code> のコンテクストは決して変わらないため、<code>dispatch</code> だけを使うコンポーネントは（アプリケーションの state も必要でない限り）再レンダーする必要がなくなります。</section><section id="how-to-read-an-often-changing-value-from-usecallback"class="level3"><h3><code>useCallback</code> からの頻繁に変わる値を読み出す方法は？</h3><blockquote><p>補足<p>我々は個別のコールバックを props として渡すのではなく、<a href="#how-to-avoid-passing-callbacks-down">コンテクスト経由で <code>dispatch</code> を渡す</a>ことを推奨しています。以下のアプローチは網羅性と避難ハッチの目的で掲載しているものです。</blockquote><p>稀なケースですが、コールバックを <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a> でメモ化しているにも関わらず、内部関数を何度も再作成しないといけないためメモ化がうまく働かない、ということがあります。あなたがメモ化しようとしている関数がレンダー最中には使われないイベントハンドラなのであれば、<a href="#is-there-something-like-instance-variables">インスタンス変数としての ref</a> を使って最後に使われた値を手動で保持しておくことができます。<pre class="language-js{6,10}"><code class="language-js{6,10}">function Form() {
  const [text, updateText] = useState('');
  const textRef = useRef();

  useEffect(() => {
    textRef.current = text; // Write it to the ref
  });

  const handleSubmit = useCallback(() => {
    const currentText = textRef.current; // Read it from the ref
    alert(currentText);
  }, [textRef]); // Don't recreate handleSubmit like [text] would do

  return (
    &#x3C;>
      &#x3C;input value={text} onChange={e => updateText(e.target.value)} />
      &#x3C;ExpensiveTree onSubmit={handleSubmit} />
    &#x3C;/>
  );
}</code></pre><p>これはやや複雑なパターンですが、このような避難ハッチ的最適化は必要であれば可能だということです。カスタムフックに抽出すれば多少は読みやすくなります：<pre class="language-js{4,16}"><code class="language-js{4,16}">function Form() {
  const [text, updateText] = useState('');
  // Will be memoized even if `text` changes:
  const handleSubmit = useEventCallback(() => {
    alert(text);
  }, [text]);

  return (
    &#x3C;>
      &#x3C;input value={text} onChange={e => updateText(e.target.value)} />
      &#x3C;ExpensiveTree onSubmit={handleSubmit} />
    &#x3C;/>
  );
}

function useEventCallback(fn, dependencies) {
  const ref = useRef(() => {
    throw new Error('Cannot call an event handler while rendering.');
  });

  useEffect(() => {
    ref.current = fn;
  }, [fn, ...dependencies]);

  return useCallback(() => {
    const fn = ref.current;
    return fn();
  }, [ref]);
}</code></pre><p>いずれにせよ、<strong>このパターンは薦められず</strong>、網羅性のために示しているに過ぎません。代わりに<a href="#how-to-avoid-passing-callbacks-down">コールバックを深く受け渡していくことを回避する</a>のが望ましいパターンです。</section></section><section id="under-the-hood"class="level2"><h2>内部の仕組み</h2><section id="how-does-react-associate-hook-calls-with-components"class="level3"><h3>React はフック呼び出しとコンポーネントとをどのように関連付けているのですか？</h3><p>React は現在どのコンポーネントがレンダー中なのかを把握しています。<a href="./hooks-rules.html">フックのルール</a>のお陰で、フックは React のコンポーネント内（あるいはそれらから呼び出されるカスタムフック内）でのみ呼び出されるということが分かっています。<p>それぞれのコンポーネントに関連付けられる形で、React 内に「メモリーセル」のリストが存在しています。それらは単に何らかのデータを保存できる JavaScript のオブジェクトです。あなたが <code>useState()</code> のようなフックを呼ぶと、フックは現在のセルの値を読み出し（あるいは初回レンダー時はセル内容を初期化し）、ポインタを次に進めます。これが複数の <code>useState()</code> の呼び出しが個別のローカル state を得る仕組みです。</section><section id="what-is-the-prior-art-for-hooks"class="level3"><h3>フックの先行技術にはどのようなものがありますか？</h3><p>フックは複数の異なった出典からのアイディアを総合したものです：<ul><li><a href="https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State">react-future</a> リポジトリにおける関数型 API の古い実験。<li><a href="https://github.com/ryanflorence">Ryan Florence</a> の <a href="https://github.com/reactions/component">Reactions Component</a> を含む、React コミュニティのレンダープロップ API に関する実験。<li><a href="https://github.com/trueadm">Dominic Gannaway</a> によって提案された、レンダープロップの糖衣構文としての <a href="https://gist.github.com/trueadm/17beb64288e30192f3aa29cad0218067"><code>adopt</code> keyword</a>。<li><a href="http://displayscript.org/introduction.html">DisplayScript</a> のステート変数とステートセル。<li>ReasonReact の <a href="https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html">Reducer components</a>。<li>Rx の <a href="http://reactivex.io/rxjs/class/es6/Subscription.js~Subscription.html">Subscriptions</a>。<li>Multicore OCaml の <a href="https://github.com/ocamllabs/ocaml-effects-tutorial#2-effectful-computations-in-a-pure-setting">Algebraic effects</a>。</ul><p>フックは <a href="https://github.com/sebmarkbage">Sebastian Markbåge</a> が最初のデザインを作り、<a href="https://github.com/acdlite">Andrew Clark</a>、<a href="https://github.com/sophiebits">Sophie Alpert</a>、<a href="https://github.com/trueadm">Dominic Gannaway</a> およびその他の React チームのメンバーが洗練させました。 <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section></section>