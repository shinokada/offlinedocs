<!doctype html><html lang="ja"><meta charset="utf-8"><title>React 用語集</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="react-用語集"class="level1"><h1>React 用語集</h1><section id="single-page-application"class="level2"><h2>シングルページアプリケーション</h2><p>シングルページアプリケーション (single-page application) は、単一の HTML ページでアプリケーションの実行に必要なすべてのアセット（JavaScript や CSS など）をロードするようなアプリケーションです。初回ページもしくはそれ以降のページでのユーザとのやりとりにおいて、サーバとの往復が不要、すなわちページのリロードが発生しません。<p>React でシングルページアプリケーションを構築することができますが、そうすることは必須ではありません。React は、既存のウェブサイトの小さな一部分を拡張してよりインタラクティブにするために使用することもできます。React で記述されたコードは、PHP などによりサーバでレンダリングされたマークアップや、他のクライアントサイドのライブラリと問題なく共存できます。実際に、Facebook では React はそのように利用されています。</section><section id="es6-es2015-es2016-etc"class="level2"><h2>ES6、ES2015、ES2016 など</h2><p>これらの頭字語は全て、ECMAScript 言語の標準仕様の最近のバージョンのことを指しており、JavaScript 言語とはこれらの仕様に対する実装です。ES6 バージョン（ES2015 とも呼ばれます）はそれ以前のバージョンから、多くのものが追加されています：アロー関数、クラス、テンプレートリテラル、<code>let</code> および <code>const</code> ステートメントなどです。特定のバージョンの詳細については<a href="https://en.wikipedia.org/wiki/ECMAScript#Versions">こちら</a>で学ぶことができます。</section><section id="compilers"class="level2"><h2>コンパイラ</h2><p>JavaScript コンパイラは JavaScript コードを受け取って変換し、別のフォーマットの JavaScript コードを返します。最も一般的なユースケースは ES6 構文を受け取り、古いブラウザーが解釈できる構文に変換することです。Babel は React とともに利用されることが最も多いコンパイラです。</section><section id="bundlers"class="level2"><h2>バンドラ</h2><p>バンドラは別々のモジュールとして記述された（しばしば数百個になる）JavaScript および CSS のコードを受け取り、ブラウザに最適化された数個のファイルに結合します。<a href="https://webpack.js.org/">Webpack</a> や <a href="http://browserify.org/">Browserify</a> を含む、いくつかのバンドラが React アプリケーションで一般的に利用されています。</section><section id="package-managers"class="level2"><h2>パッケージマネージャ</h2><p>パッケージ マネージャーは、プロジェクト内の依存関係を管理するためのツールです。<a href="https://www.npmjs.com/">npm</a> および <a href="https://yarnpkg.com/">Yarn</a> の 2 つのパッケージマネージャが React アプリケーションで一般的に利用されています。どちらも同じ npm パッケージレジストリのクライアントです。</section><section id="cdn"class="level2"><h2>CDN</h2><p>CDN は Content Delivery Network の略です。CDN はキャッシュされた静的なコンテンツをネットワーク化されたサーバから世界中に配信します。</section><section id="jsx"class="level2"><h2>JSX</h2><p>JSX は JavaScript の拡張構文です。テンプレート言語に似ていますが、完全に JavaScript だけで動作します。JSX は、"React 要素" と呼ばれるプレーンな JavaScript オブジェクトを返す、<code>React.createElement()</code> のコールにコンパイルされます。JSX の基本的な導入部分を学ぶには<a href="./introducing-jsx.html">こちらのドキュメントを参照してください</a>。また、さらに JSX について詳細に学ぶには<a href="./jsx-in-depth.html">こちら</a>を参照してください。<p>React DOM は HTML の属性名ではなく、キャメルケースの命名規則を使用します。例えば、<code>tabindex</code> は、JSX では <code>tabIndex</code> となります。<code>class</code> も <code>className</code> と記述されますが、これは <code>class</code> が JavaScript において予約語であるためです：<pre class="language-jsx"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>h1</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hello<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">My name is Clementine!</span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>h1</span><span class="token punctuation">></span></span></code></pre></section><section id="要素-elements"class="level2"><h2><a href="./rendering-elements.html">要素</a> {#elements}</h2><p>React 要素は React アプリケーションを構成するブロックです。要素を、より広く知られている概念である "コンポーネント" と混同する人もいるかもしれません。要素はあなたが画面上に表示したいものの説明書きとなるものです。React 要素はイミュータブルです。<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token maybe-class-name">Hello</span><span class="token punctuation">,</span> world<span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>通常、要素は直接使用されるものではなく、コンポーネントから返されるものです。</section><section id="コンポーネント-components"class="level2"><h2><a href="./components-and-props.html">コンポーネント</a> {#components}</h2><p>React のコンポーネントとは、ページに表示される React 要素を返す、小さく再利用可能なコードのことです。もっともシンプルな形の React コンポーネントは、React 要素を返すプレーンな JavaScript 関数です：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Welcome</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token maybe-class-name">Hello</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>コンポーネントは ES6 クラスであることもあります：<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Welcome</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token maybe-class-name">Hello</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>コンポーネントは機能的に異なる部品に分割でき、他のコンポーネントの中で使用することができます。コンポーネントは別のコンポーネント、配列、文字列および数値を返すことができます。役に立つ経験則として、UI の一部（Button、Panel、Avatar など）が複数回使われている場合、または UI の一部が独立できるほど複雑（App、FeedStory、Comment など）な場合、それらは再利用可能なコンポーネントの有力な候補であるといえます。コンポーネント名は常に大文字で始める必要があります（<code>&#x3C;wrapper/></code> ではなく <code>&#x3C;Wrapper/></code> とすること）。コンポーネントのレンダーについての詳細は<a href="./components-and-props.html#rendering-a-component">このドキュメント</a>を参照してください。<section id="props-props"class="level3"><h3><a href="./components-and-props.html"><code>props</code></a> {#props}</h3><p><code>props</code> は、React コンポーネントへの入力のことです。親コンポーネントから子コンポーネントへと順番に渡されるようなデータです。<p><code>props</code> は読み取り専用です。どのような形であれ変更されるべきではありません：<pre class="language-js"><code class="language-js"><span class="token comment">// 間違った例</span>
props<span class="token punctuation">.</span><span class="token property-access">number</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span></code></pre><p>ある値を、ユーザの入力やネットワークのレスポンスに応じて変更する必要がある場合は、代わりに state を使用してください。</section><section id="propschildren-propschildren"class="level3"><h3><code>props.children</code> {#propschildren}</h3><p><code>props.children</code> は全てのコンポーネントで使用可能です。これには、コンポーネントの開始タグと終了タグの間の全てのコンテンツが含まれています。例えば：<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Welcome</span><span class="token operator">></span><span class="token maybe-class-name">Hello</span> world<span class="token operator">!</span><span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Welcome</span><span class="token operator">></span></code></pre><p>文字列 <code>Hello world!</code> は <code>Welcome</code> コンポーネントの <code>props.children</code> で利用できます：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Welcome</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span><span class="token property-access">children</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>クラスとして定義されたコンポーネントでは、<code>this.props.children</code> を使用してください：<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Welcome</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">children</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></section><section id="state-state"class="level3"><h3><a href="./state-and-lifecycle.html#adding-local-state-to-a-class"><code>state</code></a> {#state}</h3><p>あるコンポーネントが時間とともに変化するデータと関連付けられている場合は、<code>state</code> が必要です。例えば、<code>Checkbox</code> というコンポーネントはその state に <code>isChecked</code> が必要となるかもしれません。また <code>NewsFeed</code> というコンポーネントは <code>fetchedPosts</code> を state に入れて管理したいかもしれません。<p><code>state</code> と <code>props</code> の最も重要な違いは、<code>props</code> は親コンポーネントから渡されますが、<code>state</code> はコンポーネント自身によって管理されるということです。コンポーネントは自身の <code>props</code> を変更できませんが、<code>state</code> を変更することはできます。<p>経時的に変化するそれぞれのデータについて、それを state として「所有する」コンポーネントは 1 つだけであるべきです。2 つの異なるコンポーネントの state を同期しようとしないでください。代わりに、それらの直近の共通祖先コンポーネントに state を<a href="./lifting-state-up.html">リフトアップ</a> して、両方に props として渡してください。</section></section><section id="ライフサイクルメソッド-lifecycle-methods"class="level2"><h2><a href="./state-and-lifecycle.html#adding-lifecycle-methods-to-a-class">ライフサイクルメソッド</a> {#lifecycle-methods}</h2><p>ライフサイクルメソッドは、コンポーネントの様々なフェーズにおいて実行される特別な関数です。コンポーネントが作成されて DOM に挿入（<a href="./react-component.html#mounting">マウント</a>）された時、コンポーネントが更新された時、コンポーネントが DOM からアンマウント（つまり削除）された時のそれぞれで、利用可能なメソッドがあります。</section><section id="制御されたコンポーネント-vs-非制御コンポーネント"class="level2"><h2><a href="./forms.html#controlled-components">制御されたコンポーネント</a> vs. <a href="./uncontrolled-components.html">非制御コンポーネント</a></h2><p>React では、フォームの入力を扱うのに 2 つの異なるアプローチがあります。<p>React によって値が制御される入力フォーム要素は<em>制御されたコンポーネント</em> (controlled component) と呼ばれます。ユーザが制御されたコンポーネントにデータを入力すると、変更イベントハンドラがトリガーされ、コードが入力が有効であるか（更新された値で再レンダーすることで）決定します。再レンダーしなければフォーム要素は変更されないままとなります。<p><em>非制御コンポーネント</em> (uncontrolled component) は React の管理外にあるフォーム要素と同様に動作します。ユーザがフォームフィールド（入力ボックス、ドロップダウンなど）にデータを入力した場合、更新された情報が反映され、その際に React は何もする必要がありません。しかし、このことはフィールドに特定の値を設定できないということでもあります。<p>ほとんどの場合では、制御されたコンポーネントを使用するべきでしょう。</section><section id="key-keys"class="level2"><h2><a href="./lists-and-keys.html">key</a> {#keys}</h2><p>"key" は特別な文字列の属性で、要素の配列を作成する際に含めておく必要があります。key は React がどの要素が変更、追加もしくは削除されたかを識別するのに役立ちます。key は配列内の要素に安定した一意性を与えるよう設定されるべきです。<p>key は同じ配列内の兄弟要素間で一意としなければなりません。アプリケーション全体、単一のコンポーネントに渡ってすべて一意である必要はありません。<p><code>Math.random()</code> のようなものを key として設定しないでください。key には再レンダリングをまたいだ「安定した一意性」を持たせることで、要素の追加、削除および並べ替えがあった時に React が識別できることが重要です。理想的には key は <code>post.id</code> のように、データから得られる一意で安定した識別子に対応するべきです。</section><section id="ref-refs"class="level2"><h2><a href="./refs-and-the-dom.html">ref</a> {#refs}</h2><p>React は任意のコンポーネントに追加できる特別な属性をサポートしています。<code>ref</code> 属性は、<a href="./react-api.html#reactcreateref"><code>React.createRef()</code> 関数</a>、コールバック関数、あるいは（古い API では）文字列によって生成されるオブジェクトです。<code>ref</code> 属性がコールバック関数の場合、その関数は引数として（要素の種類によって）DOM 要素またはクラスインスタンスを受け取ります。これによって、DOM 要素またはコンポーネントのインスタンスへと直接アクセスできます。<p>ref は消極的に利用してください。アプリケーション内で何かを実行するために ref を頻繁に使用している場合、<a href="./lifting-state-up.html">トップダウンのデータフロー</a>に慣れ親しむことを検討してください。</section><section id="イベント-events"class="level2"><h2><a href="./handling-events.html">イベント</a> {#events}</h2><p>React 要素でイベントを扱う場合には、構文上の違いがあります：<ul><li>React のイベントハンドラは小文字ではなく、キャメルケースで名前が付けられます。<li>JSX ではイベントハンドラとして文字列ではなく関数を渡します。</ul></section><section id="リコンシリエーション更新検出処理-reconciliation"class="level2"><h2><a href="./reconciliation.html">リコンシリエーション（更新検出処理）</a> {#reconciliation}</h2><p>コンポーネントの props か state が変更された場合、React は新しく返された要素を以前にレンダーされた要素と比較することで、本物の DOM の更新が必要かを判断します。それらが等しくない場合、React は DOM を更新します。このプロセスを "リコンシリエーション (reconciliation)" と呼びます。 <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>