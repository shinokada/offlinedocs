<!doctypehtml><html lang="ja"><meta charset="utf-8"><title>React の流儀</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="react-の流儀"class="level1"><h1>React の流儀</h1><ul><li>'blog/2013/11/05/thinking-in-react.html'<li>'docs/thinking-in-react-zh-CN.html'</ul><p>巨大で軽快な Web アプリを開発する場合に、React は最高の手段であると、私たちは考えています。Facebook や Instagram といった私たちのサービスにおいても、とてもよくスケールしています。<p>React のすばらしい特長がいくつもありますが、あなたがどんなアプリを作ろうかと考えたことが、そのままアプリの作り方になる、というのはそのひとつです。本ドキュメントでは、検索可能な商品データ表を React で作っていく様子をお見せしましょう。<section id="start-with-a-mock"class="level2"><h2>モックから始めよう</h2><p>すでに、JSON API が実装済みで、デザイナーからもデザインモックがもらえているとしましょう。モックは次のような見た目だったとします。<figure><img src="../images/blog/thinking-in-react-mock.png"alt="デザインモック"><figcaption aria-hidden="true">デザインモック</figcaption></figure><p>また、JSON API は次のようなデータを返してくるとしましょう。<pre class="language-text"><code class="language-text">[
];</code></pre></section><section id="step-1-break-the-ui-into-a-component-hierarchy"class="level2"><h2>Step 1: UI をコンポーネントの階層構造に落とし込む</h2><p>まず最初に行うのは、モックを形作っている各コンポーネント（構成要素）を四角で囲んで、それぞれに名前をつけていくことです。もしあなたがデザイナーと一緒に仕事をしている場合は、彼らがすでにこれに相当する作業を終えている可能性がありますので、話をしに行きましょう。彼らが Photoshop でレイヤ名にしていた名前が、最終的にはあなたの React コンポーネントの名前になりうるのです！<p>しかし、どうやって単一のコンポーネントに括るべき範囲を見つけられるのでしょうか。ちょうど、新しい関数やオブジェクトをいつ作るのかを決めるときと、同じ手法が使えます。このような手法のひとつに、<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">単一責任の原則 (single responsibility principle)</a> があり、これはすなわち、ひとつのコンポーネントは理想的にはひとつのことだけをするべきだということです。将来、コンポーネントが肥大化してしまった場合には、小さなコンポーネントに分割するべきです。<p>JSON のデータモデルをユーザに向けて表示することはよくありますので、モデルを正しく構築されていれば、UI（つまりコンポーネントの構造）にもうまくマッピングされるということが分かるでしょう。これは、UI とデータモデルが同じ <strong>情報の構造</strong> を持つ傾向があるためです。UI を分割して、それぞれのコンポーネントがデータモデルの厳密に一部分だけを表現するよう、落とし込みましょう。<figure><img src="../images/blog/thinking-in-react-components.png"alt="コンポーネントのネストを表した図"><figcaption aria-hidden="true">コンポーネントのネストを表した図</figcaption></figure><p>5 種類のコンポーネントがこのアプリの中にあることが見て取れます。それぞれの解説の中で、データを表すものについては<strong>太字</strong>にしました。図中の番号は以下の番号と対応しています。<ol><li><strong><code>FilterableProductTable</code>（オレンジ色）：</strong> このサンプル全体を含む<li><strong><code>SearchBar</code>（青色）：</strong> すべての<em>ユーザ入力</em>を受け付ける<li><strong><code>ProductTable</code>（緑色）：</strong> <em>ユーザ入力</em>に基づく<em>データの集合</em>を表示・フィルタする<li><strong><code>ProductCategoryRow</code>（水色）：</strong> <em>カテゴリ</em>を見出しとして表示する<li><strong><code>ProductRow</code>（赤色）：</strong> 各<em>商品</em>を 1 行で表示する</ol><p><code>ProductTable</code> を見てみると、表のヘッダ（「Name」や「Price」のラベルを含む）が単独のコンポーネントになっていないことがわかります。これは好みの問題で、コンポーネントにするかしないかは両論あります。今回の例でいえば、ヘッダを <code>ProductTable</code> の一部にしたのは、<em>データの集合</em>を描画するという <code>ProductTable</code> の責務の一環として適切だったからです。しかしながら、将来ヘッダーが肥大化して複雑になった場合（例えばソート機能を追加した場合など）は、<code>ProductTableHeader</code> のようなコンポーネントにするのが適切になるでしょう。<p>さて、モック内にコンポーネントを特定できましたので、階層構造に並べてみましょう。モックで他のコンポーネントの中にあるコンポーネントを、階層構造でも子要素として配置すればいいのです。次のようになります。<ul><li><code>FilterableProductTable</code><ul><li><code>SearchBar</code><li><code>ProductTable</code><ul><li><code>ProductCategoryRow</code><li><code>ProductRow</code></ul></ul></ul></section><section id="step-2-build-a-static-version-in-react"class="level2"><h2>Step 2: Reactで静的なバージョンを作成する</h2><p data-height="600"data-theme-id="0"data-slug-hash="BwWzwm"data-default-tab="js"data-user="lacker"data-embed-version="2"class="codepen">See the Pen <a href="https://codepen.io/gaearon/pen/BwWzwm">Thinking In React: Step 2</a> on <a href="https://codepen.io">CodePen</a>.</p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><p>さて、コンポーネントの階層構造が決まったので、アプリの実装に取り掛かりましょう。最初は、データモデルを受け取って UI の描画だけを行い、ユーザからの操作はできないというバージョンを作るのが、もっとも簡単でしょう。表示の実装とユーザ操作の実装を切り離しておくことは重要です。静的な（操作できない）バージョンを作る際には、タイプ量が多い代わりに考えることが少なく、ユーザ操作を実装するときには、考えることが多い代わりにタイプ量は少ないからです。なぜそうなのかは後で説明します。<p>データモデルを描画するだけの機能を持った静的なバージョンのアプリを作る際には、他のコンポーネントを再利用しつつそれらに <em>props</em> を通じてデータを渡す形で、自分のコンポーネントを組み上げていきましょう。<em>props</em> は親から子へとデータを渡すための手段です。もし、あなたが <em>state</em> に慣れ親しんでいる場合でも、今回の静的なバージョンを作る上では<strong>一切 state を使わないでください。</strong>state はユーザ操作や時間経過などで動的に変化するデータを扱うために確保されている機能です。今回のアプリは静的なバージョンなので、state は必要ありません。<p>コンポーネントはトップダウンで作っても、ボトムアップで作っても問題ありません。つまり、高い階層にあるコンポーネント（例えば <code>FilterableProductTable</code>）から作り始めても、低い階層にあるコンポーネント（<code>ProductRow</code> など）から作り始めても、どちらでもいいのです。シンプルなアプリでは通常トップダウンで作った方が楽ですが、大きなプロジェクトでは開発をしながらテストを書き、ボトムアップで進める方がより簡単です。<p>ここまでのステップを終えると、データモデルを描画する再利用可能なコンポーネントの一式が手に入ります。このアプリは静的なバージョンなので、コンポーネントは <code>render()</code> メソッドだけを持つことになります。階層構造の中で最上位のコンポーネント（<code>FilterableProductTable</code>）が、データモデルを props として受け取ることになるでしょう。元となるデータモデルを更新して再度 <code>root.render()</code> を呼び出すと、UI が更新されることになります。このやり方なら、複雑なことをしていないので、UI がどのように更新されて、どこを変更すればよいか、理解できることでしょう。React の<strong>単方向データフロー</strong>（あるいは<em>単方向バインディング</em>）により、すべてがモジュール化された高速な状態で保たれます。<p>このステップを実施する上で助けが必要な場合は、<a href="./getting-started.html">React ドキュメント</a>を参照してください。<section id="a-brief-interlude-props-vs-state"class="level3"><h3>幕間：Props vs State</h3><p>React には 2 種類の「モデル」データが存在します。props と state です。このふたつの相違を理解するのは重要なことです。違いについて自信がない場合は、<a href="./state-and-lifecycle.html">公式の React ドキュメント</a>に目を通すとよいでしょう。<a href="./faq-state.html#what-is-the-difference-between-state-and-props">FAQ: state と props の違いは何ですか？</a> もご覧ください。</section></section><section id="step-3-identify-the-minimal-but-complete-representation-of-ui-state"class="level2"><h2>Step 3: UI 状態を表現する必要かつ十分な state を決定する</h2><p>UI をインタラクティブなものにするためには元となっているデータモデルを更新できる必要があります。これは React なら <strong>state</strong> を使うことで実現できます。<p>適切に開発を進めていくにあたり、そのアプリに求められている更新可能な状態の最小構成を、最初に考えておいたほうがよいでしょう。ここで重要なのは、<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY (don't repeat yourself)</a>の原則です。アプリケーションが必要としている最小限の状態を把握しておき、他に必要なものが出てきたら、そのとき計算すればよいのです。例えば、TODO リストを作る場合、TODO の各項目を配列で保持するだけにし、個数のカウント用に別の state 変数を持たないようにします。その代わりに、TODO の項目数を表示したいのであれば、配列の length を使えばよいのです。<p>今回のサンプルアプリを形作るすべてのデータについて考えてみましょう。次のようなデータがあります。<ul><li>元となる商品のリスト<li>ユーザが入力した検索文字列<li>チェックボックスの値<li>フィルタ済みの商品のリスト</ul><p>それぞれについて見ていき、どれが state になりうるのかを考えてみます。各データについて、3 つの質問をしてみましょう。<ol><li>親から props を通じて与えられたデータでしょうか？ もしそうなら、それは state ではありません<li>時間経過で変化しないままでいるデータでしょうか？ もしそうなら、それは state ではありません<li>コンポーネント内にある他の props や state を使って算出可能なデータでしょうか？ もしそうなら、それは state ではありません</ol><p>元となる商品のリストは props から渡されるので、これは state ではありません。検索文字列とチェックボックスは時間の経過の中で変化し、また、算出することもできないため、state だと思われます。最後に、フィルタ済みの商品のリストは state ではありません。何故ならば、元となる商品のリストと検索文字列とチェックボックスの値を組み合わせることで、フィルタ済みの商品のリストを算出することが可能だからです。<p>というわけで、state と呼べるのは次の 2 つです。<ul><li>ユーザが入力した検索文字列<li>チェックボックスの値</ul></section><section id="step-4-identify-where-your-state-should-live"class="level2"><h2>Step 4: state をどこに配置するべきなのかを明確にする</h2><p data-height="600"data-theme-id="0"data-slug-hash="qPrNQZ"data-default-tab="js"data-user="lacker"data-embed-version="2"class="codepen">See the Pen <a href="https://codepen.io/gaearon/pen/qPrNQZ">Thinking In React: Step 4</a> on <a href="https://codepen.io">CodePen</a>.<p>さて、state の最小構成が明確になりました。次は、どのコンポーネントが state を変化させるのか、つまり state を<em>所有</em>するのかを明確にしましょう。<p>復習：React は、コンポーネントの階層構造をデータが流れ落ちていく、単方向データフローで成り立っています。もしかすると、どのコンポーネントがどんな state を持つべきなのかが、すぐにはわからないかもしれません。<strong>これは、初学者が React への理解を深める上で、最も難しい問題になりがちなところ</strong> なので、ステップを踏みながら理解していきましょう。<p>アプリの各 state について、次の各項目を確認していきます。<ul><li>その state を使って表示を行う、すべてのコンポーネントを確認する<li>共通の親コンポーネントを見つける（その階層構造の中で、ある state を必要としているすべてのコンポーネントの上位にある単一のコンポーネントのことです）<li>共通の親コンポーネントか、その階層構造でさらに上位の別のコンポーネントが state を持っているべきである<li>もし state を持つにふさわしいコンポーネントを見つけられなかった場合は、state を保持するためだけの新しいコンポーネントを作り、階層構造の中ですでに見つけておいた共通の親コンポーネントの上に配置する</ul><p>それでは、この戦術をサンプルアプリにも適用してみましょう。<ul><li><code>ProductTable</code> は商品リストをフィルタする必要があり、<code>SearchBar</code> は検索文字列とチェック状態を表示する必要がある<li>共通の親コンポーネントは <code>FilterableProductTable</code> である<li>概念的にも、検索文字列とチェック状態が <code>FilterableProductTable</code> に配置されることは妥当である</ul><p>いいですね。state を <code>FilterableProductTable</code> の中に配置することが決まりました。では早速、インスタンス変数として <code>this.state = {filterText: '', inStockOnly: false}</code> を <code>FilterableProductTable</code> の <code>constructor</code> に追加して、初期状態をアプリに反映しましょう。その次は、<code>filterText</code> と <code>inStockOnly</code> を <code>ProductTable</code> と <code>SearchBar</code> に props として渡します。最後に、これらの props を使って <code>ProductTable</code> のフィルタ処理を行い、<code>SearchBar</code> のフォームにも値を埋めます。<p>これで、このアプリがどんな振る舞いをするのか見られるようになってきました。<code>filterText</code> に <code>"ball"</code> と入力した状態でアプリを更新すると、データの表が正しく更新されたことが確認できるはずです。</section><section id="step-5-add-inverse-data-flow"class="level2"><h2>Step 5: 逆方向のデータフローを追加する</h2><p data-height="600"data-theme-id="0"data-slug-hash="LzWZvb"data-default-tab="js,result"data-user="rohan10"data-embed-version="2"data-pen-title="Thinking In React: Step 5"class="codepen">See the Pen <a href="https://codepen.io/gaearon/pen/LzWZvb">Thinking In React: Step 5</a> on <a href="https://codepen.io">CodePen</a>.<p>ここまでで、props と state が階層構造を流れ落ちていく関数として、正しく描画を行うアプリを作ることができました。それでは、別の方向のデータフローもサポートしてみましょう。階層構造の奥深くにあるフォームのコンポーネントが、<code>FilterableProductTable</code> にある state を更新できるようにするのです。<p>React ではデータフローが明示的になりプログラムの動作が理解しやすくなりますが、従来の双方向データバインディングよりも少しタイプ量が増えてはしまいます。<p>試しに、ひとつ前 (step 4) のバージョンのサンプルで文字を打ち込んだり、チェックボックスを切り替えてみると、React がその入力を無視することがわかります。これは意図的な挙動で、<code>input</code> の <code>value</code> props が、常に <code>FilterableProductTable</code> から渡された <code>state</code> と同じ値になるようにセットしてあるのです。<p>それでは、どんな挙動になってほしいのかを考えてみましょう。ユーザがフォームを変更するたびに、ユーザ入力を反映するように state を更新したいですね。コンポーネントの state を更新できるのは自分自身だけであるべきなので、<code>FilterableProductTable</code> は <code>SearchBar</code> にコールバックを渡しておいて、state を更新したいときに実行してもらうようにします。入力のたびに呼び出される <code>onChange</code> イベントを利用するとよいでしょう。このコールバックを実行された <code>FilterableProductTable</code> は、<code>setState()</code> を呼び出し、その結果としてアプリが更新されます。</section><section id="and-thats-it"class="level2"><h2>終わりに</h2><p>これで React を使ってコンポーネントやアプリケーションを構築するときの考え方が身に付いたのではないでしょうか。それはもしかしたら、あなたのこれまでのやり方よりも、多くのコードを書くことになるかもしれません。しかしながら、コードは書くよりも読むことのほうが多いこと、そしてモジュール化されていて明示的であるコードはより読みやすいということを思い出してください。大規模なコンポーネントのライブラリを構築し始めると、この明示性やモジュール化しやすさのありがたみが分かり始めます。そしてコードを再利用できるようになるにつれて、あなたが書くコードの行数は減っていくのです。:) <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>