<!doctypehtml><html lang="ja"><meta charset="utf-8"><title>React の最上位 API</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="react-の最上位-api"class="level1"><h1>React の最上位 API</h1><p><code>React</code> は React ライブラリのエントリポイントです。<code>&#x3C;script></code> タグから React を読み込む場合、これらの最上位 API をグローバルの <code>React</code> から利用できます。npm と ES6 を使う場合、<code>import React from 'react'</code> と書けます。npm と ES5 を使う場合、<code>var React = require('react')</code> と書けます。<section id="overview"class="level2"><h2>概要</h2><section id="components"class="level3"><h3>コンポーネント</h3><p>React コンポーネントを使用すると UI を独立した再利用可能な部分に分割し、各部分を個別に考えることができます。React コンポーネントは <code>React.Component</code> または <code>React.PureComponent</code> をサブクラス化することで定義できます。<ul><li><a href="#reactcomponent"><code>React.Component</code></a><li><a href="#reactpurecomponent"><code>React.PureComponent</code></a></ul><p>ES6 クラスを使わない場合は、代わりに <code>create-react-class</code> モジュールを使うことができます。詳しくは <a href="./react-without-es6.html">Using React without ES6</a> を参照してください。<p>React コンポーネントは関数で定義でき、その際に以下の関数でラップできます：<ul><li><a href="#reactmemo"><code>React.memo</code></a></ul></section><section id="creating-react-elements"class="level3"><h3>React 要素を作成する</h3><p>UI がどのように見えるべきかを記述するために <a href="./introducing-jsx.html">JSX の使用</a> を推奨します。JSX のそれぞれの要素は <a href="#createelement"><code>React.createElement()</code></a> を呼ぶための単なる糖衣構文です。JSX を使用している場合は、通常、次のメソッドを直接呼び出すことはありません。<ul><li><a href="#createelement"><code>createElement()</code></a><li><a href="#createfactory"><code>createFactory()</code></a></ul><p>詳しくは <a href="./react-without-jsx.html">JSX なしで React を使う</a> を参照してください。</section><section id="transforming-elements"class="level3"><h3>要素を変換する</h3><p><code>React</code> は要素を操作するためのいくつかの API を提供しています。<ul><li><a href="#cloneelement"><code>cloneElement()</code></a><li><a href="#isvalidelement"><code>isValidElement()</code></a><li><a href="#reactchildren"><code>React.Children</code></a></ul></section><section id="fragments"class="level3"><h3>フラグメント (Fragment)</h3><p><code>React</code> はラッパーなしで複数の要素をレンダーするためのコンポーネントを提供しています。<ul><li><a href="#reactfragment"><code>React.Fragment</code></a></ul></section><section id="refs"class="level3"><h3>Refs</h3><ul><li><a href="#reactcreateref"><code>React.createRef</code></a><li><a href="#reactforwardref"><code>React.forwardRef</code></a></ul></section><section id="suspense"class="level3"><h3>サスペンス (Suspense)</h3><p>サスペンスを使用すると、コンポーネントはレンダーの前に何かを「待機」できます。現在、サスペンスは 1 つのユースケースのみをサポートしています：<a href="./code-splitting.html#reactlazy"><code>React.lazy</code> を使ってコンポーネントを動的に読み込む</a>。将来的にはデータの取得のような他のユースケースもサポートされるでしょう。<ul><li><a href="#reactlazy"><code>React.lazy</code></a><li><a href="#reactsuspense"><code>React.Suspense</code></a></ul></section><section id="transitions"class="level3"><h3>トランジション</h3><p><em>トランジション</em>は React 18 で導入された新しい並行レンダー機能です。これにより更新をトランジションとしてマークすることができ、既に表示されているコンテンツがサスペンスによるフォールバック状態に戻ってしまわないよう更新を中断して構わない、と React に伝えることができるようになります。<ul><li><a href="#starttransition"><code>React.startTransition</code></a><li><a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a></ul></section><section id="hooks"class="level3"><h3>フック (hook)</h3><p><em>フック (hook)</em> は React 16.8 で追加された新機能です。state などの React の機能を、クラスを書かずに使えるようになります。フックには<a href="./hooks-intro.html">専用のセクション</a>と別の API リファレンスがあります。<ul><li><a href="./hooks-reference.html#basic-hooks">基本的なフック</a><ul><li><a href="./hooks-reference.html#usestate"><code>useState</code></a><li><a href="./hooks-reference.html#useeffect"><code>useEffect</code></a><li><a href="./hooks-reference.html#usecontext"><code>useContext</code></a></ul><li><a href="./hooks-reference.html#additional-hooks">追加のフック</a><ul><li><a href="./hooks-reference.html#usereducer"><code>useReducer</code></a><li><a href="./hooks-reference.html#usecallback"><code>useCallback</code></a><li><a href="./hooks-reference.html#usememo"><code>useMemo</code></a><li><a href="./hooks-reference.html#useref"><code>useRef</code></a><li><a href="./hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a><li><a href="./hooks-reference.html#uselayouteffect"><code>useLayoutEffect</code></a><li><a href="./hooks-reference.html#usedebugvalue"><code>useDebugValue</code></a><li><a href="./hooks-reference.html#usedeferredvalue"><code>useDeferredValue</code></a><li><a href="./hooks-reference.html#usetransition"><code>useTransition</code></a><li><a href="./hooks-reference.html#useid"><code>useId</code></a></ul><li><a href="./hooks-reference.html#library-hooks">ライブラリ製作者用フック</a><ul><li><a href="./hooks-reference.html#usesyncexternalstore"><code>useSyncExternalStore</code></a><li><a href="./hooks-reference.html#useinsertioneffect"><code>useInsertionEffect</code></a></ul></ul><hr></section></section><section id="reference"class="level2"><h2>リファレンス</h2><section id="reactcomponent-reactcomponent"class="level3"><h3><code>React.Component</code> {#reactcomponent}</h3><p>React コンポーネントが <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6 クラス</a> を用いて定義されている場合、<code>React.Component</code> はそれらの基底クラスになります。<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Greeting</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token maybe-class-name">Hello</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>基底クラス <code>React.Component</code> に関するメソッドとプロパティの一覧については、<a href="./react-component.html">React.Component API Reference</a> を参照してください。<hr></section><section id="reactpurecomponent-reactpurecomponent"class="level3"><h3><code>React.PureComponent</code> {#reactpurecomponent}</h3><p><code>React.PureComponent</code> は <a href="#reactcomponent"><code>React.Component</code></a> と似ています。両者の違いは <a href="#reactcomponent"><code>React.Component</code></a> が <a href="./react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a> を実装していないことに対し、<code>React.PureComponent</code> は props と state を浅く (shallow) 比較することでそれを実装していることです。<p>React コンポーネントの <code>render()</code> 関数が同じ props と state を与えられたときに同じ結果をレンダーするときは、パフォーマンスを向上させるために <code>React.PureComponent</code> を使用できます。<blockquote><p>補足<p><code>React.PureComponent</code> の <code>shouldComponentUpdate()</code> は オブジェクトの浅い比較のみを行います。これらに複雑なデータ構造が含まれていると、深い部分のみに差分があるために、本当は差分があるにも関わらず差分がないと見なされる場合があります。単純な props と state を持つ場合にのみ <code>PureComponent</code> を継承するか、深いデータ構造が変更されたとわかっているときに <a href="./react-component.html#forceupdate"><code>forceUpdate()</code></a> を使用してください。あるいは、ネストされたデータ構造の高速な比較を容易にするために <a href="https://immutable-js.com/">イミュータブルなオブジェクト</a> の使用を検討してください。<p>さらに、<code>React.PureComponent</code> の <code>shouldComponentUpdate()</code> はサブツリー全体のコンポーネントの props の更新をスキップします。子コンポーネントの全てが「純粋な」コンポーネントであることを確認してください。</blockquote><hr></section><section id="reactmemo-reactmemo"class="level3"><h3><code>React.memo</code> {#reactmemo}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token maybe-class-name">MyComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* render using props */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>React.memo</code> は<a href="./higher-order-components.html">高階コンポーネント</a>です。<p>もしあるコンポーネントが同じ props を与えられたときに同じ結果をレンダーするなら、結果を記憶してパフォーマンスを向上させるためにそれを <code>React.memo</code> でラップすることができます。つまり、React はコンポーネントのレンダーをスキップし、最後のレンダー結果を再利用します。<p><code>React.memo</code> は props の変更のみをチェックします。<code>React.memo</code> でラップしているあなたのコンポーネントがその実装内で <a href="./hooks-state.html"><code>useState</code></a>、<a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> や <a href="./hooks-reference.html#usecontext"><code>useContext</code></a> フックを使っている場合、state やコンテクストの変化に応じた再レンダーは発生します。<p>デフォルトでは props オブジェクト内の複雑なオブジェクトは浅い比較のみが行われます。比較を制御したい場合は 2 番目の引数でカスタム比較関数を指定できます。<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* render using props */</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">areEqual</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*
  nextProps を render に渡した結果が
  prevProps を render に渡した結果となるときに true を返し
  それ以外のときに false を返す
  */</span>
<span class="token punctuation">}</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token maybe-class-name">MyComponent</span><span class="token punctuation">,</span> areEqual<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>これは<strong><a href="./optimizing-performance.html">パフォーマンス最適化</a></strong>のためだけの方法です。バグを引き起こす可能性があるため、レンダーを「抑止する」ために使用しないでください。<blockquote><p>注意<p>クラスコンポーネントの <a href="./react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a> とは異なり、この <code>areEqual</code> 関数は props が等しいときに <code>true</code> を返し、props が等しくないときに <code>false</code> を返します。これは <code>shouldComponentUpdate</code> とは逆です。</blockquote><hr></section><section id="createelement-createelement"class="level3"><h3><code>createElement()</code> {#createelement}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">createElement</span><span class="token punctuation">(</span>
  type<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>props<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token spread operator">...</span>children<span class="token punctuation">]</span>
<span class="token punctuation">)</span></code></pre><p>与えられた型の新しい <a href="./rendering-elements.html">React 要素</a>を作成して返します。<code>type</code> 引数はタグ名の文字列（<code>'div'</code> や <code>'span'</code> など）、<a href="./components-and-props.html">React component</a> 型（クラスもしくは関数）、<a href="#reactfragment">React fragment</a> 型のいずれかです。<p>JSX で書かれたコードは <code>React.createElement()</code> を用いるコードに変換されます。JSX を使っていれば通常 <code>React.createElement()</code> を直接呼び出すことはありません。詳しくは <a href="./react-without-jsx.html">JSX なしで React を使う</a>を参照してください。<hr></section><section id="cloneelement-cloneelement"class="level3"><h3><code>cloneElement()</code> {#cloneelement}</h3><pre class="language-text"><code class="language-text">React.cloneElement(
  element,
  [config],
  [...children]
)</code></pre><p><code>element</code> から新しい React 要素を複製して返します。<code>config</code> には新しく使う props や <code>key</code> や <code>ref</code> を指定します。結果の要素は元の要素の props に新しい props が浅くマージされたものになります。新しい子要素は既存の子要素を置き換えます。<code>config</code> 内で <code>key</code> や <code>ref</code> が指定されていない場合、元の要素の <code>key</code> や <code>ref</code> が保持されます。<p><code>React.cloneElement()</code> は以下のコードとほぼ同等です：<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span>element<span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>props<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token operator">></span></code></pre><p>ただし、<code>ref</code> も保持されます。つまり <code>ref</code> のある子要素を受け取っても、間違って元の React 要素から <code>ref</code> を盗むことはありません。新しい要素にも同じ <code>ref</code> が追加されます。新しい <code>ref</code> や <code>key</code> が存在する場合古いものを置き換えます。<p>この API は非推奨の <code>React.addons.cloneWithProps()</code> の代替として導入されました。<hr></section><section id="createfactory-createfactory"class="level3"><h3><code>createFactory()</code> {#createfactory}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">createFactory</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span></code></pre><p>与えられた型の React 要素を生成する関数を返します。<a href="#createelement"><code>React.createElement()</code></a> と同様に、<code>type</code> 引数はタグ名の文字列（<code>'div'</code> や <code>'span'</code> など）、<a href="./components-and-props.html">React コンポーネント</a>型（クラスもしくは関数）、<a href="#reactfragment">React フラグメント</a>型のいずれかです。<p>このヘルパーはレガシーだと考えられているため、代わりに JSX か <code>React.createElement()</code> を直接使用することをおすすめします。<p>JSX を使っていれば通常 <code>React.createFactory()</code> を直接呼び出すことはありません。詳しくは <a href="./react-without-jsx.html">JSX なしで React を使う</a>を参照してください。<hr></section><section id="isvalidelement-isvalidelement"class="level3"><h3><code>isValidElement()</code> {#isvalidelement}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">isValidElement</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span></code></pre><p>オブジェクトが React 要素であることを確認します。<code>true</code> または <code>false</code> を返します。<hr></section><section id="reactchildren-reactchildren"class="level3"><h3><code>React.Children</code> {#reactchildren}</h3><p><code>React.Children</code> はデータ構造が非公開の <code>this.props.children</code> を扱うためのユーティリティを提供します。<section id="reactchildrenmap-reactchildrenmap"class="level4"><h4><code>React.Children.map</code> {#reactchildrenmap}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">[</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><code>this</code> を <code>thisArg</code> に設定して、<code>children</code> 内に含まれるすべての直下の子要素に対して関数を呼び出します。<code>children</code> が配列の場合は走査され、配列の各要素に対して関数が呼び出されます。<code>children</code> が <code>null</code> または <code>undefined</code> の場合はこのメソッドは配列ではなく <code>null</code> または <code>undefined</code> を返します。<blockquote><p>補足<p><code>children</code> が <code>Fragment</code> の場合、それは 1 つの子要素として扱われ、走査されません。</blockquote></section><section id="reactchildrenforeach-reactchildrenforeach"class="level4"><h4><code>React.Children.forEach</code> {#reactchildrenforeach}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">[</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><a href="#reactchildrenmap"><code>React.Children.map()</code></a> と似ていますが、配列を返しません。</section><section id="reactchildrencount-reactchildrencount"class="level4"><h4><code>React.Children.count</code> {#reactchildrencount}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">count</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p><code>children</code> に含まれるコンポーネントの総数を返します。これは <code>map</code> または <code>forEach</code> に渡したコールバックが呼ばれる回数と同じです。</section><section id="reactchildrenonly-reactchildrenonly"class="level4"><h4><code>React.Children.only</code> {#reactchildrenonly}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">only</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p><code>children</code> が 1 つの子要素しか持たないことを確認し、結果を返します。そうでない場合、このメソッドはエラーを投げます。<blockquote><p>補足:<p><a href="#reactchildrenmap"><code>React.Children.map()</code></a> の返り値は React 要素ではなく配列なため、<code>React.Children.only()</code> はそれを受け付けません。</blockquote></section><section id="reactchildrentoarray-reactchildrentoarray"class="level4"><h4><code>React.Children.toArray</code> {#reactchildrentoarray}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">toArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p>データ構造が非公開の <code>children</code> を平坦な配列として返し、それぞれの要素に key を割り当てます。レンダーメソッド内で子の集合を操作したい場合、特に <code>this.props.children</code> を渡す前に並べ替えたりスライスしたい場合に便利です。<blockquote><p>補足:<p><code>React.Children.toArray()</code> は子のリストを平坦にするときにネストされた配列の意味を保つために key を変更します。つまり、<code>toArray</code> は配列のそれぞれの要素の key に接頭辞を付けて返します。</blockquote><hr></section></section><section id="reactfragment-reactfragment"class="level3"><h3><code>React.Fragment</code> {#reactfragment}</h3><p><code>React.Fragment</code> コンポーネントを使用すると追加の DOM 要素を作成することなく <code>render()</code> メソッドで複数の要素を返すことができます。<pre class="language-javascript"><code class="language-javascript"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Fragment</span></span><span class="token operator">></span>
      <span class="token maybe-class-name">Some</span> text<span class="token punctuation">.</span>
      <span class="token operator">&#x3C;</span>h2<span class="token operator">></span><span class="token constant">A</span> heading<span class="token operator">&#x3C;</span><span class="token operator">/</span>h2<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Fragment</span></span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>また、フラグメントを <code>&#x3C;>&#x3C;/></code> という短縮構文で使用できます。詳しくは <a href="/blog/2017/11/28/react-v16.2.0-fragment-support.html">React v16.2.0: Improved Support for Fragments</a> を参照してください。</section><section id="reactcreateref-reactcreateref"class="level3"><h3><code>React.createRef</code> {#reactcreateref}</h3><p><code>React.createRef</code> は <a href="./refs-and-the-dom.html">ref</a> を作成します。ref は <code>ref</code> 属性を介して React 要素に取り付けることができます。 <code>embed:16-3-release-blog-post/create-ref-example.js</code></section><section id="reactforwardref-reactforwardref"class="level3"><h3><code>React.forwardRef</code> {#reactforwardref}</h3><p><code>React.forwardRef</code> は <a href="./refs-and-the-dom.html">ref</a> を配下のツリーの別のコンポーネントに受け渡す React コンポーネントを作成します。この手法はあまり一般的ではありませんが、2 つのシナリオで特に役立ちます：<ul><li><a href="./forwarding-refs.html#forwarding-refs-to-dom-components">Forwarding refs to DOM components</a><li><a href="./forwarding-refs.html#forwarding-refs-in-higher-order-components">Forwarding refs in higher-order-components</a></ul><p><code>React.forwardRef</code> はレンダー関数を引数として受け入れます。React は props と ref を 2 つの引数として呼び出します。この関数は React ノードを返す必要があります。<p><code>embed:reference-react-forward-ref.js</code><p>上の例では、React は <code>&#x3C;FancyButton ref={ref}></code> 要素に与えた <code>ref</code> を <code>React.forwardRef</code> の呼び出し内のレンダー関数の 2 番目の引数として渡します。このレンダー関数は <code>ref</code> を <code>&#x3C;button ref={ref}></code> 要素に渡します。<p>結果として、React が <code>ref</code> を取り付けた後、<code>ref.current</code> は <code>&#x3C;button></code> の DOM 要素のインスタンスを直接指すようになります。<p>詳しくは <a href="./forwarding-refs.html">forwarding refs</a> を参照してください。</section><section id="reactlazy-reactlazy"class="level3"><h3><code>React.lazy</code> {#reactlazy}</h3><p><code>React.lazy()</code> を使用すると、動的に読み込まれるコンポーネントを定義できます。これにより、バンドルサイズを削減して、最初のレンダー時に使用されないコンポーネントの読み込みを遅らせることができます。<p><a href="./code-splitting.html#reactlazy">code splitting のドキュメント</a>から使用方法を学ぶことができます。また、使い方をより詳しく説明した<a href="https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d">こちらの記事</a>もチェックしてみてください。<pre class="language-js"><code class="language-js"><span class="token comment">// This component is loaded dynamically</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">SomeComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./SomeComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>lazy</code> コンポーネントをレンダーするには <code>&#x3C;React.Suspense></code> がレンダリングツリーの上位に必要です。これはローディングインジケータを指定する方法です。</section><section id="reactsuspense-reactsuspense"class="level3"><h3><code>React.Suspense</code> {#reactsuspense}</h3><p><code>React.Suspense</code> を使用することで、その配下のツリーにレンダーする準備ができていないコンポーネントがあるときに表示するローディングインジケータを指定できます。将来的には <code>Suspense</code> をデータフェッチングのようなより多くのシナリオで使えるようにする予定です。詳細は<a href="/blog/2018/11/27/react-16-roadmap.html">ロードマップ</a>を参照してください。<p>現時点ではコンポーネントの遅延ローディングが <code>&#x3C;React.Suspense></code> がサポートする<strong>唯一の</strong>ユースケースです：<pre class="language-js"><code class="language-js"><span class="token comment">// This component is loaded dynamically</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">OtherComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./OtherComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token comment">// Displays &#x3C;Spinner> until OtherComponent loads</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Suspense</span></span> fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Spinner</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
        <span class="token operator">&#x3C;</span><span class="token maybe-class-name">OtherComponent</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Suspense</span></span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>これは <a href="./code-splitting.html#reactlazy">code splitting guide</a> で文書化されています。遅延される (lazy) コンポーネントを <code>Suspense</code> ツリーの奥深くに置くことができ、それらを 1 つずつラップする必要はありません。ベストプラクティスは <code>&#x3C;Suspense></code> をローディングインジケータを表示したい場所に配置することですが、コードを分割したい場合は <code>lazy()</code> を使用してください。<blockquote><p>補足：<p>既にユーザに表示されているコンテンツがある場合、それがローディングインジケータに戻ってしまうのは不親切です。新しい UI を準備している間「古い」UI を表示しておくことが望ましいことがあります。これを行うため、新たなトランジション API である <a href="#starttransition"><code>startTransition</code></a> と <a href="./hooks-reference.html#usetransition"><code>useTransition</code></a> を用い、更新をトランジションとしてマークすることで意図しない場面でのフォールバックを避けることができます。</blockquote><section id="サーバサイドレンダリングでの-reactsuspense-reactsuspense-in-server-side-rendering"class="level4"><h4>サーバサイドレンダリングでの <code>React.Suspense</code> {#reactsuspense-in-server-side-rendering}</h4><p>サーバサイドレンダリングにおいてもサスペンスバウンダリとサスペンドを用いることで、アプリを部分的に分割して表示していくことができます。 コンポーネントがサスペンドした場合、直近のサスペンスバウンダリに指定されているフォールバックをレンダーするような低優先度のタスクがスケジュールされます。フォールバックを表示する前にコンポーネントのサスペンドが解除された場合は、フォールバックのコンテンツを捨てて実コンテンツを送信します。</section><section id="ハイドレーション中の-reactsuspense-reactsuspense-during-hydration"class="level4"><h4>ハイドレーション中の <code>React.Suspense</code> {#reactsuspense-during-hydration}</h4><p>サスペンスバウンダリがハイドレートされる前に親のバウンダリはハイドレートされていなければなりませんが、兄弟の関係にあるバウンダリとは独立してハイドレートされることができます。 何らかのバウンダリでイベントが起こった場合、そのバウンダリは他のものより優先的にハイドレートされるようになります。<a href="https://github.com/reactwg/react-18/discussions/130">詳細</a></section></section><section id="reactstarttransition-starttransition"class="level3"><h3><code>React.startTransition</code> {#starttransition}</h3><pre class="language-js"><code class="language-js"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">startTransition</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span></code></pre><p><code>React.startTransition</code> は渡されたコールバック内で発生した更新をトランジションとしてマークします。これは <a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a> が使えない場合でも使えるように設計されています。<blockquote><p>補足：<p>トランジション内での更新はクリックのようなより緊急性の高い更新があった場合に遅延されます。<p>トランジション内で起こった更新は、コンテンツが再サスペンドした場合でもフォールバックを表示させないため、更新をレンダーしている最中でもユーザが操作できる状態が保たれます。<p><code>React.startTransition</code> は <code>isPending</code> フラグを返しません。トランジションのペンディング状態を知るには <a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a> を参照してください。<span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></blockquote></section></section></section>