<!doctypehtml><html lang="ja"><meta charset="utf-8"><title>strict モード</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="strict-モード"class="level1"><h1>strict モード</h1><p><code>StrictMode</code> はアプリケーションの潜在的な問題点を洗い出すためのツールです。<code>Fragment</code> と同様に、<code>StrictMode</code> は目に見える UI を描画しません。<code>StrictMode</code> の子孫要素に対しては、付加的な検査および警告が動くようになります。<blockquote><p>補足：<p>strict モードでの検査は開発モードでのみ動きます。<em>本番ビルドには影響を与えません</em>。</blockquote><p>strict モードはアプリケーションの任意の箇所で有効にできます。下はその一例です。 <code>embed:strict-mode/enabling-strict-mode.js</code><p>上のコード例において、<code>Header</code> と <code>Footer</code> に対しては strict モードの検査は<em>されません</em>。しかし <code>ComponentOne</code>、<code>ComponentTwo</code> およびそのすべての子孫要素に対しては検査が働きます。<p>現在、<code>StrictMode</code> は以下のことに役立ちます。<ul><li><a href="#identifying-unsafe-lifecycles">安全でないライフサイクルの特定</a><li><a href="#warning-about-legacy-string-ref-api-usage">レガシーな文字列 ref API の使用に対する警告</a><li><a href="#warning-about-deprecated-finddomnode-usage">非推奨な findDOMNode の使用に対する警告</a><li><a href="#detecting-unexpected-side-effects">意図しない副作用の検出</a><li><a href="#detecting-legacy-context-api">レガシーなコンテクスト API の検出</a><li><a href="#ensuring-reusable-state">state の再利用性を保証する</a></ul><p>将来の React のリリースではこの他にも機能が追加される予定です。<section id="identifying-unsafe-lifecycles"class="level3"><h3>安全でないライフサイクルの特定</h3><p><a href="/blog/2018/03/27/update-on-async-rendering.html">このブログ記事</a>で書かれているように、いくつかのライフサイクルメソッドは非同期な React アプリケーションで使用するにあたって安全ではありません。しかしながら、アプリケーションがサードパーティのライブラリを用いているなら、そのような安全でないライフサイクルが使用されていないと保証することは難しくなります。strict モードは、幸運にもこのような場合に役立ちます！<p>strict モードが有効のとき、React は安全でないライフサイクルを使用した全てのクラス型コンポーネントのリストをまとめあげ、それらのコンポーネントの情報を含む下のような警告のログを出力します。<p><img src="../images/blog/strict-mode-unsafe-lifecycles-warning.png"><p><em>今</em> strict モードによって特定された問題に対処しておくことで、将来の React のリリース時に、並行レンダリングを活用しやすくなります。</section><section id="warning-about-legacy-string-ref-api-usage"class="level3"><h3>レガシーな文字列 ref API の使用に対する警告</h3><p>以前は、React は ref を管理するためにレガシーな文字列 ref API とコールバック API の 2 つの手法を提供していました。文字列 ref API はより便利なものでしたが、<a href="https://github.com/facebook/react/issues/1373">いくつか不都合な点</a>があり、公式に<a href="./refs-and-the-dom.html#legacy-api-string-refs">コールバック形式を代わりに用いること</a>を推奨しました。<p>React 16.3 ではこれらの不都合なく文字列 ref の利点を活かせるような次の第 3 の選択を追加しました。 <code>embed:16-3-release-blog-post/create-ref-example.js</code><p>オブジェクトによる ref は文字列 ref を置きかえるため主に追加されたため、現在 strict モードでは文字列 ref の使用に対して警告します。<blockquote><p><strong>補足：</strong><p>コールバックによる ref は新しい <code>createRef</code> API に加えて継続してサポートされます。<p>コンポーネント内のコールバックによる ref を置きかえる必要はありません。コールバック ref は少しだけ柔軟に使えるため、発展的な機能として残り続けます。</blockquote><p><a href="./refs-and-the-dom.html">新しい <code>createRef</code> API についてはこちらを参照してください。</a></section><section id="warning-about-deprecated-finddomnode-usage"class="level3"><h3>非推奨な findDOMNode の使用に対する警告</h3><p>React ではかつてクラスのインスタンスを元にツリー内の DOM ノードを見つける <code>findDOMNode</code> がサポートされていました。通常、<a href="./refs-and-the-dom.html#creating-refs">DOM ノードに ref を付与する</a>ことができるため、このような操作は必要ありません。<p><code>findDOMNode</code> はクラスコンポーネントでも使用可能でしたが、これによって親要素が特定の子要素がレンダーされるのを要求する状況が許されてしまい、抽象レベルを破壊してしまっていました。このことにより、親要素が子の DOM ノードにまで踏み込んでしまう可能性があるためにコンポーネントの詳細な実装を変更できない、というようなリファクタリングの危険要因を生み出してしまっていました。<code>findDOMNode</code> は 1 番目の子要素しか返しませんが、フラグメントを使うことによりコンポーネントは複数の DOM ノードをレンダーできます。更に <code>findDOMNode</code> はその場限りの読みこみ API であり、問い合わせたときにしか結果を返しません。もし子コンポーネントが別のノードをレンダーした場合に、この変化を捕捉することはできません。これらのため、<code>findDOMNode</code> はコンポーネントが絶対に変化することのない単一の DOM ノードのみを返す場合のみ有効なものでした。<p>代わりに <a href="./forwarding-refs.html#forwarding-refs-to-dom-components">ref のフォワーディング</a>を使うことで、カスタムコンポーネントに ref を渡し、DOM にまで引き継ぐことでこれを明示的にすることができます。<p>コンポーネントのラッパーの DOM ノードを追加し、そこに直接 ref を付与することもできます。<pre class="language-javascript{4,7}"><code class="language-javascript{4,7}">class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.wrapper = React.createRef();
  }
  render() {
    return &#x3C;div ref={this.wrapper}>{this.props.children}&#x3C;/div>;
  }
}</code></pre><blockquote><p>補足：<p>CSS では、特定のノードをレイアウトの一部にしたくない場合 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display#display_contents"><code>display: contents</code></a> 属性が利用できます。</blockquote></section><section id="detecting-unexpected-side-effects"class="level3"><h3>意図しない副作用の検出</h3><p>概念的に、React は次の 2 つのフェーズで動作します。<ul><li><strong>レンダー</strong>フェーズでは、変更対象（例えば DOM）にどのような変更が必要か決めます。このフェーズにおいて、React は <code>render</code> を呼び出し、1 つ前のレンダー結果と比較します。<li><strong>コミット</strong>フェーズで React は変更を反映します（React DOM の場合ではここで React は DOM ノードの挿入、更新、削除を行います）。React はこのフェーズで <code>componentDidMount</code> や <code>componentDidUpdate</code> などのライフサイクルの呼び出しも行います。</ul><p>コミットフェーズは大体の場合非常に高速ですが、レンダーは低速になることがあります。このため、今後追加される並行モード（現状ではまだデフォルトでは無効です）ではレンダー処理を細分化し、ブラウザをブロックしてしまうことを避けるために処理を中断、再開するようになります。これは、React がコミットの前にレンダーフェーズのライフサイクルを複数回呼び出しうるということであり、（エラーや優先度の高い割り込みによって）コミットを行わずに呼び出しうるということを意味します。<p>レンダーフェーズのライフサイクルには次のクラス型コンポーネントのメソッドが含まれます。<ul><li><code>constructor</code><li><code>componentWillMount</code> (or <code>UNSAFE_componentWillMount</code>)<li><code>componentWillReceiveProps</code> (or <code>UNSAFE_componentWillReceiveProps</code>)<li><code>componentWillUpdate</code> (or <code>UNSAFE_componentWillUpdate</code>)<li><code>getDerivedStateFromProps</code><li><code>shouldComponentUpdate</code><li><code>render</code><li><code>setState</code> 更新関数（第 1 引数）</ul><p>上記のメソッドは複数回呼ばれることがあるため、副作用を持たないようにすることが大切です。このルールを破ると、メモリリークやアプリケーションの無効な状態など、多くの問題を引き起こしえます。不幸にも、これらの問題はしばしば<a href="https://en.wikipedia.org/wiki/Deterministic_algorithm">非決定的な</a>ため、検出が難しくなります。<p>strict モードでは自動的には副作用を見つけてはくれませんが、それらの副作用をほんの少し決定的にすることによって特定できる助けになります。これは、以下の関数を意図的に 2 回呼び出すことによって行われます。<ul><li>クラスコンポーネントの <code>constructor</code>, <code>render</code>, <code>shouldComponentUpdate</code> メソッド<li>クラスコンポーネントの <code>getDerivedStateFromProps</code> 静的メソッド<li>関数コンポーネントの本体<li>state 更新用関数（<code>setState</code> の第 1 引数として渡されるもの）<li><code>useState</code>, <code>useMemo</code>, <code>useReducer</code> に渡される関数</ul><blockquote><p>補足：<p>この機能は開発モードのみで適用されます。<em>ライフサイクルは本番モードでは 2 回呼び出されることはありません。</em></blockquote><p>例えば、次のようなコードを考えてみましょう。 <code>embed:strict-mode/side-effects-in-constructor.js</code><p>はじめ見たとき、このコードには問題があるようには見えないかもしれません。しかし、<code>SharedApplicationState.recordEvent</code> が<a href="https://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning">冪等</a>ではないとすると、このコンポーネントを複数回インスタンス化するとアプリケーションの無効な状態を引き起こしえます。このような分かりづらいバグは開発中には現れないかもしれませんし、バグが一貫性のない挙動をして見逃してしまうかもしれません。<p>コンポーネントのコンストラクタなどのメソッドを意図的に 2 度呼び出すことによって、strict モードではこのようなことが起きた場合に気付きやすくしています。<blockquote><p>補足<p>React 17 では、2 回目にコールされたライフサイクル関数からはログが表示されないようにするため、<code>console.log()</code> のようなコンソールメソッドを自動的に書き換えていました。しかしこれは特定のケースで望ましくない挙動を引き起こしており、そのための<a href="https://github.com/facebook/react/issues/20090#issuecomment-715927125">回避策</a>も存在していました。<p>React 18 以降では、React はログを一切抑止しなくなります。ただし React DevTools をインストールしている場合、2 回目以降のコールからのログはわずかに薄く表示されるようになります。また React DevTools にはそのようなログを完全に抑制するオプションも存在します（デフォルトでは off です）。</blockquote></section><section id="detecting-legacy-context-api"class="level3"><h3>レガシーなコンテクスト API の検出</h3><p>レガシーなコンテクスト API はエラーを起こしがちで、将来のメジャーバージョンで削除予定です。16.x の全てのバージョンでは依然として動きますが、strict モードでは下のような警告文が表示されます。<p><img src="../images/blog/warn-legacy-context-in-strict-mode.png"><p>Read the <a href="./context.html">new context API documentation</a> to help migrate to the new version.</section><section id="ensuring-reusable-state"class="level3"><h3>state 再利用可能性の保証</h3><p>将来的に、React が state を保ったままで UI の一部分を追加・削除できるような機能を導入したいと考えています。例えば、ユーザがタブを切り替えて画面を離れてから戻ってきた場合に、React が以前の画面をすぐに表示できるようにしたいのです。これを可能にするため、React はアンマウントする前にコンポーネントが使用していたものと同じ state を使用してツリーを再マウントする機能をサポートする予定です。<p>この機能により、React の標準状態でのパフォーマンスが向上しますが、コンポーネントは副作用が何度も登録されたり破棄されたりすることに対して耐性を持つことが必要になります。ほとんどの副作用は何の変更もなく動作しますが、一部の副作用は破棄用コールバックで購読を適切にクリーンアップしていなかったり、暗黙のうちに一度だけマウントまたは破棄されるものと想定していたりします。<p>これらの問題に気付きやすくするために、React 18 は strict モードに新しい開発時専用のチェックを導入します。この新しいチェックは、コンポーネントが初めてマウントされるたびに、すべてのコンポーネントを自動的にアンマウント・再マウントし、かつ 2 回目のマウントで以前の state を復元します。<p>strict モードでこの機能を有効にした場合の開発時動作を示すために、React が新しいコンポーネントをマウントするときに起こることを考えてみましょう。この機能がない状態でコンポーネントがマウントされる際、React は以下のように副作用を作成します。<pre class="language-text"><code class="language-text">* React がコンポーネントをマウント
  * レイアウト副作用 (layout effect) を作成
  * （通常の）副作用を作成</code></pre><p>React 18 以降の strict モードでは、開発時にコンポーネントがマウントされた場合、React はコンポーネントの即時アンマウント・再マウントをシミュレーションします：<pre class="language-text"><code class="language-text">* React がコンポーネントをマウント
    * レイアウト副作用を作成
    * 副作用を作成
* マウントされたコンポーネント内で副作用の破棄をシミュレート
    * レイアウト副作用を破棄
    * 副作用を破棄
* マウントされたコンポーネント内で副作用の再生成をシミュレート
    * レイアウト副作用を作成
    * 副作用の作成用コードの実行</code></pre><p>2 度目のマウントにおいて React は初回マウント時の state を復元します。この機能はタブを操作して画面を離れてから戻ってくる、といったユーザの挙動をシミュレートしたものであり、コードが state の復元を正しく処理できることを保証できます。<p>コンポーネントがアンマウントされる場合は副作用は通常通り破棄されます：<pre class="language-text"><code class="language-text">* React がコンポーネントをアンマウント
  * レイアウト副作用を破棄
  * 副作用を破棄</code></pre><p>アンマウント・再マウントでは以下が発生します：<ul><li><code>componentDidMount</code><li><code>componentWillUnmount</code><li><code>useEffect</code><li><code>useLayoutEffect</code><li><code>useInsertionEffect</code></ul><blockquote><p>補足<p>この挙動は開発モードの場合にのみ適用されます。<em>本番用の挙動は変わりません</em>。</blockquote><p>よくある問題についてのサポートは以下を参照してください：<ul><li><a href="https://github.com/reactwg/react-18/discussions/18">How to support Reusable State in Effects</a> <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></ul></section></section>