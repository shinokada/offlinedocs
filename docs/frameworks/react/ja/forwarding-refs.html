<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>ref のフォワーディング</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="ref-のフォワーディング" class="level1">
      <h1>ref のフォワーディング</h1>
      <p>ref のフォワーディングはあるコンポーネントを通じてその子コンポーネントのひとつに <a href="./refs-and-the-dom.html">ref</a> を自動的に渡すテクニックです。これは基本的にはアプリケーション内のほとんどのコンポーネントで必要ありません。しかし、コンポーネントの種類によっては、特に再利用可能なコンポーネントライブラリにおいては、便利なものとなるかもしれません。一般的なシナリオについて以下で述べます。</p>
      <section id="forwarding-refs-to-dom-components" class="level2">
        <h2>DOM コンポーネントに ref をフォワーディングする</h2>
        <p>
          ネイティブの <code>button</code> DOM 要素をレンダーする <code>FancyButton</code> というコンポーネントを考えてみましょう：
          <code>embed:forwarding-refs/fancy-button-simple.js</code>
        </p>
        <p>React コンポーネントは、レンダーの結果も含め、実装の詳細を隠蔽します。<code>FancyButton</code> を使用する他のコンポーネントは内側の <code>button</code> DOM 要素に対する <a href="./refs-and-the-dom.html">ref を取得する</a><strong>必要は通常ありません</strong> 。これは、互いのコンポーネントの DOM 構造に過剰に依存することを防ぐので、良いことです。</p>
        <p>そういったカプセル化は <code>FeedStory</code> や <code>Comment</code> のようなアプリケーションレベルのコンポーネントでは望ましいことではありますが、<code>FancyButton</code> や <code>MyTextInput</code> といった非常に多くのところで再利用可能な "末梢の" コンポーネントでは不便である可能性があります。このようなコンポーネントは、アプリケーションのいたるところで通常の DOM である <code>button</code> や <code>input</code> と同様に扱われる傾向にあり、フォーカス、要素の選択、アニメーションをこなすにはそれら DOM ノードにアクセスすることが避けられないかもしれません。</p>
        <p><strong>ref のフォワーディングはオプトインの機能であり、それにより、コンポーネントが <code>ref</code> を受け取って、それをさらに下層の子に渡せる（つまり、ref を "転送" できる）ようになります。</strong></p>
        <p>下の例では、<code>FancyButton</code> は渡された <code>ref</code> を取得して、それをレンダーする <code>button</code> DOM にフォワーディングするために、<code>React.forwardRef</code> を使っています。</p>
        <p><code>embed:forwarding-refs/fancy-button-simple-ref.js</code></p>
        <p>このように、<code>FancyButton</code> を使ったコンポーネントは下層の <code>button</code> DOM ノードの ref を取得することができ、必要であれば <code>button</code> DOM を直接使うかのように、DOM にアクセスすることができます。</p>
        <p>上の例で、何が起こっているかを順々に説明します。</p>
        <ol>
          <li><code>React.createRef</code> を呼び、<a href="./refs-and-the-dom.html">React ref</a> をつくり、それを <code>ref</code> 変数に代入します。</li>
          <li><code>ref</code> を <code>&#x3C;FancyButton ref={ref}></code> に JSX の属性として指定することで渡します。</li>
          <li>React は <code>ref</code> を、<code>forwardRef</code> 内の関数 <code>(props, ref) => ...</code> の 2 番目の引数として渡します。</li>
          <li>この引数として受け取った <code>ref</code> を <code>&#x3C;button ref={ref}></code> に JSX の属性として指定することで渡します。</li>
          <li>この ref が紐付けられると、<code>ref.current</code> は <code>&#x3C;button></code> DOM ノードのことを指すようになります。</li>
        </ol>
        <blockquote>
          <p>補足</p>
          <p>2 番目の引数 <code>ref</code> は <code>React.forwardRef</code> の呼び出しを使ってコンポーネントを定義したときにだけ存在します。通常の関数またはクラスコンポーネントは <code>ref</code> 引数を受け取らず、ref は props からも利用できません。</p>
          <p>ref のフォワーディング先は DOM コンポーネントだけにとどまりません。クラスコンポーネントインスタンスに対しても ref をフォワーディングできます。</p>
        </blockquote>
      </section>
      <section id="note-for-component-library-maintainers" class="level2">
        <h2>コンポーネントライブラリのメンテナ向けの補足</h2>
        <p><strong>コンポーネントライブラリの中で、<code>forwardRef</code> を使い始めた場合、破壊的変更として扱い、新しいメジャーバージョンをリリースすべきです。</strong>ライブラリが外から見て今までと違う挙動（例えば、どの値が ref に代入されるかや、どの型がエクスポートされるのか）をする可能性があり、古い挙動に依存しているアプリケーションや他のライブラリを壊す可能性があるからです。</p>
        <p><code>React.forwardRef</code> が存在する場合だけ、条件的に <code>React.forwardRef</code> を適用することも同じ理由で推奨されません：そのような実装は、React そのものを更新したとき、ライブラリがどのように振る舞うかを変えてしまい、ユーザのアプリケーションを破壊する可能性があるからです。</p>
      </section>
      <section id="forwarding-refs-in-higher-order-components" class="level2">
        <h2>高階コンポーネントにおける ref のフォワーディング</h2>
        <p>
          このテクニックは<a href="./higher-order-components.html">高階コンポーネント</a>（HOC としても知られています）においても特に便利です。コンポーネントの props をコンソールにログ出力する HOC を例として考えてみましょう。
          <code>embed:forwarding-refs/log-props-before.js</code>
        </p>
        <p>
          "logProps" HOC はすべての <code>props</code> をラップするコンポーネントに渡すので、レンダーされる出力は同じになるでしょう。例えば、"fancy button" コンポーネントに渡されるすべての props をログとして記録するために、この HOC を使用することができます。
          <code>embed:forwarding-refs/fancy-button.js</code>
        </p>
        <p>ところが上記の例には欠陥があります。これでは ref が渡されないのです。<code>ref</code> は props のひとつではないからです。<code>key</code> と同様に ref は React では props とは違う扱いになります。HOC に対する ref を追加した場合、ラップされたコンポーネントではなく、一番外側のコンテナコンポーネントを参照します。</p>
        <p>
          これは <code>FancyButton</code> コンポーネントに紐付けられることを意図した ref が、実際には <code>LogProps</code> コンポーネントに紐付けられてしまうことを意味します。
          <code>embed:forwarding-refs/fancy-button-ref.js</code>
        </p>
        <p>
          幸いにも、<code>React.forwardRef</code> API を使って、内側の <code>FancyButton</code> コンポーネントに対して ref を明示的に転送することができます。<code>React.forwardRef</code> は render 関数を受け取り、その関数は <code>props</code> と <code>ref</code> を引数として取り、React ノードを返します。例えば、
          <code>embed:forwarding-refs/log-props-after.js</code>
        </p>
      </section>
      <section id="displaying-a-custom-name-in-devtools" class="level2">
        <h2>DevTools でのカスタム名表示</h2>
        <p><code>React.forwardRef</code> は render 関数を受け取ります。React DevTools は ref をフォワーディングしているコンポーネントとして何を表示すべきかを決定するために、この関数を使います。</p>
        <p>例えば、次のコンポーネントは "<em>ForwardRef</em>" として DevTools に表示されます。</p>
        <p><code>embed:forwarding-refs/wrapped-component.js</code></p>
        <p>render 関数に名前をつけると、DevTools はその名前を含めるようになります（例： "<em>ForwardRef(myFunction)</em>"）：</p>
        <p><code>embed:forwarding-refs/wrapped-component-with-function-name.js</code></p>
        <p>ラップしているコンポーネントを含めるために、render 関数の <code>displayName</code> を設定することもできます：</p>
        <p>
          <code>embed:forwarding-refs/customized-display-name.js</code>
          <span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span>
        </p>
      </section>
    </section>
  </body>
</html>
