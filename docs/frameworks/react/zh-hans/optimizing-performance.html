<!doctypehtml><html lang="zh-hans"><meta charset="utf-8"><title>性能优化</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="性能优化"class="level1"><h1>性能优化</h1><p>UI 更新需要昂贵的 DOM 操作，因此 React 内部使用了几种巧妙的技术来最小化 DOM 操作次数。对于大部分应用而言，使用 React 时无需做大量优化工作就能拥有高性能的用户界面。尽管如此，你仍然有办法来加速你的 React 应用。<section id="use-the-production-build"class="level2"><h2>使用生产版本</h2><p>当你需要对你的 React 应用进行 benchmark，或者遇到了性能问题，请确保你正在使用压缩后的生产版本。<p>React 默认包含了许多有用的警告信息。这些警告信息在开发过程中非常有帮助。然而这使得 React 变得更大且更慢，所以你需要确保部署时使用了生产版本。<p>如果你不能确定你的编译过程是否设置正确，你可以通过安装 <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">Chrome 的 React 开发者工具</a> 来检查。如果你浏览一个基于 React 生产版本的网站，图标背景会变成深色：</p><img src="./docs/devtools-prod.png"style="max-width:100%"alt="React DevTools on a website with production version of React"><p>如果你浏览一个基于 React 开发模式的网站，图标背景会变成红色：</p><img src="./docs/devtools-dev.png"style="max-width:100%"alt="React DevTools on a website with development version of React"><p>推荐你在开发应用时使用开发模式，而在为用户部署应用时使用生产模式。<p>你可以在下面看到几种为应用构建生产版本的操作说明。<section id="create-react-app"class="level3"><h3>Create React App</h3><p>如果你的项目是通过 <a href="https://github.com/facebookincubator/create-react-app">Create React App</a> 构建的，运行：<pre class="language-text"><code class="language-text">npm run build</code></pre><p>这段命令将在你的项目下的 <code>build/</code> 目录中生成对应的生产版本。<p>注意只有在生产部署前才需要执行这个命令。正常开发使用 <code>npm start</code> 即可。</section><section id="single-file-builds"class="level3"><h3>单文件构建</h3><p>我们提供了可以在生产环境使用的单文件版 React 和 React DOM：<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/react@18/umd/react.production.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/react-dom@18/umd/react-dom.production.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>注意只有以 <code>.production.min.js</code> 为结尾的 React 文件适用于生产。</section><section id="brunch"class="level3"><h3>Brunch</h3><p>通过安装 <a href="https://github.com/brunch/terser-brunch"><code>terser-brunch</code></a> 插件，来获得最高效的 Brunch 生产构建：<pre class="language-text"><code class="language-text"># 如果你使用 npm
npm install --save-dev terser-brunch

# 如果你使用 Yarn
yarn add --dev terser-brunch</code></pre><p>接着，在 <code>build</code> 命令后添加 <code>-p</code> 参数，以创建生产构建：<pre class="language-text"><code class="language-text">brunch build -p</code></pre><p>请注意，你只需要在生产构建时这么做。你不需要在开发环境中使用 <code>-p</code> 参数或者应用这个插件，因为这会隐藏有用的 React 警告信息并使得构建速度变慢。</section><section id="browserify"class="level3"><h3>Browserify</h3><p>为了最高效的生产构建，需要安装一些插件：<pre class="language-text"><code class="language-text"># 如果你使用 npm
npm install --save-dev envify terser uglifyify

# 如果你使用 Yarn
yarn add --dev envify terser uglifyify</code></pre><p>为了创建生产构建，确保你添加了以下转换器 <strong>（顺序很重要）</strong>：<ul><li><a href="https://github.com/hughsk/envify"><code>envify</code></a> 转换器用于设置正确的环境变量。设置为全局 (<code>-g</code>)。<li><a href="https://github.com/hughsk/uglifyify"><code>uglifyify</code></a> 转换器移除开发相关的引用代码。同样设置为全局 (<code>-g</code>)。<li>最后，将产物传给 <a href="https://github.com/terser-js/terser"><code>terser</code></a> 并进行压缩（<a href="https://github.com/hughsk/uglifyify#motivationusage">为什么要这么做？</a>）。</ul><p>举个例子：<pre class="language-text"><code class="language-text">browserify ./index.js \
  -g [ envify --NODE_ENV production ] \
  -g uglifyify \
  | terser --compress --mangle > ./bundle.js</code></pre><p>请注意，你只需要在生产构建时用到它。你不需要在开发环境应用这些插件，因为这会隐藏有用的 React 警告信息并使得构建速度变慢。</section><section id="rollup"class="level3"><h3>Rollup</h3><p>为了最高效的 Rollup 生产构建，需要安装一些插件：<pre class="language-text"><code class="language-text"># 如果你使用 npm
npm install --save-dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-terser

# 如果你使用 Yarn
yarn add --dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-terser</code></pre><p>为了创建生产构建，确保你添加了以下插件 <strong>（顺序很重要）</strong>：<ul><li><a href="https://github.com/rollup/rollup-plugin-replace"><code>replace</code></a> 插件确保环境被正确设置。<li><a href="https://github.com/rollup/rollup-plugin-commonjs"><code>commonjs</code></a> 插件用于支持 CommonJS。<li><a href="https://github.com/TrySound/rollup-plugin-terser"><code>terser</code></a> 插件用于压缩并生成最终的产物。</ul><pre class="language-js"><code class="language-js"><span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token comment">// ...</span>
  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'rollup-plugin-replace'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token string-property property">'process.env.NODE_ENV'</span><span class="token operator">:</span> <span class="token known-class-name class-name">JSON</span><span class="token punctuation">.</span><span class="token method function property-access">stringify</span><span class="token punctuation">(</span><span class="token string">'production'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'rollup-plugin-commonjs'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'rollup-plugin-terser'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">]</span></code></pre><p><a href="https://gist.github.com/Rich-Harris/cb14f4bc0670c47d00d191565be36bf0">点击</a>查看完整的安装示例。<p>请注意，你只需要在生产构建时用到它。你不需要在开发中使用 <code>terser</code> 插件或者 <code>replace</code> 插件替换 <code>'production'</code> 变量，因为这会隐藏有用的 React 警告信息并使得构建速度变慢。</section><section id="webpack"class="level3"><h3>webpack</h3><blockquote><p><strong>注意：</strong><p>如果你使用了 Create React App，请跟随<a href="#create-react-app">上面的说明</a>进行操作。<br>只有当你直接配置了 webpack 才需要参考以下内容。</blockquote><p>在生产模式下，Webpack v4+ 将默认对代码进行压缩：<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">TerserPlugin</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'terser-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span><span class="token property-access">exports</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">mode</span><span class="token operator">:</span> <span class="token string">'production'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">optimization</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">minimizer</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">TerserPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token comment">/* additional options here */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>你可以在 <a href="https://webpack.js.org/guides/production/">webpack 文档</a>中了解更多内容。<p>请注意，你只需要在生产构建时用到它。你不需要在开发中使用 <code>TerserPlugin</code> 插件，因为这会隐藏有用的 React 警告信息并使得构建速度变慢。</section></section><section id="profiling-components-with-the-devtools-profiler"class="level2"><h2>使用开发者工具中的分析器对组件进行分析</h2><p><code>react-dom</code> 16.5+ 和 <code>react-native</code> 0.57+ 加强了分析能力。在开发模式下，React 开发者工具会出现分析器标签。 你可以在<a href="/blog/2018/09/10/introducing-the-react-profiler.html">《介绍 React 分析器》</a>这篇博客中了解概述。 你也可以<a href="https://www.youtube.com/watch?v=nySib7ipZdk">在 YouTube 上</a>观看分析器的视频指导。<p>如果你还未安装 React 开发者工具，你可以在这里找到它们：<ul><li><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en">Chrome 浏览器扩展</a><li><a href="https://addons.mozilla.org/en-GB/firefox/addon/react-devtools/">Firefox 浏览器扩展</a><li><a href="https://www.npmjs.com/package/react-devtools">独立 Node 包</a></ul><blockquote><p>注意<p><code>react-dom</code> 的生产分析包也可以在 <code>react-dom/profiling</code> 中找到。 通过查阅 <a href="https://fb.me/react-profiling">fb.me/react-profiling</a> 来了解更多关于使用这个包的内容。</blockquote><blockquote><p>注意<p>在 React 17 之前，我们使用了标准的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API">User Timing API</a>，用 chrome 的 performance 性能选项卡来配置组件。 更详细的攻略，请参阅 <a href="https://calibreapp.com/blog/react-performance-profiling-optimization">Ben Schwarz 的文章</a>。</blockquote></section><section id="virtualize-long-lists"class="level2"><h2>虚拟化长列表</h2><p>如果你的应用渲染了长列表（上百甚至上千的数据），我们推荐使用“虚拟滚动”技术。这项技术会在有限的时间内仅渲染有限的内容，并奇迹般地降低重新渲染组件消耗的时间，以及创建 DOM 节点的数量。<p><a href="https://react-window.now.sh/">react-window</a> 和 <a href="https://bvaughn.github.io/react-virtualized/">react-virtualized</a> 是热门的虚拟滚动库。 它们提供了多种可复用的组件，用于展示列表、网格和表格数据。 如果你想要一些针对你的应用做定制优化，你也可以创建你自己的虚拟滚动组件，就像 <a href="https://medium.com/@paularmstrong/twitter-lite-and-high-performance-react-progressive-web-apps-at-scale-d28a00e780a3">Twitter 所做的</a>。</section><section id="avoid-reconciliation"class="level2"><h2>避免调停</h2><p>React 构建并维护了一套内部的 UI 渲染描述。它包含了来自你的组件返回的 React 元素。该描述使得 React 避免创建 DOM 节点以及没有必要的节点访问，因为 DOM 操作相对于 JavaScript 对象操作更慢。虽然有时候它被称为“虚拟 DOM”，但是它在 React Native 中拥有相同的工作原理。<p>当一个组件的 props 或 state 变更，React 会将最新返回的元素与之前渲染的元素进行对比，以此决定是否有必要更新真实的 DOM。当它们不相同时，React 会更新该 DOM。<p>即使 React 只更新改变了的 DOM 节点，重新渲染仍然花费了一些时间。在大部分情况下它并不是问题，不过如果它已经慢到让人注意了，你可以通过覆盖生命周期方法 <code>shouldComponentUpdate</code> 来进行提速。该方法会在重新渲染前被触发。其默认实现总是返回 <code>true</code>，让 React 执行更新：<pre class="language-javascript"><code class="language-javascript"><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>如果你知道在什么情况下你的组件不需要更新，你可以在 <code>shouldComponentUpdate</code> 中返回 <code>false</code> 来跳过整个渲染过程。其包括该组件的 <code>render</code> 调用以及之后的操作。<p>在大部分情况下，你可以继承 <a href="./react-api.html#reactpurecomponent"><code>React.PureComponent</code></a> 以代替手写 <code>shouldComponentUpdate()</code>。它用当前与之前 props 和 state 的浅比较覆写了 <code>shouldComponentUpdate()</code> 的实现。</section><section id="shouldcomponentupdate-in-action"class="level2"><h2>shouldComponentUpdate 的作用</h2><p>这是一个组件的子树。每个节点中，<code>SCU</code> 代表 <code>shouldComponentUpdate</code> 返回的值，而 <code>vDOMEq</code> 代表返回的 React 元素是否相同。最后，圆圈的颜色代表了该组件是否需要被调停。<figure><img src="./docs/should-component-update.png"style="max-width:100%"></figure><p>节点 C2 的 <code>shouldComponentUpdate</code> 返回了 <code>false</code>，React 因而不会去渲染 C2，也因此 C4 和 C5 的 <code>shouldComponentUpdate</code> 不会被调用到。<p>对于 C1 和 C3，<code>shouldComponentUpdate</code> 返回了 <code>true</code>，所以 React 需要继续向下查询子节点。这里 C6 的 <code>shouldComponentUpdate</code> 返回了 <code>true</code>，同时由于渲染的元素与之前的不同使得 React 更新了该 DOM。<p>最后一个有趣的例子是 C8。React 需要渲染这个组件，但是由于其返回的 React 元素和之前渲染的相同，所以不需要更新 DOM。<p>显而易见，你看到 React 只改变了 C6 的 DOM。对于 C8，通过对比了渲染的 React 元素跳过了渲染。而对于 C2 的子节点和 C7，由于 <code>shouldComponentUpdate</code> 使得 <code>render</code> 并没有被调用。因此它们也不需要对比元素了。</section><section id="examples"class="level2"><h2>示例</h2><p>如果你的组件只有当 <code>props.color</code> 或者 <code>state.count</code> 的值改变才需要更新时，你可以使用 <code>shouldComponentUpdate</code> 来进行检查：<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">CounterButton</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">color</span> <span class="token operator">!==</span> nextProps<span class="token punctuation">.</span><span class="token property-access">color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">!==</span> nextState<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&#x3C;</span>button
        color<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">color</span><span class="token punctuation">}</span>
        onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token parameter">state</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token literal-property property">Count</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>在这段代码中，<code>shouldComponentUpdate</code> 仅检查了 <code>props.color</code> 或 <code>state.count</code> 是否改变。如果这些值没有改变，那么这个组件不会更新。如果你的组件更复杂一些，你可以使用类似“浅比较”的模式来检查 <code>props</code> 和 <code>state</code> 中所有的字段，以此来决定是否组件需要更新。React 已经提供了一位好帮手来帮你实现这种常见的模式 - 你只要继承 <code>React.PureComponent</code> 就行了。所以这段代码可以改成以下这种更简洁的形式：<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CounterButton</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&#x3C;</span>button
        color<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">color</span><span class="token punctuation">}</span>
        onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token parameter">state</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token literal-property property">Count</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>大部分情况下，你可以使用 <code>React.PureComponent</code> 来代替手写 <code>shouldComponentUpdate</code>。但它只进行浅比较，所以当 props 或者 state 某种程度是可变的话，浅比较会有遗漏，那你就不能使用它了。当数据结构很复杂时，情况会变得麻烦。例如，你想要一个 <code>ListOfWords</code> 组件来渲染一组用逗号分开的单词。它有一个叫做 <code>WordAdder</code> 的父组件，该组件允许你点击一个按钮来添加一个单词到列表中。以下代码<em>并不</em>正确：<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">ListOfWords</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>div<span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">words</span><span class="token punctuation">.</span><span class="token method function property-access">join</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">WordAdder</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">words</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'marklar'</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleClick</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">handleClick</span><span class="token punctuation">.</span><span class="token method function property-access">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这部分代码很糟，而且还有 bug</span>
    <span class="token keyword">const</span> words <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">words</span><span class="token punctuation">;</span>
    words<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token string">'marklar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">words</span><span class="token operator">:</span> words<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
        <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleClick</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
        <span class="token operator">&#x3C;</span><span class="token maybe-class-name">ListOfWords</span> words<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">words</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>问题在于 <code>PureComponent</code> 仅仅会对新老 <code>this.props.words</code> 的值进行简单的对比。由于代码中 <code>WordAdder</code> 的 <code>handleClick</code> 方法改变了同一个 <code>words</code> 数组，使得新老 <code>this.props.words</code> 比较的其实还是同一个数组。即便实际上数组中的单词已经变了，但是比较结果是相同的。可以看到，即便多了新的单词需要被渲染， <code>ListOfWords</code> 却并没有被更新。</section><section id="the-power-of-not-mutating-data"class="level2"><h2>不可变数据的力量</h2><p>避免该问题最简单的方式是避免更改你正用于 props 或 state 的值。例如，上面 <code>handleClick</code> 方法可以用 <code>concat</code> 重写：<pre class="language-javascript"><code class="language-javascript"><span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token parameter">state</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">words</span><span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">words</span><span class="token punctuation">.</span><span class="token method function property-access">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'marklar'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>ES6 数组支持<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">扩展运算符</a>，这让代码写起来更方便了。如果你在使用 Create React App，该语法已经默认支持了。<pre class="language-js"><code class="language-js"><span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token parameter">state</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">words</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token spread operator">...</span>state<span class="token punctuation">.</span><span class="token property-access">words</span><span class="token punctuation">,</span> <span class="token string">'marklar'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>你可以用类似的方式改写代码来避免可变对象的产生。例如，我们有一个叫做 <code>colormap</code> 的对象。我们希望写一个方法来将 <code>colormap.right</code> 设置为 <code>'blue'</code>。我们可以这么写：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">updateColorMap</span><span class="token punctuation">(</span><span class="token parameter">colormap</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  colormap<span class="token punctuation">.</span><span class="token property-access">right</span> <span class="token operator">=</span> <span class="token string">'blue'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>为了不改变原本的对象，我们可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 方法：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">updateColorMap</span><span class="token punctuation">(</span><span class="token parameter">colormap</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> colormap<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">right</span><span class="token operator">:</span> <span class="token string">'blue'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>现在 <code>updateColorMap</code> 返回了一个新的对象，而不是修改老对象。<code>Object.assign</code> 是 ES6 的方法，需要 polyfill。<p>这里有一个 JavaScript 的提案，旨在添加<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">对象扩展属性</a>以使得更新不可变对象变得更方便：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">updateColorMap</span><span class="token punctuation">(</span><span class="token parameter">colormap</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>colormap<span class="token punctuation">,</span> <span class="token literal-property property">right</span><span class="token operator">:</span> <span class="token string">'blue'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>此特性已被收录在 JavaScript 的 ES2018 中。<p>如果你在使用 Create React App，<code>Object.assign</code> 以及对象扩展运算符已经默认支持了。<p>当处理深层嵌套对象时，以 immutable （不可变）的方式更新它们令人费解。如遇到此类问题，请参阅 <a href="https://github.com/mweststrate/immer">Immer</a> 或 <a href="https://github.com/kolodny/immutability-helper">immutability-helper</a>。这些库会帮助你编写高可读性的代码，且不会失去 immutability （不可变性）带来的好处。 <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>