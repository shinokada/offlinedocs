<!doctype html>
<html lang="zh-hans">
  <head>
    <meta charset="utf-8">
    <title>实现说明</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="实现说明" class="level1">
      <h1>实现说明</h1>
      <p>这一部分是关于 <a href="./codebase-overview.html#stack-reconciler">stack reconciler</a> 的一些实现说明。</p>
      <p>这部分比较具有技术性，需要对 React 公共 API，以及 React 是如何将其分为 core、renderer 和 reconciler 的具有较好的理解。如果你对源码库还不是很熟悉，请先阅读<a href="./codebase-overview.html">源码总览</a>。</p>
      <p>这部分还要求了解 <a href="/blog/2015/12/18/react-components-elements-and-instances.html">React 组件及其实例和元素之间的不同</a>。</p>
      <p>stack reconciler 是在 React 15 以及更早的版本中被采用。它的源码位于 <a href="https://github.com/facebook/react/tree/15-stable/src/renderers/shared/stack/reconciler">src/renderers/shared/stack/reconciler</a>。</p>
      <section id="video-building-react-from-scratch" class="level3">
        <h3>视频：从零开始构建 React</h3>
        <p><a href="https://twitter.com/zpao">Paul O'Shannessy</a> 讲解的<a href="https://www.youtube.com/watch?v=_MAD4Oly9yg">从零开始构建 React</a> 对本文档有较大的启发。</p>
        <p>本文档和他的讲解都是对实际代码库的简化，所以你能通过熟悉它们来获得更好的理解。</p>
      </section>
      <section id="overview" class="level3">
        <h3>概览</h3>
        <p>reconciler 本身没有公共的 API。像 React DOM 和 React Native 这样的 <a href="./codebase-overview.html#renderers">renderer</a> 使用它来根据用户写的 React 组件来高效地更新用户界面。</p>
      </section>
      <section id="mounting-as-a-recursive-process" class="level3">
        <h3>挂载是递归过程</h3>
        <p>让我们考虑第一次挂载组件时：</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token maybe-class-name">ReactDOM</span><span class="token punctuation">.</span><span class="token method function property-access">createRoot</span><span class="token punctuation">(</span>rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span>
root<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p><code>root.render</code> 把 <code>&#x3C;App /></code> 传递给 reconciler。请记住，<code>&#x3C;App /></code> 是一个 React 元素，也就是对要渲染的<em>内容</em>的描述。可以把它视为普通的对象：</p>
        <pre class="language-js"><code class="language-js"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { type: App, props: {} }</span></code></pre>
        <p>reconciler 检查 <code>App</code> 是一个类还是一个函数。</p>
        <p>如果 <code>App</code> 是函数，那么 reconciler 会调用 <code>App(props)</code> 来获取渲染的元素。</p>
        <p>如果 <code>App</code> 是类，那么 reconciler 会通过 <code>new App(props)</code> 来实例化 <code>App</code>，并调用生命周期方法 <code>componentWillMount()</code>，之后调用 <code>render()</code> 方法来获取渲染的元素。</p>
        <p>无论哪种方式，reconciler 都会探悉 <code>App</code> 的内容并渲染。</p>
        <p>这个过程是递归的。<code>App</code> 可能会渲染某个 <code>&#x3C;Greeting /></code>，<code>Greeting</code> 可能会渲染某个 <code>&#x3C;Button /></code>，以此类推。当它探悉各个组件渲染的元素时，reconciler 会通过用户定义的组件递归地 "向下探索"。</p>
        <p>通过以下伪代码想象一下这个过程：</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isClass</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 类组件会有这个标识位</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token known-class-name class-name">Boolean</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">)</span> <span class="token operator">&#x26;&#x26;</span>
    <span class="token known-class-name class-name">Boolean</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">isReactComponent</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这个函数接受一个 React 元素 (例如： &#x3C;App />)</span>
<span class="token comment">// 并返回表示已挂载树的 DOM 或者 原生节点</span>
<span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> props <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>

  <span class="token comment">// 将通过 type 作为函数运行</span>
  <span class="token comment">// 或创建实例并调用 render() </span>
  <span class="token comment">// 返回渲染后的元素</span>
  <span class="token keyword">var</span> renderedElement<span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isClass</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 类组件</span>
    <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置 props</span>
    publicInstance<span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
    <span class="token comment">// 如果有生命周期方法就调用</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">.</span><span class="token property-access">componentWillMount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      publicInstance<span class="token punctuation">.</span><span class="token method function property-access">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 调用 render() 返回渲染后的元素</span>
    renderedElement <span class="token operator">=</span> publicInstance<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 函数组件</span>
    renderedElement <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 这个过程是递归的</span>
  <span class="token comment">// 因为组件可能会返回具体另一个组件类型的元素</span>
  <span class="token keyword control-flow">return</span> <span class="token function">mount</span><span class="token punctuation">(</span>renderedElement<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 提示：这个实现是不完整的并且无限递归！</span>
  <span class="token comment">// 只处理像 &#x3C;App /> 或者 &#x3C;Button /> 的元素</span>
  <span class="token comment">// 还不能处理像 &#x3C;div /> 或者 &#x3C;p /> 的元素</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> rootEl <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> node <span class="token operator">=</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
rootEl<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <blockquote>
          <p><strong>注意：</strong></p>
          <p>这其实<em>是</em>一份伪代码。它与真实的实现并不相似。因为我们还没有讨论该递归过程何时停止，所以它也会造成堆栈溢出。</p>
        </blockquote>
        <p>让我们回顾上面例子中的一些关键的想法：</p>
        <ul>
          <li>React 元素是用来表示组件的类型（例如：<code>App</code>）和 props 的简单的对象。</li>
          <li>用户定义的组件（例如：<code>App</code>）可以是类，也可以是函数，但是它们都“渲染产生”元素。</li>
          <li>“挂载”是一个递归的过程，根据特定的顶层 React 元素（e.g. <code>&#x3C;App /></code>）产生 DOM 或 Native 树。</li>
        </ul>
      </section>
      <section id="mounting-host-elements" class="level3">
        <h3>挂载宿主元素</h3>
        <p>如果我们没有渲染某些东西输出到电脑屏幕，这个过程将会是无用的。</p>
        <p>除了用户定义的（“组合”）组件，React 元素也可能表示为平台专属（“宿主”）组件。例如，<code>Button</code> 可能会从 render 方法返回一个 <code>&#x3C;div /></code>。</p>
        <p>如果元素的 <code>type</code> 属性是字符串，我们处理的就是宿主元素：</p>
        <pre class="language-js"><code class="language-js"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span>div <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { type: 'div', props: {} }</span></code></pre>
        <p>宿主元素中没有用户定义代码。</p>
        <p>当 reconciler 遇到宿主元素时，它会让 renderer 负责挂载它。例如，React DOM 会创建一个 DOM 节点。</p>
        <p>如果宿主元素拥有子元素，reconciler 会根据上文提到的算法对其进行递归地挂载。无论子元素是宿主（像 <code>&#x3C;div>&#x3C;hr />&#x3C;div></code>），还是组合（像 <code>&#x3C;div>&#x3C;Button />&#x3C;/div></code>），两者都无所谓。</p>
        <p>子组件生成的 DOM 节点会附加在父 DOM 节点上，递归地完成整个 DOM 结构的组装。</p>
        <blockquote>
          <p><strong>注意：</strong></p>
          <p>reconciler 本身不与 DOM 绑定。挂载的确切结果（在源代码中有时叫做 “挂载映像”）取决于 renderer，可以是一个 DOM 节点（React DOM），一个字符串（React DOM Server），或是一个表示原生视图的数字（React Native）。</p>
        </blockquote>
        <p>如果我们扩展代码去处理宿主元素，会是如下样子：</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isClass</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 类组件会有这个标识位</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token known-class-name class-name">Boolean</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">)</span> <span class="token operator">&#x26;&#x26;</span>
    <span class="token known-class-name class-name">Boolean</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">isReactComponent</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 此函数仅处理组合类型的元素</span>
<span class="token comment">// 例如，处理 &#x3C;App /> 和 &#x3C;Button />, 但不处理 &#x3C;div /></span>
<span class="token keyword">function</span> <span class="token function">mountComposite</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> props <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>

  <span class="token keyword">var</span> renderedElement<span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isClass</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 类组件</span>
    <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置 props</span>
    publicInstance<span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
    <span class="token comment">// 如果有生命周期方法就调用</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">.</span><span class="token property-access">componentWillMount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      publicInstance<span class="token punctuation">.</span><span class="token method function property-access">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    renderedElement <span class="token operator">=</span> publicInstance<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 函数组件</span>
    renderedElement <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 这是递归的，但是当元素是宿主(例如： &#x3C;div />)而不是组合(例如 &#x3C;App />)时，</span>
  <span class="token comment">// 我们最终会到达递归的底部：</span>
  <span class="token keyword control-flow">return</span> <span class="token function">mount</span><span class="token punctuation">(</span>renderedElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 此函数只处理宿主类型的元素</span>
<span class="token comment">// 例如： 处理 &#x3C;div /> 和 &#x3C;p />，但不处理 &#x3C;App />.</span>
<span class="token keyword">function</span> <span class="token function">mountHost</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> props <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> children <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    children <span class="token operator">=</span> <span class="token punctuation">[</span>children<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  children <span class="token operator">=</span> children<span class="token punctuation">.</span><span class="token method function property-access">filter</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 这段代码不应该出现在 reconciler。</span>
  <span class="token comment">// 不同的 renderer 可能会以不同方式初始化节点。</span>
  <span class="token comment">// 例如，React Native 会创建 iOS 或 Android 的视图。</span>
  <span class="token keyword">var</span> node <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">createElement</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">propName</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>propName <span class="token operator">!==</span> <span class="token string">'children'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node<span class="token punctuation">.</span><span class="token method function property-access">setAttribute</span><span class="token punctuation">(</span>propName<span class="token punctuation">,</span> props<span class="token punctuation">[</span>propName<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 挂载子元素</span>
  children<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">childElement</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// 子元素可能是宿主(例如：&#x3C;div />)或者组合 (例如：&#x3C;Button />).</span>
    <span class="token comment">// 我们还是递归挂载他们</span>
    <span class="token keyword">var</span> childNode <span class="token operator">=</span> <span class="token function">mount</span><span class="token punctuation">(</span>childElement<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 这一行代码也是特殊的 renderer。</span>
    <span class="token comment">// 根据 renderer 不同，方式也不同：</span>
    node<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>childNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// DOM 节点作为挂载的结果返回。</span>
  <span class="token comment">// 这是递归结束的位置。</span>
  <span class="token keyword control-flow">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 用户定义组件</span>
    <span class="token keyword control-flow">return</span> <span class="token function">mountComposite</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 平台特定组件</span>
    <span class="token keyword control-flow">return</span> <span class="token function">mountHost</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> rootEl <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> node <span class="token operator">=</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
rootEl<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>以上代码是可以运作的，但是与 reconciler 的实际实现依然相差很远。关键的缺失部分是对更新的支持。</p>
      </section>
      <section id="introducing-internal-instances" class="level3">
        <h3>引入内部实例</h3>
        <p>React 的关键特点是你可以重新渲染所有内容，并且不会重新生成 DOM 或重置 state：</p>
        <pre class="language-js"><code class="language-js">root<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 应该重用已经存在的 DOM：</span>
root<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>然而，之前的实现只是知道如何挂载最初的树。由于它没有储存所有的必要信息，例如所有的 <code>publicInstance</code>，或 DOM 节点属于哪个组件，所以它不能完成更新操作。</p>
        <p>stack reconciler 源码通过把 <code>mount()</code> 函数作为一个类的方法来解决这个问题。这种方法是存在缺点的，所以我们正朝着与之相对的方向<a href="./codebase-overview.html#fiber-reconciler">进行 reconciler 的重写工作</a>。不过这就是它现在的运作方式。</p>
        <p>我们会创建两个类：<code>DOMComponent</code> 和 <code>CompositeComponent</code>，而不是分离的两个函数 <code>mountHost</code> 和 <code>mountComposite</code>。</p>
        <p>两个类都有一个接受 <code>element</code> 的构造函数，同时也有一个返回挂载后节点的 <code>mount()</code> 方法。我们用一个可以实例化正确类的工厂函数替换了顶层的 <code>mount()</code> 函数：</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 用户定义组件</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">CompositeComponent</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 平台特定组件</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">DOMComponent</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span></code></pre>
        <p>首先，让我们思考一下 <code>CompositeComponent</code> 的实现：</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CompositeComponent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">publicInstance</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">getPublicInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对于组合组件，公共类实例</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">publicInstance</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> element <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> props <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> publicInstance<span class="token punctuation">;</span>
    <span class="token keyword">var</span> renderedElement<span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isClass</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 组件类</span>
      publicInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 设置 props</span>
      publicInstance<span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
      <span class="token comment">// 如果有生命周期方法就调用</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">.</span><span class="token property-access">componentWillMount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        publicInstance<span class="token punctuation">.</span><span class="token method function property-access">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      renderedElement <span class="token operator">=</span> publicInstance<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 函数组件</span>
      publicInstance <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
      renderedElement <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 保存公共实例</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">publicInstance</span> <span class="token operator">=</span> publicInstance<span class="token punctuation">;</span>

    <span class="token comment">// 根据元素实例化子内部实例。</span>
    <span class="token comment">// &#x3C;div /> 或者 &#x3C;p /> 是 DOMComponent，</span>
    <span class="token comment">// 而 &#x3C;App /> 或者 &#x3C;Button /> 是 CompositeComponent。</span>
    <span class="token keyword">var</span> renderedComponent <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>renderedElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span> <span class="token operator">=</span> renderedComponent<span class="token punctuation">;</span>

    <span class="token comment">// 挂载渲染后的输出</span>
    <span class="token keyword control-flow">return</span> renderedComponent<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>这与之前的 <code>mountComposite()</code> 的实现没有太多的不同，但是现在我们可以保存一些信息，如 <code>this.currentElement</code>，<code>this.renderedComponent</code> 和 <code>this.publicInstance</code>，用于更新期间使用。</p>
        <p>需要注意的是 <code>CompositeComponent</code> 的实例与用户提供的 <code>element.type</code> 的实例是不同的东西。<code>CompositeComponent</code> 是我们的 reconciler 的实现细节，并且永远不会暴露给用户。用户定义的类是从 <code>element.type</code> 读取的，并且 <code>CompositeComponent</code> 会创建一个它的实例。</p>
        <p>为了避免混淆，我们把 <code>CompositeComponent</code> 和 <code>DOMComponent</code> 的实例叫做“内部实例”。由于它们的存在，我们可以把一些长时间存在的数据存入其中。只有 renderer 和 reconciler 能意识到它们的存在。</p>
        <p>相反，我们把用户定义的类的实例叫做“公共实例”。公共实例就是你在 <code>render()</code> 中所见到的 <code>this</code> 和你的自定义组件中的一些其他方法。</p>
        <p><code>mountHost()</code> 函数，重构为 <code>DOMComponent</code> 类的 <code>mount()</code> 方法，看起来也很熟悉：</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">DOMComponent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedChildren</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">getPublicInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对于 DOM 组件，只公共 DOM 节点</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> element <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> type <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> props <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> children <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      children <span class="token operator">=</span> <span class="token punctuation">[</span>children<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 创建并保存节点</span>
    <span class="token keyword">var</span> node <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">createElement</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>

    <span class="token comment">// 设置属性</span>
    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">propName</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>propName <span class="token operator">!==</span> <span class="token string">'children'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span><span class="token method function property-access">setAttribute</span><span class="token punctuation">(</span>propName<span class="token punctuation">,</span> props<span class="token punctuation">[</span>propName<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 创建并保存包含的子项</span>
    <span class="token comment">// 他们每个都可以是 DOMComponent 或者是 CompositeComponent，</span>
    <span class="token comment">// 取决于类型是字符串还是函数</span>
    <span class="token keyword">var</span> renderedChildren <span class="token operator">=</span> children<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span>instantiateComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedChildren</span> <span class="token operator">=</span> renderedChildren<span class="token punctuation">;</span>

    <span class="token comment">// 收集他们在 mount 上返回的节点</span>
    <span class="token keyword">var</span> childNodes <span class="token operator">=</span> renderedChildren<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token arrow operator">=></span> child<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    childNodes<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">childNode</span> <span class="token arrow operator">=></span> node<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>childNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// DOM 节点作为挂载结果返回</span>
    <span class="token keyword control-flow">return</span> node<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p><code>mountHost()</code> 重构后主要的区别是我们保存了与内部 DOM 组件实例关联的 <code>this.node</code> 和 <code>this.renderedChildren</code>。在将来我们还使用他们来进行非破坏性更新。</p>
        <p>因此，每个内部实例，组合或者宿主，现在都指向了它的子内部实例。为帮你更直观的了解，假设有函数组件 <code>&#x3C;App></code> 会渲染类组件 <code>&#x3C;Button></code>，并且 <code>Button</code> 渲染一个 <code>&#x3C;div></code>，其内部实例树将如下所示:</p>
        <pre class="language-js"><code class="language-js"><span class="token punctuation">[</span>object <span class="token maybe-class-name">CompositeComponent</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">currentElement</span><span class="token operator">:</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span>
  <span class="token literal-property property">publicInstance</span><span class="token operator">:</span> <span class="token keyword null nil">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">renderedComponent</span><span class="token operator">:</span> <span class="token punctuation">[</span>object <span class="token maybe-class-name">CompositeComponent</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">currentElement</span><span class="token operator">:</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Button</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span>
    <span class="token literal-property property">publicInstance</span><span class="token operator">:</span> <span class="token punctuation">[</span>object <span class="token maybe-class-name">Button</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token literal-property property">renderedComponent</span><span class="token operator">:</span> <span class="token punctuation">[</span>object <span class="token maybe-class-name">DOMComponent</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">currentElement</span><span class="token operator">:</span> <span class="token operator">&#x3C;</span>div <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span>
      <span class="token literal-property property">node</span><span class="token operator">:</span> <span class="token punctuation">[</span>object <span class="token maybe-class-name">HTMLDivElement</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token literal-property property">renderedChildren</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>在 DOM 中, 你只能看到 <code>&#x3C;div></code>。但是在内部实例树包含了组合和宿主的内部实例。</p>
        <p>组合内部实例需要存储：</p>
        <ul>
          <li>当前元素。</li>
          <li>如果元素的类型是类的公共实例</li>
          <li>单次渲染后的内部实例。它可以是 <code>DOMComponent</code> 或 <code>CompositeComponent</code>。</li>
        </ul>
        <p>宿主内部实例需要存储：</p>
        <ul>
          <li>当前元素。</li>
          <li>DOM 节点.</li>
          <li>所有子内部实例。它们中的每一个都可以是 <code>DOMComponent</code> 或<code> CompositeComponent</code>。</li>
        </ul>
        <p>如果你难以想象内部实例树在较为复杂的应用程序中的结构，<a href="https://github.com/facebook/react-devtools">React DevTools</a> 可以给你一个相似的结果，因为它突出呈现了灰色的宿主实例，以及紫色的组合实例。</p>
        <img src="./docs/implementation-notes-tree.png" width="500" style="max-width: 100%" alt="React DevTools tree">
        <p>为了完成重构，我们将引入一个函数，它将完整的树挂载到容器节点中并返回公共实例：</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> containerNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建顶层内部实例</span>
  <span class="token keyword">var</span> rootComponent <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 挂载顶层组件到容器中</span>
  <span class="token keyword">var</span> node <span class="token operator">=</span> rootComponent<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  containerNode<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 返回它提供的公共实例</span>
  <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> rootComponent<span class="token punctuation">.</span><span class="token method function property-access">getPublicInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> publicInstance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> rootEl <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </section>
      <section id="unmounting" class="level3">
        <h3>卸载</h3>
        <p>现在，我们有内部实例，以保留其子节点和 DOM 节点，我们可以实现卸载。对于组合组件，卸载调用生命周期方法和递归。</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CompositeComponent</span> <span class="token punctuation">{</span>

  <span class="token comment">// ...</span>

  <span class="token function">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果有生命周期方法就调用</span>
    <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">publicInstance</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">.</span><span class="token property-access">componentWillUnmount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        publicInstance<span class="token punctuation">.</span><span class="token method function property-access">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 卸载单个渲染的组件</span>
    <span class="token keyword">var</span> renderedComponent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span><span class="token punctuation">;</span>
    renderedComponent<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>对于 <code>DOMComponent</code>，会告诉每一个子项去卸载</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">DOMComponent</span> <span class="token punctuation">{</span>

  <span class="token comment">// ...</span>

  <span class="token function">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 卸载所有的子项</span>
    <span class="token keyword">var</span> renderedChildren <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedChildren</span><span class="token punctuation">;</span>
    renderedChildren<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token arrow operator">=></span> child<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>在实践中，卸载 DOM 组件也需要删除事件侦听器和清除一些缓存，但我们将跳过这些细节。</p>
        <p>我们现在可以添加一个叫 <code>unmountTree(containerNode)</code> 顶层函数，该函数类似于 <code>ReactDOM.unmountComponentAtNode()</code> 。</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">unmountTree</span><span class="token punctuation">(</span><span class="token parameter">containerNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 从 DOM 节点读取内部实例:</span>
  <span class="token comment">// (这还不起作用,我们需要更改 mountTreeTree() 来存储它。)</span>
  <span class="token keyword">var</span> node <span class="token operator">=</span> containerNode<span class="token punctuation">.</span><span class="token property-access">firstChild</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> rootComponent <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token property-access">_internalInstance</span><span class="token punctuation">;</span>

  <span class="token comment">// 卸载树并清空容器</span>
  rootComponent<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  containerNode<span class="token punctuation">.</span><span class="token property-access">innerHTML</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
        <p>为了使其工作，我们需要从 DOM 节点读取内部根实例。我们将修改 <code>mountTree()</code> 为其增加 <code>_internalInstance</code> 属性来添加 DOM 根节点，我们还将在 <code>mountTree()</code> 中实现销毁任何现有的树的功能, 以便它可以被多次调用:</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> containerNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 销毁所有现有的树</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>containerNode<span class="token punctuation">.</span><span class="token property-access">firstChild</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">unmountTree</span><span class="token punctuation">(</span>containerNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 创建顶层的内部实例</span>
  <span class="token keyword">var</span> rootComponent <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 挂载顶层组件到容器中</span>
  <span class="token keyword">var</span> node <span class="token operator">=</span> rootComponent<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  containerNode<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 保存对内部实例的引用</span>
  node<span class="token punctuation">.</span><span class="token property-access">_internalInstance</span> <span class="token operator">=</span> rootComponent<span class="token punctuation">;</span>

  <span class="token comment">// 返回它提供的公共实例</span>
  <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> rootComponent<span class="token punctuation">.</span><span class="token method function property-access">getPublicInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> publicInstance<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
        <p>现在，运行 <code>unmountTree()</code> 或重复运行 <code>mountTree()</code>，都会删除旧树并在组件上运行 <code>componentWillUnmount()</code> 生命周期方法。</p>
      </section>
      <section id="updating" class="level3">
        <h3>更新</h3>
        <p>在上一个章节，我们实现了卸载。但是，如果每个 prop 更改都卸载整棵树，并重新挂载，那么 react 就不再高效了。reconciler 的目标是尽可能复用现有实例来保留 DOM 和状态：</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">var</span> rootEl <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 应该复用已经存在的 DOM：</span>
<span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>我们将用一种方法扩展内部实例。除了 <code>mount()</code> 和 <code>unmount()</code> 之外，<code>DOMComponent</code> 和 <code>CompositeComponent</code> 都将实现一个名为 <code>receive(nextElement)</code> 的新方法：</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CompositeComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token function">receive</span><span class="token punctuation">(</span><span class="token parameter">nextElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">DOMComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token function">receive</span><span class="token punctuation">(</span><span class="token parameter">nextElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>它的工作是尽一切可能使组件（及其任何子组件）与 <code>nextElement</code> 提供的描述一起更新。</p>
        <p>这通常被称为 "virtual DOM diffing" 的部分，但实际发生的情况是，我们递归遍历内部树，让每个内部实例接收更新。</p>
      </section>
      <section id="updating-composite-components" class="level3">
        <h3>更新组合组件</h3>
        <p>当一个组合组件接收一个新的元素时，我们将运行生命周期方法 <code>componentWillUpdate()</code>。</p>
        <p>然后我们使用新的 prop 重新渲染组件, 并获取下一次渲染的元素：</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CompositeComponent</span> <span class="token punctuation">{</span>

  <span class="token comment">// ...</span>

  <span class="token function">receive</span><span class="token punctuation">(</span><span class="token parameter">nextElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> prevProps <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> publicInstance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">publicInstance</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevRenderedComponent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevRenderedElement <span class="token operator">=</span> prevRenderedComponent<span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">;</span>

    <span class="token comment">// 更新*自己的*元素</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span> <span class="token operator">=</span> nextElement<span class="token punctuation">;</span>
    <span class="token keyword">var</span> type <span class="token operator">=</span> nextElement<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nextProps <span class="token operator">=</span> nextElement<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>

    <span class="token comment">// 找下一次 render() 输出的是什么</span>
    <span class="token keyword">var</span> nextRenderedElement<span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isClass</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 类组件</span>
      <span class="token comment">// 如果有生命周期方法就调用</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>publicInstance<span class="token punctuation">.</span><span class="token property-access">componentWillUpdate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        publicInstance<span class="token punctuation">.</span><span class="token method function property-access">componentWillUpdate</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 更新 props </span>
      publicInstance<span class="token punctuation">.</span><span class="token property-access">props</span> <span class="token operator">=</span> nextProps<span class="token punctuation">;</span>
      <span class="token comment">// 重新渲染</span>
      nextRenderedElement <span class="token operator">=</span> publicInstance<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 函数组件</span>
      nextRenderedElement <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ...</span></code></pre>
        <p>接下来，我们可以看一下渲染元素的 <code>type</code>。如果 <code>type</code> 自上次渲染后没有改变，之后的组件也可以就地更新。</p>
        <p>例如，如果第一次返回 <code>&#x3C;Button color="red" /></code>，第二次返回 <code>&#x3C;Button color="blue" /></code>，我们可以只告诉相应的内部实例 <code>receive()</code> 下一个元素：</p>
        <pre class="language-js"><code class="language-js">    <span class="token comment">// ...</span>

    <span class="token comment">// 如果渲染元素的 type 没有更改，</span>
    <span class="token comment">// 重用已经存在组件实例并退出。</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>prevRenderedElement<span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token operator">===</span> nextRenderedElement<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      prevRenderedComponent<span class="token punctuation">.</span><span class="token method function property-access">receive</span><span class="token punctuation">(</span>nextRenderedElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ...</span></code></pre>
        <p>但是，如果下一个渲染元素的 <code>type</code> 与先前渲染的元素不同，则无法更新内部实例。<code>&#x3C;button></code> 不能 “变成” <code>&#x3C;input></code>。</p>
        <p>相反，我们必须卸载现有的内部实例，然后挂载并渲染元素 <code>type</code> 对应的新实例。例如，当先前渲染 <code>&#x3C;button /></code> 的组件再渲染 <code>&#x3C;input /></code> 时，会发生这种情况：</p>
        <pre class="language-js"><code class="language-js">    <span class="token comment">// ...</span>

    <span class="token comment">// 如果我们达到这里，我们需要卸载以前挂载的组件。</span>
    <span class="token comment">// 挂载新的组件，并交换其节点。</span>

    <span class="token comment">// 查找旧节点，因为需要替换它</span>
    <span class="token keyword">var</span> prevNode <span class="token operator">=</span> prevRenderedComponent<span class="token punctuation">.</span><span class="token method function property-access">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 卸载旧的子组件并挂载新的子组件</span>
    prevRenderedComponent<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nextRenderedComponent <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>nextRenderedElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nextNode <span class="token operator">=</span> nextRenderedComponent<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 替换子组件的引用</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span> <span class="token operator">=</span> nextRenderedComponent<span class="token punctuation">;</span>

    <span class="token comment">// 将旧节点替换为新节点</span>
    <span class="token comment">// 注意：这是 renderer 特定的代码,</span>
    <span class="token comment">// 理想情况下应位于 CompositeComponent 之外：</span>
    prevNode<span class="token punctuation">.</span><span class="token property-access">parentNode</span><span class="token punctuation">.</span><span class="token method function property-access">replaceChild</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">,</span> prevNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>综上所述，当组合组件收到新元素时，它可以将更新委派给其渲染的内部实例，或者卸载它并在其位置挂载新元素。</p>
        <p>还有另一种情况，组件将重新挂载而非接收元素，即元素的 <code>key</code> 已更改。在当前文档中，我们不讨论 <code>key</code> 处理，因为它增加了复杂教程的复杂性。</p>
        <p>请注意，我们需要向内部实例添加名为 <code>getHostNode()</code> 的方法，以便可以在更新期间找到平台特定的节点并替换它。对于两个类，其实现都非常简单:</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">CompositeComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token function">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 要求渲染组件提供它。</span>
    <span class="token comment">// 递归深入任意组合组件。</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedComponent</span><span class="token punctuation">.</span><span class="token method function property-access">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">DOMComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token function">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span></code></pre>
      </section>
      <section id="updating-host-components" class="level3">
        <h3>更新宿主组件</h3>
        <p>宿主组件实现，如<code>DOMComponent</code>，更新方式不同。当他们收到一个元素时，他们需要更新平台特定的视图。在 React DOM 的情况下，这意味着更新 DOM 属性:</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">DOMComponent</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token function">receive</span><span class="token punctuation">(</span><span class="token parameter">nextElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevElement <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevProps <span class="token operator">=</span> prevElement<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nextProps <span class="token operator">=</span> nextElement<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">;</span>    
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">currentElement</span> <span class="token operator">=</span> nextElement<span class="token punctuation">;</span>

    <span class="token comment">// 删除旧的属性</span>
    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">propName</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>propName <span class="token operator">!==</span> <span class="token string">'children'</span> <span class="token operator">&#x26;&#x26;</span> <span class="token operator">!</span>nextProps<span class="token punctuation">.</span><span class="token method function property-access">hasOwnProperty</span><span class="token punctuation">(</span>propName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span><span class="token method function property-access">removeAttribute</span><span class="token punctuation">(</span>propName<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置新的属性</span>
    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token parameter">propName</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>propName <span class="token operator">!==</span> <span class="token string">'children'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span><span class="token method function property-access">setAttribute</span><span class="token punctuation">(</span>propName<span class="token punctuation">,</span> nextProps<span class="token punctuation">[</span>propName<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// ...</span></code></pre>
        <p>然后宿主组件需要更新其子组件。与组合组件不同，它们可能包含多个子组件。</p>
        <p>在此简化的示例中，我们使用内部实例数组并遍历它，根据接收的 <code>type</code> 是否与以前的 <code>type</code> 匹配更新或替换内部实例。真正的 reconciler 还会在描述中获取元素的 <code>key</code>，并存储和跟踪除了插入和删除之外的移动，但我们这里将省略此逻辑。</p>
        <p>我们在列表中收集子组件的 DOM 操作，以便可以批量执行它们:</p>
        <pre class="language-js"><code class="language-js">    <span class="token comment">// ...</span>

    <span class="token comment">// 这些是 React 元素的数组:</span>
    <span class="token keyword">var</span> prevChildren <span class="token operator">=</span> prevProps<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      prevChildren <span class="token operator">=</span> <span class="token punctuation">[</span>prevChildren<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> nextChildren <span class="token operator">=</span> nextProps<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nextChildren <span class="token operator">=</span> <span class="token punctuation">[</span>nextChildren<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 这些是内部实例的数组:</span>
    <span class="token keyword">var</span> prevRenderedChildren <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedChildren</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> nextRenderedChildren <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// 当我们迭代子组件时，我们将向数组添加相应操作。</span>
    <span class="token keyword">var</span> operationQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// 注意：以下部分非常简化!</span>
    <span class="token comment">// 它不处理重新排序、带空洞或有 key 的子组件。</span>
    <span class="token comment">// 它的存在只是为了说明整个流程，而不是细节。</span>

    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> nextChildren<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 尝试去获取此子组件现有的内部实例</span>
      <span class="token keyword">var</span> prevChild <span class="token operator">=</span> prevRenderedChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

      <span class="token comment">// 如果此索引下没有内部实例，</span>
      <span class="token comment">// 则子实例已追加到末尾。</span>
      <span class="token comment">// 创建新的内部实例,挂载它,并使用其节点。</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prevChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> nextChild <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> node <span class="token operator">=</span> nextChild<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 记录我们需要追加的节点</span>
        operationQueue<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'ADD'</span><span class="token punctuation">,</span> node<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nextRenderedChildren<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>nextChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">continue</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 仅当实例的元素类型匹配时，我们才能更新该实例。</span>
      <span class="token comment">// 例如，&#x3C;Button size="small" /> 可以更新成 &#x3C;Button size="large" />，</span>
      <span class="token comment">// 但是不能更新成 &#x3C;App />。</span>
      <span class="token keyword">var</span> canUpdate <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token operator">===</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">;</span>

      <span class="token comment">// 如果我们无法更新现有的实例，</span>
      <span class="token comment">// 我们必须卸载它并安装一个新实例去替代</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>canUpdate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> prevNode <span class="token operator">=</span> prevChild<span class="token punctuation">.</span><span class="token method function property-access">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        prevChild<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">var</span> nextChild <span class="token operator">=</span> <span class="token function">instantiateComponent</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> nextNode <span class="token operator">=</span> nextChild<span class="token punctuation">.</span><span class="token method function property-access">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 记录我们需要替换的节点</span>
        operationQueue<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'REPLACE'</span><span class="token punctuation">,</span> prevNode<span class="token punctuation">,</span> nextNode<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nextRenderedChildren<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>nextChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">continue</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 如果我们能更新现有的内部实例，</span>
      <span class="token comment">// 只是让它接收下一个元素并处理自己的更新。</span>
      prevChild<span class="token punctuation">.</span><span class="token method function property-access">receive</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      nextRenderedChildren<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>prevChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 最后，卸载不存在的任何子组件:</span>
    <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> nextChildren<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> j <span class="token operator">&#x3C;</span> prevChildren<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> prevChild <span class="token operator">=</span> prevRenderedChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> node <span class="token operator">=</span> prevChild<span class="token punctuation">.</span><span class="token method function property-access">getHostNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      prevChild<span class="token punctuation">.</span><span class="token method function property-access">unmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// 记录我们需要删除的节点</span>
      operationQueue<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'REMOVE'</span><span class="token punctuation">,</span> node<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 将渲染的子级列表指向更新的版本。</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">renderedChildren</span> <span class="token operator">=</span> nextRenderedChildren<span class="token punctuation">;</span>

    <span class="token comment">// ...</span></code></pre>
        <p>最后一步，我们执行 DOM 操作。同样，真正的 reconciler 代码更为复杂，因为它还处理移动操作:</p>
        <pre class="language-js"><code class="language-js">    <span class="token comment">// ...</span>

    <span class="token comment">// 处理操作队列。</span>
    <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span>operationQueue<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> operation <span class="token operator">=</span> operationQueue<span class="token punctuation">.</span><span class="token method function property-access">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">switch</span> <span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">'ADD'</span><span class="token operator">:</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token string">'REPLACE'</span><span class="token operator">:</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">.</span><span class="token method function property-access">replaceChild</span><span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token property-access">nextNode</span><span class="token punctuation">,</span> operation<span class="token punctuation">.</span><span class="token property-access">prevNode</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token string">'REMOVE'</span><span class="token operator">:</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">.</span><span class="token method function property-access">removeChild</span><span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token property-access">node</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
        <p>这就是更新宿主组件。</p>
      </section>
      <section id="top-level-updates" class="level3">
        <h3>顶层更新</h3>
        <p>现在，<code>CompositeComponent</code> 和 <code>DOMComponent</code> 都实现了 <code>receive(nextElement)</code> 方法，我们可以更改顶级的 <code>mountTree()</code> 函数，以便当元素的 <code>type</code> 与上次相同时使用它:</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> containerNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 检查现有的树</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>containerNode<span class="token punctuation">.</span><span class="token property-access">firstChild</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> prevNode <span class="token operator">=</span> containerNode<span class="token punctuation">.</span><span class="token property-access">firstChild</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevRootComponent <span class="token operator">=</span> prevNode<span class="token punctuation">.</span><span class="token property-access">_internalInstance</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> prevElement <span class="token operator">=</span> prevRootComponent<span class="token punctuation">.</span><span class="token property-access">currentElement</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果可以，重用现有的根组件</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>prevElement<span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token operator">===</span> element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      prevRootComponent<span class="token punctuation">.</span><span class="token method function property-access">receive</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 否则，卸载现有树</span>
    <span class="token function">unmountTree</span><span class="token punctuation">(</span>containerNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// ...</span>

<span class="token punctuation">}</span></code></pre>
        <p>现在调用 <code>mountTree()</code> 两次相同的 <code>type</code> 是没有破坏性的</p>
        <pre class="language-js"><code class="language-js"><span class="token keyword">var</span> rootEl <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 应该重用已经存在的 DOM：</span>
<span class="token function">mountTree</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>这些是 React 内部工作原理的基础知识。</p>
      </section>
      <section id="what-we-left-out" class="level3">
        <h3>我们遗漏了什么</h3>
        <p>与真实代码库相比，本文档得到了简化。我们没有解决几个重要方面：</p>
        <ul>
          <li>
            <p>组件可以呈现 <code>null</code>，reconciler 可以处理在数组中“空插槽”和渲染输出。</p>
          </li>
          <li>
            <p>reconciler 还从元素中读取 <code>key</code>，并使用它来确定哪个内部实例对应于数组中的哪个元素。实际 React 实现中的大部分复杂性与此相关。</p>
          </li>
          <li>
            <p>除了组合和宿主内部实例类外，还有用于“文本”和“空”组件的类。它们表示文本节点和通过渲染 <code>null</code> 获得 “空插槽”。</p>
          </li>
          <li>
            <p>renderer 使用<a href="./codebase-overview.html#dynamic-injection">注入</a>的方式将宿主内部类传递给 reconciler. 例如，React DOM 告诉 reconciler 使用 <code>ReactDOMComponent</code> 作为宿主内部实例实现。</p>
          </li>
          <li>
            <p>更新子列表的逻辑被提取到一个名为 <code>ReactMultiChild</code> 的 mixin 中，它由 React DOM 和 React Native 中的宿主内部实例类实现使用。</p>
          </li>
          <li>
            <p>reconciler 还在组合组件中实现对 <code>setState()</code> 的支持。事件处理程序内的多个更新将被批处理为单一更新。</p>
          </li>
          <li>
            <p>reconciler 还负责将 refs 附加和分离到组合组件和宿主节点。</p>
          </li>
          <li>
            <p>在 DOM 准备好之后调用的生命周期方法，例如 <code>componentDidMount()</code> 和 <code>componentDidUpdate()</code>，被收集到“回调队列”中并在一个批处理中执行。</p>
          </li>
          <li>
            <p>React 将有关当前更新的信息放入名为 “transaction” 的内部对象中。事务可用于跟踪挂起的生命周期方法的队列、警告的当前 DOM 嵌套以及特定更新的“全局”任何其他内容。事务还确保在更新后“清理所有内容”。例如，React DOM 提供的事务类在任何更新后还原 input selection。</p>
          </li>
        </ul>
      </section>
      <section id="jumping-into-the-code" class="level3">
        <h3>跳转到代码</h3>
        <ul>
          <li>
            <p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/dom/client/ReactMount.js"><code>ReactMount</code></a> 就像本教程中 <code>mountTree()</code> 和 <code>unmountTree()</code> 这样的代码。它负责挂载和卸载顶层组件。<a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/native/ReactNativeMount.js"><code>ReactNativeMount</code></a> 是 React Native 的模拟。</p>
          </li>
          <li>
            <p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/dom/shared/ReactDOMComponent.js"><code>ReactDOMComponent</code></a> 相当于本教程中的 <code>DOMComponent</code>。它实现了React DOM renderer 的宿主组件类。<a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/native/ReactNativeBaseComponent.js"><code>ReactNativeBaseComponent</code></a> 是 React Native 的模拟。</p>
          </li>
          <li>
            <p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js"><code>ReactCompositeComponent</code></a> 相当于本教程中的 <code>CompositeComponent</code>。它处理调用用户定义的组件并维护其状态。</p>
          </li>
          <li>
            <p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/instantiateReactComponent.js"><code>instantiateReactComponent</code></a> 包含选择要为元素构造的正确内部实例类的开关。它相当于本教程中的 <code>instantiateComponent()</code>.</p>
          </li>
          <li>
            <p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/Reactreconciler.js"><code>ReactReconciler</code></a> 是一个包含 <code>mountComponent()</code>、<code>receiveComponent()</code> 和 <code>unmountComponent()</code> 方法的包装器。它调用内部实例上的底层实现，但也包括一些由所有内部实例实现共享的代码。</p>
          </li>
          <li>
            <p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/ReactChildreconciler.js"><code>ReactChildReconciler</code></a> 实现根据子元素的 <code>key</code> 挂载、更新和卸载子级的逻辑。</p>
          </li>
          <li>
            <p><a href="https://github.com/facebook/react/blob/83381c1673d14cd16cf747e34c945291e5518a86/src/renderers/shared/stack/reconciler/ReactMultiChild.js"><code>ReactMultiChild</code></a> 实现对子组件插入、删除和移动操作队列的处理，独立于渲 renderer。</p>
          </li>
          <li>
            <p>由于遗留原因，<code>mount()</code>、 <code>receive()</code> 和 <code>unmount()</code> 在 React 代码库中实际上名字为 <code>mountComponent()</code>、<code>receiveComponent()</code> 和 <code>unmountComponent()</code>，但是它们接收元素。</p>
          </li>
          <li>
            <p>内部实例的属性以下划线开头，例如，<code>_currentElement</code>。它们被认为是整个代码库中的只读公共字段。</p>
          </li>
        </ul>
      </section>
      <section id="future-directions" class="level3">
        <h3>未来方向</h3>
        <p>stack reconciler 具有固有的局限性，例如同步并且无法中断工作或将其拆分为块。<a href="./codebase-overview.html#fiber-reconciler">新的 Fiber reconciler</a>正在进行中，具有<a href="https://github.com/acdlite/react-fiber-architecture">完全不同的架构</a>。在未来，我们打算用它替换 stack reconciler，但目前它还远远没有达到功能对等。</p>
      </section>
      <section id="next-steps" class="level3">
        <h3>下一步</h3>
        <p>
          阅读<a href="./design-principles.html">下一节</a> 了解我们用于开发 React 的指导原则。
          <span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span>
        </p>
      </section>
    </section>
  </body>
</html>
