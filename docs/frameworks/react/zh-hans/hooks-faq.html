<!doctypehtml><html lang="zh-hans"><meta charset="utf-8"><title>Hooks FAQ</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="hooks-faq"class="level1"><h1>Hooks FAQ</h1><p><em>Hook</em> 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。<p>此章节回答了关于 <a href="./hooks-overview.html">Hook</a> 的常见问题。<ul><li><strong><a href="#adoption-strategy">采纳策略</a></strong><ul><li><a href="#which-versions-of-react-include-hooks">哪个版本的 React 包含了 Hook？</a><li><a href="#do-i-need-to-rewrite-all-my-class-components">我需要重写所有的 class 组件吗？</a><li><a href="#what-can-i-do-with-hooks-that-i-couldnt-with-classes">有什么是 Hook 能做而 class 做不到的？</a><li><a href="#how-much-of-my-react-knowledge-stays-relevant">我的 React 知识还有多少是仍然有用的？</a><li><a href="#should-i-use-hooks-classes-or-a-mix-of-both">我应该使用 Hook，class，还是两者混用？</a><li><a href="#do-hooks-cover-all-use-cases-for-classes">Hook 能否覆盖 class 的所有使用场景？</a><li><a href="#do-hooks-replace-render-props-and-higher-order-components">Hook 会替代 render props 和高阶组件吗？</a><li><a href="#what-do-hooks-mean-for-popular-apis-like-redux-connect-and-react-router">Hook 对于 Redux connect() 和 React Router 等流行的 API 来说，意味着什么？</a><li><a href="#do-hooks-work-with-static-typing">Hook 能和静态类型一起用吗？</a><li><a href="#how-to-test-components-that-use-hooks">如何测试使用了 Hook 的组件？</a><li><a href="#what-exactly-do-the-lint-rules-enforce">lint 规则具体强制了哪些内容？</a></ul><li><strong><a href="#from-classes-to-hooks">从 Class 迁移到 Hook</a></strong><ul><li><a href="#how-do-lifecycle-methods-correspond-to-hooks">生命周期方法要如何对应到 Hook？</a><li><a href="#how-can-i-do-data-fetching-with-hooks">我该如何使用 Hook 进行数据获取？</a><li><a href="#is-there-something-like-instance-variables">有类似实例变量的东西吗？</a><li><a href="#should-i-use-one-or-many-state-variables">我应该使用单个还是多个 state 变量？</a><li><a href="#can-i-run-an-effect-only-on-updates">我可以只在更新时运行 effect 吗？</a><li><a href="#how-to-get-the-previous-props-or-state">如何获取上一轮的 props 或 state？</a><li><a href="#why-am-i-seeing-stale-props-or-state-inside-my-function">为什么我会在我的函数中看到陈旧的 props 和 state ？</a><li><a href="#how-do-i-implement-getderivedstatefromprops">我该如何实现 getDerivedStateFromProps？</a><li><a href="#is-there-something-like-forceupdate">有类似 forceUpdate 的东西吗？</a><li><a href="#can-i-make-a-ref-to-a-function-component">我可以引用一个函数组件吗？</a><li><a href="#how-can-i-measure-a-dom-node">我该如何测量 DOM 节点？</a><li><a href="#what-does-const-thing-setthing--usestate-mean">const [thing, setThing] = useState() 是什么意思？</a></ul><li><strong><a href="#performance-optimizations">性能优化</a></strong><ul><li><a href="#can-i-skip-an-effect-on-updates">我可以在更新时跳过 effect 吗？</a><li><a href="#is-it-safe-to-omit-functions-from-the-list-of-dependencies">在依赖列表中省略函数是否安全？</a><li><a href="#what-can-i-do-if-my-effect-dependencies-change-too-often">如果我的 effect 的依赖频繁变化，我该怎么办？</a><li><a href="#how-do-i-implement-shouldcomponentupdate">我该如何实现 shouldComponentUpdate？</a><li><a href="#how-to-memoize-calculations">如何记忆计算结果？</a><li><a href="#how-to-create-expensive-objects-lazily">如何惰性创建昂贵的对象？</a><li><a href="#are-hooks-slow-because-of-creating-functions-in-render">Hook 会因为在渲染时创建函数而变慢吗？</a><li><a href="#how-to-avoid-passing-callbacks-down">如何避免向下传递回调？</a><li><a href="#how-to-read-an-often-changing-value-from-usecallback">如何从 useCallback 读取一个经常变化的值？</a></ul><li><strong><a href="#under-the-hood">底层原理</a></strong><ul><li><a href="#how-does-react-associate-hook-calls-with-components">React 是如何把对 Hook 的调用和组件联系起来的？</a><li><a href="#what-is-the-prior-art-for-hooks">Hook 使用了哪些现有技术？</a></ul></ul><section id="adoption-strategy"class="level2"><h2>采纳策略</h2><section id="which-versions-of-react-include-hooks"class="level3"><h3>哪个版本的 React 包含了 Hook？</h3><p>从 16.8.0 开始，React 在以下模块中包含了 React Hook 的稳定实现：<ul><li>React DOM<li>React Native<li>React DOM Server<li>React Test Renderer<li>React Shallow Renderer</ul><p>请注意，<strong>要启用 Hook，所有 React 相关的 package 都必须升级到 16.8.0 或更高版本</strong>。如果你忘记更新诸如 React DOM 之类的 package，Hook 将无法运行。<p><a href="https://reactnative.dev/blog/2019/03/12/releasing-react-native-059">React Native 0.59</a> 及以上版本支持 Hook。</section><section id="do-i-need-to-rewrite-all-my-class-components"class="level3"><h3>我需要重写所有的 class 组件吗？</h3><p>不。我们并 <a href="./hooks-intro.html#gradual-adoption-strategy">没有计划</a> 从 React 中移除 class —— 我们也需要不断地发布产品，重写成本较高。我们推荐在新代码中尝试 Hook。</section><section id="what-can-i-do-with-hooks-that-i-couldnt-with-classes"class="level3"><h3>有什么是 Hook 能做而 class 做不到的？</h3><p>Hook 提供了强大而富有表现力的方式来在组件间复用功能。通过 <a href="./hooks-custom.html">「自定义 Hook」</a> 这一节可以了解能用它做些什么。这篇来自一位 React 核心团队的成员的 <a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889">文章</a> 则更加深入地剖析了 Hook 解锁了哪些新的能力。</section><section id="how-much-of-my-react-knowledge-stays-relevant"class="level3"><h3>我的 React 知识还有多少是仍然有用的？</h3><p>Hook 是使用你已经知道的 React 特性的一种更直接的方式 —— 比如 state，生命周期，context，以及 refs。它们并没有从根本上改变 React 的工作方式，你对组件，props, 以及自顶向下的数据流的知识并没有改变。<p>Hook 确实有它们自己的学习曲线。如果这份文档中遗失了一些什么，<a href="https://github.com/reactjs/reactjs.org/issues/new">提一个 issue</a>，我们会尽可能地帮你。</section><section id="should-i-use-hooks-classes-or-a-mix-of-both"class="level3"><h3>我应该使用 Hook，class，还是两者混用？</h3><p>当你准备好了，我们鼓励你在写新组件的时候开始尝试 Hook。请确保你团队中的每个人都愿意使用它们并且熟知这份文档中的内容。我们不推荐用 Hook 重写你已有的 class，除非你本就打算重写它们。（例如：为了修复bug）。<p>你不能在 class 组件<em>内部</em>使用 Hook，但毫无疑问你可以在组件树里混合使用 class 组件和使用了 Hook 的函数组件。不论一个组件是 class 还是一个使用了 Hook 的函数，都只是这个组件的实现细节而已。长远来看，我们期望 Hook 能够成为人们编写 React 组件的主要方式。</section><section id="do-hooks-cover-all-use-cases-for-classes"class="level3"><h3>Hook 能否覆盖 class 的所有使用场景？</h3><p>我们给 Hook 设定的目标是尽早覆盖 class 的所有使用场景。目前暂时还没有对应不常用的 <code>getSnapshotBeforeUpdate</code>，<code>getDerivedStateFromError</code> 和 <code>componentDidCatch</code> 生命周期的 Hook 等价写法，但我们计划尽早把它们加进来。</section><section id="do-hooks-replace-render-props-and-higher-order-components"class="level3"><h3>Hook 会替代 render props 和高阶组件吗？</h3><p>通常，render props 和高阶组件只渲染一个子节点。我们认为让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 <code>renderItem</code> 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。</section><section id="what-do-hooks-mean-for-popular-apis-like-redux-connect-and-react-router"class="level3"><h3>Hook 对于 Redux <code>connect()</code> 和 React Router 等流行的 API 来说，意味着什么？</h3><p>你可以继续使用之前使用的 API；它们仍会继续有效。<p>React Redux 从 v7.1.0 开始<a href="https://react-redux.js.org/api/hooks">支持 Hook API</a> 并暴露了 <code>useDispatch</code> 和 <code>useSelector</code> 等 hook。<p>React Router 从 v5.1 开始<a href="https://reacttraining.com/react-router/web/api/Hooks">支持 hook</a>。<p>其它第三库也将即将支持 hook。</section><section id="do-hooks-work-with-static-typing"class="level3"><h3>Hook 能和静态类型一起用吗？</h3><p>Hook 在设计阶段就考虑了静态类型的问题。因为它们是函数，所以它们比像高阶组件这样的模式更易于设定正确的类型。最新版的 Flow 和 TypeScript React 定义已经包含了对 React Hook 的支持。<p>重要的是，在你需要严格限制类型的时候，自定义 Hook 能够帮你限制 React 的 API。React 只是给你提供了基础功能，具体怎么用就是你自己的事了。</section><section id="how-to-test-components-that-use-hooks"class="level3"><h3>如何测试使用了 Hook 的组件？</h3><p>在 React 看来，一个使用了 Hook 的组件只不过是一个常规组件。如果你的测试方案不依赖于 React 的内部实现，测试带 Hook 的组件应该和你通常测试组件的方式没什么差别。<blockquote><p>注意<p><a href="./testing-recipes.html">测试技巧</a> 中包含了许多可以拷贝粘贴的示例。</blockquote><p>举个例子，比如我们有这么个计数器组件：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Example</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token maybe-class-name">You</span> clicked <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times<span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Click</span> me
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>我们会使用 React DOM 来测试它。为了确保它表现得和在浏览器中一样，我们会把代码渲染的部分包裹起来，并更新为 <a href="./test-utils.html#act"><code>ReactTestUtils.act()</code></a> 调用:<pre class="language-js{3,20-22,29-31}"><code class="language-js{3,20-22,29-31}">import React from 'react';
import ReactDOM from 'react-dom/client';
import { act } from 'react-dom/test-utils';
import Counter from './Counter';

let container;

beforeEach(() => {
  container = document.createElement('div');
  document.body.appendChild(container);
});

afterEach(() => {
  document.body.removeChild(container);
  container = null;
});

it('can render and update a counter', () => {
  // 测试首次渲染和 effect
  act(() => {
    ReactDOM.createRoot(container).render(&#x3C;Counter />);
  });
  const button = container.querySelector('button');
  const label = container.querySelector('p');
  expect(label.textContent).toBe('You clicked 0 times');
  expect(document.title).toBe('You clicked 0 times');

  // 测试第二次渲染和 effect
  act(() => {
    button.dispatchEvent(new MouseEvent('click', {bubbles: true}));
  });
  expect(label.textContent).toBe('You clicked 1 times');
  expect(document.title).toBe('You clicked 1 times');
});</code></pre><p>对 <code>act()</code> 的调用也会清空它们内部的 effect。<p>如果你需要测试一个自定义 Hook，你可以在你的测试代码中创建一个组件并在其中使用你的 Hook。然后你就可以测试你刚写的组件了。<p>为了减少不必要的模板项目，我们推荐使用 <a href="https://testing-library.com/react">React Testing Library</a>，该项目旨在鼓励你按照终端用户使用组件的方式来编写测试。<p>欲了解更多，请参阅<a href="./testing-recipes.html">测试技巧</a>一节。</section><section id="what-exactly-do-the-lint-rules-enforce"class="level3"><h3><a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">lint 规则</a>具体强制了哪些内容？</h3><p>我们提供了一个 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">ESLint 插件</a> 来强制 <a href="./hooks-rules.html">Hook 规范</a> 以避免 Bug。它假设任何以 「<code>use</code>」 开头并紧跟着一个大写字母的函数就是一个 Hook。我们知道这种启发方式并不完美，甚至存在一些假阳性，但如果没有一个全生态范围的约定就没法让 Hook 很好的工作 —— 而名字太长会让人要么不愿意采用 Hook，要么不愿意遵守约定。<p>规范尤其强制了以下内容：<ul><li>对 Hook 的调用要么在一个<code>大驼峰法</code>命名的函数（视作一个组件）内部，要么在另一个 <code>useSomething</code> 函数（视作一个自定义 Hook）中。<li>Hook 在每次渲染时都按照相同的顺序被调用。</ul><p>还有一些其他的启发方式，但随着我们不断地调优以在发现 Bug 和避免假阳性之间取得平衡，这些方式随时会改变。</section></section><section id="from-classes-to-hooks"class="level2"><h2>从 Class 迁移到 Hook</h2><section id="how-do-lifecycle-methods-correspond-to-hooks"class="level3"><h3>生命周期方法要如何对应到 Hook？</h3><ul><li><p><code>constructor</code>：函数组件不需要构造函数。你可以通过调用 <a href="./hooks-reference.html#usestate"><code>useState</code></a> 来初始化 state。如果计算的代价比较昂贵，你可以传一个函数给 <code>useState</code>。<li><p><code>getDerivedStateFromProps</code>：改为 <a href="#how-do-i-implement-getderivedstatefromprops">在渲染时</a> 安排一次更新。<li><p><code>shouldComponentUpdate</code>：详见 <a href="#how-do-i-implement-shouldcomponentupdate">下方</a> <code>React.memo</code>.<li><p><code>render</code>：这是函数组件体本身。<li><p><code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>：<a href="./hooks-reference.html#useeffect"><code>useEffect</code> Hook</a> 可以表达所有这些(包括 <a href="#can-i-skip-an-effect-on-updates">不那么</a> <a href="#can-i-run-an-effect-only-on-updates">常见</a> 的场景)的组合。<li><p><code>getSnapshotBeforeUpdate</code>，<code>componentDidCatch</code> 以及 <code>getDerivedStateFromError</code>：目前还没有这些方法的 Hook 等价写法，但很快会被添加。</ul></section><section id="how-can-i-do-data-fetching-with-hooks"class="level3"><h3>我该如何使用 Hook 进行数据获取？</h3><p>该 <a href="https://codesandbox.io/s/jvvkoo8pq3">demo</a> 会帮助你开始理解。欲了解更多，请查阅 <a href="https://www.robinwieruch.de/react-hooks-fetch-data/">此文章</a> 来了解如何使用 Hook 进行数据获取。</section><section id="is-there-something-like-instance-variables"class="level3"><h3>有类似实例变量的东西吗？</h3><p>有！<a href="./hooks-reference.html#useref"><code>useRef()</code></a> Hook 不仅可以用于 DOM refs。「ref」 对象是一个 <code>current</code> 属性可变且可以容纳任意值的通用容器，类似于一个 class 的实例属性。<p>你可以在 <code>useEffect</code> 内部对其进行写入:<pre class="language-js{2,8}"><code class="language-js{2,8}">function Timer() {
  const intervalRef = useRef();

  useEffect(() => {
    const id = setInterval(() => {
      // ...
    });
    intervalRef.current = id;
    return () => {
      clearInterval(intervalRef.current);
    };
  });

  // ...
}</code></pre><p>如果我们只是想设定一个循环定时器，我们不会需要这个 ref（<code>id</code> 可以是在 effect 本地的），但如果我们想要在一个事件处理器中清除这个循环定时器的话这就很有用了：<pre class="language-js{3}"><code class="language-js{3}">  // ...
  function handleCancelClick() {
    clearInterval(intervalRef.current);
  }
  // ...</code></pre><p>从概念上讲，你可以认为 refs 就像是一个 class 的实例变量。除非你正在做 <a href="#how-to-create-expensive-objects-lazily">懒加载</a>，否则避免在渲染期间设置 refs —— 这可能会导致意外的行为。相反的，通常你应该在事件处理器和 effects 中修改 refs。</section><section id="should-i-use-one-or-many-state-variables"class="level3"><h3>我应该使用单个还是多个 state 变量？</h3><p>如果你之前用过 class，你或许会试图总是在一次 <code>useState()</code> 调用中传入一个包含了所有 state 的对象。如果你愿意的话你可以这么做。这里有一个跟踪鼠标移动的组件的例子。我们在本地 state 中记录它的位置和尺寸：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Box</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">left</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">top</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">width</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>现在假设我们想要编写一些逻辑以便在用户移动鼠标时改变 <code>left</code> 和 <code>top</code>。注意到我们是如何必须手动把这些字段合并到之前的 state 对象的：<pre class="language-js{4,5}"><code class="language-js{4,5}">// ...
  useEffect(() => {
    function handleWindowMouseMove(e) {
      // 展开 「...state」 以确保我们没有 「丢失」 width 和 height
      setState(state => ({ ...state, left: e.pageX, top: e.pageY }));
    }
    // 注意：这是个简化版的实现
    window.addEventListener('mousemove', handleWindowMouseMove);
    return () => window.removeEventListener('mousemove', handleWindowMouseMove);
  }, []);
  // ...</code></pre><p>这是因为当我们更新一个 state 变量，我们会 <em>替换</em> 它的值。这和 class 中的 <code>this.setState</code> 不一样，后者会把更新后的字段 <em>合并</em> 入对象中。<p>如果你还怀念自动合并，你可以写一个自定义的 <code>useLegacyState</code> Hook 来合并对象 state 的更新。然而，<strong>我们推荐把 state 切分成多个 state 变量，每个变量包含的不同值会在同时发生变化。</strong><p>举个例子，我们可以把组件的 state 拆分为 <code>position</code> 和 <code>size</code> 两个对象，并永远以非合并的方式去替换 <code>position</code>：<pre class="language-js{2,7}"><code class="language-js{2,7}">function Box() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  const [size, setSize] = useState({ width: 100, height: 100 });

  useEffect(() => {
    function handleWindowMouseMove(e) {
      setPosition({ left: e.pageX, top: e.pageY });
    }
    // ...</code></pre><p>把独立的 state 变量拆分开还有另外的好处。这使得后期把一些相关的逻辑抽取到一个自定义 Hook 变得容易，比如说:<pre class="language-js{2,7}"><code class="language-js{2,7}">function Box() {
  const position = useWindowPosition();
  const [size, setSize] = useState({ width: 100, height: 100 });
  // ...
}

function useWindowPosition() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  useEffect(() => {
    // ...
  }, []);
  return position;
}</code></pre><p>注意看我们是如何做到不改动代码就把对 <code>position</code> 这个 state 变量的 <code>useState</code> 调用和相关的 effect 移动到一个自定义 Hook 的。如果所有的 state 都存在同一个对象中，想要抽取出来就比较难了。<p>把所有 state 都放在同一个 <code>useState</code> 调用中，或是每一个字段都对应一个 <code>useState</code> 调用，这两方式都能跑通。当你在这两个极端之间找到平衡，然后把相关 state 组合到几个独立的 state 变量时，组件就会更加的可读。如果 state 的逻辑开始变得复杂，我们推荐 <a href="./hooks-reference.html#usereducer">用 reducer 来管理它</a>，或使用自定义 Hook。</section><section id="can-i-run-an-effect-only-on-updates"class="level3"><h3>我可以只在更新时运行 effect 吗？</h3><p>这是个比较罕见的使用场景。如果你需要的话，你可以 <a href="#is-there-something-like-instance-variables">使用一个可变的 ref</a> 手动存储一个布尔值来表示是首次渲染还是后续渲染，然后在你的 effect 中检查这个标识。（如果你发现自己经常在这么做，你可以为之创建一个自定义 Hook。）</section><section id="how-to-get-the-previous-props-or-state"class="level3"><h3>如何获取上一轮的 props 或 state？</h3><p>在以下两种场景下，你可以能会需要获取上一轮的 props 或 state。<p>有时，你需要获取之前的 props 来 <strong>进行副作用的清理</strong>。例如，你可能有这样一个副作用，依赖 <code>userId</code> props 来订阅 socket。如果 <code>userId</code> 发生了变化，你需要取消 <strong>之前</strong> <code>userId</code> 的订阅，再进行后续订阅。这种情况下，你无需做额外操作即可实现：<pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToSocket</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">userId</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromSocket</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">userId</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>props<span class="token punctuation">.</span><span class="token property-access">userId</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上述示例中，如果 <code>userId</code> 从 <code>3</code> 变为 <code>4</code>，<code>ChatAPI.unsubscribeFromSocket(3)</code> 将会优先运行，然后才会执行 <code>ChatAPI.subscribeToSocket(4)</code>。这种情况下，你没必要获取之前的 <code>userId</code>，因为清理函数将在闭包中捕获它，<p>其他情况下，你可能需要 <strong>根据 props 或其他 state 的变化来调整 state</strong>。但这一般并不常用，出现这种情况说明你代码中存在重复或多余的 state。然而，如果你需要应对这种场景，你可以在 <a href="#how-do-i-implement-getderivedstatefromprops">状态中存储之前的 state 或 props，并在渲染时更新它们</a>。<p>我们之前曾建议使用 <code>usePrevious</code> 的自定义 Hook 来保持前值。然后，我们发现大多数用例，都属于上述两种场景。如果你的用例与上述两种情况不同，你可以在 <a href="#is-there-something-like-instance-variables">Ref 中对该值进行存储</a> 并在需要时手动更新它。注意，应避免在渲染过程中读取和更新 refs，因为这使得你组件的行为难以预测，且难以理解。</section><section id="why-am-i-seeing-stale-props-or-state-inside-my-function"class="level3"><h3>为什么我会在我的函数中看到陈旧的 props 和 state ？</h3><p>组件内部的任何函数，包括事件处理函数和 effect，都是从它被创建的那次渲染中被「看到」的。例如，考虑这样的代码：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Example</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleAlertClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'You clicked on: '</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token maybe-class-name">You</span> clicked <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times<span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Click</span> me
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleAlertClick<span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Show</span> alert
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>如果你先点击「Show alert」然后增加计数器的计数，那这个 alert 会显示<strong>在你点击『Show alert』按钮时</strong>的 <code>count</code> 变量。这避免了那些因为假设 props 和 state 没有改变的代码引起问题。<p>如果你刻意地想要从某些异步回调中读取 <em>最新的</em> state，你可以用 <a href="./hooks-faq.html#is-there-something-like-instance-variables">一个 ref</a> 来保存它，修改它，并从中读取。<p>最后，你看到陈旧的 props 和 state 的另一个可能的原因，是你使用了「依赖数组」优化但没有正确地指定所有的依赖。举个例子，如果一个 effect 指定了 <code>[]</code> 作为第二个参数，但在内部读取了 <code>someProp</code>，它会一直「看到」 <code>someProp</code> 的初始值。解决办法是要么移除依赖数组，要么修正它。 这里介绍了 <a href="#is-it-safe-to-omit-functions-from-the-list-of-dependencies">你该如何处理函数</a>，而这里介绍了关于如何减少 effect 的运行而不必错误的跳过依赖的 <a href="#what-can-i-do-if-my-effect-dependencies-change-too-often">一些常见策略</a>。<blockquote><p>注意<p>我们提供了一个 <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> ESLint 规则作为 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> 包的一部分。它会在依赖被错误指定时发出警告，并给出修复建议。</blockquote></section><section id="how-do-i-implement-getderivedstatefromprops"class="level3"><h3>我该如何实现 <code>getDerivedStateFromProps</code>？</h3><p>尽管你可能 <a href="/blog/2018/06/07/you-probably-dont-need-derived-state.html">不需要它</a>，但在一些罕见的你需要用到的场景下（比如实现一个 <code>&#x3C;Transition></code> 组件），你可以在渲染过程中更新 state 。React 会立即退出第一次渲染并用更新后的 state 重新运行组件以避免耗费太多性能。<p>这里我们把 <code>row</code> prop 上一轮的值存在一个 state 变量中以便比较：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ScrollView</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>row<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isScrollingDown<span class="token punctuation">,</span> setIsScrollingDown<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>prevRow<span class="token punctuation">,</span> setPrevRow<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>row <span class="token operator">!==</span> prevRow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Row 自上次渲染以来发生过改变。更新 isScrollingDown。</span>
    <span class="token function">setIsScrollingDown</span><span class="token punctuation">(</span>prevRow <span class="token operator">!==</span> <span class="token keyword null nil">null</span> <span class="token operator">&#x26;&#x26;</span> row <span class="token operator">></span> prevRow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setPrevRow</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Scrolling down: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isScrollingDown<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>初看这或许有点奇怪，但渲染期间的一次更新恰恰就是 <code>getDerivedStateFromProps</code> 一直以来的概念。</section><section id="is-there-something-like-forceupdate"class="level3"><h3>有类似 forceUpdate 的东西吗？</h3><p>如果前后两次的值相同，<code>useState</code> 和 <code>useReducer</code> Hook <a href="./hooks-reference.html#bailing-out-of-a-state-update">都会放弃更新</a>。原地修改 state 并调用 <code>setState</code> 不会引起重新渲染。<p>通常，你不应该在 React 中修改本地 state。然而，作为一条出路，你可以用一个增长的计数器来在 state 没变的时候依然强制一次重新渲染：<pre class="language-js"><code class="language-js">  <span class="token keyword">const</span> <span class="token punctuation">[</span>ignored<span class="token punctuation">,</span> forceUpdate<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token arrow operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">forceUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre><p>可能的话尽量避免这种模式。</section><section id="can-i-make-a-ref-to-a-function-component"class="level3"><h3>我可以引用一个函数组件吗？</h3><p>尽管你不应该经常需要这么做，但你可以通过 <a href="./hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a> Hook 暴露一些命令式的方法给父组件。</section><section id="how-can-i-measure-a-dom-node"class="level3"><h3>我该如何测量 DOM 节点？</h3><p>获取 DOM 节点的位置或是大小的基本方式是使用 <a href="./refs-and-the-dom.html#callback-refs">callback ref</a>。每当 ref 被附加到一个另一个节点，React 就会调用 callback。这里有一个 <a href="https://codesandbox.io/s/l7m0v5x4v9">小 demo</a>:<pre class="language-js{4-8,12}"><code class="language-js{4-8,12}">function MeasureExample() {
  const [height, setHeight] = useState(0);

  const measuredRef = useCallback(node => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  }, []);

  return (
    &#x3C;>
      &#x3C;h1 ref={measuredRef}>Hello, world&#x3C;/h1>
      &#x3C;h2>The above header is {Math.round(height)}px tall&#x3C;/h2>
    &#x3C;/>
  );
}</code></pre><p>在这个案例中，我们没有选择使用 <code>useRef</code>，因为当 ref 是一个对象时它并不会把当前 ref 的值的 <em>变化</em> 通知到我们。使用 callback ref 可以确保 <a href="https://codesandbox.io/s/818zzk8m78">即便子组件延迟显示被测量的节点</a> (比如为了响应一次点击)，我们依然能够在父组件接收到相关的信息，以便更新测量结果。<p>注意到我们传递了 <code>[]</code> 作为 <code>useCallback</code> 的依赖列表。这确保了 ref callback 不会在再次渲染时改变，因此 React 不会在非必要的时候调用它。<p>在此示例中，当且仅当组件挂载和卸载时，callback ref 才会被调用，因为渲染的 <code>&#x3C;h1></code> 组件在整个重新渲染期间始终存在。如果你希望在每次组件调整大小时都收到通知，则可能需要使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver"><code>ResizeObserver</code></a> 或基于其构建的第三方 Hook。<p>如果你愿意，你可以 <a href="https://codesandbox.io/s/m5o42082xy">把这个逻辑抽取出来作为</a> 一个可复用的 Hook:<pre class="language-js{2}"><code class="language-js{2}">function MeasureExample() {
  const [rect, ref] = useClientRect();
  return (
    &#x3C;>
      &#x3C;h1 ref={ref}>Hello, world&#x3C;/h1>
      {rect !== null &#x26;&#x26;
        &#x3C;h2>The above header is {Math.round(rect.height)}px tall&#x3C;/h2>
      }
    &#x3C;/>
  );
}

function useClientRect() {
  const [rect, setRect] = useState(null);
  const ref = useCallback(node => {
    if (node !== null) {
      setRect(node.getBoundingClientRect());
    }
  }, []);
  return [rect, ref];
}</code></pre></section><section id="what-does-const-thing-setthing--usestate-mean"class="level3"><h3><code>const [thing, setThing] = useState()</code> 是什么意思？</h3><p>如果你不熟悉这个语法，可以查看 State Hook 文档中的 <a href="./hooks-state.html#tip-what-do-square-brackets-mean">解释</a> 一节。</section></section><section id="performance-optimizations"class="level2"><h2>性能优化</h2><section id="can-i-skip-an-effect-on-updates"class="level3"><h3>我可以在更新时跳过 effect 吗？</h3><p>可以的。参见 <a href="./hooks-reference.html#conditionally-firing-an-effect">条件式的发起 effect</a>。注意，忘记处理更新常会 <a href="./hooks-effect.html#explanation-why-effects-run-on-each-update">导致 bug</a>，这也正是我们没有默认使用条件式 effect 的原因。</section><section id="is-it-safe-to-omit-functions-from-the-list-of-dependencies"class="level3"><h3>在依赖列表中省略函数是否安全？</h3><p>一般来说，不安全。<pre class="language-js{3,8}"><code class="language-js{3,8}">function Example({ someProp }) {
  function doSomething() {
    console.log(someProp);
  }

  useEffect(() => {
    doSomething();
  }, []); // 🔴 这样不安全（它调用的 `doSomething` 函数使用了 `someProp`）
}</code></pre><p>要记住 effect 外部的函数使用了哪些 props 和 state 很难。这也是为什么 <strong>通常你会想要在 effect <em>内部</em> 去声明它所需要的函数。</strong> 这样就能容易的看出那个 effect 依赖了组件作用域中的哪些值：<pre class="language-js{4,8}"><code class="language-js{4,8}">function Example({ someProp }) {
  useEffect(() => {
    function doSomething() {
      console.log(someProp);
    }

    doSomething();
  }, [someProp]); // ✅ 安全（我们的 effect 仅用到了 `someProp`）
}</code></pre><p>如果这样之后我们依然没用到组件作用域中的任何值，就可以安全地把它指定为 <code>[]</code>：<pre class="language-js{7}"><code class="language-js{7}">useEffect(() => {
  function doSomething() {
    console.log('hello');
  }

  doSomething();
}, []); // ✅ 在这个例子中是安全的，因为我们没有用到组件作用域中的 *任何* 值</code></pre><p>根据你的用例，下面列举了一些其他的办法。<blockquote><p>注意<p>我们提供了一个 <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> ESLint 规则作为 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> 包的一部分。它会帮助你找出无法一致地处理更新的组件。</blockquote><p>让我们来看看这有什么关系。<p>如果你指定了一个 <a href="./hooks-reference.html#conditionally-firing-an-effect">依赖列表</a> 作为 <code>useEffect</code>、<code>useLayoutEffect</code>、<code>useMemo</code>、<code>useCallback</code> 或 <code>useImperativeHandle</code> 的最后一个参数，它必须包含回调中的所有值，并参与 React 数据流。这就包括 props、state，以及任何由它们衍生而来的东西。<p><strong>只有</strong> 当函数（以及它所调用的函数）不引用 props、state 以及由它们衍生而来的值时，你才能放心地把它们从依赖列表中省略。下面这个案例有一个 Bug：<pre class="language-js{5,12}"><code class="language-js{5,12}">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);

  async function fetchProduct() {
    const response = await fetch('http://myapi/product/' + productId); // 使用了 productId prop
    const json = await response.json();
    setProduct(json);
  }

  useEffect(() => {
    fetchProduct();
  }, []); // 🔴 这样是无效的，因为 `fetchProduct` 使用了 `productId`
  // ...
}</code></pre><p><strong>推荐的修复方案是把那个函数移动到你的 effect <em>内部</em></strong>。这样就能很容易的看出来你的 effect 使用了哪些 props 和 state，并确保它们都被声明了：<pre class="language-js{5-10,13}"><code class="language-js{5-10,13}">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);

  useEffect(() => {
    // 把这个函数移动到 effect 内部后，我们可以清楚地看到它用到的值。
    async function fetchProduct() {
      const response = await fetch('http://myapi/product/' + productId);
      const json = await response.json();
      setProduct(json);
    }

    fetchProduct();
  }, [productId]); // ✅ 有效，因为我们的 effect 只用到了 productId
  // ...
}</code></pre><p>这同时也允许你通过 effect 内部的局部变量来处理无序的响应：<pre class="language-js{2,6,10}"><code class="language-js{2,6,10}">  useEffect(() => {
    let ignore = false;
    async function fetchProduct() {
      const response = await fetch('http://myapi/product/' + productId);
      const json = await response.json();
      if (!ignore) setProduct(json);
    }

    fetchProduct();
    return () => { ignore = true };
  }, [productId]);</code></pre><p>我们把这个函数移动到 effect 内部，这样它就不用出现在它的依赖列表中了。<blockquote><p>提示<p>看看 <a href="https://codesandbox.io/s/jvvkoo8pq3">这个小 demo</a> 和 <a href="https://www.robinwieruch.de/react-hooks-fetch-data/">这篇文章</a> 来了解更多关于如何用 Hook 进行数据获取。</blockquote><p><strong>如果出于某些原因你 <em>无法</em> 把一个函数移动到 effect 内部，还有一些其他办法：</strong><ul><li><strong>你可以尝试把那个函数移动到你的组件之外</strong>。那样一来，这个函数就肯定不会依赖任何 props 或 state，并且也不用出现在依赖列表中了。<li>如果你所调用的方法是一个纯计算，并且可以在渲染时调用，你可以 <strong>转而在 effect 之外调用它，</strong> 并让 effect 依赖于它的返回值。<li>万不得已的情况下，你可以 <strong>把函数加入 effect 的依赖但 <em>把它的定义包裹</em></strong> 进 <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a> Hook。这就确保了它不随渲染而改变，除非 <em>它自身</em> 的依赖发生了改变：</ul><pre class="language-js{2-5}"><code class="language-js{2-5}">function ProductPage({ productId }) {
  // ✅ 用 useCallback 包裹以避免随渲染发生改变
  const fetchProduct = useCallback(() => {
    // ... Does something with productId ...
  }, [productId]); // ✅ useCallback 的所有依赖都被指定了

  return &#x3C;ProductDetails fetchProduct={fetchProduct} />;
}

function ProductDetails({ fetchProduct }) {
  useEffect(() => {
    fetchProduct();
  }, [fetchProduct]); // ✅ useEffect 的所有依赖都被指定了
  // ...
}</code></pre><p>注意在上面的案例中，我们 <strong>需要</strong> 让函数出现在依赖列表中。这确保了 <code>ProductPage</code> 的 <code>productId</code> prop 的变化会自动触发 <code>ProductDetails</code> 的重新获取。</section><section id="what-can-i-do-if-my-effect-dependencies-change-too-often"class="level3"><h3>如果我的 effect 的依赖频繁变化，我该怎么办？</h3><p>有时候，你的 effect 可能会使用一些频繁变化的值。你可能会忽略依赖列表中 state，但这通常会引起 Bug：<pre class="language-js{6,9}"><code class="language-js{6,9}">function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(count + 1); // 这个 effect 依赖于 `count` state
    }, 1000);
    return () => clearInterval(id);
  }, []); // 🔴 Bug: `count` 没有被指定为依赖

  return &#x3C;h1>{count}&#x3C;/h1>;
}</code></pre><p>传入空的依赖数组 <code>[]</code>，意味着该 hook 只在组件挂载时运行一次，并非重新渲染时。但如此会有问题，在 <code>setInterval</code> 的回调中，<code>count</code> 的值不会发生变化。因为当 effect 执行时，我们会创建一个闭包，并将 <code>count</code> 的值被保存在该闭包当中，且初值为 <code>0</code>。每隔一秒，回调就会执行 <code>setCount(0 + 1)</code>，因此，<code>count</code> 永远不会超过 1。<p>指定 <code>[count]</code> 作为依赖列表就能修复这个 Bug，但会导致每次改变发生时定时器都被重置。事实上，每个 <code>setInterval</code> 在被清除前（类似于 <code>setTimeout</code>）都会调用一次。但这并不是我们想要的。要解决这个问题，我们可以使用 <a href="./hooks-reference.html#functional-updates"><code>setState</code> 的函数式更新形式</a>。它允许我们指定 state 该 <em>如何</em> 改变而不用引用 <em>当前</em> state：<pre class="language-js{6,9}"><code class="language-js{6,9}">function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + 1); // ✅ 在这不依赖于外部的 `count` 变量
    }, 1000);
    return () => clearInterval(id);
  }, []); // ✅ 我们的 effect 不使用组件作用域中的任何变量

  return &#x3C;h1>{count}&#x3C;/h1>;
}</code></pre><p>（<code>setCount</code> 函数的身份是被确保稳定的，所以可以放心的省略掉）<p>此时，<code>setInterval</code> 的回调依旧每秒调用一次，但每次 <code>setCount</code> 内部的回调取到的 <code>count</code> 是最新值（在回调中变量命名为 <code>c</code>）。<p>在一些更加复杂的场景中（比如一个 state 依赖于另一个 state），尝试用 <a href="./hooks-reference.html#usereducer"><code>useReducer</code> Hook</a> 把 state 更新逻辑移到 effect 之外。<a href="https://adamrackis.dev/state-and-use-reducer/">这篇文章</a> 提供了一个你该如何做到这一点的案例。 <strong><code>useReducer</code> 的 <code>dispatch</code> 的身份永远是稳定的</strong> —— 即使 reducer 函数是定义在组件内部并且依赖 props。<p>万不得已的情况下，如果你想要类似 class 中的 <code>this</code> 的功能，你可以 <a href="./hooks-faq.html#is-there-something-like-instance-variables">使用一个 ref</a> 来保存一个可变的变量。然后你就可以对它进行读写了。举个例子：<pre class="language-js{2-6,10-11,16}"><code class="language-js{2-6,10-11,16}">function Example(props) {
  // 把最新的 props 保存在一个 ref 中
  const latestProps = useRef(props);
  useEffect(() => {
    latestProps.current = props;
  });

  useEffect(() => {
    function tick() {
      // 在任何时候读取最新的 props
      console.log(latestProps.current);
    }

    const id = setInterval(tick, 1000);
    return () => clearInterval(id);
  }, []); // 这个 effect 从不会重新执行
}</code></pre><p>仅当你实在找不到更好办法的时候才这么做，因为依赖于变更会使得组件更难以预测。如果有某些特定的模式无法很好地转化成这样，<a href="https://github.com/facebook/react/issues/new">发起一个 issue</a> 并配上可运行的实例代码以便，我们会尽可能帮助你。</section><section id="how-do-i-implement-shouldcomponentupdate"class="level3"><h3>我该如何实现 <code>shouldComponentUpdate</code>?</h3><p>你可以用 <code>React.memo</code> 包裹一个组件来对它的 props 进行浅比较：<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">Button</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// 你的组件</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这不是一个 Hook 因为它的写法和 Hook 不同。<code>React.memo</code> 等效于 <code>PureComponent</code>，但它只比较 props。（你也可以通过第二个参数指定一个自定义的比较函数来比较新旧 props。如果函数返回 true，就会跳过更新。）<p><code>React.memo</code> 不比较 state，因为没有单一的 state 对象可供比较。但你也可以让子节点变为纯组件，或者 <a href="./hooks-faq.html#how-to-memoize-calculations">用 <code>useMemo</code> 优化每一个具体的子节点</a>。</section><section id="how-to-memoize-calculations"class="level3"><h3>如何记忆计算结果？</h3><p><a href="./hooks-reference.html#usememo"><code>useMemo</code></a> Hook 允许你通过「记住」上一次计算结果的方式在多次渲染的之间缓存计算结果：<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">computeExpensiveValue</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这行代码会调用 <code>computeExpensiveValue(a, b)</code>。但如果依赖数组 <code>[a, b]</code> 自上次赋值以来没有改变过，<code>useMemo</code> 会跳过二次调用，只是简单复用它上一次返回的值。<p>记住，传给 <code>useMemo</code> 的函数是在渲染期间运行的。不要在其中做任何你通常不会在渲染期间做的事。举个例子，副作用属于 <code>useEffect</code>，而不是 <code>useMemo</code>。<p><strong>你可以把 <code>useMemo</code> 作为一种性能优化的手段，但不要把它当做一种语义上的保证。</strong>未来，React 可能会选择「忘掉」一些之前记住的值并在下一次渲染时重新计算它们，比如为离屏组件释放内存。建议自己编写相关代码以便没有 <code>useMemo</code> 也能正常工作 —— 然后把它加入性能优化。（在某些取值必须 <em>从不</em> 被重新计算的罕见场景，你可以 <a href="#how-to-create-expensive-objects-lazily">惰性初始化</a> 一个 ref。）<p>方便起见，<code>useMemo</code> 也允许你跳过一次子节点的昂贵的重新渲染：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Parent</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Only re-rendered if `a` changes:</span>
  <span class="token keyword">const</span> child1 <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Child1</span> a<span class="token operator">=</span><span class="token punctuation">{</span>a<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Only re-rendered if `b` changes:</span>
  <span class="token keyword">const</span> child2 <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Child2</span> b<span class="token operator">=</span><span class="token punctuation">{</span>b<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token punctuation">{</span>child1<span class="token punctuation">}</span>
      <span class="token punctuation">{</span>child2<span class="token punctuation">}</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>注意这种方式在循环中是无效的，因为 Hook 调用 <a href="./hooks-rules.html">不能</a> 被放在循环中。但你可以为列表项抽取一个单独的组件，并在其中调用 <code>useMemo</code>。</section><section id="how-to-create-expensive-objects-lazily"class="level3"><h3>如何惰性创建昂贵的对象？</h3><p>如果依赖数组的值相同，<code>useMemo</code> 允许你 <a href="#how-to-memoize-calculations">记住一次昂贵的计算</a>。但是，这仅作为一种提示，并不 <em>保证</em> 计算不会重新运行。但有时候需要确保一个对象仅被创建一次。<p><strong>第一个常见的使用场景是当创建初始 state 很昂贵时：</strong><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Table</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ⚠️ createRows() 每次渲染都会被调用</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>rows<span class="token punctuation">,</span> setRows<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token function">createRows</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>为避免重新创建被忽略的初始 state，我们可以传一个 <strong>函数</strong> 给 <code>useState</code>：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Table</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ✅ createRows() 只会被调用一次</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>rows<span class="token punctuation">,</span> setRows<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">createRows</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>React 只会在首次渲染时调用这个函数。参见 <a href="./hooks-reference.html#usestate"><code>useState</code> API 参考</a>。<p><strong>你或许也会偶尔想要避免重新创建 <code>useRef()</code> 的初始值。</strong>举个例子，或许你想确保某些命令式的 class 实例只被创建一次：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ⚠️ IntersectionObserver 在每次渲染都会被创建</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>onIntersect<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p><code>useRef</code> <strong>不会</strong> 像 <code>useState</code> 那样接受一个特殊的函数重载。相反，你可以编写你自己的函数来创建并将其设为惰性的：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ✅ IntersectionObserver 只会被惰性创建一次</span>
  <span class="token keyword">function</span> <span class="token function">getObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>onIntersect<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> ref<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 当你需要时，调用 getObserver()</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>这避免了我们在一个对象被首次真正需要之前就创建它。如果你使用 Flow 或 TypeScript，你还可以为了方便给 <code>getObserver()</code> 一个不可为 null 的类型。</section><section id="are-hooks-slow-because-of-creating-functions-in-render"class="level3"><h3>Hook 会因为在渲染时创建函数而变慢吗？</h3><p>不会。在现代浏览器中，闭包和类的原始性能只有在极端场景下才会有明显的差别。<p>除此之外，可以认为 Hook 的设计在某些方面更加高效：<ul><li><p>Hook 避免了 class 需要的额外开支，像是创建类实例和在构造函数中绑定事件处理器的成本。<li><p><strong>符合语言习惯的代码在使用 Hook 时不需要很深的组件树嵌套</strong>。这个现象在使用高阶组件、render props、和 context 的代码库中非常普遍。组件树小了，React 的工作量也随之减少。</ul><p>传统上认为，在 React 中使用内联函数对性能的影响，与每次渲染都传递新的回调会如何破坏子组件的 <code>shouldComponentUpdate</code> 优化有关。Hook 从三个方面解决了这个问题。<ul><li><p><a href="./hooks-reference.html#usecallback"><code>useCallback</code></a> Hook 允许你在重新渲染之间保持对相同的回调引用以使得 <code>shouldComponentUpdate</code> 继续工作：<pre class="language-js{2}"><code class="language-js{2}">// 除非 `a` 或 `b` 改变，否则不会变
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);</code></pre><li><p><a href="./hooks-faq.html#how-to-memoize-calculations"><code>useMemo</code></a> Hook 使得控制具体子节点何时更新变得更容易，减少了对纯组件的需要。<li><p>最后，<a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> Hook 减少了对深层传递回调的依赖，正如下面解释的那样。</ul></section><section id="how-to-avoid-passing-callbacks-down"class="level3"><h3>如何避免向下传递回调？</h3><p>我们已经发现大部分人并不喜欢在组件树的每一层手动传递回调。尽管这种写法更明确，但这给人感觉像错综复杂的管道工程一样麻烦。<p>在大型的组件树中，我们推荐的替代方案是通过 context 用 <a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> 往下传一个 <code>dispatch</code> 函数：<pre class="language-js{4,5}"><code class="language-js{4,5}">const TodosDispatch = React.createContext(null);

function TodosApp() {
  // 提示：`dispatch` 不会在重新渲染之间变化
  const [todos, dispatch] = useReducer(todosReducer);

  return (
    &#x3C;TodosDispatch.Provider value={dispatch}>
      &#x3C;DeepTree todos={todos} />
    &#x3C;/TodosDispatch.Provider>
  );
}</code></pre><p><code>TodosApp</code> 内部组件树里的任何子节点都可以使用 <code>dispatch</code> 函数来向上传递 actions 到 <code>TodosApp</code>：<pre class="language-js{2,3}"><code class="language-js{2,3}">function DeepChild(props) {
  // 如果我们想要执行一个 action，我们可以从 context 中获取 dispatch。
  const dispatch = useContext(TodosDispatch);

  function handleClick() {
    dispatch({ type: 'add', text: 'hello' });
  }

  return (
    &#x3C;button onClick={handleClick}>Add todo&#x3C;/button>
  );
}</code></pre><p>总而言之，从维护的角度来这样看更加方便（不用不断转发回调），同时也避免了回调的问题。像这样向下传递 <code>dispatch</code> 是处理深度更新的推荐模式。<p>注意，你依然可以选择将应用的 <em>state</em> 作为 props（更显明确）向下传递或者使用 context（对很深的更新而言更加方便）向下传递。如果你选择使用 context 来向下传递 state，请使用两种不同的 context 类型传递 state 和 dispatch —— 由于 <code>dispatch</code> context 永远不会变，因此读取它的组件不需要重新渲染，除非这些组件也需要用到应用程序的 state。</section><section id="how-to-read-an-often-changing-value-from-usecallback"class="level3"><h3>如何从 <code>useCallback</code> 读取一个经常变化的值？</h3><blockquote><p>注意<p>我们推荐 <a href="#how-to-avoid-passing-callbacks-down">在 context 中向下传递 <code>dispatch</code></a> 而非在 props 中使用独立的回调。下面的方法仅仅出于文档完整性考虑，以及作为一条出路在此提及。</blockquote><p>在某些罕见场景中，你可能会需要用 <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a> 记住一个回调，但由于内部函数必须经常重新创建，记忆效果不是很好。如果你想要记住的函数是一个事件处理器并且在渲染期间没有被用到，你可以 <a href="#is-there-something-like-instance-variables">把 ref 当做实例变量</a> 来用，并手动把最后提交的值保存在它当中：<pre class="language-js{6,10}"><code class="language-js{6,10}">function Form() {
  const [text, updateText] = useState('');
  const textRef = useRef();

  useEffect(() => {
    textRef.current = text; // 把它写入 ref
  });

  const handleSubmit = useCallback(() => {
    const currentText = textRef.current; // 从 ref 读取它
    alert(currentText);
  }, [textRef]); // 不要像 [text] 那样重新创建 handleSubmit

  return (
    &#x3C;>
      &#x3C;input value={text} onChange={e => updateText(e.target.value)} />
      &#x3C;ExpensiveTree onSubmit={handleSubmit} />
    &#x3C;/>
  );
}</code></pre><p>这是一个比较麻烦的模式，但这表示如果你需要的话你可以用这条出路进行优化。如果你把它抽取成一个自定义 Hook 的话会更加好受些：<pre class="language-js{4,16}"><code class="language-js{4,16}">function Form() {
  const [text, updateText] = useState('');
  // 即便 `text` 变了也会被记住:
  const handleSubmit = useEventCallback(() => {
    alert(text);
  }, [text]);

  return (
    &#x3C;>
      &#x3C;input value={text} onChange={e => updateText(e.target.value)} />
      &#x3C;ExpensiveTree onSubmit={handleSubmit} />
    &#x3C;/>
  );
}

function useEventCallback(fn, dependencies) {
  const ref = useRef(() => {
    throw new Error('Cannot call an event handler while rendering.');
  });

  useEffect(() => {
    ref.current = fn;
  }, [fn, ...dependencies]);

  return useCallback(() => {
    const fn = ref.current;
    return fn();
  }, [ref]);
}</code></pre><p>无论如何，我们都 <strong>不推荐使用这种模式</strong> ，只是为了文档的完整性而把它展示在这里。相反的，我们更倾向于 <a href="#how-to-avoid-passing-callbacks-down">避免向下深入传递回调</a>。</section></section><section id="under-the-hood"class="level2"><h2>底层原理</h2><section id="how-does-react-associate-hook-calls-with-components"class="level3"><h3>React 是如何把对 Hook 的调用和组件联系起来的？</h3><p>React 保持对当前渲染中的组件的追踪。多亏了 <a href="./hooks-rules.html">Hook 规范</a>，我们得知 Hook 只会在 React 组件中被调用（或自定义 Hook —— 同样只会在 React 组件中被调用）。<p>每个组件内部都有一个「记忆单元格」列表。它们只不过是我们用来存储一些数据的 JavaScript 对象。当你用 <code>useState()</code> 调用一个 Hook 的时候，它会读取当前的单元格（或在首次渲染时将其初始化），然后把指针移动到下一个。这就是多个 <code>useState()</code> 调用会得到各自独立的本地 state 的原因。</section><section id="what-is-the-prior-art-for-hooks"class="level3"><h3>Hook 使用了哪些现有技术？</h3><p>Hook 由不同的来源的多个想法构成：<ul><li><a href="https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State">react-future</a> 这个仓库中包含我们对函数式 API 的老旧实验。<li>React 社区对 render prop API 的实验，其中包括 <a href="https://github.com/ryanflorence">Ryan Florence</a> 的 <a href="https://github.com/reactions/component">Reactions Component</a> 。<li><a href="https://github.com/trueadm">Dominic Gannaway</a> 的用 <a href="https://gist.github.com/trueadm/17beb64288e30192f3aa29cad0218067"><code>adopt</code> 关键字</a> 作为 render props 的语法糖的提案。<li><a href="http://displayscript.org/introduction.html">DisplayScript</a> 中的 state 变量和 state 单元格。<li>ReasonReact 中的 <a href="https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html">Reducer components</a>。<li>Rx 中的 <a href="http://reactivex.io/rxjs/class/es6/Subscription.js~Subscription.html">Subscriptions</a>。<li>Multicore OCaml 提到的 <a href="https://github.com/ocamllabs/ocaml-effects-tutorial#2-effectful-computations-in-a-pure-setting">Algebraic effects</a>。</ul><p><a href="https://github.com/sebmarkbage">Sebastian Markbåge</a> 想到了 Hook 最初的设计，后来经过 <a href="https://github.com/acdlite">Andrew Clark</a>，<a href="https://github.com/sophiebits">Sophie Alpert</a>，<a href="https://github.com/trueadm">Dominic Gannaway</a>，和 React 团队的其他成员的提炼。 <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section></section>