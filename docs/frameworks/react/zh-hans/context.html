<!doctypehtml><html lang="zh-hans"><meta charset="utf-8"><title>Context</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="context"class="level1"><h1>Context</h1><p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。<p>在一个典型的 React 应用中，数据是通过 props 属性自上而下（由父及子）进行传递的，但此种用法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI 主题），这些属性是应用程序中许多组件都需要的。Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。<ul><li><a href="#when-to-use-context">何时使用 Context</a><li><a href="#before-you-use-context">使用 Context 之前的考虑</a><li><a href="#api">API</a><ul><li><a href="#reactcreatecontext">React.createContext</a><li><a href="#contextprovider">Context.Provider</a><li><a href="#classcontexttype">Class.contextType</a><li><a href="#contextconsumer">Context.Consumer</a><li><a href="#contextdisplayname">Context.displayName</a></ul><li><a href="#examples">示例</a><ul><li><a href="#dynamic-context">动态 Context</a><li><a href="#updating-context-from-a-nested-component">在嵌套组件中更新 Context</a><li><a href="#consuming-multiple-contexts">使用多个 Context</a></ul><li><a href="#caveats">注意事项</a><li><a href="#legacy-api">废弃的 API</a></ul><section id="when-to-use-context"class="level2"><h2>何时使用 Context</h2><p>Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。举个例子，在下面的代码中，我们通过一个 “theme” 属性手动调整一个按钮组件的样式：<p><code>embed:context/motivation-problem.js</code><p>使用 context, 我们可以避免通过中间元素传递 props：<p><code>embed:context/motivation-solution.js</code></section><section id="before-you-use-context"class="level2"><h2>使用 Context 之前的考虑</h2><p>Context 主要应用场景在于<em>很多</em>不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。<p><strong>如果你只是想避免层层传递一些属性，<a href="./composition-vs-inheritance.html">组件组合（component composition）</a>有时候是一个比 context 更好的解决方案。</strong><p>比如，考虑这样一个 <code>Page</code> 组件，它层层向下传递 <code>user</code> 和 <code>avatarSize</code> 属性，从而让深度嵌套的 <code>Link</code> 和 <code>Avatar</code> 组件可以读取到这些属性：<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Page</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> avatarSize<span class="token operator">=</span><span class="token punctuation">{</span>avatarSize<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token comment">// ... 渲染出 ...</span>
<span class="token operator">&#x3C;</span><span class="token maybe-class-name">PageLayout</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> avatarSize<span class="token operator">=</span><span class="token punctuation">{</span>avatarSize<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token comment">// ... 渲染出 ...</span>
<span class="token operator">&#x3C;</span><span class="token maybe-class-name">NavigationBar</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> avatarSize<span class="token operator">=</span><span class="token punctuation">{</span>avatarSize<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token comment">// ... 渲染出 ...</span>
<span class="token operator">&#x3C;</span><span class="token maybe-class-name">Link</span> href<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">.</span><span class="token property-access">permalink</span><span class="token punctuation">}</span><span class="token operator">></span>
  <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Avatar</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> size<span class="token operator">=</span><span class="token punctuation">{</span>avatarSize<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Link</span><span class="token operator">></span></code></pre><p>如果在最后只有 <code>Avatar</code> 组件真的需要 <code>user</code> 和 <code>avatarSize</code>，那么层层传递这两个 props 就显得非常冗余。而且一旦 <code>Avatar</code> 组件需要更多从来自顶层组件的 props，你还得在中间层级一个一个加上去，这将会变得非常麻烦。<p>一种 <strong>无需 context</strong> 的解决方案是<a href="./composition-vs-inheritance.html#containment">将 <code>Avatar</code> 组件自身传递下去</a>，因为中间组件无需知道 <code>user</code> 或者 <code>avatarSize</code> 等 props：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Page</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">user</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> userLink <span class="token operator">=</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Link</span> href<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">.</span><span class="token property-access">permalink</span><span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Avatar</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> size<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span><span class="token property-access">avatarSize</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Link</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">PageLayout</span> userLink<span class="token operator">=</span><span class="token punctuation">{</span>userLink<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 现在，我们有这样的组件：</span>
<span class="token operator">&#x3C;</span><span class="token maybe-class-name">Page</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> avatarSize<span class="token operator">=</span><span class="token punctuation">{</span>avatarSize<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token comment">// ... 渲染出 ...</span>
<span class="token operator">&#x3C;</span><span class="token maybe-class-name">PageLayout</span> userLink<span class="token operator">=</span><span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token comment">// ... 渲染出 ...</span>
<span class="token operator">&#x3C;</span><span class="token maybe-class-name">NavigationBar</span> userLink<span class="token operator">=</span><span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token comment">// ... 渲染出 ...</span>
<span class="token punctuation">{</span>props<span class="token punctuation">.</span><span class="token property-access">userLink</span><span class="token punctuation">}</span></code></pre><p>这种变化下，只有最顶部的 Page 组件需要知道 <code>Link</code> 和 <code>Avatar</code> 组件是如何使用 <code>user</code> 和 <code>avatarSize</code> 的。<p>这种对组件的<em>控制反转</em>减少了在你的应用中要传递的 props 数量，这在很多场景下会使得你的代码更加干净，使你对根组件有更多的把控。但是，这并不适用于每一个场景：这种将逻辑提升到组件树的更高层次来处理，会使得这些高层组件变得更复杂，并且会强行将低层组件适应这样的形式，这可能不会是你想要的。<p>而且你的组件并不限制于接收单个子组件。你可能会传递多个子组件，甚至会为这些子组件（children）封装多个单独的“接口（slots）”，<a href="./composition-vs-inheritance.html#containment">正如这里的文档所列举的</a><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Page</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> props<span class="token punctuation">.</span><span class="token property-access">user</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> content <span class="token operator">=</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Feed</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> topBar <span class="token operator">=</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">NavigationBar</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Link</span> href<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">.</span><span class="token property-access">permalink</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Avatar</span> user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> size<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span><span class="token property-access">avatarSize</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Link</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">NavigationBar</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">PageLayout</span>
      topBar<span class="token operator">=</span><span class="token punctuation">{</span>topBar<span class="token punctuation">}</span>
      content<span class="token operator">=</span><span class="token punctuation">{</span>content<span class="token punctuation">}</span>
    <span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>这种模式足够覆盖很多场景了，在这些场景下你需要将子组件和直接关联的父组件解耦。如果子组件需要在渲染前和父组件进行一些交流，你可以进一步使用 <a href="./render-props.html">render props</a>。<p>但是，有的时候在组件树中很多不同层级的组件需要访问同样的一批数据。Context 能让你将这些数据向组件树下所有的组件进行“广播”，所有的组件都能访问到这些数据，也能访问到后续的数据更新。使用 context 的通用的场景包括管理当前的 locale，theme，或者一些缓存数据，这比替代方案要简单的多。</section><section id="api"class="level2"><h2>API</h2><section id="reactcreatecontext-reactcreatecontext"class="level3"><h3><code>React.createContext</code> {#reactcreatecontext}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">MyContext</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">createContext</span><span class="token punctuation">(</span>defaultValue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 <code>Provider</code> 中读取到当前的 context 值。<p><strong>只有</strong>当组件所处的树中没有匹配到 Provider 时，其 <code>defaultValue</code> 参数才会生效。此默认值有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 <code>undefined</code> 传递给 Provider 的 value 时，消费组件的 <code>defaultValue</code> 不会生效。</section><section id="contextprovider-contextprovider"class="level3"><h3><code>Context.Provider</code> {#contextprovider}</h3><pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">MyContext</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Provider</span></span> value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token comment">/* 某个值 */</span><span class="token punctuation">}</span><span class="token operator">></span></code></pre><p>每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。<p>Provider 接收一个 <code>value</code> 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。<p>当 Provider 的 <code>value</code> 值发生变化时，它内部的所有消费组件都会重新渲染。从 Provider 到其内部 consumer 组件（包括 <a href="#classcontexttype">.contextType</a> 和 <a href="./hooks-reference.html#usecontext">useContext</a>）的传播不受制于 <code>shouldComponentUpdate</code> 函数，因此当 consumer 组件在其祖先组件跳过更新的情况下也能更新。<p>通过新旧值检测来确定变化，使用了与 <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"><code>Object.is</code></a> 相同的算法。<blockquote><p>注意<p>当传递对象给 <code>value</code> 时，检测变化的方式会导致一些问题：详见<a href="#caveats">注意事项</a>。</blockquote></section><section id="classcontexttype-classcontexttype"class="level3"><h3><code>Class.contextType</code> {#classcontexttype}</h3><pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">context</span><span class="token punctuation">;</span>
    <span class="token comment">/* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */</span>
  <span class="token punctuation">}</span>
  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">context</span><span class="token punctuation">;</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">context</span><span class="token punctuation">;</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">context</span><span class="token punctuation">;</span>
    <span class="token comment">/* 基于 MyContext 组件的值进行渲染 */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token maybe-class-name">MyClass</span><span class="token punctuation">.</span><span class="token property-access">contextType</span> <span class="token operator">=</span> <span class="token maybe-class-name">MyContext</span><span class="token punctuation">;</span></code></pre><p>挂载在 class 上的 <code>contextType</code> 属性可以赋值为由 <a href="#reactcreatecontext"><code>React.createContext()</code></a> 创建的 Context 对象。此属性可以让你使用 <code>this.context</code> 来获取最近 Context 上的值。你可以在任何生命周期中访问到它，包括 render 函数中。<blockquote><p>注意：<p>你只通过该 API 订阅单一 context。如果你想订阅多个，阅读<a href="#consuming-multiple-contexts">使用多个 Context</a> 章节<p>如果你正在使用实验性的 <a href="https://babeljs.io/docs/plugins/transform-class-properties/">public class fields 语法</a>，你可以使用 <code>static</code> 这个类属性来初始化你的 <code>contextType</code>。</blockquote><pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> contextType <span class="token operator">=</span> <span class="token maybe-class-name">MyContext</span><span class="token punctuation">;</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">context</span><span class="token punctuation">;</span>
    <span class="token comment">/* 基于这个值进行渲染工作 */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></section><section id="contextconsumer-contextconsumer"class="level3"><h3><code>Context.Consumer</code> {#contextconsumer}</h3><pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">MyContext</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Consumer</span></span><span class="token operator">></span>
  <span class="token punctuation">{</span><span class="token parameter">value</span> <span class="token arrow operator">=></span> <span class="token comment">/* 基于 context 值进行渲染*/</span><span class="token punctuation">}</span>
<span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">MyContext</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Consumer</span></span><span class="token operator">></span></code></pre><p>一个 React 组件可以订阅 context 的变更，此组件可以让你在<a href="./components-and-props.html#function-and-class-components">函数式组件</a>中可以订阅 context。<p>这种方法需要一个<a href="./render-props.html#using-props-other-than-render">函数作为子元素（function as a child）</a>。这个函数接收当前的 context 值，并返回一个 React 节点。传递给函数的 <code>value</code> 值等价于组件树上方离这个 context 最近的 Provider 提供的 <code>value</code> 值。如果没有对应的 Provider，<code>value</code> 参数等同于传递给 <code>createContext()</code> 的 <code>defaultValue</code>。<blockquote><p>注意<p>想要了解更多关于 “函数作为子元素（function as a child）” 模式，详见 <a href="./render-props.html">render props</a>。</blockquote></section><section id="contextdisplayname-contextdisplayname"class="level3"><h3><code>Context.displayName</code> {#contextdisplayname}</h3><p>context 对象接受一个名为 <code>displayName</code> 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。<p>示例，下述组件在 DevTools 中将显示为 MyDisplayName：<pre class="language-js{2}"><code class="language-js{2}">const MyContext = React.createContext(/* some value */);
MyContext.displayName = 'MyDisplayName';

&#x3C;MyContext.Provider> // "MyDisplayName.Provider" 在 DevTools 中
&#x3C;MyContext.Consumer> // "MyDisplayName.Consumer" 在 DevTools 中</code></pre></section></section><section id="examples"class="level2"><h2>示例</h2><section id="dynamic-context"class="level3"><h3>动态 Context</h3><p>一个更加复杂的方案是对上面的 theme 例子使用动态值（dynamic values）：<p><strong>theme-context.js</strong> <code>embed:context/theme-detailed-theme-context.js</code><p><strong>themed-button.js</strong> <code>embed:context/theme-detailed-themed-button.js</code><p><strong>app.js</strong> <code>embed:context/theme-detailed-app.js</code></section><section id="updating-context-from-a-nested-component"class="level3"><h3>在嵌套组件中更新 Context</h3><p>从一个在组件树中嵌套很深的组件中更新 context 是很有必要的。在这种场景下，你可以通过 context 传递一个函数，使得 consumers 组件更新 context：<p><strong>theme-context.js</strong> <code>embed:context/updating-nested-context-context.js</code><p><strong>theme-toggler-button.js</strong> <code>embed:context/updating-nested-context-theme-toggler-button.js</code><p><strong>app.js</strong> <code>embed:context/updating-nested-context-app.js</code></section><section id="consuming-multiple-contexts"class="level3"><h3>消费多个 Context</h3><p>为了确保 context 快速进行重渲染，React 需要使每一个 consumers 组件的 context 在组件树中成为一个单独的节点。<p><code>embed:context/multiple-contexts.js</code><p>如果两个或者更多的 context 值经常被一起使用，那你可能要考虑一下另外创建你自己的渲染组件，以提供这些值。</section></section><section id="caveats"class="level2"><h2>注意事项</h2><p>因为 context 会根据引用标识来决定何时进行渲染（本质上是 <code>value</code> 属性值的浅比较），所以这里可能存在一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。举个例子，当每一次 Provider 重渲染时，由于 <code>value</code> 属性总是被赋值为新的对象，以下的代码会重新渲染下面所有的 consumers 组件：<p><code>embed:context/reference-caveats-problem.js</code><p>为了防止这种情况，将 value 状态提升到父节点的 state 里：<p><code>embed:context/reference-caveats-solution.js</code></section><section id="legacy-api"class="level2"><h2>过时的 API</h2><blockquote><p>注意<p>先前 React 使用实验性的 context API 运行，旧的 API 将会在所有 16.x 版本中得到支持，但用到它的应用应该迁移到新版本。过时的 API 将在未来的 React 版本中被移除。阅读<a href="./legacy-context.html">过时的 context 文档</a>了解更多。 <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></blockquote></section></section>