<!doctype html><html lang="zh-hans"><meta charset="utf-8"><title>"React v18.0"</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="react-v180"><h1 id="react-v180">"React v18.0"</h1><p>2022 年 3 月 29 日，由 <a href="/community/team">React 团队</a> 发布</p><intro><p>React 18 现在可以在 npm 上使用啦！在我们的上一篇文章里，我们分享了 <a href="/blog/2022/03/08/react-18-upgrade-guide">将你的应用更新到 React 18</a> 的每一个步骤。在这片文章里，我们将会概述 React 18 究竟有哪些更新，以及这些更新对于未来的意义。</p></intro><p>我们最新的主要版本包含了开箱即用的改进，如自动批处理、<code>startTransition</code> 等新 API，以及支持 Suspense 的流式服务端渲染。<p>React 18 的许多新功能都建立在新推出的并发渲染特性之上，也就是一种解锁全新能力的底层变动。并发模式 React 是选择性启用的——只有当你使用了一个并发功能的时候才会开启——但是我们认为它将会对人们构建应用的方式产生巨大的影响。<p>我们花了很多年时间来研发 React 的并发渲染，同时我们也还考虑为现有用户提供一种过渡的路径。去年夏天，<a href="/blog/2021/06/08/the-plan-for-react-18">我们成立了 React 18 工作组</a> 来收集社区专家们的反馈信息，保证整个 React 生态都能有一个丝滑的升级体验。<p>如果你忘了，我们在 React 大会 2021 上公开提出了这个愿景：<ul><li>在 <a href="https://www.youtube.com/watch?v=FZ0cG47msEk&#x26;list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa">摘要</a> 中，我们解释了 React 18 为什么能够实现让开发者创造更好的用户体验这一使命。<li><a href="https://twitter.com/shrutikapoor08">Shruti Kapoor</a> <a href="https://www.youtube.com/watch?v=ytudH8je5ko&#x26;list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&#x26;index=2">示范了如何使用 React 18 中的新功能</a>。<li><a href="https://twitter.com/shaundai">Shaundai Person</a> 为我们大概介绍了 <a href="https://www.youtube.com/watch?v=pj5N-Khihgc&#x26;list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&#x26;index=3">支持 Suspense 的流式服务端渲染</a>。</ul><p>以下是一个在此版本中对需要关注的内容的总结，先从并发渲染开始介绍。</p><note><p>对于 React Native 用户而言，React 18 将会伴随新的 React Native 体系结构发布。想了解更多信息，可以阅读 <a href="https://www.youtube.com/watch?v=FZ0cG47msEk&#x26;t=1530s">React Conf 摘要</a>。</p></note><section class="level2"aria-labelledby="什么是并发-react-what-is-concurrent-react"><h2 id="什么是并发-react-what-is-concurrent-react">什么是并发 React？ {/<em>what-is-concurrent-react</em>/}</h2><p>React 18 中最重要的更新内容是我们希望你永远不会考虑的：并发。我们认为这对于应用开发者而言是一件非常好的事情，尽管这对于库的维护者来说可能有点复杂。<p>并发渲染本身并不是一个功能。它是一个新的底层机制，使得 React 能够同时准备多个版本的 UI。你可以把并发视为一种底层实现的细节——它解锁了许多新功能因而非常有价值。React 在底层实现上使用了非常复杂的技术，如优先队列和多级缓冲。但是你不会在任何公共 API 中感知到这些。<p>在设计 API 时，我们刻意隐藏了实现细节。作为一名 React 开发者，你只需要关注视图是 <strong>什么</strong> 样子，然后由 React 来处理 <strong>如何</strong> 来实现，所以我们不需要 React 开发者了解并发的底层运行原理。<p>不过，并发模式 React 比典型的实现细节更重要──它是 React 核心渲染模型的基础性更新。因此，尽管了解并发渲染底层工作原理不是很重要，但如果是为了追求更高的技术层次，倒是值得去了解它。<p>并发模式的一个关键特性是渲染可中断。当首次升级到 React 18，在加入任何并发功能之前，更新内容渲染的方式和 React 之前的版本一样——通过一个单一的且不可中断的同步事务进行处理。同步渲染意味着，一旦开始渲染就无法中断，直到用户可以在屏幕上看到渲染结果。<p>在并发渲染中，情况并不总是如此。React 可能开始渲染一个更新，然后中途挂起，稍后又继续。它甚至可能完全放弃一个正在进行的渲染。React 保证即使渲染被中断，UI 也会保持一致。为了实现这一点，它会在整个 DOM 树被计算完毕前一直等待，完毕后再执行 DOM 变更。这样做，React 就可以在后台提前准备新的屏幕内容，而不阻塞主线程。这意味着用户输入可以被立即响应，即使存在大量渲染任务，也能有流畅的用户体验。<p>另一个例子是可重用状态。并发 React 可以从屏幕中移除部分 UI，然后在稍后将它们再添加回来，并重用之前的状态。例如，当用户来回切换标签页，React 应该能够立即将屏幕恢复到它先前的状态。在即将到来的次要版本中，我们计划添加一个新的名为 <code>&#x3C;Offscreen></code> 的组件，它实现了这种模式。同样地，你将能够使用 Offscreen 在后台准备新的 UI，在显示前就准备完毕以便快速响应。<p>并发渲染是一个 React 中非常强大的工具，并且我们大多数新功能都是利用了它的优势来创建的，包括 Suspense，transition 和流式服务端渲染。但是在并发渲染这个方向，React 18 也仅仅只是实现我们最终目标的第一步。</section><section class="level2"aria-labelledby="渐进式采用并发特性-gradually-adopting-concurrent-features"><h2 id="渐进式采用并发特性-gradually-adopting-concurrent-features">渐进式采用并发特性 {/<em>gradually-adopting-concurrent-features</em>/}</h2><p>从技术上讲，并发渲染是一个破坏性变更。因为并发渲染是可中断的，因此在并发模式下组件的行为会略微不同。<p>在我们的测试过程中，我们已经把几千个组件更新到了 React 18。我们发现，几乎所有现有的组件都能在并发渲染下“正常工作”。然而部分组件可能需要一些额外的迁移工作。这种变化通常很小，你仍然可以按照自己的节奏进行使用。React 18 中的新渲染行为 <strong>只在你的应用中使用新功能的部分启用</strong>。<p>整体的升级策略是使你的应用基于 React 18 运行而不用破坏现存的代码，然后你可以渐进地按照你的节奏开始添加并发功能。你可以在开发环境中使用 <a href="/reference/react/StrictMode"><code>&#x3C;StrictMode></code></a> 以利于暴露并发模式相关的问题。严格模式是不影响生产环境的，但是在开发环境中它将会记录额外的警告日志，并且被视为幂等的函数将被调用两次。这没办法捕获所有异常，但是能够有效预防大部分常见的错误类型。<p>在升级到 React 18 后，可以立即开始使用并发模式的功能。例如，你可以使用 <code>startTransition</code> 在屏幕内容之间进行导航，而不会阻塞用户输入；或者使用 <code>useDeferredValue</code> 来节流处理开销巨大的重新渲染。<p>长远来看，我们希望你在应用中添加并发渲染能力的主要方式是，使用支持并发渲染的库或者框架。在大多数情况中，你不用与并发模式的 API 直接交互。例如，在导航到一个新的屏幕时，开发者无需调用 <code>startTransition</code>，路由库会自动将导航操作包裹在 <code>startTransition</code> 中。<p>这些库升级到兼容并发模式可能需要一些时间。我们已经提供了新的 API，使这些库更容易利用并发功能。同时，在我们努力逐步迁移 React 生态系统的过程中，请对维护者保持耐心。<p>如果想了解更多信息，可以查看我们之前的文章：<a href="/blog/2022/03/08/react-18-upgrade-guide">如何升级到 React 18</a>。</section><section class="level2"aria-labelledby="数据框架中的-suspense-suspense-in-data-frameworks"><h2 id="数据框架中的-suspense-suspense-in-data-frameworks">数据框架中的 Suspense {/<em>suspense-in-data-frameworks</em>/}</h2><p>在 React 18 中，你可以在 Relay，Next.js，Hydrogen 或者 Remix 等框架中获取数据。临时使用 <a href="/reference/react/Suspense">Suspense</a> 获取数据在技术上是可行的，但是不建议作为一般方案。<p>在未来，我们可能会暴露更多原语，使你能用 <code>Suspense</code> 更容易地获取数据，那时也就不一定必须要使用某个的框架。不过，Suspense 被深度整合到你的应用结构中时能产生最好的效果：你的路由，你的数据层，你的服务端渲染环境。因此我们预计，即使在未来相当长一段时间里，库和框架也还会在 React 生态中发挥关键作用。<p>就像在过去的 React 的版本中，你总是可以使用 Suspense 与客户端侧的 <code>React.lazy</code> 配合进行代码分割。但是我们的对 Suspense 的期望并不仅仅是加载代码——最终的目标是扩展对 Suspense 的支持，以至于相同的声明式 Suspense fallback 能够处理任何异步操作（加载代码，数据，图片等）。</section><section class="level2"aria-labelledby="服务端组件仍在开发中-server-components-is-still-in-development"><h2 id="服务端组件仍在开发中-server-components-is-still-in-development">服务端组件仍在开发中 {/<em>server-components-is-still-in-development</em>/}</h2><p><a href="/blog/2020/12/21/data-fetching-with-react-server-components"><strong>服务端组件</strong></a> 是一个即将到来的功能，允许开发者构建跨越服务端和客户端的应用，结合客户端应用丰富的交互性和传统服务端渲染的优良性能，服务端组件和并发模式 React 并不是强耦合的，但是它设计的初衷就是为了配合 Suspense 和流式服务端渲染这样的并发功能。<p>服务端组件仍然是实验性的，但是我们预计会在 18.x 的一个小版本中正式发布。同时，我们正在与 Next.js，Hydrogen 和 Remix 等框架合作，以推进提案，并使其准备好被广泛采用。</section><section class="level2"aria-labelledby="react-18-的新内容-whats-new-in-react-18"><h2 id="react-18-的新内容-whats-new-in-react-18">React 18 的新内容 {/<em>whats-new-in-react-18</em>/}</h2><section class="level3"aria-labelledby="新功能自动批处理-new-feature-automatic-batching"><h3 id="新功能自动批处理-new-feature-automatic-batching">新功能：自动批处理 {/<em>new-feature-automatic-batching</em>/}</h3><p>批处理是指，当 React 在一个单独的重渲染事件中批量处理多个状态更新以此实现优化性能。如果没有自动批处理的话，我们仅能够在 React 事件处理程序中批量更新。在 React 18 之前，默认情况下 <code>promise</code>、<code>setTimeout</code>、原生应用的事件处理程序以及任何其他事件中的更新都不会被批量处理；但现在，这些更新内容都会被自动批处理：<pre class="language-js"><code class="language-js"><span class="token comment">// 以前: 只有 React 事件会被批处理。</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token arrow operator">=></span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token parameter">f</span> <span class="token arrow operator">=></span> <span class="token operator">!</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// React 会渲染两次，每次更新一个状态（没有批处理）</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 现在: 超时，promise，本机事件处理程序</span>
<span class="token comment">// 原生应用时间处理程序或者任何其他时间都被批处理了</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token arrow operator">=></span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token parameter">f</span> <span class="token arrow operator">=></span> <span class="token operator">!</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 最终，React 将仅会重新渲染一次（这就是批处理！）</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>想要了解更多信息，可以阅读 <a href="https://github.com/reactwg/react-18/discussions/21">React 18 中能减少渲染次数的自动批处理机制</a>。</section><section class="level3"aria-labelledby="新功能过渡更新-new-feature-transitions"><h3 id="新功能过渡更新-new-feature-transitions">新功能：过渡更新 {/<em>new-feature-transitions</em>/}</h3><p>过渡（transition）更新是 React 中一个新的概念，用于区分紧急和非紧急的更新。<ul><li><strong>紧急更新</strong> 对应直接的交互，如输入，点击，按压等。<li><strong>过渡更新</strong> 将 UI 从一个视图过渡到另一个。</ul><p>像输入，点击，按压等紧急更新，需要立刻响应以符合人们对物理对象行为的预期。否则，他们就会觉得“不对劲”。但是，过渡更新不太一样，因为用户对感知到屏幕上的每一个中间值这件事是没有预期的。<p>举个例子，当我们在一个下拉菜单中选择了一个过滤器，你期望的是这个过滤器按钮在你点击的时候立即就能响应。然而，实际结果可能是不连贯的过渡。这样一个较短的延迟是难以察觉的，而且这往往也是能符合预期的。并且如果你在渲染完成之前，再次改变了过滤器，你需要关心的其实只是最新的结果。<p>通常情况下，为了更好的用户体验，一个用户输入应该同时产生一个紧急更新和一个过渡更新。你可以在一个输入事件中使用 <code>startTransition</code> API 告诉 React 哪些更新是紧急更新，哪些又是过渡更新：<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> startTransition <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token comment">// 紧急更新: 显示输入的内容</span>
<span class="token function">setInputValue</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 将任何内部的状态更新都标记为过渡更新</span>
<span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// 过渡更新: 展示结果</span>
  <span class="token function">setSearchQuery</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>被包裹在 <code>startTransition</code> 中的更新会被处理为过渡更新，如果有紧急更新出现，比如点击或者按键，则会中断过渡更新。如果一个过渡更新被用户中断（比如，快速输入多个字符），React 将会抛弃未完成的渲染结果，然后仅渲染最新的内容。<ul><li><code>useTransition</code>： 一个用于开启过渡更新的 hook，用于跟踪待定转场状态。<li><code>startTransition</code>： 当 hook 不能使用时，用于开启过渡的方法。</ul><p>并发渲染中将会加入过渡更新，允许更新被中断。如果更新内容被重新挂起，过渡机制也会告诉 React 在后台渲染过渡内容时继续展示当前内容（查看 <a href="https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md">Suspense 意见征求</a> 了解更多信息）。<p><a href="/reference/react/useTransition">更多内容请参阅 transition 相关的文档</a>。</section><section class="level3"aria-labelledby="新的-suspense-特性-new-suspense-features"><h3 id="新的-suspense-特性-new-suspense-features">新的 Suspense 特性 {/<em>new-suspense-features</em>/}</h3><p>Suspense 允许你声明式地为一部分还没有准备好被展示的组件树指定加载状态：<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Suspense</span> fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Spinner</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">}</span><span class="token operator">></span>
  <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Comments</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Suspense</span><span class="token operator">></span></code></pre><p>Suspense 使得“UI 加载状态”成为了 React 编程模型中最高级的声明式概念。我们基于此能够构建更高级的功能。<p>几年前，我们推出了一个受限制版的 Suspense。但是唯一支持的场景就是用 <code>React.lazy</code> 拆分代码，而且在服务端渲染时完全没有作用。<p>在 React 18 中，我们已经支持了服务端 Suspense，并且使用并发渲染特性扩展了其功能。<p>React 18 中的 Suspense 在与 transition API 结合时效果最好。如果你在 transition 期间挂起，React 不会让已显示的内容被之前的内容取代。相反，React 会延迟渲染，直到有足够的数据，以防止出现加载状态错误。<p>更多内容参见 <a href="https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md">React 18 中的 Suspense</a> 的意见征求。</section><section class="level3"aria-labelledby="新的客户端和服务端渲染-apis-new-client-and-server-rendering-apis"><h3 id="新的客户端和服务端渲染-apis-new-client-and-server-rendering-apis">新的客户端和服务端渲染 APIs {/<em>new-client-and-server-rendering-apis</em>/}</h3><p>我们利用这次版本更新的机会，重新设计了我们为在客户端和服务端进行渲染所暴露的 API。这些更改允许用户在升级到 React 18 使用新的 API 时，也能继续使用 React 17 中的旧 API。<section class="level4"aria-labelledby="react-dom-client-react-dom-client"><h4 id="react-dom-client-react-dom-client">React DOM Client {/<em>react-dom-client</em>/}</h4><p>这些新的 API 现在可以从 <code>react-dom/client</code> 中导出：<ul><li><code>createRoot</code>：为 <code>render</code> 或者 <code>unmount</code> 创建根节点的新方法。请用它替代 <code>ReactDOM.render</code>。如果没有它，React 18 中的新功能就无法生效。<li><code>hydrateRoot</code>：hydrate 服务端渲染的应用的新方法。使用它来替代 <code>ReactDOM.hydrate</code> 与新的 React DOM 服务端 API 一起使用。如果没有它，React 18 中的新功能就无法生效。</ul><p><code>createRoot</code> 和 <code>hydrateRoot</code> 都能接受一个新的可选参数叫做 <code>onRecoverableError</code>，它能在 React 在渲染或者 hydrate 过程发生错误后又恢复时，做日志记录对你进行通知。默认情况下，React 会使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/reportError"><code>reportError</code></a>，如果在老旧版本浏览器中，则会使用 <code>console.error</code>。<p><a href="/reference/react-dom/client">参阅 React DOM Client 的文档</a>。</section><section class="level4"aria-labelledby="react-dom-server-react-dom-server"><h4 id="react-dom-server-react-dom-server">React DOM Server {/<em>react-dom-server</em>/}</h4><p>这些新的 API 现在可以从 <code>react-dom/server</code> 中导出，并且在服务端端完全支持流式 Suspense：<ul><li><code>renderToPipeableStream</code>：用于 Node 环境中的流式渲染。<li><code>renderToReadableStream</code>：对新式的非主流运行时环境，比如 Deno 和 Cloudflare workers。</ul><p>现有的 <code>renderToString</code> 方法仍然可以使用，但是并不推荐这样做。<p><a href="/reference/react-dom/server">参阅 React DOM Server 的文档</a>。 ### 新的严格模式行为 {/<em>new-strict-mode-behaviors</em>/}<p>在未来，我们希望新增一个功能，允许 React 在保留状态的同时添加和移除 UI。例如，当一个用户标签页切出又切回时，React 应该能够立即将之前的页面内容恢复到它先前的状态。为了实现这一点，React 将在卸载后又重新挂载组件树时，复用之前的状态。<p>这个功能将给 React 应用带来更好的开箱即用能力，但要求组件能够灵活应对多次安装和销毁的副作用。对于大多数副作用不需要任何改动也依然能够生效，但是部分副作用需要保证它们只进行一次挂载或销毁。<p>为了利于暴露这些问题，React 18 为严格模式下的开发环境引入了一个新的检查机制。每当组件第一次挂载时，这个检查机制将自动卸载又重新挂载每个组件，并在第二次挂载时复用先前的状态。<p>在这个变更之前，React 是在挂载组件时产生一些副作用：<pre class="language-text"><code class="language-text">* React 装载组件
  * layout effect 创建
  * effect 创建</code></pre><p>在 React 18 的严格模式下，React 在开发模式下将会模拟组件的卸载和挂载：<pre class="language-text"><code class="language-text">* React 挂载组件
  * layout effect 创建
  * effect 创建
* React 模拟卸载组件
  * layout effect 销毁
  * effect 销毁
* React 模拟挂载组件，并复用之前的状态
  * layout effect 创建
  * effect 创建</code></pre><p><a href="/reference/react/StrictMode#fixing-bugs-found-by-re-running-effects-in-development">参阅确保状态可复用的文档</a>。</section></section><section class="level3"aria-labelledby="新的-hook-new-hooks"><h3 id="新的-hook-new-hooks">新的 Hook {/<em>new-hooks</em>/}</h3><section class="level4"aria-labelledby="useid-useid"><h4 id="useid-useid">useId {/<em>useid</em>/}</h4><p><code>useId</code> 是一个新的 hook，用于生成在客户端和服务端两侧都独一无二的 id，避免 hydrate 后两侧内容不匹配。它主要用于需要唯一 id 的，具有集成 API 的组件库。这个更新不仅解决了一个在 React 17 及更低版本中的存在的问题，而且它会在 React 18 中发挥更重要的作用，因为新的流式服务端渲染响应 HTML 的方式将是无序的，需要独一无二的 id 作为索引。<a href="/reference/react/useId">参阅文档</a>。<blockquote><p>Note<p><code>useId</code> <strong>不是</strong> 为了生成 <a href="/learn/rendering-lists#where-to-get-your-key">列表中的 key</a>。key 应该根据你的数据生成。</blockquote></section><section class="level4"aria-labelledby="usetransition-usetransition"><h4 id="usetransition-usetransition">useTransition {/<em>usetransition</em>/}</h4><p><code>useTransition</code> 和 <code>startTransition</code> 让你能够将一些状态更新标记为过渡更新。默认情况下，状态更新都被视为紧急更新。React 将允许紧急更新（例如，更新一个文本输入内容）打断过渡更新（例如，渲染一个搜索结果列表）。<a href="/reference/react/useTransition">参阅文档</a>。</section><section class="level4"aria-labelledby="usedeferredvalue-usedeferredvalue"><h4 id="usedeferredvalue-usedeferredvalue">useDeferredValue {/<em>usedeferredvalue</em>/}</h4><p><code>useDeferredValue</code> 允许推迟渲染树的非紧急更新。这和防抖操作非常相似，但是有一些改进。它没有固定的延迟时间，React 会在第一次渲染在屏幕上出现后立即尝试延迟渲染。延迟渲染是可中断的，它不会阻塞用户输入。<a href="/reference/react/useDeferredValue">参阅文档</a>。</section><section class="level4"aria-labelledby="usesyncexternalstore-usesyncexternalstore"><h4 id="usesyncexternalstore-usesyncexternalstore">useSyncExternalStore {/<em>usesyncexternalstore</em>/}</h4><p><code>useSyncExternalStore</code> 是一个新的 hook，允许使用第三方状态管理来支持并发模式，并且能通过对 store 进行强制更新实现数据同步。对第三方数据源的订阅能力的实现上，消除了对 <code>useEffect</code> 的依赖，推荐任何 React 相关的第三方状态管理库使用这个新特性。<a href="/reference/react/useSyncExternalStore">参阅文档</a>。<blockquote><p>Note<p><code>useSyncExternalStore</code> 旨在供库使用，而不是应用程序代码。</blockquote></section><section class="level4"aria-labelledby="useinsertioneffect-useinsertioneffect"><h4 id="useinsertioneffect-useinsertioneffect">useInsertionEffect {/<em>useinsertioneffect</em>/}</h4><p><code>useInsertionEffect</code> 是一个新的 Hook ，允许 CSS-in-JS 库解决在渲染中注入样式的性能问题。除非你已经建立了一个 CSS-in-JS 库，否则我们不希望你使用它。这个 hook 将在 DOM 变更发生后，在 layout effect 获取新布局之前运行。这个功能不仅解决了一个在 React 17 及以下版本中已经存在的问题，而且在 React 18 中更加重要，因为 React 在并发渲染时会为浏览器让步，给它一个重新计算布局的机会。<a href="/reference/react/useInsertionEffect">参阅文档</a>。<blockquote><p>Note<p><code>useInsertionEffect</code> 旨在供库使用，而不是应用程序代码。</blockquote></section></section></section><section class="level2"aria-labelledby="如何更新-how-to-upgrade"><h2 id="如何更新-how-to-upgrade">如何更新 {/<em>how-to-upgrade</em>/}</h2><p>请参阅 <a href="/blog/2022/03/08/react-18-upgrade-guide">如何升级到 React 18</a> 以获取分步说明和完整的中断列表以及值得注意的变化。</section><section class="level2"aria-labelledby="修改日志-changelog"><h2 id="修改日志-changelog">修改日志 {/<em>changelog</em>/}</h2><section class="level3"aria-labelledby="react-react"><h3 id="react-react">React {/<em>react</em>/}</h3><ul><li>添加 <code>useTransition</code> 和 <code>useDeferredValue</code> 以将紧急更新和过渡更新分开。(<a href="https://github.com/facebook/react/pull/10426">#10426</a>，<a href="https://github.com/facebook/react/pull/10715">#10715</a>，<a href="https://github.com/facebook/react/pull/15593">#15593</a>，<a href="https://github.com/facebook/react/pull/15272">#15272</a>，<a href="https://github.com/facebook/react/pull/15578">#15578</a>，<a href="https://github.com/facebook/react/pull/15769">#15769</a>，<a href="https://github.com/facebook/react/pull/17058">#17058</a>，<a href="https://github.com/facebook/react/pull/18796">#18796</a>，<a href="https://github.com/facebook/react/pull/19121">#19121</a>，<a href="https://github.com/facebook/react/pull/19703">#19703</a>，<a href="https://github.com/facebook/react/pull/19719">#19719</a>，<a href="https://github.com/facebook/react/pull/19724">#19724</a>，<a href="https://github.com/facebook/react/pull/20672">#20672</a>，<a href="https://github.com/facebook/react/pull/20976">#20976</a> <a href="https://github.com/acdlite">@acdlite</a>，<a href="https://github.com/lunaruan">@lunaruan</a>，<a href="https://github.com/rickhanlonii">@rickhanlonii</a>，and <a href="https://github.com/sebmarkbage">@sebmarkbage</a>)<li>添加 <code>useId</code> 用于生成唯一 ID。(<a href="https://github.com/facebook/react/pull/17322">#17322</a>，<a href="https://github.com/facebook/react/pull/18576">#18576</a>，<a href="https://github.com/facebook/react/pull/22644">#22644</a>，<a href="https://github.com/facebook/react/pull/22672">#22672</a>，<a href="https://github.com/facebook/react/pull/21260">#21260</a> <a href="https://github.com/acdlite">@acdlite</a>，<a href="https://github.com/lunaruan">@lunaruan</a>，and <a href="https://github.com/sebmarkbage">@sebmarkbage</a>)<li>添加 <code>useSyncExternalStore</code> 以帮助外部存储库与 React 集成。(<a href="https://github.com/facebook/react/pull/15022">#15022</a>，<a href="https://github.com/facebook/react/pull/18000">#18000</a>，<a href="https://github.com/facebook/react/pull/18771">#18771</a>，<a href="https://github.com/facebook/react/pull/22211">#22211</a>，<a href="https://github.com/facebook/react/pull/22292">#22292</a>，<a href="https://github.com/facebook/react/pull/22239">#22239</a>，<a href="https://github.com/facebook/react/pull/22347">#22347</a>，<a href="https://github.com/facebook/react/pull/23150">#23150</a> <a href="https://github.com/acdlite">@acdlite</a>，<a href="https://github.com/bvaughn">@bvaughn</a>，and <a href="https://github.com/drarmstr">@drarmstr</a>)<li>添加 <code>startTransition</code> 作为 <code>useTransition</code> 的一个版本，不需要等待反馈。 (<a href="https://github.com/facebook/react/pull/19696">#19696</a> <a href="https://github.com/rickhanlonii">@rickhanlonii</a>)<li>添加 <code>useInsertionEffect</code> 用于 CSS-in-JS 库。(<a href="https://github.com/facebook/react/pull/21913">#21913</a> <a href="https://github.com/rickhanlonii">@rickhanlonii</a>)<li>当内容重新出现时，使 Suspense 重新装载 layout effect。(<a href="https://github.com/facebook/react/pull/19322">#19322</a>，<a href="https://github.com/facebook/react/pull/19374">#19374</a>，<a href="https://github.com/facebook/react/pull/19523">#19523</a>，<a href="https://github.com/facebook/react/pull/20625">#20625</a>，<a href="https://github.com/facebook/react/pull/21079">#21079</a> <a href="https://github.com/acdlite">@acdlite</a>，<a href="https://github.com/bvaughn">@bvaughn</a>，and <a href="https://github.com/lunaruan">@lunaruan</a>)<li>使 <code>&#x3C;StrictMode></code> 重新运行 effect 以检查可恢复的状态。(<a href="https://github.com/facebook/react/pull/19523">#19523</a> ，<a href="https://github.com/facebook/react/pull/21418">#21418</a> <a href="https://github.com/bvaughn">@bvaughn</a> and <a href="https://github.com/lunaruan">@lunaruan</a>)<li>假设 <code>Symbols</code> 总是可用的。(<a href="https://github.com/facebook/react/pull/23348">#23348</a> <a href="https://github.com/sebmarkbage">@sebmarkbage</a>)<li>移除 <code>object-assign</code> polyfill。(<a href="https://github.com/facebook/react/pull/23351">#23351</a> <a href="https://github.com/sebmarkbage">@sebmarkbage</a>)<li>移除不支持的 <code>unstable_changedBits</code> API。(<a href="https://github.com/facebook/react/pull/20953">#20953</a> <a href="https://github.com/acdlite">@acdlite</a>)<li>允许组件渲染 undefined。(<a href="https://github.com/facebook/react/pull/21869">#21869</a> <a href="https://github.com/rickhanlonii">@rickhanlonii</a>)<li>从个别事件（如点击），同步送出 useEffect 结果。(<a href="https://github.com/facebook/react/pull/21150">#21150</a> <a href="https://github.com/acdlite">@acdlite</a>)<li>Suspense <code>fallback={undefined}</code> 现在与 <code>null</code> 的行为相同，不会被忽略。(<a href="https://github.com/facebook/react/pull/21854">#21854</a> <a href="https://github.com/rickhanlonii">@rickhanlonii</a>)<li>考虑所有 <code>lazy()</code> 解析为相同的等效组件。(<a href="https://github.com/facebook/react/pull/20357">#20357</a> <a href="https://github.com/sebmarkbage">@sebmarkbage</a>)<li>首次渲染时不要 patch 控制台。(<a href="https://github.com/facebook/react/pull/22308">#22308</a> <a href="https://github.com/lunaruan">@lunaruan</a>)<li>提高内存利用率。(<a href="https://github.com/facebook/react/pull/21039">#21039</a> <a href="https://github.com/bgirard">@bgirard</a>)<li>如果字符串强制抛出（Temporal.<em>，Symbol，等），改进提示信息。(<a href="https://github.com/facebook/react/pull/22064">#22064</a> <a href="https://github.com/justingrant">@justingrant</a>) </em>使用 setImmediate 当它在 MessageChannel 上可用时。(<a href="https://github.com/facebook/react/pull/20834">#20834</a> <a href="https://github.com/gaearon">@gaearon</a>)<li>修复上下文无法在挂起的树内传播。(<a href="https://github.com/facebook/react/pull/23095">#23095</a> <a href="https://github.com/gaearon">@gaearon</a>)<li>通过移除紧急处理机制，修复 <code>useReducer</code> 观察到不正确的参数。(<a href="https://github.com/facebook/react/pull/22445">#22445</a> <a href="https://github.com/josephsavona">@josephsavona</a>)<li>修复 Safari 在追加 iframe 时忽略 <code>setState</code> 的问题。(<a href="https://github.com/facebook/react/pull/23111">#23111</a> <a href="https://github.com/gaearon">@gaearon</a>)<li>修复在树中渲染 <code>ZonedDateTime</code> 时的崩溃。(<a href="https://github.com/facebook/react/pull/20617">#20617</a> <a href="https://github.com/dimaqq">@dimaqq</a>)<li>修复在测试中文档被设置为 <code>null</code> 时的崩溃问题。(<a href="https://github.com/facebook/react/pull/22695">#22695</a> <a href="https://github.com/SimenB">@SimenB</a>)<li>修复 onLoad 在开启并发特性时不触发的问题。(<a href="https://github.com/facebook/react/pull/23316">#23316</a> <a href="https://github.com/gnoff">@gnoff</a>)<li>修复选择器返回 <code>NaN</code> 时的警告。(<a href="https://github.com/facebook/react/pull/23333">#23333</a> <a href="https://github.com/hachibeeDI">@hachibeeDI</a>)<li>修复在测试中文档被设置为 <code>null</code> 时的崩溃问题。(<a href="https://github.com/facebook/react/pull/22695">#22695</a> <a href="https://github.com/SimenB">@SimenB</a>)<li>修复生成的 License 头。(<a href="https://github.com/facebook/react/pull/23004">#23004</a> <a href="https://github.com/vitaliemiron">@vitaliemiron</a>)<li>添加 <code>package.json</code> 作为入口点之一。 (<a href="https://github.com/facebook/react/pull/22954">#22954</a> <a href="https://github.com/Jack-Works">@Jack</a>)<li>允许在 Suspense 边界外挂起。(<a href="https://github.com/facebook/react/pull/23267">#23267</a> <a href="https://github.com/acdlite">@acdlite</a>)<li>每当 hydrate 失败时记录一个可恢复的错误。(<a href="https://github.com/facebook/react/pull/23319">#23319</a> <a href="https://github.com/acdlite">@acdlite</a>)</ul></section><section class="level3"aria-labelledby="react-dom-react-dom"><h3 id="react-dom-react-dom">React DOM {/<em>react-dom</em>/}</h3><ul><li>添加 <code>createRoot</code> 和 <code>hydrateRoot</code>。(<a href="https://github.com/facebook/react/pull/10239">#10239</a>，<a href="https://github.com/facebook/react/pull/11225">#11225</a>，<a href="https://github.com/facebook/react/pull/12117">#12117</a>，<a href="https://github.com/facebook/react/pull/13732">#13732</a>，<a href="https://github.com/facebook/react/pull/15502">#15502</a>，<a href="https://github.com/facebook/react/pull/15532">#15532</a>，<a href="https://github.com/facebook/react/pull/17035">#17035</a>，<a href="https://github.com/facebook/react/pull/17165">#17165</a>，<a href="https://github.com/facebook/react/pull/20669">#20669</a>，<a href="https://github.com/facebook/react/pull/20748">#20748</a>，<a href="https://github.com/facebook/react/pull/20888">#20888</a>，<a href="https://github.com/facebook/react/pull/21072">#21072</a>，<a href="https://github.com/facebook/react/pull/21417">#21417</a>，<a href="https://github.com/facebook/react/pull/21652">#21652</a>，<a href="https://github.com/facebook/react/pull/21687">#21687</a>，<a href="https://github.com/facebook/react/pull/23207">#23207</a>，<a href="https://github.com/facebook/react/pull/23385">#23385</a> <a href="https://github.com/acdlite">@acdlite</a>，<a href="https://github.com/bvaughn">@bvaughn</a>，<a href="https://github.com/gaearon">@gaearon</a>，<a href="https://github.com/lunaruan">@lunaruan</a>，<a href="https://github.com/rickhanlonii">@rickhanlonii</a>，<a href="https://github.com/trueadm">@trueadm</a>，and <a href="https://github.com/sebmarkbage">@sebmarkbage</a>)<li>添加选择性 hydrate。(<a href="https://github.com/facebook/react/pull/14717">#14717</a>，<a href="https://github.com/facebook/react/pull/14884">#14884</a>，<a href="https://github.com/facebook/react/pull/16725">#16725</a>，<a href="https://github.com/facebook/react/pull/16880">#16880</a>，<a href="https://github.com/facebook/react/pull/17004">#17004</a>，<a href="https://github.com/facebook/react/pull/22416">#22416</a>，<a href="https://github.com/facebook/react/pull/22629">#22629</a>，<a href="https://github.com/facebook/react/pull/22448">#22448</a>，<a href="https://github.com/facebook/react/pull/22856">#22856</a>，<a href="https://github.com/facebook/react/pull/23176">#23176</a> <a href="https://github.com/acdlite">@acdlite</a>，<a href="https://github.com/gaearon">@gaearon</a>，<a href="https://github.com/salazarm">@salazarm</a>，and <a href="https://github.com/sebmarkbage">@sebmarkbage</a>)<li>在已知的 ARIA 属性列表中增加 <code>aria-description</code>。(<a href="https://github.com/facebook/react/pull/22142">#22142</a> <a href="https://github.com/mahyareb">@mahyareb</a>)<li>为 video 元素添加 <code>onResize</code> 事件。(<a href="https://github.com/facebook/react/pull/21973">#21973</a> <a href="https://github.com/rileyjshaw">@rileyjshaw</a>)<li>将 <code>imageSizes</code> 和 <code>imageSrcSet</code> 添加到已知属性中。(<a href="https://github.com/facebook/react/pull/22550">#22550</a> <a href="https://github.com/eps1lon">@eps1lon</a>)<li>若提供了 <code>value</code>，允许非字符串 <code>&#x3C;option></code> 子元素。 (<a href="https://github.com/facebook/react/pull/21431">#21431</a> <a href="https://github.com/sebmarkbage">@sebmarkbage</a>)<li>修复 <code>aspectRatio</code> 样式未被应用的问题。 (<a href="https://github.com/facebook/react/pull/21100">#21100</a> <a href="https://github.com/gaearon">@gaearon</a>)<li>若 <code>renderSubtreeIntoContainer</code> 被调用，发出警告。 (<a href="https://github.com/facebook/react/pull/23355">#23355</a> <a href="https://github.com/acdlite">@acdlite</a>)</ul></section><section class="level3"aria-labelledby="react-dom-server-react-dom-server-1"><h3 id="react-dom-server-react-dom-server-1">React DOM Server {/<em>react-dom-server-1</em>/}</h3><ul><li>添加新的流式渲染器。(<a href="https://github.com/facebook/react/pull/14144">#14144</a>，<a href="https://github.com/facebook/react/pull/20970">#20970</a>，<a href="https://github.com/facebook/react/pull/21056">#21056</a>，<a href="https://github.com/facebook/react/pull/21255">#21255</a>，<a href="https://github.com/facebook/react/pull/21200">#21200</a>，<a href="https://github.com/facebook/react/pull/21257">#21257</a>，<a href="https://github.com/facebook/react/pull/21276">#21276</a>，<a href="https://github.com/facebook/react/pull/22443">#22443</a>，<a href="https://github.com/facebook/react/pull/22450">#22450</a>，<a href="https://github.com/facebook/react/pull/23247">#23247</a>，<a href="https://github.com/facebook/react/pull/24025">#24025</a>，<a href="https://github.com/facebook/react/pull/24030">#24030</a> <a href="https://github.com/sebmarkbage">@sebmarkbage</a>)<li>修复 SSR 中的上下文提供者在处理多个请求时的问题。(<a href="https://github.com/facebook/react/pull/23171">#23171</a> <a href="https://github.com/frandiox">@frandiox</a>)<li>文本不匹配时恢复到客户端渲染。(<a href="https://github.com/facebook/react/pull/23354">#23354</a> <a href="https://github.com/acdlite">@acdlite</a>)<li>弃用 <code>renderToNodeStream</code>。(<a href="https://github.com/facebook/react/pull/23359">#23359</a> <a href="https://github.com/sebmarkbage">@sebmarkbage</a>)<li>修复新服务端渲染器中一个有误的错误日志。(<a href="https://github.com/facebook/react/pull/24043">#24043</a> <a href="https://github.com/eps1lon">@eps1lon</a>)<li>修复新服务端渲染器中的一个错误。(<a href="https://github.com/facebook/react/pull/22617">#22617</a> <a href="https://github.com/shuding">@shuding</a>)<li>忽略服务端自定义元素内的函数和符号值。(<a href="https://github.com/facebook/react/pull/21157">#21157</a> <a href="https://github.com/sebmarkbage">@sebmarkbage</a>)</ul></section><section class="level3"aria-labelledby="react-dom-test-utils-react-dom-test-utils"><h3 id="react-dom-test-utils-react-dom-test-utils">React DOM Test Utils {/<em>react-dom-test-utils</em>/}</h3><ul><li>在生产环境使用 <code>act</code> 时抛出错误。 (<a href="https://github.com/facebook/react/pull/21686">#21686</a> <a href="https://github.com/acdlite">@acdlite</a>)<li>支持使用 <code>global.IS_REACT_ACT_ENVIRONMENT</code> 禁用 act 警告。 (<a href="https://github.com/facebook/react/pull/22561">#22561</a> <a href="https://github.com/acdlite">@acdlite</a>)<li>扩大 act 警告，以覆盖所有可能预计 React 工作的 API。(<a href="https://github.com/facebook/react/pull/22607">#22607</a> <a href="https://github.com/acdlite">@acdlite</a>)<li>使 act 批量更新。(<a href="https://github.com/facebook/react/pull/21797">#21797</a> <a href="https://github.com/acdlite">@acdlite</a>)<li>移除对被挂起的 effect 的警告。(<a href="https://github.com/facebook/react/pull/22609">#22609</a> <a href="https://github.com/acdlite">@acdlite</a>)</ul></section><section class="level3"aria-labelledby="react-refresh-react-refresh"><h3 id="react-refresh-react-refresh">React Refresh {/<em>react-refresh</em>/}</h3><ul><li>在快速刷新中跟踪后期装载的 root。(<a href="https://github.com/facebook/react/pull/22740">#22740</a> <a href="https://github.com/anc95">@anc95</a>)<li>在 <code>package.json</code> 中添加 <code>exports</code> 字段。(<a href="https://github.com/facebook/react/pull/23087">#23087</a> <a href="https://github.com/otakustay">@otakustay</a>)</ul></section><section class="level3"aria-labelledby="实验性的服务端组件-server-components-experimental"><h3 id="实验性的服务端组件-server-components-experimental">实验性的服务端组件 {/<em>server-components-experimental</em>/}</h3><ul><li>增加服务端上下文支持。(<a href="https://github.com/facebook/react/pull/23244">#23244</a> <a href="https://github.com/salazarm">@salazarm</a>)<li>增加对 <code>lazy</code> 的支持。 (<a href="https://github.com/facebook/react/pull/24068">#24068</a> <a href="https://github.com/gnoff">@gnoff</a>)<li>更新 webpack 插件以支持 webpack 5。(<a href="https://github.com/facebook/react/pull/22739">#22739</a> <a href="https://github.com/michenly">@michenly</a>)<li>修正 Noder loader 中的一个错误。(<a href="https://github.com/facebook/react/pull/22537">#22537</a> <a href="https://github.com/btea">@btea</a>)<li>在边缘环境中使用 <code>globalThis</code> 而不是 <code>window</code>。(<a href="https://github.com/facebook/react/pull/22777">#22777</a> <a href="https://github.com/huozhi">@huozhi</a>) <span style="float:footnote"><a href="../../../../index.html#toc">Go to TOC</a></span></ul></section></section></section>