<!doctype html><html lang="zh-hans"><meta charset="utf-8"><title>"React 19 RC"</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"type="text/css"href="../../../../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="react-19-rc"><h1 id="react-19-rc">"React 19 RC"</h1><p>author: The React Team date: 2024/04/25 description: React 19 RC 版现在可以在 npm 上使用了! 在这篇文章中，我们将概述 React 19 的新特性，以及如何使用它们。<p>2024 年 4 月 25 日 <a href="/community/team">The React Team</a></p><intro><p>React 19 RC 版本现在可以在 npm 上使用了!</p></intro><p>在我们的 <a href="/blog/2024/04/25/react-19-upgrade-guide">React 19 RC 升级指南</a> 中, 我们分享了将应用程序升级到 React 19 的分步说明。在这篇文章中，我们将概述 React 19 的新特性，以及如何使用它们。<ul><li><a href="#whats-new-in-react-19">React 19 中的新功能</a><li><a href="#improvements-in-react-19">React 19 中的改进</a><li><a href="#how-to-upgrade">如何升级</a></ul><p>有关破坏性更改的列表，请参阅 <a href="/blog/2024/04/25/react-19-upgrade-guide">升级指南</a>。<section class="level2"aria-labelledby="react-19-中的新功能-whats-new-in-react-19"><h2 id="react-19-中的新功能-whats-new-in-react-19">React 19 中的新功能 {/<em>whats-new-in-react-19</em>/}</h2><section class="level3"aria-labelledby="actions-actions"><h3 id="actions-actions">Actions {/<em>actions</em>/}</h3><p>在 React 应用中，一个常见的用例是执行数据变更，然后响应更新状态。例如，当用户提交一个表单来更改他们的名字，你会发起一个 API 请求，然后处理响应。在过去，你需要手动处理待定状态、错误、乐观更新和顺序请求。<p>例如，你可以在 <code>useState</code> 中处理待定和错误状态：<pre class="language-js"><code class="language-js"><span class="token comment">// 没有 Actions 之前</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">UpdateName</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>error<span class="token punctuation">,</span> setError<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isPending<span class="token punctuation">,</span> setIsPending<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">handleSubmit</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">setIsPending</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> error <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">updateName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setIsPending</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token function">redirect</span><span class="token punctuation">(</span><span class="token string">"/path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>input value<span class="token operator">=</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span> onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setName</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleSubmit<span class="token punctuation">}</span> disabled<span class="token operator">=</span><span class="token punctuation">{</span>isPending<span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Update</span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token punctuation">{</span>error <span class="token operator">&#x26;&#x26;</span> <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token punctuation">{</span>error<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">}</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>在 React 19 中，我们正在添加在过渡中使用异步函数的支持，以自动处理待定状态、错误、表单和乐观更新。<p>例如，你可以使用 <code>useTransition</code> 来为你处理待定状态：<pre class="language-js"><code class="language-js"><span class="token comment">// 使用 Actions 中的待定状态</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">UpdateName</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>error<span class="token punctuation">,</span> setError<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isPending<span class="token punctuation">,</span> startTransition<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">handleSubmit</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> error <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">updateName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> 
      <span class="token function">redirect</span><span class="token punctuation">(</span><span class="token string">"/path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>input value<span class="token operator">=</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span> onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setName</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleSubmit<span class="token punctuation">}</span> disabled<span class="token operator">=</span><span class="token punctuation">{</span>isPending<span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Update</span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token punctuation">{</span>error <span class="token operator">&#x26;&#x26;</span> <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token punctuation">{</span>error<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">}</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>异步过渡会立即将 <code>isPending</code> 状态设置为 true，发出异步请求，然后在任何过渡后将 <code>isPending</code> 切换为 <code>false</code>。这使你能够在数据变化时保持当前 UI 的响应性和交互性。</p><note><section class="level4"aria-labelledby="按照惯例使用异步过渡的函数被称为-actions-by-convention-functions-that-use-async-transitions-are-called-actions"><h4 id="按照惯例使用异步过渡的函数被称为-actions-by-convention-functions-that-use-async-transitions-are-called-actions">按照惯例，使用异步过渡的函数被称为 "Actions"。 {/<em>by-convention-functions-that-use-async-transitions-are-called-actions</em>/}</h4><p>Actions 自动为你管理数据提交：<ul><li><strong>待定状态</strong>: Actions 提供一个待定状态，该状态在请求开始时启动，并在最终状态更新提交时自动重置。<li><strong>乐观更新</strong>: Actions 支持新的 <a href="#new-hook-optimistic-updates"><code>useOptimistic</code></a> Hook，因此你可以在请求提交时向用户显示即时反馈。<li><strong>错误处理</strong>: Actions 提供错误处理，因此当请求失败时，你可以显示错误边界，并自动将乐观更新恢复到其原始值。<li><strong>表单</strong>: <code>&#x3C;form></code> 元素现在支持将函数传递给 <code>action</code> 和 <code>formAction</code> 属性。将函数传递给 <code>action</code> 属性默认使用 Actions，并在提交后自动重置表单。</ul></section></note><p>在 Actions 的基础上，React 19 引入了 <a href="#new-hook-optimistic-updates"><code>useOptimistic</code></a> 来管理乐观更新，以及一个新的 Hook <a href="#new-hook-useactionstate"><code>React.useActionState</code></a> 来处理 Actions 的常见情况。在 <code>react-dom</code> 中我们添加了 <a href="#form-actions"><code>&#x3C;form></code> Actions</a> 来自动管理表单和 <code>useFormStatus</code> 来支持表单中 Actions 的常见情况。<p>在 React 19 中，上述示例可以简化为：<pre class="language-js"><code class="language-js"><span class="token comment">// 使用表单的 Actions 和 useActionState</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ChangeName</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> name<span class="token punctuation">,</span> setName <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>error<span class="token punctuation">,</span> submitAction<span class="token punctuation">,</span> isPending<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useActionState</span><span class="token punctuation">(</span>
    <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">previousState<span class="token punctuation">,</span> formData</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> error <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">updateName</span><span class="token punctuation">(</span>formData<span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword control-flow">return</span> error<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token function">redirect</span><span class="token punctuation">(</span><span class="token string">"/path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">return</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword null nil">null</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>form action<span class="token operator">=</span><span class="token punctuation">{</span>submitAction<span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> name<span class="token operator">=</span><span class="token string">"name"</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button type<span class="token operator">=</span><span class="token string">"submit"</span> disabled<span class="token operator">=</span><span class="token punctuation">{</span>isPending<span class="token punctuation">}</span><span class="token operator">></span><span class="token maybe-class-name">Update</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token punctuation">{</span>error <span class="token operator">&#x26;&#x26;</span> <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token punctuation">{</span>error<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">}</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>form<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>在下一节中，我们将详细介绍 React 19 中的每一个新的 Action 功能。</section><section class="level3"aria-labelledby="新的-hook-useactionstate-new-hook-useactionstate"><h3 id="新的-hook-useactionstate-new-hook-useactionstate">新的 Hook: <code>useActionState</code> {/<em>new-hook-useactionstate</em>/}</h3><p>为了使 Actions 的常见情况更加简单，我们添加了一个名为 <code>useActionState</code> 的新 Hook：<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>error<span class="token punctuation">,</span> submitAction<span class="token punctuation">,</span> isPending<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useActionState</span><span class="token punctuation">(</span>
  <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">previousState<span class="token punctuation">,</span> newName</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> error <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">updateName</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 您可以返回操作的任何结果。</span>
      <span class="token comment">// 这里，我们只返回错误。</span>
      <span class="token keyword control-flow">return</span> error<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 处理成功的情况。</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword null nil">null</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>useActionState</code> 接受一个函数（"Action"），并返回一个被包装的用于调用的 Action。这是因为 Actions 是可以组合的。当调用被包装的 Action 时，<code>useActionState</code> 将返回 Action 的最后结果作为 <code>data</code>，以及 Action 的待定状态作为 <code>pending</code>。</p><note><p><code>React.useActionState</code> 在 Canary 版本中曾被称为 <code>ReactDOM.useFormState</code>，但我们已经将其重命名并弃用了 <code>useFormState</code>。<p>有关更多信息，请参见 <a href="https://github.com/facebook/react/pull/28491">#28491</a>。</p></note><p>相关的更多信息，请参阅文档 <a href="/reference/react/useActionState"><code>useActionState</code></a>。</section><section class="level3"aria-labelledby="react-dom--actions-form-actions"><h3 id="react-dom--actions-form-actions">React DOM: <code>&#x3C;form></code> Actions {/<em>form-actions</em>/}</h3><p>Actions 也与 React 19 的新 <code>&#x3C;form></code> 功能集成在 <code>react-dom</code> 中。我们已经添加了对将函数作为 <code>&#x3C;form></code>、<code>&#x3C;input></code> 和 <code>&#x3C;button></code> 元素的 <code>action</code> 和 <code>formAction</code> 属性的支持，以便使用 Actions 自动提交表单：<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span>form action<span class="token operator">=</span><span class="token punctuation">{</span>actionFunction<span class="token punctuation">}</span><span class="token operator">></span></code></pre><p>当 <code>&#x3C;form></code> Action 成功时，React 将自动为非受控组件重置表单。如果你需要手动重置 <code>&#x3C;form></code>，你可以调用新的 <code>requestFormReset</code> React DOM API。<p>有关更多信息，请参阅 <code>react-dom</code> 文档中的 <a href="/reference/react-dom/components/form"><code>&#x3C;form></code></a>、<a href="/reference/react-dom/components/input"><code>&#x3C;input></code></a> 和 <code>&#x3C;button></code>。</section><section class="level3"aria-labelledby="react-dom-新-hook-useformstatus-new-hook-useformstatus"><h3 id="react-dom-新-hook-useformstatus-new-hook-useformstatus">React DOM: 新 Hook: <code>useFormStatus</code> {/<em>new-hook-useformstatus</em>/}</h3><p>在设计系统中，常常需要编写设计一类能够访问其所在的 <code>&#x3C;form></code> 的信息而无需将属性传递到组件内的组件。这可以通过 Context 来实现，但为了使这类常见情况更简单，我们添加了一个新的 Hook <code>useFormStatus</code>：<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>useFormStatus<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">DesignButton</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span>pending<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useFormStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>button type<span class="token operator">=</span><span class="token string">"submit"</span> disabled<span class="token operator">=</span><span class="token punctuation">{</span>pending<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token punctuation">}</span></code></pre><p><code>useFormStatus</code> 读取父 <code>&#x3C;form></code> 的状态，就像表单是一个 Context 提供者一样。<p>有关更多信息，请参阅 <code>react-dom</code> 文档中的 <a href="/reference/react-dom/hooks/useFormStatus"><code>useFormStatus</code></a>。</section><section class="level3"aria-labelledby="新-hook-useoptimistic-new-hook-optimistic-updates"><h3 id="新-hook-useoptimistic-new-hook-optimistic-updates">新 Hook: <code>useOptimistic</code> {/<em>new-hook-optimistic-updates</em>/}</h3><p>执行数据变更时的另一个常见 UI 模式是在异步请求进行时乐观地显示最终状态。在 React 19 中，我们添加了一个名为 <code>useOptimistic</code> 的新 Hook，以便更容易实现这一点：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ChangeName</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>currentName<span class="token punctuation">,</span> onUpdateName<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>optimisticName<span class="token punctuation">,</span> setOptimisticName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useOptimistic</span><span class="token punctuation">(</span>currentName<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">submitAction</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token parameter">formData</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> newName <span class="token operator">=</span> formData<span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setOptimisticName</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> updatedName <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">updateName</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">onUpdateName</span><span class="token punctuation">(</span>updatedName<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>form action<span class="token operator">=</span><span class="token punctuation">{</span>submitAction<span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token maybe-class-name">Your</span> name is<span class="token operator">:</span> <span class="token punctuation">{</span>optimisticName<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span>
        <span class="token operator">&#x3C;</span>label<span class="token operator">></span><span class="token maybe-class-name">Change</span> <span class="token maybe-class-name">Name</span><span class="token operator">:</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>label<span class="token operator">></span>
        <span class="token operator">&#x3C;</span>input
          type<span class="token operator">=</span><span class="token string">"text"</span>
          name<span class="token operator">=</span><span class="token string">"name"</span>
          disabled<span class="token operator">=</span><span class="token punctuation">{</span>currentName <span class="token operator">!==</span> optimisticName<span class="token punctuation">}</span>
        <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>form<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><code>useOptimistic</code> Hook 会在 <code>updateName</code> 请求进行时立即渲染 <code>optimisticName</code>。当更新完成或出错时，React 将自动切换回 <code>currentName</code> 值。<p>有关更多信息，请参阅 <a href="/reference/react/useOptimistic"><code>useOptimistic</code></a> 文档。</section><section class="level3"aria-labelledby="新的-api-use-new-feature-use"><h3 id="新的-api-use-new-feature-use">新的 API: <code>use</code> {/<em>new-feature-use</em>/}</h3><p>在 React 19 中，我们引入了一个新的 API 来在渲染中读取资源：<code>use</code>。<p>例如，你可以使用 <code>use</code> 读取一个 promise，React 将挂起，直到 promise 解析完成：<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>use<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Comments</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>commentsPromise<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// `use` 将被暂停直到 promise 被解决.</span>
  <span class="token keyword">const</span> comments <span class="token operator">=</span> <span class="token function">use</span><span class="token punctuation">(</span>commentsPromise<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> comments<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token parameter">comment</span> <span class="token arrow operator">=></span> <span class="token operator">&#x3C;</span>p key<span class="token operator">=</span><span class="token punctuation">{</span>comment<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>comment<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Page</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>commentsPromise<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当“use”在注释中暂停时,</span>
  <span class="token comment">// 将显示此悬念边界。</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Suspense</span> fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&#x3C;</span>div<span class="token operator">></span><span class="token maybe-class-name">Loading</span><span class="token spread operator">...</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Comments</span> commentsPromise<span class="token operator">=</span><span class="token punctuation">{</span>commentsPromise<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Suspense</span><span class="token operator">></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><note><section class="level4"aria-labelledby="use-不支持在渲染中创建的-promises-use-does-not-support-promises-created-in-render"><h4 id="use-不支持在渲染中创建的-promises-use-does-not-support-promises-created-in-render"><code>use</code> 不支持在渲染中创建的 promises。 {/<em>use-does-not-support-promises-created-in-render</em>/}</h4><p>如果你尝试将在渲染中创建的 promise 传递给 <code>use</code>，React 将发出警告：</p><consoleblockmulti><consolelogline level="error"><p>A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.</p></consolelogline></consoleblockmulti><p>为了解决这个问题，你需要从支持 promise 缓存的 Suspense 强化库或框架中传递一个 promise。在未来，我们计划推出功能，使在渲染中缓存 promise 更加容易。</section></note><p>你也可以使用 <code>use</code> 读取 context，这使你能够在如提前返回之后的情况下有条件地读取 Context：<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>use<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">ThemeContext</span></span> <span class="token keyword module">from</span> <span class="token string">'./ThemeContext'</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Heading</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>children<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>children <span class="token operator">==</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 因为过早的返回</span>
  <span class="token comment">// 这里 useContext 无法正常工作。</span>
  <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token maybe-class-name">ThemeContext</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>h1 style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token literal-property property">color</span><span class="token operator">:</span> theme<span class="token punctuation">.</span><span class="token property-access">color</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token punctuation">{</span>children<span class="token punctuation">}</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><code>use</code> API 只能在渲染中被调用，类似于 hooks。与 hooks 不同，<code>use</code> 可以被有条件地调用。在未来，我们计划支持在渲染中使用 <code>use</code> 消费更多资源的方式。<p>有关更多信息，请参阅 <a href="/reference/react/use"><code>use</code></a> 文档。</section></section><section class="level2"aria-labelledby="react-服务器组件-react-server-components"><h2 id="react-服务器组件-react-server-components">React 服务器组件 {/<em>react-server-components</em>/}</h2><section class="level3"aria-labelledby="服务器组件-server-components"><h3 id="服务器组件-server-components">服务器组件 {/<em>server-components</em>/}</h3><p>服务器组件是一种新的选项，允许在打包前提前渲染组件，在与你的客户端应用程序或 SSR 服务器不同的环境中。这个独立的环境就是 React 服务器组件中的 "服务器"。服务器组件可以在你的 CI 服务器上在构建时运行一次，或者可以在每次请求时使用 web 服务器运行。<p>React 19 包含了所有从 Canary 频道引入的 React 服务器组件功能。这意味着，现在可以将 React 19 作为 peer 依赖项来发布带有服务器组件的库，使用 <code>react-server</code> <a href="https://github.com/reactjs/rfcs/blob/main/text/0227-server-module-conventions.md#react-server-conditional-exports">导出条件</a> 用于支持 <a href="/learn/start-a-new-react-project#which-features-make-up-the-react-teams-full-stack-architecture-vision">全栈 React 架构</a> 的框架。</p><note><section class="level4"aria-labelledby="如何构建对服务器组件的支持-how-do-i-build-support-for-server-components"><h4 id="如何构建对服务器组件的支持-how-do-i-build-support-for-server-components">如何构建对服务器组件的支持? {/<em>how-do-i-build-support-for-server-components</em>/}</h4><p>虽然 React 19 中的 React 服务器组件是稳定的，并且在主版本之间不会发生破坏，但用于实现 React 服务器组件打包器或框架的底层 API 不遵循 semver，并可能在 React 19.x 的小版本之间发生破坏。<p>为了支持 React 服务器组件作为打包器或框架，我们建议固定到特定的 React 版本，或者使用 Canary 发行版。我们将继续与打包器和框架合作，以稳定用于实现 React 服务器组件的 API。</section></note><p>有关更多信息，请参阅文档 <a href="/reference/rsc/server-components">React Server Components</a>.</section><section class="level3"aria-labelledby="服务器操作-server-actions"><h3 id="服务器操作-server-actions">服务器操作 {/<em>server-actions</em>/}</h3><p>服务器 Actions 允许客户端组件调用在服务器上执行的异步函数。<p>当使用 <code>"use server"</code> 指令定义服务器 Action 时，你的框架将自动创建一个指向服务器函数的引用，并将该引用传递给客户端组件。当在客户端调用该函数时，React 将向服务器发送一个请求来执行该函数，并返回结果。</p><note><section class="level4"aria-labelledby="服务器组件没有指令-there-is-no-directive-for-server-components"><h4 id="服务器组件没有指令-there-is-no-directive-for-server-components">服务器组件没有指令 {/<em>there-is-no-directive-for-server-components</em>/}</h4><p>一个常见的误解是服务器组件由 <code>"use server"</code> 指示，但服务器组件没有指令。<code>"use server"</code> 指令用于服务器 Actions。<p>有关更多信息，请参阅 <a href="/reference/rsc/directives">指令</a> 文档。</section></note><p>服务器 Actions 可以在服务器组件中创建并作为 props 传递给客户端组件，或者可以在客户端组件中导入和使用。<p>有关更多信息，请参阅 <a href="/reference/rsc/server-actions">React 服务器 Actions</a> 文档。</section></section><section class="level2"aria-labelledby="react-19-中的改进-improvements-in-react-19"><h2 id="react-19-中的改进-improvements-in-react-19">React 19 中的改进 {/<em>improvements-in-react-19</em>/}</h2><section class="level3"aria-labelledby="ref-作为一个属性-ref-as-a-prop"><h3 id="ref-作为一个属性-ref-as-a-prop"><code>ref</code> 作为一个属性 {/<em>ref-as-a-prop</em>/}</h3><p>从 React 19 开始，你现在可以在函数组件中将 <code>ref</code> 作为 prop 进行访问：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyInput</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>placeholder<span class="token punctuation">,</span> ref<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>input placeholder<span class="token operator">=</span><span class="token punctuation">{</span>placeholder<span class="token punctuation">}</span> ref<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token punctuation">}</span>

<span class="token comment">//...</span>
<span class="token operator">&#x3C;</span><span class="token maybe-class-name">MyInput</span> ref<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span></code></pre><p>新的函数组件将不再需要 <code>forwardRef</code>，我们将发布一个 codemod 来自动更新你的组件以使用新的 <code>ref</code> prop。在未来的版本中，我们将弃用并移除 <code>forwardRef</code>。</p><note><p>在类组件中，<code>ref</code> 不作为 props 传递，因为它们引用的是组件实例。这意味着，如果你在类组件中需要访问 <code>ref</code>，你需要使用 <code>React.forwardRef</code> 或者 <code>React.createRef</code>。</p></note></section><section class="level3"aria-labelledby="激活错误的差异-diffs-for-hydration-errors"><h3 id="激活错误的差异-diffs-for-hydration-errors">激活错误的差异 {/<em>diffs-for-hydration-errors</em>/}</h3><p>在 <code>react-dom</code> 中，我们也改进了水合错误的错误报告。例如，现在不再在 DEV 中记录多个没有任何不匹配信息的错误：</p><consoleblockmulti><consolelogline level="error"><p>Warning: Text content did not match. Server: "Server" Client: "Client" {' '}at span {' '}at App</p></consolelogline><consolelogline level="error"><p>Warning: An error occurred during hydration. The server HTML was replaced with client content in &#x3C;div>.</p></consolelogline><consolelogline level="error"><p>Warning: Text content did not match. Server: "Server" Client: "Client" {' '}at span {' '}at App</p></consolelogline><consolelogline level="error"><p>Warning: An error occurred during hydration. The server HTML was replaced with client content in &#x3C;div>.</p></consolelogline><consolelogline level="error"><p>Uncaught Error: Text content does not match server-rendered HTML. {' '}at checkForUnmatchedText {' '}...</p></consolelogline></consoleblockmulti><p>现在我们会记录一条带有不匹配差异的单一消息：</p><consoleblockmulti><consolelogline level="error"><p>Uncaught Error: Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if an SSR-ed Client Component used:{'\n'} - A server/client branch <code>if (typeof window !== 'undefined')</code>. - Variable input such as <code>Date.now()</code> or <code>Math.random()</code> which changes each time it's called. - Date formatting in a user's locale which doesn't match the server. - External changing data without sending a snapshot of it along with the HTML. - Invalid HTML tag nesting.{'\n'} It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.{'\n'} <a href="https://react.dev/link/hydration-mismatch">https://react.dev/link/hydration-mismatch</a> {'\n'} {' '}&#x3C;App> {' '}&#x3C;span> {'+ '}Client {'- '}Server{'\n'} {' '}at throwOnHydrationMismatch {' '}...</p></consolelogline></consoleblockmulti></section><section class="level3"aria-labelledby="-作为提供者-context-as-a-provider"><h3 id="-作为提供者-context-as-a-provider"><code>&#x3C;Context></code> 作为提供者 {/<em>context-as-a-provider</em>/}</h3><p>在 React 19 中，你可以将 <code>&#x3C;Context></code> 渲染为提供者，就无需再使用 <code>&#x3C;Context.Provider></code> 了：<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">ThemeContext</span> <span class="token operator">=</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">App</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>children<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">ThemeContext</span> value<span class="token operator">=</span><span class="token string">"dark"</span><span class="token operator">></span>
      <span class="token punctuation">{</span>children<span class="token punctuation">}</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">ThemeContext</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span></code></pre><p>新的 Context 提供者可以使用 <code>&#x3C;Context></code>，我们将发布一个 codemod 来转换现有的提供者。在未来的版本中，我们将弃用 <code>&#x3C;Context.Provider></code>。</section><section class="level3"aria-labelledby="refs-支持清理函数-cleanup-functions-for-refs"><h3 id="refs-支持清理函数-cleanup-functions-for-refs">refs 支持清理函数 {/<em>cleanup-functions-for-refs</em>/}</h3><p>这将使得在 <code>ref</code> 改变时执行清理操作变得更加容易。例如，你可以在 <code>ref</code> 改变时取消订阅事件：<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span>input
  ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">ref</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// ref 创建</span>

    <span class="token comment">// 新特性: 当元素从 DOM 中被移除时</span>
    <span class="token comment">// 返回一个清理函数来重置 ref</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token comment">// ref cleanup</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token operator">/</span><span class="token operator">></span></code></pre><p>当组件卸载时，React 将调用从 <code>ref</code> 回调返回的清理函数。这适用于 DOM refs，类组件的 refs，以及 <code>useImperativeHandle</code>。</p><note><p>以前，当卸载组件时，React 会用 <code>null</code> 调用 <code>ref</code> 函数。如果你的 <code>ref</code> 返回一个清理函数，React 现在将跳过这一步。<p>在未来的版本中，我们将弃用在卸载组件时用 <code>null</code> 调用 refs。</p></note><p>由于引入了 <code>ref</code> 清理函数，现在 TypeScript 将拒绝从 <code>ref</code> 回调中返回任何其他内容。通常的解决方法是停止使用隐式返回，例如：<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> &#x3C;div ref={current => (instance = current)} />
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> &#x3C;div ref={current => {instance = current}} /></span></span></code></pre><p>原始代码返回了 <code>HTMLDivElement</code> 的实例，TypeScript 不知道这是否应该是一个清理函数，或者你是否不想返回一个清理函数。<p>你可以使用 <a href="https://github.com/eps1lon/types-react-codemod/#no-implicit-ref-callback-return"><code>no-implicit-ref-callback-return</code></a> 这个 codemod 来转换这种模式。</section><section class="level3"aria-labelledby="usedeferredvalue-初始化-value-use-deferred-value-initial-value"><h3 id="usedeferredvalue-初始化-value-use-deferred-value-initial-value"><code>useDeferredValue</code> 初始化 value {/<em>use-deferred-value-initial-value</em>/}</h3><p>我们为 <code>useDeferredValue</code> 添加了一个 <code>initialValue</code> 选项：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Search</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>deferredValue<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// On initial render the value is ''.</span>
  <span class="token comment">// Then a re-render is scheduled with the deferredValue.</span>
  <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">useDeferredValue</span><span class="token punctuation">(</span>deferredValue<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Results</span> query<span class="token operator">=</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>当提供了<codestep step="{2}">initialValue</codestep>, <code>useDeferredValue</code> 将在组件的初始渲染中返回它作为 <code>value</code> , 并在后台安排一个使用返回的<codestep step="{1}">deferredValue</codestep>重新渲染。<p>有关更多信息，请参阅 <a href="/reference/react/useDeferredValue"><code>useDeferredValue</code></a>。</section><section class="level3"aria-labelledby="支持文档元数据-support-for-metadata-tags"><h3 id="支持文档元数据-support-for-metadata-tags">支持文档元数据 {/<em>support-for-metadata-tags</em>/}</h3><p>在 HTML 中，像 <code>&#x3C;title></code>、<code>&#x3C;link></code> 和 <code>&#x3C;meta></code> 这样的文档元数据标签被保留在文档的 <code>&#x3C;head></code> 部分。在 React 中，决定应用程序适合的元数据的组件可能与你渲染 <code>&#x3C;head></code> 的地方相距甚远，或者 React 根本不渲染 <code>&#x3C;head></code>。在过去，这些元素需要在效果中手动插入，或者通过像 <a href="https://github.com/nfl/react-helmet"><code>react-helmet</code></a> 这样的库，并在服务器渲染 React 应用程序时需要小心处理。<p>在 React 19 中，我们将原生支持在组件中渲染文档元数据标签：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">BlogPost</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>post<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>article<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token punctuation">{</span>post<span class="token punctuation">.</span><span class="token property-access">title</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>title<span class="token operator">></span><span class="token punctuation">{</span>post<span class="token punctuation">.</span><span class="token property-access">title</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>title<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>meta name<span class="token operator">=</span><span class="token string">"author"</span> content<span class="token operator">=</span><span class="token string">"Josh"</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>link rel<span class="token operator">=</span><span class="token string">"author"</span> href<span class="token operator">=</span><span class="token string">"https://twitter.com/joshcstory/"</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>meta name<span class="token operator">=</span><span class="token string">"keywords"</span> content<span class="token operator">=</span><span class="token punctuation">{</span>post<span class="token punctuation">.</span><span class="token property-access">keywords</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span>
        <span class="token maybe-class-name">Eee</span> equals em<span class="token operator">-</span>see<span class="token operator">-</span>squared<span class="token spread operator">...</span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>article<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>当 React 渲染这个组件时，它会看到 <code>&#x3C;title></code>、<code>&#x3C;link></code> 和 <code>&#x3C;meta></code> 标签，并自动将它们提升到文档的 <code>&#x3C;head></code> 部分。通过原生支持这些元数据标签，我们能够确保它们与仅客户端应用、流式 SSR 和服务器组件一起工作。</p><note><section class="level4"aria-labelledby="你可能仍然需要一个元数据库-you-may-still-want-a-metadata-library"><h4 id="你可能仍然需要一个元数据库-you-may-still-want-a-metadata-library">你可能仍然需要一个元数据库 {/<em>you-may-still-want-a-metadata-library</em>/}</h4><p>对于简单的用例，渲染文档元数据为标签可能是合适的，但库可以提供更强大的功能，如基于当前路由用特定的元数据覆盖通用元数据。这些功能使得像 <a href="https://github.com/nfl/react-helmet"><code>react-helmet</code></a> 这样的框架和库更容易支持元数据标签，而不是替换它们。</section></note><p>有关更多信息，请参阅文档 <a href="/reference/react-dom/components/title"><code>&#x3C;title></code></a>, <a href="/reference/react-dom/components/link"><code>&#x3C;link></code></a>, and <a href="/reference/react-dom/components/meta"><code>&#x3C;meta></code></a>.</section><section class="level3"aria-labelledby="支持样式表-support-for-stylesheets"><h3 id="支持样式表-support-for-stylesheets">支持样式表 {/<em>support-for-stylesheets</em>/}</h3><p>样式表，无论是外部链接的 (<code>&#x3C;link rel="stylesheet" href="..."></code>) 还是内联的 (<code>&#x3C;style>...&#x3C;/style></code>)，都需要在 DOM 中进行精确的定位，因为样式优先级规则。构建一个允许在组件内部进行组合的样式表功能是困难的，所以用户通常要么将所有的样式远离可能依赖它们的组件加载，要么使用一个封装了这种复杂性的样式库。<p>在 React 19 中，我们正在解决这个复杂性，并提供更深入的集成到客户端的并发渲染和服务器的流式渲染，内置支持样式表。如果你告诉 React 你的样式表的 <code>precedence</code>，它将管理样式表在 DOM 中的插入顺序，并确保在显示依赖于这些样式规则的内容之前加载样式表（如果是外部的）。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ComponentOne</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Suspense</span> fallback<span class="token operator">=</span><span class="token string">"loading..."</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>link rel<span class="token operator">=</span><span class="token string">"stylesheet"</span> href<span class="token operator">=</span><span class="token string">"foo"</span> precedence<span class="token operator">=</span><span class="token string">"default"</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>link rel<span class="token operator">=</span><span class="token string">"stylesheet"</span> href<span class="token operator">=</span><span class="token string">"bar"</span> precedence<span class="token operator">=</span><span class="token string">"high"</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>article <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"foo-class bar-class"</span><span class="token operator">></span>
        <span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>article<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Suspense</span><span class="token operator">></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ComponentTwo</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>link rel<span class="token operator">=</span><span class="token string">"stylesheet"</span> href<span class="token operator">=</span><span class="token string">"baz"</span> precedence<span class="token operator">=</span><span class="token string">"default"</span> <span class="token operator">/</span><span class="token operator">></span>  <span class="token operator">&#x3C;</span><span class="token operator">--</span> will be inserted between foo <span class="token operator">&#x26;</span> bar
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>在服务器端渲染时，React 会在 <code>&#x3C;head></code> 中包含样式表，确保浏览器在加载完样式表之前不会进行绘制。如果在已经开始流式传输后才发现样式表，React 会确保在揭示依赖于该样式表的 Suspense 边界的内容之前，将样式表插入到客户端的 <code>&#x3C;head></code> 中。<p>在客户端渲染时，React 会等待新渲染的样式表加载完成后再提交渲染。如果你在应用程序的多个地方渲染此组件，React 会只在文档中包含一次样式表：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">App</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">ComponentOne</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token spread operator">...</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">ComponentOne</span> <span class="token operator">/</span><span class="token operator">></span> <span class="token comment">// won't lead to a duplicate stylesheet link in the DOM</span>
  <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
<span class="token punctuation">}</span></code></pre><p>对于习惯于手动加载样式表的用户来说，这是一个机会，可以将这些样式表放在依赖它们的组件旁边，从而更好地进行本地推理，并确保只加载你实际依赖的样式表。<p>样式库和与打包器的样式集成也可以采用这种新的功能，所以即使你不直接渲染你自己的样式表，你也可以从你的工具升级到使用这个特性中受益。<p>有关更多详细信息，请阅读 <a href="/reference/react-dom/components/link"><code>&#x3C;link></code></a> 和 <a href="/reference/react-dom/components/style"><code>&#x3C;style></code></a> 的文档。</section><section class="level3"aria-labelledby="支持异步脚本-support-for-async-scripts"><h3 id="支持异步脚本-support-for-async-scripts">支持异步脚本 {/<em>support-for-async-scripts</em>/}</h3><p>在 HTML 中，普通脚本 (<code>&#x3C;script src="..."></code>) 和延迟脚本 (<code>&#x3C;script defer="" src="..."></code>) 按照文档顺序加载，这使得在组件树深处渲染这些类型的脚本变得具有挑战性。然而，异步脚本 (<code>&#x3C;script async="" src="..."></code>) 将以任意顺序加载。<p>在 React 19 中，我们通过允许你在组件树的任何位置，即实际依赖脚本的组件内部，渲染它们，从而为异步脚本提供了更好的支持，无需管理脚本实例的重新定位和去重。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>script async<span class="token operator">=</span><span class="token punctuation">{</span><span class="token boolean">true</span><span class="token punctuation">}</span> src<span class="token operator">=</span><span class="token string">"..."</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token maybe-class-name">Hello</span> <span class="token maybe-class-name">World</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">App</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">&#x3C;</span>html<span class="token operator">></span>
    <span class="token operator">&#x3C;</span>body<span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">MyComponent</span><span class="token operator">></span>
      <span class="token spread operator">...</span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">MyComponent</span><span class="token operator">></span> <span class="token comment">// won't lead to duplicate script in the DOM</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>body<span class="token operator">></span>
  <span class="token operator">&#x3C;</span><span class="token operator">/</span>html<span class="token operator">></span>
<span class="token punctuation">}</span></code></pre><p>在所有渲染环境中，异步脚本将被去重，因此即使它被多个不同的组件渲染，React 也只会加载并执行脚本一次。<p>在服务器端渲染中，异步脚本将被包含在 <code>&#x3C;head></code> 中，并优先于阻塞绘制的更关键的资源，如样式表、字体和图片预加载。<p>有关更多详细信息，请阅读 <a href="/reference/react-dom/components/script"><code>&#x3C;script></code></a> 的文档。</section><section class="level3"aria-labelledby="支持预加载资源-support-for-preloading-resources"><h3 id="支持预加载资源-support-for-preloading-resources">支持预加载资源 {/<em>support-for-preloading-resources</em>/}</h3><p>在初始文档加载和客户端更新时，尽早告诉浏览器它可能需要加载的资源，可以显著提高页面性能。<p>React 19 包含了一些新的 API，用于加载和预加载浏览器资源，使得构建不受资源加载效率影响的优秀体验变得尽可能容易。<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> prefetchDNS<span class="token punctuation">,</span> preconnect<span class="token punctuation">,</span> preload<span class="token punctuation">,</span> preinit <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react-dom'</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">preinit</span><span class="token punctuation">(</span><span class="token string">'https://.../path/to/some/script.js'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword module">as</span><span class="token operator">:</span> <span class="token string">'script'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// loads and executes this script eagerly</span>
  <span class="token function">preload</span><span class="token punctuation">(</span><span class="token string">'https://.../path/to/font.woff'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword module">as</span><span class="token operator">:</span> <span class="token string">'font'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// preloads this font</span>
  <span class="token function">preload</span><span class="token punctuation">(</span><span class="token string">'https://.../path/to/stylesheet.css'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword module">as</span><span class="token operator">:</span> <span class="token string">'style'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// preloads this stylesheet</span>
  <span class="token function">prefetchDNS</span><span class="token punctuation">(</span><span class="token string">'https://...'</span><span class="token punctuation">)</span> <span class="token comment">// when you may not actually request anything from this host</span>
  <span class="token function">preconnect</span><span class="token punctuation">(</span><span class="token string">'https://...'</span><span class="token punctuation">)</span> <span class="token comment">// when you will request something but aren't sure what</span>
<span class="token punctuation">}</span></code></pre><pre class="language-html"><code class="language-html"><span class="token comment">&#x3C;!-- the above would result in the following DOM/HTML --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>html</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>head</span><span class="token punctuation">></span></span>
    <span class="token comment">&#x3C;!-- links/scripts are prioritized by their utility to early loading, not call order --></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>prefetch-dns<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://...<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>preconnect<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://...<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>font<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://.../path/to/font.woff<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>style<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://.../path/to/stylesheet.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>script</span> <span class="token attr-name">async</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://.../path/to/some/script.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>script</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>head</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>body</span><span class="token punctuation">></span></span>
    ...
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>这些 API 可以通过将像字体这样的额外资源的发现从样式表加载中移出来，优化初始页面加载。它们还可以通过预取预期导航使用的资源列表，然后在点击或甚至悬停时积极预加载这些资源，使客户端更新更快。<p>有关更多详细信息，请参阅 <a href="/reference/react-dom#resource-preloading-apis">资源预加载 API</a>。</section><section class="level3"aria-labelledby="兼容第三方脚本和扩展-compatibility-with-third-party-scripts-and-extensions"><h3 id="兼容第三方脚本和扩展-compatibility-with-third-party-scripts-and-extensions">兼容第三方脚本和扩展 {/<em>compatibility-with-third-party-scripts-and-extensions</em>/}</h3><p>我们改进了激活机制，以考虑第三方脚本和浏览器扩展。<p>在激活过程中，如果在客户端渲染的元素与从服务器获取的 HTML 中找到的元素不匹配，React 将强制进行客户端重新渲染以修复内容。以前，如果一个元素是由第三方脚本或浏览器扩展插入的，它会触发一个不匹配的错误并进行客户端渲染。<p>在 React 19 中，<code>&#x3C;head></code> 和 <code>&#x3C;body></code> 中的意外标签将被跳过，避免了不匹配的错误。如果 React 需要由于无关的激活不匹配而重新渲染整个文档，它将保留由第三方脚本和浏览器扩展插入的样式表。</section><section class="level3"aria-labelledby="更好的错误报告-error-handling"><h3 id="更好的错误报告-error-handling">更好的错误报告 {/<em>error-handling</em>/}</h3><p>在 React 19 中，我们改进了错误处理，以消除重复并提供处理捕获和未捕获错误的选项。例如，当在由错误边界捕获的渲染中出现错误时，以前 React 会抛出两次错误（一次是原始错误，然后在自动恢复失败后再次抛出），然后调用 <code>console.error</code> 提供错误发生的信息。<p>这导致每个捕获的错误都有三个错误：</p><consoleblockmulti><consolelogline level="error"><p>Uncaught Error: hit {' '}at Throws {' '}at renderWithHooks {' '}...</p></consolelogline><consolelogline level="error"><p>Uncaught Error: hit<span class="ms-2 text-gray-30">{' &#x3C;--'} Duplicate</span> {' '}at Throws {' '}at renderWithHooks {' '}...</p></consolelogline><consolelogline level="error"><p>The above error occurred in the Throws component: {' '}at Throws {' '}at ErrorBoundary {' '}at App{'\n'} React will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary.</p></consolelogline></consoleblockmulti><p>在 React 19 中，我们记录一个包含所有错误信息的单一错误：</p><consoleblockmulti><consolelogline level="error"><p>Error: hit {' '}at Throws {' '}at renderWithHooks {' '}...{'\n'} The above error occurred in the Throws component: {' '}at Throws {' '}at ErrorBoundary {' '}at App{'\n'} React will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary. {' '}at ErrorBoundary {' '}at App</p></consolelogline></consoleblockmulti><p>此段代码介绍了 React 19 中添加的两个新的根选项，用于补充 <code>onRecoverableError</code>：<ul><li><code>onCaughtError</code>：当 React 在错误边界中捕获错误时调用。<li><code>onUncaughtError</code>：当抛出错误并且未被错误边界捕获时调用。<li><code>onRecoverableError</code>：当抛出错误并自动恢复时调用。</ul><p>有关更多信息和示例，请参阅 <a href="/reference/react-dom/client/createRoot"><code>createRoot</code></a> 和 <a href="/reference/react-dom/client/hydrateRoot"><code>hydrateRoot</code></a> 的文档。</section><section class="level3"aria-labelledby="支持自定义元素-support-for-custom-elements"><h3 id="支持自定义元素-support-for-custom-elements">支持自定义元素 {/<em>support-for-custom-elements</em>/}</h3><p>React 19 添加了对自定义元素的全面支持，并通过了 <a href="https://custom-elements-everywhere.com/">Custom Elements Everywhere</a> 上的所有测试。<p>在过去的版本中，使用 React 中的自定义元素很困难，因为 React 将无法识别的 props 视为 HTML attribute 而不是 DOM property。在 React 19 中，我们添加了对 DOM property 的支持，该支持在客户端和 SSR 期间都有效，策略如下：<ul><li><strong>服务器端渲染</strong>：传递给自定义元素的 props 将作为 HTML attribute 渲染，如果它们的类型是原始值，如 <code>string</code>、<code>number</code>，或者值为 <code>true</code>。具有非原始类型的 props，如 <code>object</code>、<code>symbol</code>、<code>function</code>，或者值为 <code>false</code> 的 props 将被省略。<li><strong>客户端渲染</strong>：匹配自定义元素实例上的属性的 props 将被赋值为 DOM property，否则它们将被赋值为 HTML attribute。</ul><p>感谢 <a href="https://github.com/josepharhar">Joey Arhar</a> 在 React 中推动自定义元素支持的设计和实现。<section class="level4"aria-labelledby="如何升级-how-to-upgrade"><h4 id="如何升级-how-to-upgrade">如何升级 {/<em>how-to-upgrade</em>/}</h4><p>请查看 <a href="/blog/2024/04/25/react-19-upgrade-guide">React 19 升级指南</a> 以获取逐步指导和完整的破坏性和显著变化列表。<p><span style="float:footnote"><a href="../../../../index.html#toc">Go to TOC</a></span></section></section></section></section>