<!doctype html><html lang="zh-hans"><meta charset="utf-8"><title>useInsertionEffect</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="useinsertioneffect"><h1 id="useinsertioneffect">useInsertionEffect</h1><pitfall><p><code>useInsertionEffect</code> 是为 CSS-in-JS 库的作者特意打造的。除非你正在使用 CSS-in-JS 库并且需要注入样式，否则你应该使用 <a href="/reference/react/useEffect"><code>useEffect</code></a> 或者 <a href="/reference/react/useLayoutEffect"><code>useLayoutEffect</code></a>。</p></pitfall><intro><p><code>useInsertionEffect</code> 可以在布局副作用触发之前将元素插入到 DOM 中。<pre class="language-js"><code class="language-js"><span class="token function">useInsertionEffect</span><span class="token punctuation">(</span>setup<span class="token punctuation">,</span> dependencies<span class="token operator">?</span><span class="token punctuation">)</span></code></pre></intro><inlinetoc><section class="level2"aria-labelledby="参考-reference"><h2 id="参考-reference">参考 {/<em>reference</em>/}</h2><section class="level3"aria-labelledby="useinsertioneffectsetup-dependencies-useinsertioneffect"><h3 id="useinsertioneffectsetup-dependencies-useinsertioneffect"><code>useInsertionEffect(setup, dependencies?)</code> {/<em>useinsertioneffect</em>/}</h3><p>调用 <code>useInsertionEffect</code> 在任何可能需要读取布局的副作用启动之前插入样式：<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> useInsertionEffect <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token comment">// 在你的 CSS-in-JS 库中</span>
<span class="token keyword">function</span> <span class="token function">useCSS</span><span class="token punctuation">(</span><span class="token parameter">rule</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useInsertionEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// ... 在此注入 &#x3C;style> 标签 ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> rule<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><a href="#usage">请参考下方更多示例</a>。<section class="level4"aria-labelledby="参数-parameters"><h4 id="参数-parameters">参数 {/<em>parameters</em>/}</h4><ul><li><p><code>setup</code>: The function with your Effect's logic. Your setup function may also optionally return a <em>cleanup</em> function. When your component is added to the DOM, but before any layout effects fire, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. When your component is removed from the DOM, React will run your cleanup function.<li><p><strong>optional</strong> <code>dependencies</code>: The list of all reactive values referenced inside of the <code>setup</code> code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is <a href="/learn/editor-setup#linting">configured for React</a>, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like <code>[dep1, dep2, dep3]</code>. React will compare each dependency with its previous value using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is</code></a> comparison algorithm. If you don't specify the dependencies at all, your Effect will re-run after every re-render of the component.<li><p><strong>可选</strong> <code>dependencies</code>：<code>setup</code> 代码中引用的所有响应式值的列表。响应式值包括 props、state 以及所有直接在组件内部声明的变量和函数。如果你的代码检查工具 <a href="/learn/editor-setup#linting">配置了 React</a>，那么它将验证是否每个响应式值都被正确地指定为依赖项。依赖列表必须具有固定数量的项，并且必须像 <code>[dep1, dep2, dep3]</code> 这样内联编写。React 将使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is</code></a> 来比较每个依赖项和它先前的值。如果省略此参数，则将在每次重新渲染组件之后重新运行 Effect。</ul></section><section class="level4"aria-labelledby="返回值-returns"><h4 id="返回值-returns">返回值 {/<em>returns</em>/}</h4><p><code>useInsertionEffect</code> 返回 <code>undefined</code>。<ul><li>Effects only run on the client. They don't run during server rendering.<li>You can't update state from inside <code>useInsertionEffect</code>.<li>By the time <code>useInsertionEffect</code> runs, refs are not attached yet.<li><code>useInsertionEffect</code> may run either before or after the DOM has been updated. You shouldn't rely on the DOM being updated at any particular time.<li>Unlike other types of Effects, which fire cleanup for every Effect and then setup for every Effect, <code>useInsertionEffect</code> will fire both cleanup and setup one component at a time. This results in an "interleaving" of the cleanup and setup functions.</ul></section></section></section><section class="level2"aria-labelledby="用法-usage"><h2 id="用法-usage">用法 {/<em>usage</em>/}</h2><section class="level3"aria-labelledby="从-css-in-js-库中注入动态样式-injecting-dynamic-styles-from-css-in-js-libraries"><h3 id="从-css-in-js-库中注入动态样式-injecting-dynamic-styles-from-css-in-js-libraries">从 CSS-in-JS 库中注入动态样式 {/<em>injecting-dynamic-styles-from-css-in-js-libraries</em>/}</h3><p>传统上，你会使用纯 CSS 为 React 组件设置样式。<pre class="language-js"><code class="language-js"><span class="token comment">// 在你的 JS 文件中：</span>
<span class="token operator">&#x3C;</span>button className<span class="token operator">=</span><span class="token string">"success"</span> <span class="token operator">/</span><span class="token operator">></span>

<span class="token comment">// 在你的 CSS 文件中：</span>
<span class="token punctuation">.</span><span class="token property-access">success</span> <span class="token punctuation">{</span> <span class="token literal-property property">color</span><span class="token operator">:</span> green<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>有些团队更喜欢直接在 JavaScript 代码中编写样式，而不是编写 CSS 文件。这通常需要使用 CSS-in-JS 库或工具。以下是 CSS-in-JS 三种常见的实现方法：<ol><li>使用编译器静态提取到 CSS 文件<li>内联样式，例如 <code>&#x3C;div style={{ opacity: 1 }}></code><li>运行时注入 <code>&#x3C;style></code> 标签</ol><p>如果你使用 CSS-in-JS，我们建议结合使用前两种方法（静态样式使用 CSS 文件，动态样式使用内联样式）。<strong>我们不建议运行时注入 <code>&#x3C;style></code> 标签有两个原因</strong>：<ol><li>运行时注入会使浏览器频繁地重新计算样式。<li>如果在 React 生命周期中某个错误的时机进行运行时注入，它可能会非常慢。</ol><p>第一个问题无法解决，但是 <code>useInsertionEffect</code> 可以帮助你解决第二个问题。<p>Call <code>useInsertionEffect</code> to insert the styles before any layout effects fire:<pre class="language-js"><code class="language-js"><span class="token comment">// 在你的 CSS-in-JS 库中</span>
<span class="token keyword">let</span> isInserted <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">useCSS</span><span class="token punctuation">(</span><span class="token parameter">rule</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useInsertionEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// 同前所述，我们不建议在运行时注入 &#x3C;style> 标签。</span>
    <span class="token comment">// 如果你必须这样做，那么应当在 useInsertionEffect 中进行。</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isInserted<span class="token punctuation">.</span><span class="token method function property-access">has</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isInserted<span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">head</span><span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span><span class="token function">getStyleForRule</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> rule<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Button</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> className <span class="token operator">=</span> <span class="token function">useCSS</span><span class="token punctuation">(</span><span class="token string">'...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>div className<span class="token operator">=</span><span class="token punctuation">{</span>className<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>与 <code>useEffect</code> 类似，<code>useInsertionEffect</code> 不在服务端运行。如果你需要收集在服务端上使用了哪些 CSS 规则，你可以在渲染期间进行：<pre class="language-js"><code class="language-js"><span class="token keyword">let</span> collectedRulesSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">useCSS</span><span class="token punctuation">(</span><span class="token parameter">rule</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token dom variable">window</span> <span class="token operator">===</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    collectedRulesSet<span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">useInsertionEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> rule<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><a href="https://github.com/reactwg/react-18/discussions/110">阅读更多使用 <code>useInsertionEffect</code> 升级 CSS-in-JS 库的相关指南</a>。</p><deepdive><section class="level4"aria-labelledby="这与在渲染期间或-uselayouteffect-中注入样式相比有何优势-how-is-this-better-than-injecting-styles-during-rendering-or-uselayouteffect"><h4 id="这与在渲染期间或-uselayouteffect-中注入样式相比有何优势-how-is-this-better-than-injecting-styles-during-rendering-or-uselayouteffect">这与在渲染期间或 <code>useLayoutEffect</code> 中注入样式相比有何优势？ {/<em>how-is-this-better-than-injecting-styles-during-rendering-or-uselayouteffect</em>/}</h4><p>如果你在渲染期间注入样式并且 React 正在处理 <a href="/reference/react/useTransition#marking-a-state-update-as-a-non-blocking-transition">非阻塞更新</a>，那么浏览器将在渲染组件树时每一帧都会重新计算样式，这可能会 <strong>非常慢</strong>。<p><code>useInsertionEffect</code> 比在 <a href="/reference/react/useLayoutEffect"><code>useLayoutEffect</code></a> 或 <a href="/reference/react/useEffect"><code>useEffect</code></a> 期间注入样式更好。因为它会确保 <code>&#x3C;style></code> 标签在其它 Effect 运行前被注入。否则，正常的 Effect 中的布局计算将由于过时的样式而出错。</p><span style="float:footnote"><a href="../../index.html#toc">Go to TOC</a></span></section></deepdive></section></section></inlinetoc></section>