<!doctype html><html lang="zh-hans"><meta charset="utf-8"><title>cache</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="cache"><h1 id="cache">cache</h1><p>canary: true</p><canary>* `cache` 仅供与 [React 服务器组件](/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components) 一起使用。请参阅支持 React 服务器组件的 [框架](/learn/start-a-new-react-project#bleeding-edge-react-frameworks)。<ul><li><code>cache</code> 仅在 React 的 <a href="/community/versioning-policy#canary-channel">Canary</a> 和 <a href="/community/versioning-policy#experimental-channel">experimental</a> 渠道中可用。在将 <code>cache</code> 用于生产环境之前，请确保了解其限制。查看此处了解有关 <a href="/community/versioning-policy#all-release-channels">React 发布渠道的更多信息</a>。</ul><intro><p><code>cache</code> 允许缓存数据获取或计算的结果。<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> cachedFn <span class="token operator">=</span> <span class="token function">cache</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></intro><inlinetoc><section class="level2"aria-labelledby="参考-reference"><h2 id="参考-reference">参考 {/<em>reference</em>/}</h2><section class="level3"aria-labelledby="cachefn-cache"><h3 id="cachefn-cache"><code>cache(fn)</code> {/<em>cache</em>/}</h3><p>在任何组件之外调用 <code>cache</code> 以创建带有缓存的函数版本。<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>cache<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports">calculateMetrics</span> <span class="token keyword module">from</span> <span class="token string">'lib/metrics'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> getMetrics <span class="token operator">=</span> <span class="token function">cache</span><span class="token punctuation">(</span>calculateMetrics<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Chart</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>data<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> report <span class="token operator">=</span> <span class="token function">getMetrics</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>当首次使用 <code>data</code> 调用 <code>getMetrics</code> 时，<code>getMetrics</code> 将调用 <code>calculateMetrics(data)</code> 并将结果存储在缓存中。如果再次使用相同的 <code>data</code> 调用 <code>getMetrics</code>，它将返回缓存的结果，而不会再次调用 <code>calculateMetrics(data)</code>。<p><a href="#usage">参见下方更多示例</a>。<section class="level4"aria-labelledby="参数-parameters"><h4 id="参数-parameters">参数 {/<em>parameters</em>/}</h4><ul><li><code>fn</code>：要对其结果进行缓存的函数。<code>fn</code> 可以接受任何参数并返回任何值。</ul></section><section class="level4"aria-labelledby="返回值-returns"><h4 id="返回值-returns">返回值 {/<em>returns</em>/}</h4><p><code>cache</code> 返回一个与 <code>fn</code> 具有相同类型签名的已缓存版本。在此过程中，它不会调用 <code>fn</code>。<p>在使用给定的参数调用 <code>cachedFn</code> 时，它首先检查缓存中是否存在缓存的结果。如果存在缓存的结果，它将返回该结果。如果没有，它将使用参数调用 <code>fn</code>，将结果存储在缓存中，并返回该结果。只有在缓存未命中时才会调用 <code>fn</code>。</p><note><p>基于输入进行返回值缓存的优化称为 <a href="https://en.wikipedia.org/wiki/Memoization">记忆化</a>。我们将从 <code>cache</code> 返回的函数称为一个记忆化函数。</p></note></section><section class="level4"aria-labelledby="注意-caveats"><h4 id="注意-caveats">注意 {/<em>caveats</em>/}</h4><ul><li>React 将在每次服务器请求时使所有记忆化函数的缓存失效。<li>每次调用 <code>cache</code> 都会创建一个新函数。这意味着多次使用相同的函数调用 <code>cache</code> 将返回不共享相同缓存的不同记忆化函数。<li><code>cachedFn</code> 还会缓存错误。如果对于某些参数 <code>fn</code> 抛出错误，错误将被缓存，当使用相同参数调用 <code>cachedFn</code> 时，相同的错误将被重新抛出。<li><code>cache</code> 仅供在 <a href="/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components">服务器组件</a> 中使用。</ul></section></section></section><section class="level2"aria-labelledby="用法-usage"><h2 id="用法-usage">用法 {/<em>usage</em>/}</h2><section class="level3"aria-labelledby="缓存代价昂贵的计算-cache-expensive-computation"><h3 id="缓存代价昂贵的计算-cache-expensive-computation">缓存代价昂贵的计算 {/<em>cache-expensive-computation</em>/}</h3><p>使用 <code>cache</code> 跳过重复工作。<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>cache<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports">calculateUserMetrics</span> <span class="token keyword module">from</span> <span class="token string">'lib/user'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> getUserMetrics <span class="token operator">=</span> <span class="token function">cache</span><span class="token punctuation">(</span>calculateUserMetrics<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Profile</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>user<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> metrics <span class="token operator">=</span> <span class="token function">getUserMetrics</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">TeamReport</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>users<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> user <span class="token keyword">in</span> users<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> metrics <span class="token operator">=</span> <span class="token function">getUserMetrics</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>如果相同的 <code>user</code> 对象在 <code>Profile</code> 和 <code>TeamReport</code> 中都被渲染，那么这两个组件可以共享工作，并且只为该 <code>user</code> 调用一次 <code>calculateUserMetrics</code>。<p>假设首先渲染了 <code>Profile</code>。它将调用<codestep step="{1}"><code>getUserMetrics</code></codestep>，并检查是否有缓存的结果。由于这是第一次以该 <code>user</code> 调用 <code>getUserMetrics</code>，所以缓存未命中。于是 <code>getUserMetrics</code> 将会使用 <code>user</code> 调用 <code>calculateUserMetrics</code> 并将结果写入缓存。<p>当 <code>TeamReport</code> 使用相同的 <code>user</code> 对象来渲染 <code>users</code> 列表时，它将调用<codestep step="{2}"><code>getUserMetrics</code></codestep>并从缓存中读取结果。</p><pitfall><section class="level5"aria-labelledby="调用不同的记忆化函数将从不同的缓存中读取数据-pitfall-different-memoized-functions"><h5 id="调用不同的记忆化函数将从不同的缓存中读取数据-pitfall-different-memoized-functions">调用不同的记忆化函数将从不同的缓存中读取数据 {/<em>pitfall-different-memoized-functions</em>/}</h5><p>要访问相同的缓存，组件必须调用同一个记忆化函数。<pre class="language-js"><code class="language-js"><span class="token comment">// Temperature.js</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>cache<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>calculateWeekReport<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./report'</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Temperature</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>cityData<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 🚩 错误示例：在组件中调用 `cache` 会为每次渲染创建新的 `getWeekReport`。</span>
  <span class="token keyword">const</span> getWeekReport <span class="token operator">=</span> <span class="token function">cache</span><span class="token punctuation">(</span>calculateWeekReport<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> report <span class="token operator">=</span> <span class="token function">getWeekReport</span><span class="token punctuation">(</span>cityData<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token comment">// Precipitation.js</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>cache<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>calculateWeekReport<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./report'</span><span class="token punctuation">;</span>

<span class="token comment">// 🚩 错误示例：`getWeekReport` 仅供 `Precipitation` 组件访问。</span>
<span class="token keyword">const</span> getWeekReport <span class="token operator">=</span> <span class="token function">cache</span><span class="token punctuation">(</span>calculateWeekReport<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Precipitation</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>cityData<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> report <span class="token operator">=</span> <span class="token function">getWeekReport</span><span class="token punctuation">(</span>cityData<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>在上面的示例中，<codestep step="{2}"><code>Precipitation</code></codestep>和<codestep step="{1}"><code>Temperature</code></codestep>都将调用 <code>cache</code> 创建新的记忆化函数，并使用自己的缓存查找。如果两个组件都使用相同的 <code>cityData</code> 进行渲染，它们将重复调用 <code>calculateWeekReport</code>，进行重复的工作。<p>此外，<code>Temperature</code> 每次组件渲染时都创建一个<codestep step="{1}">新的记忆化函数</codestep>，这不允许任何缓存共享。<p>为了最大化缓存命中率并减少工作量，这两个组件应该调用相同的记忆化函数以访问相同的缓存。因此应该在专用模块中定义记忆化函数，以在不同组件之间使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import"><code>import</code>-ed</a> 进行共享。<pre class="language-js"><code class="language-js"><span class="token comment">// getWeekReport.js</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>cache<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>calculateWeekReport<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./report'</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">cache</span><span class="token punctuation">(</span>calculateWeekReport<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class="language-js"><code class="language-js"><span class="token comment">// Temperature.js</span>
<span class="token keyword module">import</span> <span class="token imports">getWeekReport</span> <span class="token keyword module">from</span> <span class="token string">'./getWeekReport'</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Temperature</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>cityData<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> report <span class="token operator">=</span> <span class="token function">getWeekReport</span><span class="token punctuation">(</span>cityData<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token comment">// Precipitation.js</span>
<span class="token keyword module">import</span> <span class="token imports">getWeekReport</span> <span class="token keyword module">from</span> <span class="token string">'./getWeekReport'</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Precipitation</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>cityData<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> report <span class="token operator">=</span> <span class="token function">getWeekReport</span><span class="token punctuation">(</span>cityData<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>在这里，两个组件都调用从 <code>./getWeekReport.js</code> 导出的<codestep step="{3}">相同的记忆化函数</codestep>来读取和写入相同的缓存。</section></pitfall></section><section class="level3"aria-labelledby="共享数据快照-take-and-share-snapshot-of-data"><h3 id="共享数据快照-take-and-share-snapshot-of-data">共享数据快照 {/<em>take-and-share-snapshot-of-data</em>/}</h3><p>要在组件之间共享数据快照，请使用类似 <code>fetch</code> 的数据获取函数调用 <code>cache</code>。当多个组件进行相同的数据获取时，只会发出一个请求，并且返回的数据会被缓存并在各个组件之间共享。所有组件在服务器渲染期间都引用相同的数据快照。<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>cache<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>fetchTemperature<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./api.js'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> getTemperature <span class="token operator">=</span> <span class="token function">cache</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">city</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
	<span class="token keyword control-flow">return</span> <span class="token keyword control-flow">await</span> <span class="token function">fetchTemperature</span><span class="token punctuation">(</span>city<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">AnimatedWeatherCard</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>city<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> temperature <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">getTemperature</span><span class="token punctuation">(</span>city<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MinimalWeatherCard</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>city<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> temperature <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">getTemperature</span><span class="token punctuation">(</span>city<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>如果 <code>AnimatedWeatherCard</code> 和 <code>MinimalWeatherCard</code> 都为相同的<codestep step="{1}"><code>city</code></codestep>进行渲染，它们将从<codestep step="{2}">记忆化函数</codestep>接收相同的数据快照。<p>如果 <code>AnimatedWeatherCard</code> 和 <code>MinimalWeatherCard</code> 向<codestep step="{2}"><code>getTemperature</code></codestep>提供不同的<codestep step="{1}"><code>city</code></codestep>参数，那么将调用两次 <code>fetchTemperature</code>，并且每个调用站点将接收不同的数据。<p><codestep step="{1}"><code>city</code></codestep>在其中充当缓存键。</p><note><p><codestep step="{3}">异步渲染</codestep>只在服务器组件中支持。<pre class="language-js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">AnimatedWeatherCard</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>city<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> temperature <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">getTemperature</span><span class="token punctuation">(</span>city<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></note></section><section class="level3"aria-labelledby="预加载数据-preload-data"><h3 id="预加载数据-preload-data">预加载数据 {/<em>preload-data</em>/}</h3><p>通过缓存长时间运行的数据获取，你可以在渲染组件之前开始异步工作。<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> getUser <span class="token operator">=</span> <span class="token function">cache</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword control-flow">await</span> db<span class="token punctuation">.</span><span class="token property-access">user</span><span class="token punctuation">.</span><span class="token method function property-access">query</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Profile</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>id<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">getUser</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>section</span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>img</span> <span class="token attr-name">src</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>user<span class="token punctuation">.</span><span class="token property-access">profilePic</span><span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>h2</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>user<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>h2</span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>section</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Page</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>id<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ✅ 正确示例：开始获取用户数据。</span>
  <span class="token function">getUser</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ……一些计算工作</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span><span class="token class-name">Profile</span></span> <span class="token attr-name">id</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>id<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span></span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>在渲染 <code>Page</code> 时，组件调用<codestep step="{1}"><code>getUser</code></codestep>，但请注意它并不使用返回的数据。这个早期的<codestep step="{1}"><code>getUser</code></codestep>调用会启动异步数据库查询，而在 <code>Page</code> 执行其他计算工作并渲染子组件时进行。<p>在渲染 <code>Profile</code> 时，我们再次调用<codestep step="{2}"><code>getUser</code></codestep>。如果初始<codestep step="{1}"><code>getUser</code></codestep>调用已经返回并缓存了用户数据，那么当 <code>Profile</code> 在<codestep step="{2}">请求并等待这些数据</codestep>时，它可以简单地从缓存中读取，而无需进行另一个远程过程调用。如果初始<codestep step="{1}"><code>fetchData</code></codestep>还没有完成，那么在这种模式下预加载数据可以减少数据获取的延迟。</p><deepdive><section class="level4"aria-labelledby="缓存异步工作-caching-asynchronous-work"><h4 id="缓存异步工作-caching-asynchronous-work">缓存异步工作 {/<em>caching-asynchronous-work</em>/}</h4><p>在评估 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">异步函数</a> 时，你将收到一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>，该 Promise 包含了该工作的状态（pending，fulfilled，failed）和最终的完成结果。<p>在这个示例中，异步函数<codestep step="{1}"><code>fetchData</code></codestep>返回一个等待 <code>fetch</code> 的 promise。<pre class="language-js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword control-flow">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">https://...</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> getData <span class="token operator">=</span> <span class="token function">cache</span><span class="token punctuation">(</span>fetchData<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ……一些计算工作</span>
  <span class="token keyword control-flow">await</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ……</span>
<span class="token punctuation">}</span></code></pre><p>在第一次调用<codestep step="{2}"><code>getData</code></codestep>时，从<codestep step="{1}"><code>fetchData</code></codestep>返回的 promise 将被缓存。随后的查找将返回相同的 promise。<p>请注意，第一次调用<codestep step="{2}"><code>getData</code></codestep>不使用 <code>await</code>，而<codestep step="{3}">第二次</codestep>调用会使用。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await"><code>await</code></a> 是 JavaScript 中的一个操作符，它会等待并返回 promise 的已解决结果。第一次调用<codestep step="{2}"><code>getData</code></codestep>仅启动 <code>fetch</code> 以缓存 promise，以供<codestep step="{3}">第二次</codestep>查找。<p>如果在<codestep step="{3}">第二次</codestep>调用时，promise 仍处于 pending 状态，那么 <code>await</code> 会等待结果。优化之处在于，在等待 <code>fetch</code> 的同时，React 可以继续进行计算工作，从而减少了第二次调用的等待时间。<p>如果 promise 已经解决，无论是得到错误还是 fulfilled 的结果，<code>await</code> 都会立即返回该值。在这两种结果中，都存在性能优势。</p><pitfall><section class="level5"aria-labelledby="在组件外部调用记忆化函数将不使用缓存-pitfall-memoized-call-outside-component"><h5 id="在组件外部调用记忆化函数将不使用缓存-pitfall-memoized-call-outside-component">在组件外部调用记忆化函数将不使用缓存 {/<em>pitfall-memoized-call-outside-component</em>/}</h5><pre class="language-jsx"><code class="language-jsx"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>cache<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> getUser <span class="token operator">=</span> <span class="token function">cache</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">userId</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword control-flow">await</span> db<span class="token punctuation">.</span><span class="token property-access">user</span><span class="token punctuation">.</span><span class="token method function property-access">query</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 🚩 错误示例：在组件外部调用记忆化函数将不进行记忆化。</span>
<span class="token function">getUser</span><span class="token punctuation">(</span><span class="token string">'demo-id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">DemoProfile</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ✅ 正确示例：`getUser` 将进行记忆化。</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token string">'demo-id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span><span class="token class-name">Profile</span></span> <span class="token attr-name">user</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>React 只允许在组件内访问记忆化函数的缓存。在组件外部调用<codestep step="{1}"><code>getUser</code></codestep>时，它仍会评估函数，但不会读取或更新缓存。<p>这是因为缓存访问是通过 <a href="/learn/passing-data-deeply-with-context">上下文（context）</a> 提供的，而上下文只能从组件中访问。</p><deepdive></deepdive></section></pitfall></section><section class="level4"aria-labelledby="应该何时使用-cachememo-和-usememo-cache-memo-usememo"><h4 id="应该何时使用-cachememo-和-usememo-cache-memo-usememo">应该何时使用 <code>cache</code>、<a href="/reference/react/memo"><code>memo</code></a> 和 <a href="/reference/react/useMemo"><code>useMemo</code></a>？ {/<em>cache-memo-usememo</em>/}</h4><p>所有提到的 API 都提供了记忆化功能，它们的区别在于记忆化什么、谁可以访问缓存以及何时缓存会失效。</section><section class="level4"aria-labelledby="usememo-deep-dive-use-memo"><h4 id="usememo-deep-dive-use-memo"><code>useMemo</code> {/<em>deep-dive-use-memo</em>/}</h4><p>一般来说，<a href="/reference/react/useMemo"><code>useMemo</code></a> 用于在客户端组件跨渲染时缓存昂贵的计算。例如，可以用它来记忆化组件内部数据的转换。<pre class="language-jsx"><code class="language-jsx"><span class="token string">'use client'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">WeatherReport</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>record<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> avgTemp <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">calculateAvg</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> record<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">App</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> record <span class="token operator">=</span> <span class="token function">getRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span><span class="token class-name">WeatherReport</span></span> <span class="token attr-name">record</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>record<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span><span class="token class-name">WeatherReport</span></span> <span class="token attr-name">record</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>record<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span></span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>在这个示例中，<code>App</code> 渲染了两个具有相同记录的 <code>WeatherReport</code>。尽管这两个组件都执行相同的工作，但它们无法共享工作。<code>useMemo</code> 的缓存仅在组件内部可用。<p>但是 <code>useMemo</code> 能够确保如果 <code>App</code> 重新渲染并且 <code>record</code> 对象没有更改，每个组件实例都将跳过工作并使用 <code>avgTemp</code> 的记忆化值。<code>useMemo</code> 仅会缓存具有给定依赖项的 <code>avgTemp</code> 的最后一次计算结果。</section><section class="level4"aria-labelledby="cache-deep-dive-cache"><h4 id="cache-deep-dive-cache"><code>cache</code> {/<em>deep-dive-cache</em>/}</h4><p>一般来说，<code>cache</code> 应用于服务器组件以记忆化可以跨组件共享的工作。<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> cachedFetchReport <span class="token operator">=</span> <span class="token function">cache</span><span class="token punctuation">(</span>fetchReport<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">WeatherReport</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>city<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> report <span class="token operator">=</span> <span class="token function">cachedFetchReport</span><span class="token punctuation">(</span>city<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">App</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> city <span class="token operator">=</span> <span class="token string">"Los Angeles"</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">WeatherReport</span> city<span class="token operator">=</span><span class="token punctuation">{</span>city<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">WeatherReport</span> city<span class="token operator">=</span><span class="token punctuation">{</span>city<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>使用 <code>cache</code> 重新编写前面的示例，在这种情况下，<codestep step="{3}"><code>WeatherReport</code> 的第二个实例</codestep>将能够跳过重复的工作并从与第一个 <code>WeatherReport</code> 相同的缓存中读取。与前面的示例不同的另一个地方是，<code>cache</code> 也推荐用于<codestep step="{2}">记忆化数据获取</codestep>，而 <code>useMemo</code> 只应用于计算。<p>目前 <code>cache</code> 应该仅在服务器组件中使用，并且缓存会在服务器请求之间失效。</section><section class="level4"aria-labelledby="memo-deep-dive-memo"><h4 id="memo-deep-dive-memo"><code>memo</code> {/<em>deep-dive-memo</em>/}</h4><p>你应该使用 <a href="reference/react/memo"><code>memo</code></a> 防止组件在其 <code>props</code> 未更改时重新渲染。<pre class="language-js"><code class="language-js"><span class="token string">'use client'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">WeatherReport</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>record<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> avgTemp <span class="token operator">=</span> <span class="token function">calculateAvg</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token maybe-class-name">MemoWeatherReport</span> <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token maybe-class-name">WeatherReport</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">App</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> record <span class="token operator">=</span> <span class="token function">getRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">MemoWeatherReport</span> record<span class="token operator">=</span><span class="token punctuation">{</span>record<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">MemoWeatherReport</span> record<span class="token operator">=</span><span class="token punctuation">{</span>record<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>在这个示例中，两个 <code>MemoWeatherReport</code> 组件在首次渲染时都会调用 <code>calculateAvg</code>。然而，如果 <code>App</code> 重新渲染，但没有更改 <code>record</code>，则没有 props 发生更改，<code>MemoWeatherReport</code> 将不会重新渲染。<p>与 <code>useMemo</code> 相比，<code>memo</code> 根据 props 而不是特定计算来记忆化组件渲染。与 <code>useMemo</code> 类似，记忆化的组件只缓存了具有最后一组 prop 值的最后一次渲染。一旦 props 更改，缓存将失效，组件将重新渲染。</section></deepdive></section></section><section class="level2"aria-labelledby="疑难解答-troubleshooting"><h2 id="疑难解答-troubleshooting">疑难解答 {/<em>troubleshooting</em>/}</h2><section class="level3"aria-labelledby="尽管传递的是相同参数我的记忆化函数仍在重新运行-memoized-function-still-runs"><h3 id="尽管传递的是相同参数我的记忆化函数仍在重新运行-memoized-function-still-runs">尽管传递的是相同参数，我的记忆化函数仍在重新运行 {/<em>memoized-function-still-runs</em>/}</h3><p>请查看之前提到的常见问题：<ul><li><a href="#pitfall-different-memoized-functions">调用不同的记忆化函数将从不同的缓存中读取</a>。<li><a href="#pitfall-memoized-call-outside-component">在组件外部调用记忆化函数将不使用缓存</a>。</ul><p>如果以上问题都不适用，那么可能是与 React 检查缓存中是否存在内容的方式有关。<p>如果参数不是原始数据类型(<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)%EF%BC%88%E4%BE%8B%E5%A6%82%E5%AF%B9%E8%B1%A1%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E6%95%B0%E7%BB%84%EF%BC%89%EF%BC%8C%E8%AF%B7%E7%A1%AE%E4%BF%9D%E4%BC%A0%E9%80%92%E7%9A%84%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E3%80%82">https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)（例如对象、函数、数组），请确保传递的是相同的对象引用。</a><p>在调用记忆化函数时，React 将查找输入参数，以查看是否已经缓存了结果。React 将使用浅相等确定是否存在缓存。<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>cache<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> calculateNorm <span class="token operator">=</span> <span class="token function">cache</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">vector</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MapMarker</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 🚩 错误示例：props 是一个对象，每次渲染时都会更改</span>
  <span class="token keyword">const</span> length <span class="token operator">=</span> <span class="token function">calculateNorm</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">App</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">MapMarker</span> x<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span> y<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span> z<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">MapMarker</span> x<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span> y<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span> z<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>在这种情况下，两个 <code>MapMarker</code> 看起来执行相同的工作，并使用相同的值 <code>{x: 10, y: 10, z: 10}</code> 调用 <code>calculateNorm</code>。尽管这些对象包含相同的值，但它们不是相同的对象引用，因为每个组件都创建了自己的 props 对象。<p>React 将调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is">Object.is</a> 来验证是否存在缓存命中。<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>cache<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> calculateNorm <span class="token operator">=</span> <span class="token function">cache</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MapMarker</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ✅ 正确示例：传递原始类型给记忆化函数</span>
  <span class="token keyword">const</span> length <span class="token operator">=</span> <span class="token function">calculateNorm</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">x</span><span class="token punctuation">,</span> props<span class="token punctuation">.</span><span class="token property-access">y</span><span class="token punctuation">,</span> props<span class="token punctuation">.</span><span class="token property-access">z</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">App</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">MapMarker</span> x<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span> y<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span> z<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">MapMarker</span> x<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span> y<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span> z<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>解决这个问题的一种方法是将向量的维度传递给 <code>calculateNorm</code>。这个方法有效，因为维度本身是原始数据类型。<p>另一种解决方案可能是将向量对象本身作为一个 prop 传递给组件。我们需要将相同的对象传递给两个组件实例。<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>cache<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> calculateNorm <span class="token operator">=</span> <span class="token function">cache</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">vector</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MapMarker</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ✅ 正确示例：传递相同的 `vector` 对象。</span>
  <span class="token keyword">const</span> length <span class="token operator">=</span> <span class="token function">calculateNorm</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">vector</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">App</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> vector <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">MapMarker</span> vector<span class="token operator">=</span><span class="token punctuation">{</span>vector<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">MapMarker</span> vector<span class="token operator">=</span><span class="token punctuation">{</span>vector<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><span style="float:footnote"><a href="../../index.html#toc">Go to TOC</a></span></section></section></inlinetoc></canary></section>