<!doctype html><html lang="zh-hans"><meta charset="utf-8"><title>组件和 Hook 必须是纯粹的</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"type="text/css"href="../../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="组件和-hook-必须是纯粹的"><h1 id="组件和-hook-必须是纯粹的">组件和 Hook 必须是纯粹的</h1><intro>纯函数仅仅执行计算，除此之外不做任何事情。这使得你的代码更易于理解和调试，并允许 React 能够正确地自动优化你的组件和 Hook。</intro><note>本参考文档讨论了一些高级议题，因此建议先了解 [保持组件纯粹](/learn/keeping-components-pure) 页面中涉及的相关概念。</note><inlinetoc><section class="level3"aria-labelledby="为什么保持纯粹很重要-why-does-purity-matter"><h3 id="为什么保持纯粹很重要-why-does-purity-matter">为什么保持纯粹很重要？ {/<em>why-does-purity-matter</em>/}</h3><p>React 中的一个核心概念是保持纯粹。一个纯组件或 Hook 应该是：<ul><li><strong>幂等的</strong> ——每次使用相同的输入（组件输入的 props、state、context 以及 Hook 输入的参数）运行它，你 <a href="/learn/keeping-components-pure#purity-components-as-formulas">总是得到相同的结果</a>。<li><strong>在渲染中没有副作用</strong> ——具有副作用的代码应该 <a href="#how-does-react-run-your-code">与渲染过程分开执行</a>。例如，可以作为 <a href="/learn/responding-to-events">响应事件</a>，在用户与用户界面交互并导致其更新时触发。或者作为一个 <a href="/reference/react/useEffect">Effect</a>，在渲染之后运行。<li><strong>不要修改非局部作用域中的值</strong>：组件和 Hook 在渲染时中 <a href="#mutation">绝不应该修改非局部创建的值</a>。</ul><p>当渲染保持纯粹时，React 能够理解哪些更新对用户来说最重要，应该优先显示。因为渲染的纯粹，即组件 <a href="#how-does-react-run-your-code">在渲染过程中</a> 不会产生副作用，React 可以暂停渲染那些不是那么重要的组件，等到真正需要时再继续渲染它们。<p>具体来说，这意味着渲染逻辑可以多次运行，这样 React 就能够为你的用户提供最佳的体验。然而，如果你的组件 <a href="#how-does-react-run-your-code">在渲染过程中</a> 有无追踪的副作用，比如修改全局变量的值，那么当 React 再次运行你的渲染代码时，这些副作用会以你不希望的方式被触发。这通常会导致意外的 bug，从而降低用户对你应用的体验感。你可以再 <a href="/learn/keeping-components-pure#side-effects-unintended-consequences">保持组件纯粹页面中</a> 看到这样一个例子。<section class="level4"aria-labelledby="react-是如何运行你的代码的-how-does-react-run-your-code"><h4 id="react-是如何运行你的代码的-how-does-react-run-your-code">React 是如何运行你的代码的？ {/<em>how-does-react-run-your-code</em>/}</h4><p>React 是声明式的，即你告诉 React 你想要渲染的内容，React 会自己选择最佳的方式向用户展示它。为了做到这一点，React 在执行你的代码时分为几个阶段。虽然你不必了解所有这些阶段就能很好地使用 React。但是，了解哪些代码在渲染阶段运行，哪些代码在渲染阶段之外运行，可以让你更高层次地理解 React。<p>“渲染”指的是计算你的用户界面（UI）下一个版本应该呈现的样子。渲染完成后，<a href="/reference/react/useEffect">Effect</a> 会被“清空”（意思是一直运行完所有的 Effect 为止），如果这些 Effect 对布局有影响，比如它们可能会改变之前的计算结果。React 会用这个新的计算结果与你 UI 上一个版本所用的计算结果进行比较，然后仅对 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">DOM</a>，也就是用户实际看到的部分进行最小的必要更改，以确保 UI 更新至最新内容。</p><deepdive></deepdive></section><section class="level4"aria-labelledby="如何判断代码是否在渲染中运行-how-to-tell-if-code-runs-in-render"><h4 id="如何判断代码是否在渲染中运行-how-to-tell-if-code-runs-in-render">如何判断代码是否在渲染中运行 {/<em>how-to-tell-if-code-runs-in-render</em>/}</h4><p>一个快速判断代码是否在渲染过程中运行的方法是检查代码书写的位置：如果它像下面的例子这样写在顶层，那么它很可能会在渲染过程中运行。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Dropdown</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> selectedItems <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在渲染过程中创建</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>事件处理函数和 Effect 在渲染过程中不会运行：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Dropdown</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> selectedItems <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">onSelect</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// 这段代码位于事件处理函数中，因此只有在用户触发这个事件时才会运行。</span>
    selectedItems<span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Dropdown</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> selectedItems <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// 这段代码位于 Effect 内部，因此它只在渲染完成后运行。</span>
    <span class="token function">logForAnalytics</span><span class="token punctuation">(</span>selectedItems<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>selectedItems<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></section></section><section class="level2"aria-labelledby="组件和-hook-必须是幂等的-components-and-hooks-must-be-idempotent"><h2 id="组件和-hook-必须是幂等的-components-and-hooks-must-be-idempotent">组件和 Hook 必须是幂等的 {/<em>components-and-hooks-must-be-idempotent</em>/}</h2><p>组件必须始终根据其输入（props、state、和 context）返回相同的输出。这被称为“幂等性”。<a href="https://en.wikipedia.org/wiki/Idempotence">幂等性</a> 是函数式编程中经常使用的一个术语，它指的是只要你使用相同的输入运行代码， <a href="learn/keeping-components-pure">得到的结果总是一样的</a>。<p>这意味着，为了遵循这一规则，所有 <a href="#how-does-react-run-your-code">在渲染期间</a> 执行的代码也必须是幂等的。例如，以下这行代码就不是幂等的（因此，包含这行代码的组件也不是幂等的）：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Clock</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> time <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 错误的：总是返回不同的结果！</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>span<span class="token operator">></span><span class="token punctuation">{</span>time<span class="token punctuation">.</span><span class="token method function property-access">toLocaleString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>span<span class="token operator">></span>
<span class="token punctuation">}</span></code></pre><p><code>new Date()</code> 函数不是幂等的，因为每次调用时返回的结果都不同，它总是返回调用时刻的日期和时间。当你渲染上面的组件时，屏幕上显示的时间将会停留在组件被渲染的那一刻的时间。类似地，像 <code>Math.random()</code> 这样的函数也不是幂等的，因为即使输入相同，它们每次调用也都会返回不同的结果。<p>这并不意味着你完全不能使用像 <code>new Date()</code> 这样非幂等的函数，你只需要避免 <a href="#how-does-react-run-your-code">在渲染过程</a> 中使用它们即可。在这种情况下，我们可以使用一个 <a href="/reference/react/useEffect">Effect</a> 来将最新的日期与这个组件进行“同步”：</p><sandpack><pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">useTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1. 跟踪当前日期的状态。`useState` 接受一个初始化函数作为其</span>
  <span class="token comment">//    初始状态。它只在调用 Hook 时运行一次，因此只有调用 Hook 时的</span>
  <span class="token comment">//    当前日期才被首先设置。</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>time<span class="token punctuation">,</span> setTime<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// 2. 使用 `setInterval` 每秒更新当前日期。</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">setTime</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 正确的：非幂等代码不再在渲染中运行。</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3. 返回一个清理函数，这样我们就不会忘记清理 `setInterval` 定时器，导致内存泄漏。</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> time<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Clock</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> time <span class="token operator">=</span> <span class="token function">useTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>span<span class="token operator">></span><span class="token punctuation">{</span>time<span class="token punctuation">.</span><span class="token method function property-access">toLocaleString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></sandpack><p>通过将非幂等的 <code>new Date()</code> 调用包装在一个 Effect 中，就可以将这个计算移动到 <a href="#how-does-react-run-your-code">渲染之外</a>。<p>如果你不需要将某些外部状态与 React 同步，只需要在响应用户交互时更新，你可以考虑使用一个 <a href="/learn/responding-to-events">事件处理函数</a>。</section><section class="level2"aria-labelledby="副作用必须在渲染之外执行-side-effects-must-run-outside-of-render"><h2 id="副作用必须在渲染之外执行-side-effects-must-run-outside-of-render">副作用必须在渲染之外执行 {/<em>side-effects-must-run-outside-of-render</em>/}</h2><p><a href="/learn/keeping-components-pure#side-effects-unintended-consequences">副作用</a> 不应该 <a href="#how-does-react-run-your-code">在渲染中</a> 执行，因为 React 可能会多次渲染组件以提供最佳的用户体验。</p><note>副作用是一个比 Effect 更广泛的概念。Effect 特指被包裹在 `useEffect` 中的代码，而“副作用”是一般术语，指除了将其主要结果（返回值）传递给调用者之外，对外部环境有任何可观察影响的代码。<p>副作用通常写在 <a href="/learn/responding-to-events">事件处理函数</a> 或 Effect 内部。但绝不能在渲染过程中写。<p>尽管渲染必须保持纯净，但副作用对于你的应用来说是也是非常必要的，这样才能做一些有趣的事情，比如在屏幕上显示内容！这条规则的关键点在于，副作用不应该 <a href="#how-does-react-run-your-code">在渲染中</a> 执行，因为 React 可能会多次渲染组件。在大多数情况下，你会使用 <a href="learn/responding-to-events">事件处理函数</a> 来处理副作用。使用事件处理函数明确地告诉 React 这段代码不需要在渲染过程中执行，从而保持渲染的纯粹。如果你已经尝试了所有可能的方法，并且只是作为最后的解决办法，你也可以使用 <code>useEffect</code> 来处理副作用。<section class="level3"aria-labelledby="什么时候可以进行-mutation-mutation"><h3 id="什么时候可以进行-mutation-mutation">什么时候可以进行 mutation？ {/<em>mutation</em>/}</h3><section class="level4"aria-labelledby="局部-mutation-local-mutation"><h4 id="局部-mutation-local-mutation">局部 mutation {/<em>local-mutation</em>/}</h4><p>一个常见的具有副作用的例子是突变（mutation），在 JavaScript 中指的是改变一个非 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">原始值</a> 的值。通常来说，在 React 中 mutation 操作并不符合最佳实践，但是进行局部 mutation 是完全可以接受的：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">FriendList</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> friends <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 正确的：在局部创建</span>
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> friends<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> friend <span class="token operator">=</span> friends<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    items<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Friend</span> key<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">}</span> friend<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 正确的：局部修改是可以的。</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>section<span class="token operator">></span><span class="token punctuation">{</span>items<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>section<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>你没有必要为了回避局部 mutation 而刻意编写复杂的代码。虽然为了简洁，这里可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><code>Array.map</code></a>，但创建一个局部数组，然后 <a href="#how-does-react-run-your-code">在渲染时</a> 向其中添加数组项也是完全可以的。<p>尽管看起来我们正在修改 <code>items</code>，但关键的一点是这种 mutation 是局部的，当组件再次渲染时，这种 mutation 不会被“记住”。换句话说，<code>items</code> 只在组件存在期间有效。因为每次渲染 <code>&#x3C;FriendList /></code> 时，<code>items</code> 都会被重新创建，所以组件总能返回相同的结果。<p>另一方面，如果 <code>items</code> 是在组件外部创建的，那么它会保留其之前的值，并记住所做的更改：<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 错误的：在组件外部创建</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">FriendList</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> friends <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> friends<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> friend <span class="token operator">=</span> friends<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    items<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Friend</span> key<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">}</span> friend<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 错误的：修改了一个在渲染之外创建的值。</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>section<span class="token operator">></span><span class="token punctuation">{</span>items<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>section<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>每当 <code>&#x3C;FriendList /></code> 组件再次运行时，我们都会持续地向 <code>items</code> 数组追加 <code>friends</code>，这会产生多个重复的结果。<code>&#x3C;FriendList /></code> <a href="#how-does-react-run-your-code">在渲染中</a> 具有了可观察的副作用，所以违反了规则。</section><section class="level4"aria-labelledby="延迟初始化-lazy-initialization"><h4 id="延迟初始化-lazy-initialization">延迟初始化 {/<em>lazy-initialization</em>/}</h4><p>即使不是完全“纯粹”的，延迟初始化也是完全可以接受的：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ExpenseForm</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">SuperCalculator</span><span class="token punctuation">.</span><span class="token method function property-access">initializeIfNotReady</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 正确的：如果它对其他组件没有影响。</span>
  <span class="token comment">// Continue rendering...</span>
<span class="token punctuation">}</span></code></pre></section><section class="level4"aria-labelledby="改变-dom-changing-the-dom"><h4 id="改变-dom-changing-the-dom">改变 DOM {/<em>changing-the-dom</em>/}</h4><p>在 React 组件的渲染逻辑中不允许有直接对用户可见的副作用。换句话说，仅仅调用一个组件函数本身不应当在屏幕上产生变化。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ProductDetailPage</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> product <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> product<span class="token punctuation">.</span><span class="token property-access">title</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 错误的：改变 DOM</span>
<span class="token punctuation">}</span></code></pre><p>要在渲染之外更新 <code>window.title</code> 的一个方法是 <a href="/learn/synchronizing-with-effects">将组件与 <code>window</code> 进行同步</a>。<p>只要多次调用组件是安全的，并且不会影响其他组件的渲染，React 就不会在意组件是否在严格的函数式编程意义上是百分之百纯粹的。更重要的是，<a href="/reference/rules/components-and-hooks-must-be-pure">组件必须是幂等的</a>。</section></section></note></section><section class="level2"aria-labelledby="props-和-state-是不可变的-props-and-state-are-immutable"><h2 id="props-和-state-是不可变的-props-and-state-are-immutable">props 和 state 是不可变的 {/<em>props-and-state-are-immutable</em>/}</h2><p>组件的 props 和 state 是不可变的 <a href="learn/state-as-a-snapshot">快照</a>。永远不要直接修改它们。相反，你应该向下传递新的属性，以及使用 <code>useState</code> 提供的 setter 函数。<p>你可以将 props 和 state 视为在渲染后更新的快照。因此，你不会直接修改 props 或 state，相反，你传递新的 props，或者使用提供给你的 setter 函数来告诉 React，state 需要在下一次组件渲染时更新。<section class="level3"aria-labelledby="不要修改-props-props"><h3 id="不要修改-props-props">不要修改 props {/<em>props</em>/}</h3><p>props 是不可变的，因为如果你改变了它们，应用程序可能会产生不一致的结果，这会让调试变得困难，因为程序可能会在某些情况下工作，而在另一些情况下不工作。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Post</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> item <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  item<span class="token punctuation">.</span><span class="token property-access">url</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Url</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token property-access">url</span><span class="token punctuation">,</span> base<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 错误的：永远不要直接修改 props</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Link</span> url<span class="token operator">=</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span><span class="token property-access">url</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>item<span class="token punctuation">.</span><span class="token property-access">title</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Link</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Post</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> item <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Url</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token property-access">url</span><span class="token punctuation">,</span> base<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 正确的：创建一个新的副本替代</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Link</span> url<span class="token operator">=</span><span class="token punctuation">{</span>url<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>item<span class="token punctuation">.</span><span class="token property-access">title</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Link</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></section><section class="level3"aria-labelledby="不要修改-state-state"><h3 id="不要修改-state-state">不要修改 state {/<em>state</em>/}</h3><p><code>useState</code> 返回一个 state 和一个用于更新该状态的 setter。<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>stateVariable<span class="token punctuation">,</span> setter<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>我们不应该直接在 state 变量上进行更新，而应该使用 <code>useState</code> 返回的 setter 函数来进行更新。如果在 state 变量上直接修改值，并不会导致组件界面更新，这样用户界面就会显示过时的信息。通过使用 setter 函数，我们告诉 React 状态已经发生了变化，需要进行重新渲染，以便更新用户界面。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Counter</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 错误的：永远不要直接修改 state</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token maybe-class-name">You</span> pressed me <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Counter</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 正确的：使用由 useState 返回的 setter 函数来修改 state。</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token maybe-class-name">You</span> pressed me <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></section></section><section class="level2"aria-labelledby="hook-的返回值和参数是不可变的-return-values-and-arguments-to-hooks-are-immutable"><h2 id="hook-的返回值和参数是不可变的-return-values-and-arguments-to-hooks-are-immutable">Hook 的返回值和参数是不可变的 {/<em>return-values-and-arguments-to-hooks-are-immutable</em>/}</h2><p>一旦值被传递给 Hook，就不应该再对它们进行修改。就像在 JSX 中的 props 一样，当值被传递给 Hook 时，它们就应该是不可变的了。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">useIconStyle</span><span class="token punctuation">(</span><span class="token parameter">icon</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span><span class="token maybe-class-name">ThemeContext</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>icon<span class="token punctuation">.</span><span class="token property-access">enabled</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    icon<span class="token punctuation">.</span><span class="token property-access">className</span> <span class="token operator">=</span> <span class="token function">computeStyle</span><span class="token punctuation">(</span>icon<span class="token punctuation">,</span> theme<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 错误的：永远不要直接修改 Hook 的参数。</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> icon<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">useIconStyle</span><span class="token punctuation">(</span><span class="token parameter">icon</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span><span class="token maybe-class-name">ThemeContext</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> newIcon <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span>icon <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 正确的：创建一个新的副本替代</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>icon<span class="token punctuation">.</span><span class="token property-access">enabled</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    newIcon<span class="token punctuation">.</span><span class="token property-access">className</span> <span class="token operator">=</span> <span class="token function">computeStyle</span><span class="token punctuation">(</span>icon<span class="token punctuation">,</span> theme<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> newIcon<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>在 React 中有一个重要的原则叫做局部推理，即通过单独查看组件或 Hook 的代码，就能理解它的作用。当调用 Hook 时，应该把它们当作“黑盒子”。例如，自定义 Hook 可能使用其参数作为依赖项，在内部缓存值：<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">useIconStyle</span><span class="token punctuation">(</span><span class="token parameter">icon</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span><span class="token maybe-class-name">ThemeContext</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> newIcon <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span>icon <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>icon<span class="token punctuation">.</span><span class="token property-access">enabled</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newIcon<span class="token punctuation">.</span><span class="token property-access">className</span> <span class="token operator">=</span> <span class="token function">computeStyle</span><span class="token punctuation">(</span>icon<span class="token punctuation">,</span> theme<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> newIcon<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>icon<span class="token punctuation">,</span> theme<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>如果你改变了 Hook 的参数，那么自定义 Hook 的缓存（memoization）就会变得不正确，因此避免这样做非常重要。<pre class="language-js"><code class="language-js">style <span class="token operator">=</span> <span class="token function">useIconStyle</span><span class="token punctuation">(</span>icon<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// `style` 是基于 `icon` 进行记忆化的</span>
icon<span class="token punctuation">.</span><span class="token property-access">enabled</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>               <span class="token comment">// 错误的： 🔴 永远不要直接修改 Hook 的参数</span>
style <span class="token operator">=</span> <span class="token function">useIconStyle</span><span class="token punctuation">(</span>icon<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 返回之前记忆化的结果</span></code></pre><pre class="language-js"><code class="language-js">style <span class="token operator">=</span> <span class="token function">useIconStyle</span><span class="token punctuation">(</span>icon<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// `style` 是基于 `icon` 进行记忆化的</span>
icon <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span>icon<span class="token punctuation">,</span> <span class="token literal-property property">enabled</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 正确的: ✅ 创建一个新的副本替代</span>
style <span class="token operator">=</span> <span class="token function">useIconStyle</span><span class="token punctuation">(</span>icon<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 计算 `style` 的新值</span></code></pre><p>同样重要的是不要修改 Hook 的返回值，因为这些值可能已经被缓存了。</section><section class="level2"aria-labelledby="不要改变传递给-jsx-后的值-values-are-immutable-after-being-passed-to-jsx"><h2 id="不要改变传递给-jsx-后的值-values-are-immutable-after-being-passed-to-jsx">不要改变传递给 JSX 后的值 {/<em>values-are-immutable-after-being-passed-to-jsx</em>/}</h2><p>不要在 JSX 使用过值之后改变它们。应该在创建 JSX 之前完成值的更改。<p>当你在表达式中使用 JSX 时，React 可能会在组件完成渲染之前就急于计算 JSX。这意味着，如果在将值传递给 JSX 之后对它们进行更改，可能会导致 UI 过时，因为 React 不会知道需要更新组件的输出。<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Page</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> colour <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> styles <span class="token operator">=</span> <span class="token punctuation">{</span> colour<span class="token punctuation">,</span> <span class="token literal-property property">size</span><span class="token operator">:</span> <span class="token string">"large"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> header <span class="token operator">=</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Header</span> styles<span class="token operator">=</span><span class="token punctuation">{</span>styles<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
  styles<span class="token punctuation">.</span><span class="token property-access">size</span> <span class="token operator">=</span> <span class="token string">"small"</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 错误的：styles 已经在上面的 JSX 中使用了。</span>
  <span class="token keyword">const</span> footer <span class="token operator">=</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Footer</span> styles<span class="token operator">=</span><span class="token punctuation">{</span>styles<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token punctuation">{</span>header<span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Content</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token punctuation">{</span>footer<span class="token punctuation">}</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Page</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> colour <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> headerStyles <span class="token operator">=</span> <span class="token punctuation">{</span> colour<span class="token punctuation">,</span> <span class="token literal-property property">size</span><span class="token operator">:</span> <span class="token string">"large"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> header <span class="token operator">=</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Header</span> styles<span class="token operator">=</span><span class="token punctuation">{</span>headerStyles<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> footerStyles <span class="token operator">=</span> <span class="token punctuation">{</span> colour<span class="token punctuation">,</span> <span class="token literal-property property">size</span><span class="token operator">:</span> <span class="token string">"small"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 正确的：我们创建了一个新的值。</span>
  <span class="token keyword">const</span> footer <span class="token operator">=</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Footer</span> styles<span class="token operator">=</span><span class="token punctuation">{</span>footerStyles<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token punctuation">{</span>header<span class="token punctuation">}</span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Content</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token punctuation">{</span>footer<span class="token punctuation">}</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><span style="float:footnote"><a href="../../index.html#toc">Go to TOC</a></span></section></inlinetoc></section>