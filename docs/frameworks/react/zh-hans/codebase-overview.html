<!doctypehtml><html lang="zh-hans"><meta charset="utf-8"><title>源码概览</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="源码概览"class="level1"><h1>源码概览</h1><p>本节将对 React 的源码架构，约定及其实现进行概述。<p>如果您想<a href="./how-to-contribute.html">参与 React</a> 的开发，我们希望这份指南可以帮助你更加轻松地进行修改。<p>我们并不推荐在 React 应用中遵循这些约定。有许多约定是历史原因，并且之后也许会有所修改。<section id="top-level-folders"class="level3"><h3>项目根目录</h3><p>当克隆 <a href="https://github.com/facebook/react">React 仓库</a>之后，你们将看到项目根目录的信息：<ul><li><a href="https://github.com/facebook/react/tree/main/packages"><code>packages</code></a> 包含元数据（比如 <code>package.json</code>）和 React 仓库中所有 package 的源码（子目录 <code>src</code>）。<strong>如果你需要修改源代码, 那么每个包的 <code>src</code> 子目录是你最需要花费精力的地方。</strong><li><a href="https://github.com/facebook/react/tree/main/fixtures"><code>fixtures</code></a> 包含一些给贡献者准备的小型 React 测试项目。<li><code>build</code> 是 React 的输出目录。源码仓库中并没有这个目录，但是它会在你克隆 React 并且第一次<a href="./how-to-contribute.html#development-workflow">构建它</a>之后出现。</ul><p>文档位于 <a href="https://github.com/reactjs/reactjs.org">React 仓库之外的一个独立仓库中</a>。<p>还有一些其他的顶层目录，但是它们几乎都是工具类的，并且在贡献代码时基本不会涉及。</section><section id="colocated-tests"class="level3"><h3>共置测试</h3><p>我们没有单元测试的顶层目录。而是将它们放置在所需测试文件的相同目录下的 <code>__tests__</code> 的目录之中。<p>比如，一个用于 <a href="https://github.com/facebook/react/blob/87724bd87506325fcaf2648c70fc1f43411a87be/src/renderers/dom/client/utils/setInnerHTML.js"><code>setInnerHTML.js</code></a> 的测试文件，会存放在 <a href="https://github.com/facebook/react/blob/87724bd87506325fcaf2648c70fc1f43411a87be/src/renderers/dom/client/utils/__tests__/setInnerHTML-test.js"><code>__tests__/setInnerHTML-test.js</code></a>，就在它同级目录下。</section><section id="warnings-and-invariants"class="level3"><h3>warning 和 invariant</h3><p>React 代码库直接使用 <code>console.error</code> 来展示 warnings：<pre class="language-js"><code class="language-js"><span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">error</span><span class="token punctuation">(</span><span class="token string">'Something is wrong.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>warning 仅在开发环境中启用。在生产环境中，他们会被完全剔除掉。如果你需要在生产环境禁止执行某些代码，请使用 <code>invariant</code> 模块代替 <code>warning</code>：<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> invariant <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'invariant'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">invariant</span><span class="token punctuation">(</span>
  <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">,</span>
  <span class="token string">'You shall not pass!'</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>当 <code>invariant</code> 判别条件为 <code>false</code> 时，会将 invariant 的信息作为错误抛出</strong><p>“Invariant” 用于声明 “这个条件应总为 true”。你可以把它当成一种断言。<p>保持开发和生产环境的行为相似是十分重要的，因此 <code>invariant</code> 在开发和生产环境下都会抛出错误。不同点在于在生产环境中这些错误信息会被自动替换成错误代码，这样可以让输出库文件变得更小。</section><section id="development-and-production"class="level3"><h3>开发环境与生产环境</h3><p>你可以在代码库中使用 <code>__DEV__</code> 这个伪全局变量，用于管理开发环境中需运行的代码块<p>这在编译阶段会被内联，在 CommonJS 构建中，转化成 <code>process.env.NODE_ENV !== 'production'</code> 这样的判断。<p>对于独立构建来说，在没有 minify 的构建中，它会变成 <code>true</code>，同时在 minify 的构建中，检测到的 <code>if</code> 代码块会被完全剔除。<pre class="language-js"><code class="language-js"><span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 仅在开发环境下执行的代码</span>
<span class="token punctuation">}</span></code></pre></section><section id="flow"class="level3"><h3>Flow</h3><p>我们最近将 <a href="https://flow.org/">Flow</a> 引入源码，用于类型检查。在许可证头部的注释中，标记为 <code>@flow</code> 注释的文件是已经经过类型检查的。<p>我们接受<a href="https://github.com/facebook/react/pull/7600/files">添加 Flow 注释到现有代码</a>。Flow 注释看上去像这样：<pre class="language-js"><code class="language-js"><span class="token maybe-class-name">ReactRef</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">detachRefs</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">instance</span><span class="token operator">:</span> <span class="token maybe-class-name">ReactInstance</span><span class="token punctuation">,</span>
  <span class="token literal-property property">element</span><span class="token operator">:</span> <span class="token maybe-class-name">ReactElement</span> <span class="token operator">|</span> string <span class="token operator">|</span> number <span class="token operator">|</span> <span class="token keyword null nil">null</span> <span class="token operator">|</span> <span class="token boolean">false</span><span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>如果可以的话，新代码应尽量使用 Flow 注释。 你可以运行 <code>yarn flow</code>，用 Flow 本地检查你的代码。</section><section id="multiple-packages"class="level3"><h3>Multiple Packages</h3><p>React 采用 <a href="https://danluu.com/monorepo/">monorepo</a> 的管理方式。仓库中包含多个独立的包，以便于更改可以一起联调，并且问题只会出现在同一地方。</section><section id="react-core"class="level3"><h3>React Core</h3><p>React “Core” 中包含所有<a href="./react-api.html#react">全局 <code>React</code> API</a>，比如：<ul><li><code>React.createElement()</code><li><code>React.Component</code><li><code>React.Children</code></ul><p><strong>React 核心只包含定义组件必要的 API</strong>。它不包含<a href="./reconciliation.html">协调</a>算法或者其他平台特定的代码。它同时适用于 React DOM 和 React Native 组件。<p>React 核心代码在源码的 <a href="https://github.com/facebook/react/tree/main/packages/react"><code>packages/react</code></a> 目录中。在 npm 上发布为 <a href="https://www.npmjs.com/package/react"><code>react</code></a> 包。相应的独立浏览器构建版本称为 <code>react.js</code>，它会导出一个称为 <code>React</code> 的全局对象。</section><section id="renderers"class="level3"><h3>渲染器</h3><p>React 最初只是服务于 DOM，但是这之后被改编成也能同时支持原生平台的 <a href="https://reactnative.dev/">React Native</a>。因此，在 React 内部机制中引入了“渲染器”这个概念。<p><strong>渲染器用于管理一棵 React 树，使其根据底层平台进行不同的调用。</strong><p>渲染器同样位于 <a href="https://github.com/facebook/react/tree/main/packages/"><code>packages/</code></a> 目录下：<ul><li><a href="https://github.com/facebook/react/tree/main/packages/react-dom">React DOM Renderer</a> 将 React 组件渲染成 DOM。它实现了全局 <a href="./react-dom.html"><code>ReactDOM</code>API</a>，这在npm上作为 <a href="https://www.npmjs.com/package/react-dom"><code>react-dom</code></a> 包。这也可以作为单独浏览器版本使用，称为 <code>react-dom.js</code>，导出一个 <code>ReactDOM</code> 的全局对象.<li><a href="https://github.com/facebook/react/tree/main/packages/react-native-renderer">React Native Renderer</a> 将 React 组件渲染为 Native 视图。此渲染器在 React Native 内部使用。<li><a href="https://github.com/facebook/react/tree/main/packages/react-test-renderer">React Test Renderer</a> 将 React 组件渲染为 JSON 树。这用于 <a href="https://facebook.github.io/jest">Jest</a> 的<a href="https://facebook.github.io/jest/blog/2016/07/27/jest-14.html">快照测试</a>特性。在 npm 上作为 <a href="https://www.npmjs.com/package/react-test-renderer">react-test-renderer</a> 包发布。</ul><p>另外一个官方支持的渲染器的是 <a href="https://github.com/facebook/react/tree/main/packages/react-art"><code>react-art</code></a>。它曾经是一个独立的 <a href="https://github.com/reactjs/react-art">GitHub 仓库</a>，但是现在我们将此加入了主源代码树。<blockquote><p><strong>注意:</strong><p>严格说来，<a href="https://github.com/facebook/react/tree/main/packages/react-native-renderer"><code>react-native-renderer</code></a> 实现了 React 和 React Native 的连接。真正渲染 Native 视图的平台特定代码及组件都存储在 <a href="https://github.com/facebook/react-native">React Native 仓库</a>中。</blockquote></section><section id="reconcilers"class="level3"><h3>reconcilers</h3><p>即便 React DOM 和 React Native 渲染器的区别很大，但也需要共享一些逻辑。特别是<a href="./reconciliation.html">协调</a>算法需要尽可能相似，这样可以让声明式渲染，自定义组件，state，生命周期方法和 refs 等特性，保持跨平台工作一致。<p>为了解决这个问题，不同的渲染器彼此共享一些代码。我们称 React 的这一部分为 “reconciler”。当处理类似于 <code>setState()</code> 这样的更新时，reconciler 会调用树中组件上的 <code>render()</code>，然后决定是否进行挂载，更新或是卸载操作。<p>Reconciler 没有单独的包，因为他们暂时没有公共 API。相反，它们被如 React DOM 和 React Native 的渲染器排除在外。</section><section id="stack-reconciler"class="level3"><h3>Stack reconciler</h3><p>"stack" reconciler 是 React 15 及更早的解决方案。虽然我们已经停止了对它的使用, 但是这在<a href="./implementation-notes.html">下一章节</a>有详细的文档。</section><section id="fiber-reconciler"class="level3"><h3>Fiber reconciler</h3><p>"fiber" reconciler 是一个新尝试，致力于解决 stack reconciler 中固有的问题，同时解决一些历史遗留问题。Fiber 从 React 16 开始变成了默认的 reconciler。<p>它的主要目标是：<ul><li>能够把可中断的任务切片处理。<li>能够调整优先级，重置并复用任务。<li>能够在父元素与子元素之间交错处理，以支持 React 中的布局。<li>能够在 <code>render()</code> 中返回多个元素。<li>更好地支持错误边界。</ul><p>你可以在<a href="https://github.com/acdlite/react-fiber-architecture">这里</a>和<a href="https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e">这里</a>，深入了解 React Fiber 架构。虽然这已经在 React 16 中启用了，但是 async 特性还没有默认开启。<p>源代码在 <a href="https://github.com/facebook/react/tree/main/packages/react-reconciler"><code>packages/react-reconciler</code></a> 目录下。</section><section id="event-system"class="level3"><h3>事件系统</h3><p>React 在原生事件基础上进行了封装，以抹平浏览器间差异。其源码在 <a href="https://github.com/facebook/react/tree/main/packages/react-dom/src/events"><code>packages/react-dom/src/events</code></a> 目录下。</section><section id="what-next"class="level3"><h3>下一章节学习什么？</h3><p>查看下一章节去学习 reconciler 在 pre-React 16 中的实现。我们还没有为新的 reconciler 内部原理编写文档。 <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>