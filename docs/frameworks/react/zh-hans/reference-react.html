<!doctypehtml><html lang="zh-hans"><meta charset="utf-8"><title>React 顶层 API</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="react-顶层-api"class="level1"><h1>React 顶层 API</h1><p><code>React</code> 是 React 库的入口。如果你通过使用 <code>&#x3C;script></code> 标签的方式来加载 React，则可以通过 <code>React</code> 全局变量对象来获得 React 的顶层 API。当你使用 ES6 与 npm 时，可以通过编写 <code>import React from 'react'</code> 来引入它们。当你使用 ES5 与 npm 时，则可以通过编写 <code>var React = require('react')</code> 来引入它们。<section id="overview"class="level2"><h2>概览</h2><section id="components"class="level3"><h3>组件</h3><p>使用 React 组件可以将 UI 拆分为独立且复用的代码片段，每部分都可独立维护。你可以通过子类 <code>React.Component</code> 或 <code>React.PureComponent</code> 来定义 React 组件。<ul><li><a href="#reactcomponent"><code>React.Component</code></a><li><a href="#reactpurecomponent"><code>React.PureComponent</code></a></ul><p>如果你不使用 ES6 的 class，则可以使用 <code>create-react-class</code> 模块来替代。请参阅<a href="./react-without-es6.html">不使用 ES6</a> 以获取更多详细信息。<p>React 组件也可以被定义为可被包装的函数：<ul><li><a href="#reactmemo"><code>React.memo</code></a></ul></section><section id="creating-react-elements"class="level3"><h3>创建 React 元素</h3><p>我们建议<a href="./introducing-jsx.html">使用 JSX</a> 来编写你的 UI 组件。每个 JSX 元素都是调用 <a href="#createelement"><code>React.createElement()</code></a> 的语法糖。一般来说，如果你使用了 JSX，就不再需要调用以下方法。<ul><li><a href="#createelement"><code>createElement()</code></a><li><a href="#createfactory"><code>createFactory()</code></a></ul><p>请参阅<a href="./react-without-jsx.html">不使用 JSX</a> 以获取更多详细信息。</section><section id="transforming-elements"class="level3"><h3>转换元素</h3><p><code>React</code> 提供了几个用于操作元素的 API：<ul><li><a href="#cloneelement"><code>cloneElement()</code></a><li><a href="#isvalidelement"><code>isValidElement()</code></a><li><a href="#reactchildren"><code>React.Children</code></a></ul></section><section id="fragments"class="level3"><h3>Fragments</h3><p><code>React</code> 还提供了用于减少不必要嵌套的组件。<ul><li><a href="#reactfragment"><code>React.Fragment</code></a></ul></section><section id="refs"class="level3"><h3>Refs</h3><ul><li><a href="#reactcreateref"><code>React.createRef</code></a><li><a href="#reactforwardref"><code>React.forwardRef</code></a></ul></section><section id="suspense"class="level3"><h3>Suspense</h3><p>Suspense 使得组件可以“等待”某些操作结束后，再进行渲染。目前，Suspense 仅支持的使用场景是：<a href="./code-splitting.html#reactlazy">通过 <code>React.lazy</code> 动态加载组件</a>。它将在未来支持其它使用场景，如数据获取等。<ul><li><a href="#reactlazy"><code>React.lazy</code></a><li><a href="#reactsuspense"><code>React.Suspense</code></a></ul></section><section id="transitions"class="level3"><h3>Transitions</h3><p><em>Transitions</em> 是 React 18 引入的一个全新的并发特性。它允许你将标记更新作为一个 transitions，这会告诉 React 它们可以被中断执行，并避免回到已经可见内容的 Suspense 降级方案。<ul><li><a href="#starttransition"><code>React.startTransition</code></a><li><a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a></ul></section><section id="hooks"class="level3"><h3>Hooks</h3><p><em>Hook</em> 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。Hook 拥有<a href="./hooks-intro.html">专属文档章节</a>和单独的 API 参考文档：<ul><li><a href="./hooks-reference.html#basic-hooks">基础 Hook</a><ul><li><a href="./hooks-reference.html#usestate"><code>useState</code></a><li><a href="./hooks-reference.html#useeffect"><code>useEffect</code></a><li><a href="./hooks-reference.html#usecontext"><code>useContext</code></a></ul><li><a href="./hooks-reference.html#additional-hooks">额外的 Hook</a><ul><li><a href="./hooks-reference.html#usereducer"><code>useReducer</code></a><li><a href="./hooks-reference.html#usecallback"><code>useCallback</code></a><li><a href="./hooks-reference.html#usememo"><code>useMemo</code></a><li><a href="./hooks-reference.html#useref"><code>useRef</code></a><li><a href="./hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a><li><a href="./hooks-reference.html#uselayouteffect"><code>useLayoutEffect</code></a><li><a href="./hooks-reference.html#usedebugvalue"><code>useDebugValue</code></a><li><a href="./hooks-reference.html#usedeferredvalue"><code>useDeferredValue</code></a><li><a href="./hooks-reference.html#usetransition"><code>useTransition</code></a><li><a href="./hooks-reference.html#useid"><code>useId</code></a></ul><li><a href="./hooks-reference.html#library-hooks">Library Hooks</a><ul><li><a href="./hooks-reference.html#usesyncexternalstore"><code>useSyncExternalStore</code></a><li><a href="./hooks-reference.html#useinsertioneffect"><code>useInsertionEffect</code></a></ul></ul><hr></section></section><section id="reference"class="level2"><h2>参考</h2><section id="reactcomponent-reactcomponent"class="level3"><h3><code>React.Component</code> {#reactcomponent}</h3><p><code>React.Component</code> 是使用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6 classes</a> 方式定义 React 组件的基类：<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Greeting</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token maybe-class-name">Hello</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>请参阅 <a href="./react-component.html">React.Component API 参考</a>，获取与基类 <code>React.Component</code> 相关方法和属性的详细列表。<hr></section><section id="reactpurecomponent-reactpurecomponent"class="level3"><h3><code>React.PureComponent</code> {#reactpurecomponent}</h3><p><code>React.PureComponent</code> 与 <a href="#reactcomponent"><code>React.Component</code></a> 很相似。两者的区别在于 <a href="#reactcomponent"><code>React.Component</code></a> 并未实现 <a href="./react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a>，而 <code>React.PureComponent</code> 中以浅层对比 prop 和 state 的方式来实现了该函数。<p>如果赋予 React 组件相同的 props 和 state，<code>render()</code> 函数会渲染相同的内容，那么在某些情况下使用 <code>React.PureComponent</code> 可提高性能。<blockquote><p>注意<p><code>React.PureComponent</code> 中的 <code>shouldComponentUpdate()</code> 仅作对象的浅层比较。如果对象中包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。仅在你的 props 和 state 较为简单时，才使用 <code>React.PureComponent</code>，或者在深层数据结构发生变化时调用 <a href="./react-component.html#forceupdate"><code>forceUpdate()</code></a> 来确保组件被正确地更新。你也可以考虑使用 <a href="https://immutable-js.com/">immutable 对象</a>加速嵌套数据的比较。<p>此外，<code>React.PureComponent</code> 中的 <code>shouldComponentUpdate()</code> 将跳过所有子组件树的 prop 更新。因此，请确保所有子组件也都是“纯”的组件。</blockquote><hr></section><section id="reactmemo-reactmemo"class="level3"><h3><code>React.memo</code> {#reactmemo}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token maybe-class-name">MyComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 使用 props 渲染 */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>React.memo</code> 为<a href="./higher-order-components.html">高阶组件</a>。<p>如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 <code>React.memo</code> 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。<p><code>React.memo</code> 仅检查 props 变更。如果函数组件被 <code>React.memo</code> 包裹，且其实现中拥有 <a href="./hooks-state.html"><code>useState</code></a>，<a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> 或 <a href="./hooks-reference.html#usecontext"><code>useContext</code></a> 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。<p>默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 使用 props 渲染 */</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">areEqual</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*
  如果把 nextProps 传入 render 方法的返回结果与
  将 prevProps 传入 render 方法的返回结果一致则返回 true，
  否则返回 false
  */</span>
<span class="token punctuation">}</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token maybe-class-name">MyComponent</span><span class="token punctuation">,</span> areEqual<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>此方法仅作为<strong><a href="./optimizing-performance.html">性能优化</a></strong>的方式而存在。但请不要依赖它来“阻止”渲染，因为这会产生 bug。<blockquote><p>注意<p>与 class 组件中 <a href="./react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a> 方法不同的是，如果 props 相等，<code>areEqual</code> 会返回 <code>true</code>；如果 props 不相等，则返回 <code>false</code>。这与 <code>shouldComponentUpdate</code> 方法的返回值相反。</blockquote><hr></section><section id="createelement-createelement"class="level3"><h3><code>createElement()</code> {#createelement}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">createElement</span><span class="token punctuation">(</span>
  type<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>props<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token spread operator">...</span>children<span class="token punctuation">]</span>
<span class="token punctuation">)</span></code></pre><p>创建并返回指定类型的新 <a href="./rendering-elements.html">React 元素</a>。其中的类型参数既可以是标签名字符串（如 <code>'div'</code> 或 <code>'span'</code>），也可以是 <a href="./components-and-props.html">React 组件</a> 类型 （class 组件或函数组件），或是 <a href="#reactfragment">React fragment</a> 类型。<p>使用 <a href="./introducing-jsx.html">JSX</a> 编写的代码将会被转换成使用 <code>React.createElement()</code> 的形式。如果使用了 JSX 方式，那么一般来说就不需要直接调用 <code>React.createElement()</code>。请查阅<a href="./react-without-jsx.html">不使用 JSX</a> 章节获得更多信息。<hr></section><section id="cloneelement-cloneelement"class="level3"><h3><code>cloneElement()</code> {#cloneelement}</h3><pre class="language-text"><code class="language-text">React.cloneElement(
  element,
  [config],
  [...children]
)</code></pre><p>以 <code>element</code> 元素为样板克隆并返回新的 React 元素。<code>config</code> 中应包含新的 props，<code>key</code> 或 <code>ref</code>。返回元素的 props 是将新的 props 与原始元素的 props 浅层合并后的结果。新的子元素将取代现有的子元素，如果在 <code>config</code> 中未出现 <code>key</code> 或 <code>ref</code>，那么原始元素的 <code>key</code> 和 <code>ref</code> 将被保留。<p><code>React.cloneElement()</code> 几乎等同于：<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span>element<span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>props<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token operator">></span></code></pre><p>但是，这也保留了组件的 <code>ref</code>。这意味着当通过 <code>ref</code> 获取子节点时，你将不会意外地从你祖先节点上窃取它。相同的 <code>ref</code> 将添加到克隆后的新元素中。如果存在新的 <code>ref</code> 或 <code>key</code> 将覆盖之前的。<p>引入此 API 是为了替换已弃用的 <code>React.addons.cloneWithProps()</code>。<hr></section><section id="createfactory-createfactory"class="level3"><h3><code>createFactory()</code> {#createfactory}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">createFactory</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span></code></pre><p>返回用于生成指定类型 React 元素的函数。与 <a href="#createelement"><code>React.createElement()</code></a> 相似的是，类型参数既可以是标签名字符串（像是 <code>'div'</code> 或 <code>'span'</code>），也可以是 <a href="./components-and-props.html">React 组件</a> 类型 （class 组件或函数组件），或是 <a href="#reactfragment">React fragment</a> 类型。<p>此辅助函数已废弃，建议使用 JSX 或直接调用 <code>React.createElement()</code> 来替代它。<p>如果你使用 JSX，通常不会直接调用 <code>React.createFactory()</code>。请参阅<a href="./react-without-jsx.html">不使用 JSX</a> 以获得更多信息。<hr></section><section id="isvalidelement-isvalidelement"class="level3"><h3><code>isValidElement()</code> {#isvalidelement}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">isValidElement</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span></code></pre><p>验证对象是否为 React 元素，返回值为 <code>true</code> 或 <code>false</code>。<hr></section><section id="reactchildren-reactchildren"class="level3"><h3><code>React.Children</code> {#reactchildren}</h3><p><code>React.Children</code> 提供了用于处理 <code>this.props.children</code> 不透明数据结构的实用方法。<section id="reactchildrenmap-reactchildrenmap"class="level4"><h4><code>React.Children.map</code> {#reactchildrenmap}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">[</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>在 <code>children</code> 里的每个直接子节点上调用一个函数，并将 <code>this</code> 设置为 <code>thisArg</code>。如果 <code>children</code> 是一个数组，它将被遍历并为数组中的每个子节点调用该函数。如果子节点为 <code>null</code> 或是 <code>undefined</code>，则此方法将返回 <code>null</code> 或是 <code>undefined</code>，而不会返回数组。<blockquote><p>注意<p>如果 <code>children</code> 是一个 <code>Fragment</code> 对象，它将被视为单一子节点的情况处理，而不会被遍历。</blockquote></section><section id="reactchildrenforeach-reactchildrenforeach"class="level4"><h4><code>React.Children.forEach</code> {#reactchildrenforeach}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">[</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>与 <a href="#reactchildrenmap"><code>React.Children.map()</code></a> 类似，但它不会返回一个数组。</section><section id="reactchildrencount-reactchildrencount"class="level4"><h4><code>React.Children.count</code> {#reactchildrencount}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">count</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p>返回 <code>children</code> 中的组件总数量，等同于通过 <code>map</code> 或 <code>forEach</code> 调用回调函数的次数。</section><section id="reactchildrenonly-reactchildrenonly"class="level4"><h4><code>React.Children.only</code> {#reactchildrenonly}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">only</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p>验证 <code>children</code> 是否只有一个子节点（一个 React 元素），如果有则返回它，否则此方法会抛出错误。<blockquote><p>注意：<p><code>React.Children.only()</code> 不接受 <a href="#reactchildrenmap"><code>React.Children.map()</code></a> 的返回值，因为它是一个数组而并不是 React 元素。</blockquote></section><section id="reactchildrentoarray-reactchildrentoarray"class="level4"><h4><code>React.Children.toArray</code> {#reactchildrentoarray}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">toArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p>将 <code>children</code> 这个复杂的数据结构以数组的方式扁平展开并返回，并为每个子节点分配一个 key。当你想要在渲染函数中操作子节点的集合时，它会非常实用，特别是当你想要在向下传递 <code>this.props.children</code> 之前对内容重新排序或获取子集时。<blockquote><p>注意：<p><code>React.Children.toArray()</code> 在拉平展开子节点列表时，更改 key 值以保留嵌套数组的语义。也就是说，<code>toArray</code> 会为返回数组中的每个 key 添加前缀，以使得每个元素 key 的范围都限定在此函数入参数组的对象内。</blockquote><hr></section></section><section id="reactfragment-reactfragment"class="level3"><h3><code>React.Fragment</code> {#reactfragment}</h3><p><code>React.Fragment</code> 组件能够在不额外创建 DOM 元素的情况下，让 <code>render()</code> 方法中返回多个元素。<pre class="language-javascript"><code class="language-javascript"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Fragment</span></span><span class="token operator">></span>
      <span class="token maybe-class-name">Some</span> text<span class="token punctuation">.</span>
      <span class="token operator">&#x3C;</span>h2<span class="token operator">></span><span class="token constant">A</span> heading<span class="token operator">&#x3C;</span><span class="token operator">/</span>h2<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Fragment</span></span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>你也可以使用其简写语法 <code>&#x3C;>&#x3C;/></code>。欲了解更多相关信息，请参阅 <a href="/blog/2017/11/28/react-v16.2.0-fragment-support.html">React v16.2.0: Fragments 支持改进</a>。</section><section id="reactcreateref-reactcreateref"class="level3"><h3><code>React.createRef</code> {#reactcreateref}</h3><p><code>React.createRef</code> 创建一个能够通过 ref 属性附加到 React 元素的 <a href="./refs-and-the-dom.html">ref</a>。 <code>embed:16-3-release-blog-post/create-ref-example.js</code></section><section id="reactforwardref-reactforwardref"class="level3"><h3><code>React.forwardRef</code> {#reactforwardref}</h3><p><code>React.forwardRef</code> 会创建一个React组件，这个组件能够将其接受的 <a href="./refs-and-the-dom.html">ref</a> 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：<ul><li><a href="./forwarding-refs.html#forwarding-refs-to-dom-components">转发 refs 到 DOM 组件</a><li><a href="./forwarding-refs.html#forwarding-refs-in-higher-order-components">在高阶组件中转发 refs</a></ul><p><code>React.forwardRef</code> 接受渲染函数作为参数。React 将使用 <code>props</code> 和 <code>ref</code> 作为参数来调用此函数。此函数应返回 React 节点。<p><code>embed:reference-react-forward-ref.js</code><p>在上述的示例中，React 会将 <code>&#x3C;FancyButton ref={ref}></code> 元素的 <code>ref</code> 作为第二个参数传递给 <code>React.forwardRef</code> 函数中的渲染函数。该渲染函数会将 <code>ref</code> 传递给 <code>&#x3C;button ref={ref}></code> 元素。<p>因此，当 React 附加了 ref 属性之后，<code>ref.current</code> 将直接指向 <code>&#x3C;button></code> DOM 元素实例。<p>欲了解更多相关信息，请参阅 <a href="./forwarding-refs.html">refs 转发</a>。</section><section id="reactlazy-reactlazy"class="level3"><h3><code>React.lazy</code> {#reactlazy}</h3><p><code>React.lazy()</code> 允许你定义一个动态加载的组件。这有助于缩减 bundle 的体积，并延迟加载在初次渲染时未用到的组件。<p>你可以在<a href="./code-splitting.html#reactlazy">代码分割文档</a>中学习如何使用它。查阅<a href="https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d">此文章</a>可以了解更多用法细节。<pre class="language-js"><code class="language-js"><span class="token comment">// 这个组件是动态加载的</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">SomeComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./SomeComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>请注意，渲染 <code>lazy</code> 组件依赖该组件渲染树上层的 <code>&#x3C;React.Suspense></code> 组件。这是指定加载指示器（loading indicator）的方式。</section><section id="reactsuspense-reactsuspense"class="level3"><h3><code>React.Suspense</code> {#reactsuspense}</h3><p><code>React.Suspense</code> 可以指定加载指示器（loading indicator），以防其组件树中的某些子组件尚未具备渲染条件。在未来，我们计划让 <code>Suspense</code> 处理更多的场景，如数据获取等。你可以在 <a href="/blog/2018/11/27/react-16-roadmap.html">我们的路线图</a> 了解这一点。<p>如今，懒加载组件是 <code>&#x3C;React.Suspense></code> 支持的唯一用例：<pre class="language-js"><code class="language-js"><span class="token comment">// 该组件是动态加载的</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">OtherComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./OtherComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token comment">// 显示 &#x3C;Spinner> 组件直至 OtherComponent 加载完成</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Suspense</span></span> fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Spinner</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
        <span class="token operator">&#x3C;</span><span class="token maybe-class-name">OtherComponent</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Suspense</span></span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>它已被收录在了我们的<a href="./code-splitting.html#reactlazy">代码分割指南</a>中。请注意，<code>lazy</code> 组件可以位于 <code>Suspense</code> 组件树的深处——它不必包装树中的每一个延迟加载组件。最佳实践是将 <code>&#x3C;Suspense></code> 置于你想展示加载指示器（loading indicator）的位置，而 <code>lazy()</code> 则可被放置于任何你想要做代码分割的地方。<blockquote><p>注意<p>对于已经展示给用户的内容来说，在切换回去时，展示加载指示器可能会让人困惑。有时，在准备新的 UI 时，展示 "旧" 的 UI 可能会更加友好。要做到这一点，你可以使用新的 transition API <a href="#starttransition"><code>startTransition</code></a> 和 <a href="./hooks-reference.html#usetransition"><code>useTransition</code></a> 来将标记更新为 transitions，同时避免意外的兜底方案。</blockquote><section id="服务端渲染中的-reactsuspense-reactsuspense-in-server-side-rendering"class="level4"><h4>服务端渲染中的 <code>React.Suspense</code> {#reactsuspense-in-server-side-rendering}</h4><p>在服务端渲染过程中，Suspense 边界允许你挂起，通过较小的块来刷新应用程序。 当组件挂起时，我们会安排一个低优先级的任务来渲染最近的 Suspense 边界的 fallback。如果组件在我们刷新 fallback 之前取消挂起，那么我们会发送实际内容并丢弃 fallback。</section><section id="hydrate-过程中的-reactsuspense-reactsuspense-during-hydration"class="level4"><h4>hydrate 过程中的 <code>React.Suspense</code> {#reactsuspense-during-hydration}</h4><p>Suspense 边界依赖于它们的父边界，在它们可以 hydrate 前被 hydrate，但是它们可以独立于兄弟边界进行 hydrate。边界 hydrate 前发生的事件将导致边界 hydrate 的优先级高于相邻边界的优先级。具体请参阅<a href="https://github.com/reactwg/react-18/discussions/130">讨论</a>。</section></section><section id="reactstarttransition-starttransition"class="level3"><h3><code>React.startTransition</code> {#starttransition}</h3><pre class="language-js"><code class="language-js"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">startTransition</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span></code></pre><p><code>React.startTransition</code> 让你把提供的 fallback 里面的更新标记为 transitions。这个方法是为了在 <a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a> 不可用时使用。<blockquote><p>注意：<p>过渡期的更新会被更紧急的更新取代，如点击操作。<p>过渡期的更新不会显示重新挂起内容的 fallback，允许用户在渲染更新时继续进行交互。<p><code>React.startTransition</code> 不提供 <code>isPending</code> 的标志。要跟踪过渡的待定状态，请参阅 <a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a>。 <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></blockquote></section></section></section>