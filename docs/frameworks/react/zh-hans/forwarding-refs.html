<!doctypehtml><html lang="zh-hans"><meta charset="utf-8"><title>Refs 转发</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="refs-转发"class="level1"><h1>Refs 转发</h1><p>Ref 转发是一项将 <a href="./refs-and-the-dom.html">ref</a> 自动地通过组件传递到其一子组件的技巧。对于大多数应用中的组件来说，这通常不是必需的。但其对某些组件，尤其是可重用的组件库是很有用的。最常见的案例如下所述。<section id="forwarding-refs-to-dom-components"class="level2"><h2>转发 refs 到 DOM 组件</h2><p>考虑这个渲染原生 DOM 元素 <code>button</code> 的 <code>FancyButton</code> 组件： <code>embed:forwarding-refs/fancy-button-simple.js</code><p>React 组件隐藏其实现细节，包括其渲染结果。其他使用 <code>FancyButton</code> 的组件<strong>通常不需要</strong>获取内部的 DOM 元素 <code>button</code> 的 <a href="./refs-and-the-dom.html">ref</a>。这很好，因为这防止组件过度依赖其他组件的 DOM 结构。<p>虽然这种封装对类似 <code>FeedStory</code> 或 <code>Comment</code> 这样的应用级组件是理想的，但其对 <code>FancyButton</code> 或 <code>MyTextInput</code> 这样的高可复用“叶”组件来说可能是不方便的。这些组件倾向于在整个应用中以一种类似常规 DOM <code>button</code> 和 <code>input</code> 的方式被使用，并且访问其 DOM 节点对管理焦点，选中或动画来说是不可避免的。<p><strong>Ref 转发是一个可选特性，其允许某些组件接收 <code>ref</code>，并将其向下传递（换句话说，“转发”它）给子组件。</strong><p>在下面的示例中，<code>FancyButton</code> 使用 <code>React.forwardRef</code> 来获取传递给它的 <code>ref</code>，然后转发到它渲染的 DOM <code>button</code>：<p><code>embed:forwarding-refs/fancy-button-simple-ref.js</code><p>这样，使用 <code>FancyButton</code> 的组件可以获取底层 DOM 节点 <code>button</code> 的 ref ，并在必要时访问，就像其直接使用 DOM <code>button</code> 一样。<p>以下是对上述示例发生情况的逐步解释：<ol><li>我们通过调用 <code>React.createRef</code> 创建了一个 <a href="./refs-and-the-dom.html">React ref</a> 并将其赋值给 <code>ref</code> 变量。<li>我们通过指定 <code>ref</code> 为 JSX 属性，将其向下传递给 <code>&#x3C;FancyButton ref={ref}></code>。<li>React 传递 <code>ref</code> 给 <code>forwardRef</code> 内函数 <code>(props, ref) => ...</code>，作为其第二个参数。<li>我们向下转发该 <code>ref</code> 参数到 <code>&#x3C;button ref={ref}></code>，将其指定为 JSX 属性。<li>当 ref 挂载完成，<code>ref.current</code> 将指向 <code>&#x3C;button></code> DOM 节点。</ol><blockquote><p>注意<p>第二个参数 <code>ref</code> 只在使用 <code>React.forwardRef</code> 定义组件时存在。常规函数和 class 组件不接收 <code>ref</code> 参数，且 props 中也不存在 <code>ref</code>。<p>Ref 转发不仅限于 DOM 组件，你也可以转发 refs 到 class 组件实例中。</blockquote></section><section id="note-for-component-library-maintainers"class="level2"><h2>组件库维护者的注意事项</h2><p><strong>当你开始在组件库中使用 <code>forwardRef</code> 时，你应当将其视为一个破坏性更改，并发布库的一个新的主版本。</strong> 这是因为你的库可能会有明显不同的行为（例如 refs 被分配给了谁，以及导出了什么类型），并且这样可能会导致依赖旧行为的应用和其他库崩溃。<p>出于同样的原因，当 <code>React.forwardRef</code> 存在时有条件地使用它也是不推荐的：它改变了你的库的行为，并在升级 React 自身时破坏用户的应用。</section><section id="forwarding-refs-in-higher-order-components"class="level2"><h2>在高阶组件中转发 refs</h2><p>这个技巧对<a href="./higher-order-components.html">高阶组件</a>（也被称为 HOC）特别有用。让我们从一个输出组件 props 到控制台的 HOC 示例开始： <code>embed:forwarding-refs/log-props-before.js</code><p>“logProps” HOC 透传（pass through）所有 <code>props</code> 到其包裹的组件，所以渲染结果将是相同的。例如：我们可以使用该 HOC 记录所有传递到 “fancy button” 组件的 props： <code>embed:forwarding-refs/fancy-button.js</code><p>下面的示例有一点需要注意：refs 将不会透传下去。这是因为 <code>ref</code> 不是 prop 属性。就像 <code>key</code> 一样，其被 React 进行了特殊处理。如果你对 HOC 添加 ref，该 ref 将引用最外层的容器组件，而不是被包裹的组件。<p>这意味着用于我们 <code>FancyButton</code> 组件的 refs 实际上将被挂载到 <code>LogProps</code> 组件： <code>embed:forwarding-refs/fancy-button-ref.js</code><p>幸运的是，我们可以使用 <code>React.forwardRef</code> API 明确地将 refs 转发到内部的 <code>FancyButton</code> 组件。<code>React.forwardRef</code> 接受一个渲染函数，其接收 <code>props</code> 和 <code>ref</code> 参数并返回一个 React 节点。例如： <code>embed:forwarding-refs/log-props-after.js</code></section><section id="displaying-a-custom-name-in-devtools"class="level2"><h2>在 DevTools 中显示自定义名称</h2><p><code>React.forwardRef</code> 接受一个渲染函数。React DevTools 使用该函数来决定为 ref 转发组件显示的内容。<p>例如，以下组件将在 DevTools 中显示为 “<em>ForwardRef</em>”：<p><code>embed:forwarding-refs/wrapped-component.js</code><p>如果你命名了渲染函数，DevTools 也将包含其名称（例如 “<em>ForwardRef(myFunction)</em>”）：<p><code>embed:forwarding-refs/wrapped-component-with-function-name.js</code><p>你甚至可以设置函数的 <code>displayName</code> 属性来包含被包裹组件的名称：<p><code>embed:forwarding-refs/customized-display-name.js</code> <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>