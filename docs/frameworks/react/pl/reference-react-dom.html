<!doctypehtml><html lang="pl"><meta charset="utf-8"><title>ReactDOM</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="reactdom"class="level1"><h1>ReactDOM</h1><p>Pakiet <code>react-dom</code> udostępnia metody specyficzne dla DOM, które mogą być używane na najwyższym poziomie aplikacji i, w razie potrzeby, jako "wyjście awaryjne" poza model Reacta.<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> <span class="token maybe-class-name">ReactDOM</span></span> <span class="token keyword module">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span></code></pre><p>If you use ES5 with npm, you can write:<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token maybe-class-name">ReactDOM</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'react-dom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Pakiet <code>react-dom</code> dostarcza również moduły właściwe dla aplikacji klienckich i serwerowych:<ul><li><a href="./react-dom-client.html"><code>react-dom/client</code></a><li><a href="./react-dom-server.html"><code>react-dom/server</code></a></ul><section id="overview"class="level2"><h2>Informacje ogólne</h2><p>Pakiet <code>react-dom</code> eksportuje:<ul><li><a href="#createportal"><code>createPortal()</code></a><li><a href="#flushsync"><code>flushSync()</code></a></ul><p>These <code>react-dom</code> methods are also exported, but are considered legacy:<ul><li><a href="#render"><code>render()</code></a><li><a href="#hydrate"><code>hydrate()</code></a><li><a href="#finddomnode"><code>findDOMNode()</code></a><li><a href="#unmountcomponentatnode"><code>unmountComponentAtNode()</code></a></ul><blockquote><p>Note:<p>Both <code>render</code> and <code>hydrate</code> have been replaced with new <a href="./react-dom-client.html">client methods</a> in React 18. These methods will warn that your app will behave as if it's running React 17 (learn more <a href="https://reactjs.org/link/switch-to-createroot">here</a>).</blockquote><section id="browser-support"class="level3"><h3>Wsparcie dla przeglądarek</h3><p>React wspiera wszystkie popularne przeglądarki, jednak dla starszych wersji <a href="./javascript-environment-requirements.html">wymagane są niektóre łatki</a> (ang. <em>polyfills</em>).<blockquote><p>Uwaga<p>Nie wspieramy starszych przeglądarek, które nie obsługują metod ze standardu ES5 lub mikrozadań, takich jak Internet Explorer. Twoja aplikacja może zadziałać na nich, jeśli użyjesz odpowiednich łatek, jak na przykład <a href="https://github.com/es-shims/es5-shim">es5-shim i es5-sham</a>. Pamiętaj jednak, że pójście tą drogą skazuje cię na całkowitą samodzielność.</blockquote></section></section><section id="reference"class="level2"><h2>Dokumentacja</h2><section id="createportal-createportal"class="level3"><h3><code>createPortal()</code> {#createportal}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token function">createPortal</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> container<span class="token punctuation">)</span></code></pre><p>Tworzy portal. Portale umożliwiają <a href="./portals.html">renderowanie elementów do węzła DOM istniejącego poza hierarchią danego komponentu</a> .</section><section id="flushsync-flushsync"class="level3"><h3><code>flushSync()</code> {#flushsync}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token function">flushSync</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span></code></pre><p>Wymusza synchroniczne wykonanie wszelkich aktualizacji zawartych wewnątrz przekazanej funkcji. Metoda ta jest przydatna, gdy chcemy mieć natychmiastowy dostęp do wyników tych aktualizacji.<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// Spraw, żeby ta zmiana stanu była synchroniczna.</span>
<span class="token function">flushSync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// W tym miejscu stan jest już zaktualizowany.</span></code></pre><blockquote><p>Uwaga:<p><code>flushSync</code> może mieć znaczący wpływ na wydajność aplikacji. Używaj z rozwagą.<p><code>flushSync</code> może wymusić na granicach zawieszenia (ang. <em>Suspense boundaries</em>), aby wyświetliły swój komponent zastępczy (ang. <em>fallback</em>).<p><code>flushSync</code> przed zakończeniem swojego działania może wymusić wywołanie efektów i sychroniczne zaaplikowanie wszelkich zmian z nimi związanych.<p><code>flushSync</code> może również wymusić aktualizacje spoza przekazanej funkcji. Na przykład, jeśli aktualnie przetwarzane są jakieś aktualizacje z kliknięcia na ekranie, React może również je wymusić zanim przejdzie do aktualizacji z przekazanej funkcji.</blockquote></section></section><section id="legacy-reference"class="level2"><h2>Przestarzałe funkcjonalności</h2><section id="render-render"class="level3"><h3><code>render()</code> {#render}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token function">render</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> container<span class="token punctuation">[</span><span class="token punctuation">,</span> callback<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><blockquote><p>Uwaga:<p>W wersji React 18, <code>render</code> zostało zastąpione przez <code>createRoot</code>. Aby dowiedzieć się więcej, przeczytaj sekcję o <a href="./react-dom-client.html#createroot">createRoot</a>.</blockquote><p>Renderuje element reactowy do podanego kontenera w drzewie DOM i zwraca <a href="./more-about-refs.html">referencję</a> do komponentu (lub zwraca <code>null</code> dla <a href="./components-and-props.html#function-and-class-components">komponentów bezstanowych</a>).<p>Jeśli element reactowy był już wcześniej renderowany do kontenera <code>container</code>, zostanie on automatycznie zaktualizowany przez Reacta, który odpowiednio zmodyfikuje DOM tak, aby odzwierciedlić najnowszą wersję komponentu.<p>Jeśli w argumencie <code>callback</code> przekażesz funkcję zwrotną, zostanie ona wywołana po wyrenderowaniu lub zaktualizowaniu komponentu.<blockquote><p>Uwaga:<p><code>render()</code> kontroluje zawartość podanego węzła kontenera. Po pierwszym wywołaniu zastępowane są wszystkie elementy DOM wewnątrz niego. Każde kolejne wywołania, z pomocą reactowego algorytmu różnicującego, efektywnie aktualizują drzewo.<p><code>render()</code> nie modyfikuje węzła kontenera (jedynie jego elementy potomne). Możliwe jest wstawienie komponentu do istniejącego węzła DOM bez nadpisywania istniejących elementów podrzędnych.<p><code>render()</code> obecnie zwraca referencję do instancji klasy <code>ReactComponent</code>, będącej korzeniem drzewa. Jednak używanie tej referencji jest uznawane za przestarzałą praktykę i należy jej unikać, ponieważ przyszłe wersje Reacta mogą w niektórych przypadkach renderować komponenty asynchronicznie. Jeśli potrzebujesz referencji do instancji korzenia, sugerujemy przekazanie do niego <a href="./refs-and-the-dom.html#callback-refs">referencyjnej funkcji zwrotnej</a>.<p>Używanie <code>render()</code> do hydratacji (ang. <em>hydrating</em>) kontenera renderowanego po stronie serwera jest przestarzałą praktyką. Zamiast tego użyj funkcji <a href="./react-dom-client.html#hydrateroot"><code>hydrateRoot()</code></a>.</blockquote></section><section id="hydrate-hydrate"class="level3"><h3><code>hydrate()</code> {#hydrate}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token function">hydrate</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> container<span class="token punctuation">[</span><span class="token punctuation">,</span> callback<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><blockquote><p>Uwaga:<p>W Reakcie 18 funkcja <code>hydrate</code> została zastąpiona przez <code>hydrateRoot</code>. Aby dowiedzieć się więcej, przeczytaj sekcję o <a href="./react-dom-client.html#hydrateroot">hydrateRoot</a>.</blockquote><p>Działa podobnie do funkcji <a href="#render"><code>render()</code></a>, ale służy do odtworzenia kontenera, którego struktura HTML została wyrenderowana przez <a href="./react-dom-server.html"><code>ReactDOMServer</code></a>. React podejmie próbę dołączenia detektorów zdarzeń do istniejących elementów.<p>React oczekuje, że renderowana treść będzie identyczna między serwerem a klientem. Potrafi, co prawda, poprawić różnice w treści tekstu, ale należy traktować niedopasowania jako błędy i zawsze je naprawiać. W trybie deweloperskim React ostrzega przed niedopasowaniem podczas procesu odtwarzania struktury. Nie ma gwarancji, że różnice w atrybutach zostaną odpowiednio poprawione w przypadku niedopasowania. Jest to ważne ze względu na wydajność, ponieważ w większości aplikacji niedopasowania są rzadkie, a zatem sprawdzenie wszystkich znaczników byłoby zbyt kosztowne obliczeniowo.<p>Jeśli któryś z atrybutów elementu lub treść tekstu intencjonalnie różnią się między serwerem a klientem (jak w przypadku znacznika czasu), możesz wyłączyć ostrzeżenie, dodając do elementu atrybut <code>suppressHydrationWarning={true}</code>. Działa to tylko na tym konkretnym elemencie i jest swego rodzaju "wyjściem awaryjnym". Nie nadużywaj go. O ile nie jest to treść tekstowa, React nie będzie próbował na siłę nanosić poprawek, więc wartość może pozostać niespójna do momentu jej kolejnej aktualizacji.<p>Jeśli potrzebujesz celowo renderować coś innego po stronie serwera i klienta, możesz wykonać renderowanie dwuprzebiegowe. Komponenty, które renderują coś innego po stronie klienta, mogą bazować na zmiennej stanu, np. <code>this.state.isClient</code>, którą można ustawić na <code>true</code> w metodzie <code>componentDidMount()</code>. W ten sposób początkowe renderowania zwróci tę samą zawartość co serwer, unikając niedopasowania. Jednak zaraz po odtworzeniu struktury w sposób synchroniczny nastąpi dodatkowe renderowanie. Zauważ, że to podejście spowolni działanie komponentów, ponieważ będą musiały być renderowane dwukrotnie - dlatego używaj go z rozwagą.<p>Pamiętaj, aby zwrócić uwagę na tzw. "user experience" użytkowników z wolnym połączeniem internetowym. Kod javascriptowy może załadować się znacznie później niż nastąpi pierwsze renderowanie kodu HTML. Z tego powodu, jeśli wyrenderujesz coś innego podczas przebiegu po stronie klienta, strona może się "przycinać". Możliwe, że w tej sytuacji pomoże wyrenderowanie "powłoki" (ang. <em>shell</em>) aplikacji po stronie serwera, a w kliencie wyświetlenie jedynie dodatkowych widgetów. Aby dowiedzieć się, jak to zrobić, nie napotykając problemów związanych z niedopasowaniem znaczników, zapoznaj się z wyjaśnieniem zawartym w poprzednim akapicie.</section><section id="unmountcomponentatnode-unmountcomponentatnode"class="level3"><h3><code>unmountComponentAtNode()</code> {#unmountcomponentatnode}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token function">unmountComponentAtNode</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>Uwaga:<p>W Reakcie 18 funkcja <code>unmountComponentAtNode</code> została zastąpiona przez <code>root.unmount()</code>. Aby dowiedzieć się więcej, przeczytaj sekcję o <a href="./react-dom-client.html#createroot">createRoot</a>.</blockquote><p>Usuwa zamontowany komponent z drzewa DOM, usuwając jego stan i procedury obsługi zdarzeń. Jeśli we wskazanym kontenerze nie zamontowano jeszcze żadnego elementu, wywoływanie tej funkcji nie daje żadnego efektu. Zwraca <code>true</code>, jeśli komponent został odmontowany lub <code>false</code>, jeśli kontener był pusty.</section><section id="finddomnode-finddomnode"class="level3"><h3><code>findDOMNode()</code> {#finddomnode}</h3><blockquote><p>Uwaga:<p><code>findDOMNode</code> jest swego rodzaju "wyjściem awaryjnym", za pomocą którego możemy uzyskać dostęp do szukanego węzła DOM. Odradzamy korzystania z tej funkcji, ponieważ zaburza ona abstrakcję struktury komponentów. <a href="./strict-mode.html#warning-about-deprecated-finddomnode-usage">Została wycofana w <code>StrictMode</code>.</a></blockquote><pre class="language-javascript"><code class="language-javascript"><span class="token function">findDOMNode</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span></code></pre><p>Jeśli wskazany komponent został zamontowany w drzewie DOM, funkcja zwróci odpowiadający mu natywny element DOM. Przydaje się do odczytywania wartości z drzewa DOM, np. danych z pól formularza lub wymiarów interfejsu. <strong>W większości przypadków wystarczy jednak "podpiąć" się do węzła DOM za pomocą właściwości <code>ref</code>, całkowicie unikając stosowania funkcji <code>findDOMNode</code>.</strong><p>Jeśli komponent renderuje <code>null</code> lub <code>false</code>, <code>findDOMNode</code> zwróci <code>null</code>. Jeśli renderuje ciąg znaków, <code>findDOMNode</code> zwróci tekst danego węzła DOM. Od Reakta w wersji 16 w górę komponenty mogą również zwracać tzw. fragmenty, zawierające kilku potomków. W takim przypadku <code>findDOMNode</code> zwróci węzeł DOM odpowiadający pierwszemu niepustemu potomkowi.<blockquote><p>Uwaga:<p><code>findDOMNode</code> działa tylko na zamontowanych komponentach (czyli takich, które zostały umieszczone w drzewie DOM). Jeśli spróbujesz wywołać tę funkcję na niezamontowanym komponencie (np. jeśli wywołasz <code>findDOMNode()</code> w metodzie <code>render</code> komponentu, który jeszcze nie został utworzony), zostanie zgłoszony wyjątek.<p><code>findDOMNode</code> nie może być używane w komponentach funkcyjnych.</blockquote><hr><p><span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section></section>