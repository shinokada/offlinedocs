<!doctypehtml><html lang="pl"><meta charset="utf-8"><title>Hooki - FAQ</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="hooki---faq"class="level1"><h1>Hooki - FAQ</h1><p><em>Hooki</em> są nowym dodatkiem do Reacta w wersji 16.8. Pozwalają na użycie stanu i innych funkcji Reacta bez konieczności pisania klas.<p>Ta strona odpowiada na najczęściej zadawane pytania odnośnie <a href="./hooks-overview.html">hooków</a>.<ul><li><strong><a href="#adoption-strategy">Strategia wdrażania</a></strong><ul><li><a href="#which-versions-of-react-include-hooks">Które wersje Reacta wspierają hooki?</a><li><a href="#do-i-need-to-rewrite-all-my-class-components">Czy muszę przepisać wszystkie komponenty klasowe?</a><li><a href="#what-can-i-do-with-hooks-that-i-couldnt-with-classes">Co mogę zrobić z hookami, czego nie można było zrobić z klasami?</a><li><a href="#how-much-of-my-react-knowledge-stays-relevant">Jaka część mojej wiedzy o Reakcie jest nadal aktualna?</a><li><a href="#should-i-use-hooks-classes-or-a-mix-of-both">Czy lepiej używać hooków, klas, czy może mieszać obydwa sposoby?</a><li><a href="#do-hooks-cover-all-use-cases-for-classes">Czy hooki obejmują wszystkie przypadki użycia, które są dostępne dla klas?</a><li><a href="#do-hooks-replace-render-props-and-higher-order-components">Czy hooki zastępują "właściwości renderujące" i komponenty wyższego rzędu?</a><li><a href="#what-do-hooks-mean-for-popular-apis-like-redux-connect-and-react-router">Co hooki oznaczają dla popularnych API, takich jak <code>connect()</code> z Reduxa lub React Router?</a><li><a href="#do-hooks-work-with-static-typing">Czy hooki współpracują ze statycznym typowaniem?</a><li><a href="#how-to-test-components-that-use-hooks">Jak testować komponenty, które używają hooków?</a><li><a href="#what-exactly-do-the-lint-rules-enforce">Co dokładnie narzucają reguły lintera?</a></ul><li><strong><a href="#from-classes-to-hooks">Od klas do hooków</a></strong><ul><li><a href="#how-do-lifecycle-methods-correspond-to-hooks">Jak wyglądają metody cyklu życia w odniesieniu do hooków?</a><li><a href="#how-can-i-do-data-fetching-with-hooks">Jak mogę pobrać dane wykorzystując hooki?</a><li><a href="#is-there-something-like-instance-variables">Czy istnieje coś podobnego do zmiennych instancji?</a><li><a href="#should-i-use-one-or-many-state-variables">Lepiej używać jednej czy wielu zmiennych stanu?</a><li><a href="#can-i-run-an-effect-only-on-updates">Czy mogę uruchomić efekt tylko podczas aktualizacji komponentu?</a><li><a href="#how-to-get-the-previous-props-or-state">Jak dostać poprzednie właściwości lub stan?</a><li><a href="#why-am-i-seeing-stale-props-or-state-inside-my-function">Dlaczego widzę nieaktualne właściwości lub stan wewnątrz mojej funkcji?</a><li><a href="#how-do-i-implement-getderivedstatefromprops">Jak zaimplementować <code>getDerivedStateFromProps</code>?</a><li><a href="#is-there-something-like-forceupdate">Czy istnieje coś takiego jak forceUpdate?</a><li><a href="#can-i-make-a-ref-to-a-function-component">Czy mogę stworzyć referencję do komponentu funkcyjnego?</a><li><a href="#how-can-i-measure-a-dom-node">Jak mogę zmierzyć węzeł DOM?</a><li><a href="#what-does-const-thing-setthing--usestate-mean">Co oznacza <code>const [thing, setThing] = useState()</code>?</a></ul><li><strong><a href="#performance-optimizations">Optymalizacja wydajności</a></strong><ul><li><a href="#can-i-skip-an-effect-on-updates">Czy mogę pominąć efekt podczas aktualizacji komponentu?</a><li><a href="#is-it-safe-to-omit-functions-from-the-list-of-dependencies">Czy bezpiecznie jest pomijać funkcje w liście zależności?</a><li><a href="#what-can-i-do-if-my-effect-dependencies-change-too-often">Co zrobić, gdy zależności mojego efektu zmieniają się zbyt często?</a><li><a href="#how-do-i-implement-shouldcomponentupdate">Jak zaimplementować <code>shouldComponentUpdate</code>?</a><li><a href="#how-to-memoize-calculations">Jak memoizować obliczenia?</a><li><a href="#how-to-create-expensive-objects-lazily">Jak w leniwy sposób tworzyć "ciężkie" obiekty?</a><li><a href="#are-hooks-slow-because-of-creating-functions-in-render">Czy hooki są wolne z powodu tworzenia funkcji podczas renderowania?</a><li><a href="#how-to-avoid-passing-callbacks-down">Jak unikać przekazywania funkcji zwrotnych w dół?</a><li><a href="#how-to-read-an-often-changing-value-from-usecallback">Jak odczytywać często zmieniającą się wartość z <code>useCallback</code>?</a></ul><li><strong><a href="#under-the-hood">Pod maską</a></strong><ul><li><a href="#how-does-react-associate-hook-calls-with-components">Jak React łączy wywołania hooków z komponentami?</a><li><a href="#what-is-the-prior-art-for-hooks">Skąd wziął się pomysł na stworzenie hooków?</a></ul></ul><section id="adoption-strategy"class="level2"><h2>Strategia wdrażania</h2><section id="which-versions-of-react-include-hooks"class="level3"><h3>Które wersje Reacta wspierają hooki?</h3><p>Zaczynając od wersji 16.8.0, React zawiera stabilną implementację hooków dla:<ul><li>React DOM<li>React Native<li>React DOM Server<li>React Test Renderer<li>React Shallow Renderer</ul><p>Zauważ, że <strong>aby włączyć hooki, wszystkie paczki Reacta muszą mieć wersję 16.8.0 lub wyższą</strong>. Hooki nie zadziałają, jeżeli zapomnisz zaktualizować, na przykład, React DOM.<p><a href="https://reactnative.dev/blog/2019/03/12/releasing-react-native-059">React Native wspiera hooki od wersji 0.59</a>.</section><section id="do-i-need-to-rewrite-all-my-class-components"class="level3"><h3>Czy muszę przepisać wszystkie komponenty klasowe?</h3><p>Nie. <a href="./hooks-intro.html#gradual-adoption-strategy">Nie ma planów</a> na usunięcie klas z Reacta -- wszyscy musimy stale dostarczać nasze produkty i nie możemy sobie pozwolić na ich przepisywanie. Zachęcamy do wypróbowania hooków w nowym kodzie.</section><section id="what-can-i-do-with-hooks-that-i-couldnt-with-classes"class="level3"><h3>Co mogę zrobić z hookami, czego nie można było zrobić z klasami?</h3><p>Hooki oferują nowy, potężny i ekspresyjny sposób na wielokrotne używanie funkcjonalności w komponentach. Rozdział pt. <a href="./hooks-custom.html">"Tworzenie własnych hooków"</a> zawiera szybki wgląd w to, co można za ich pomocą zrobić. <a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889">Ten artykuł</a>, napisany przez jednego z głównych członków zespołu Reacta, zawiera bardziej szczegółowe informacje o nowych możliwościach, które pojawiły się wraz z hookami.</section><section id="how-much-of-my-react-knowledge-stays-relevant"class="level3"><h3>Jaka część mojej wiedzy o Reakcie jest nadal aktualna?</h3><p>Hooki są bardziej bezpośrednim sposobem na użycie dobrze już znanych funkcjonalności Reacta, takich jak na przykład: stan, cykl życia (ang. <em>lifecycle</em>), kontekst i referencje (ang. <em>refs</em>). Nie zmieniają podstaw działania Reacta, dlatego też twoja wiedza na temat komponentów, właściwości (ang. <em>props</em>) i przepływu danych z góry w dół pozostaje ciągle aktualna.<p>Hooki, same w sobie, posiadają pewną krzywą uczenia się. Jeżeli brakuje czegoś w tej dokumentacji, <a href="https://github.com/reactjs/reactjs.org/issues/new">zgłoś problem</a>, a my postaramy się pomóc.</section><section id="should-i-use-hooks-classes-or-a-mix-of-both"class="level3"><h3>Czy lepiej używać hooków, klas, czy może mieszać obydwa sposoby?</h3><p>Zachęcamy do wypróbowania hooków w nowych komponentach. Upewnij się, że wszyscy z twojego zespołu wiedzą, jak ich używać i są zapoznani z tą dokumentacją. Nie zalecamy przepisywania istniejących klas na hooki, chyba że z jakiegoś powodu i tak mieliście to w planach (na przykład w celu naprawy istniejących błędów).<p>Nie możesz używać hooków <em>wewnątrz</em> komponentów klasowych, jednakże bez obaw możesz mieszać komponenty klasowe i funkcyjne z hookami w tym samym drzewie. To, czy komponent jest klasowy, czy funkcyjny i używa hooków, jest detalem implementacyjnym tego komponentu. W dłuższej perspektywie oczekujemy, że hooki będą głównym sposobem pisania komponentów reactowych.</section><section id="do-hooks-cover-all-use-cases-for-classes"class="level3"><h3>Czy hooki obejmują wszystkie przypadki użycia, które są dostępne dla klas?</h3><p>Naszym celem dla hooków jest zapewnienie wszystkich przypadków użycia klas, tak szybko jak to tylko możliwe. Brakuje jeszcze odpowiedników dla kilku rzadziej używanych metod cyklu życia komponentu, takich jak <code>getSnapshotBeforeUpdate</code>, <code>getDerivedStateFromError</code> i <code>componentDidCatch</code>, ale zamierzamy je wkrótce dodać.</section><section id="do-hooks-replace-render-props-and-higher-order-components"class="level3"><h3>Czy hooki zastępują "właściwości renderujące" i komponenty wyższego rzędu?</h3><p>Zazwyczaj właściwości renderujace i komponenty wyższego rzędu renderują tylko pojedynczy komponent potomny. Sądzimy, że hooki są prostszym sposobem na obsługę tego przypadku użycia. Nadal jest miejsce dla obu wzorców (dla przykładu, wirtualny komponent do obsługi suwaka może mieć właściwość <code>renderItem</code>, a prezentacyjny komponent kontenera może mieć swoją własną strukturę DOM). Jednak w większości przypadków hooki w zupełności wystarczą, a przy okazji pomogą zmniejszyć liczbę zagnieżdżeń w drzewie.</section><section id="what-do-hooks-mean-for-popular-apis-like-redux-connect-and-react-router"class="level3"><h3>Co hooki oznaczają dla popularnych API, takich jak Redux connect() i React Router?</h3><p>Możesz używać tych samych API, co do tej pory - będą nadal działać.<p>React Redux od wersji v7.1.0 <a href="https://react-redux.js.org/api/hooks">posiada wsparcie dla API hooków</a> i udostępnia takie funkcje, jak <code>useDispatch</code> czy <code>useSelector</code>.<p>React Router <a href="https://reacttraining.com/react-router/web/api/Hooks">wspiera hooki</a> od wersji 5.1.<p>W przyszłości być może także inne biblioteki zaczną wspierać hooki.</section><section id="do-hooks-work-with-static-typing"class="level3"><h3>Czy hooki współpracują ze statycznym typowaniem?</h3><p>Hooki zostały zaprojektowane z myślą o statycznym typowaniu. Dzięki temu, że są funkcjami, łatwiej jest je poprawnie otypować, w odróżnieniu od wzorców takich jak komponenty wyższego rzędu. Najnowsze definicje Reacta dla Flow i TypeScriptu wspierają hooki.<p>Co ważne, przy pomocy bardziej restrykcyjnych typów możesz ograniczyć API Reacta we własnych hookach. React dostarcza podstawowe elementy, ale możesz je łączyć na różne sposoby, odmienne od tych, które zawarliśmy w standardzie.</section><section id="how-to-test-components-that-use-hooks"class="level3"><h3>Jak testować komponenty, które używają hooków?</h3><p>Z punktu widzenia Reacta komponent wykorzystujący hooki jest zwyczajnym komponentem. Jeżeli twoje narzędzie do testów nie opiera się na wewnętrznej implementacji Reacta, to testowanie komponentów, które używają hooków, nie powinno różnić się od tego, co robisz zazwyczaj.<blockquote><p>Uwaga<p>W rozdziale pt. <a href="./testing-recipes.html">"Testy: Przykłady i dobre praktyki"</a> znajdziesz wiele przykładów gotowych do użycia.</blockquote><p>Dla przykładu, załóżmy, że mamy komponent licznika:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Example</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Kliknięto </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> razy</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token maybe-class-name">Kliknięto</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span> razy<span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Kliknij</span> mnie
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Przetestujemy go używając React DOM. Aby upewnić się, że zachowanie komponentu odzwierciedla to w przeglądarce, opakujemy kod renderujący i aktualizujący w funkcję <a href="./test-utils.html#act"><code>ReactTestUtils.act()</code></a>:<pre class="language-js{3,20-22,29-31}"><code class="language-js{3,20-22,29-31}">import React from 'react';
import ReactDOM from 'react-dom/client';
import { act } from 'react-dom/test-utils';
import Counter from './Counter';

let container;

beforeEach(() => {
  container = document.createElement('div');
  document.body.appendChild(container);
});

afterEach(() => {
  document.body.removeChild(container);
  container = null;
});

it('potrafi wyrenderować i zaktualizować licznik', () => {
  // Testuje pierwsze renderowanie i efekt
  act(() => {
    ReactDOM.createRoot(container).render(&#x3C;Counter />);
  });
  const button = container.querySelector('button');
  const label = container.querySelector('p');
  expect(label.textContent).toBe('Kliknięto 0 razy');
  expect(document.title).toBe('Kliknięto 0 razy');

  // Testuje drugie renderowanie i efekt
  act(() => {
    button.dispatchEvent(new MouseEvent('click', {bubbles: true}));
  });
  expect(label.textContent).toBe('Kliknięto 1 razy');
  expect(document.title).toBe('Kliknięto 1 razy');
});</code></pre><p>Wywołanie funkcji <code>act()</code> opróżni bufor efektów znajdujących się wewnątrz.<p>Jeżeli musisz przetestować własny hook, możesz stworzyć komponent w teście i wywołać ten hook w ciele jego funkcji. Następnie możesz napisać test do stworzonego w ten sposób komponentu.<p>Aby zmniejszyć powtarzalność kodu, zalecamy użyć biblioteki <a href="https://git.io/react-testing-library"><code>react-testing-library</code></a>. Została ona zaprojektowana tak, aby zachęcać do pisania testów używających komponentów w sposób podobny do zachowania docelowych użytkowników aplikacji.<p>Po więcej informacji zajrzyj do rozdziału pt. <a href="./testing-recipes.html">"Testy: Przykłady i dobre praktyki</a>.</section><section id="what-exactly-do-the-lint-rules-enforce"class="level3"><h3>Co dokładnie narzucają <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">reguły lintera</a>?</h3><p>Stworzyliśmy <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">wtyczkę do ESLinta</a>, która zmusza do przestrzegania <a href="./hooks-rules.html">zasad hooków</a> w celu uniknięcia potencjalnych błędów. Zakładają one, że każda funkcja zaczynająca się od "<code>use</code>" i zaraz po tym wielkiej litery jest hookiem. Zdajemy sobie sprawę, że ta heurystyka nie jest idealna i może wywołać wiele fałszywych alarmów. Ale bez wprowadzenia wspólnej dla całego ekosystemu konwencji, nie ma możliwości, aby hooki działały poprawnie -- dłuższe nazwy zniechęcą ludzi do używania hooków lub do przestrzegania tej konwencji.<p>W szczególności, reguły te wymuszają, aby:<ul><li>Wywołania hooków znajdowały się wewnątrz funkcji pisanej stylem <code>PascalCase</code> (zakładają, że jest to komponent) lub innej funkcji <code>useSomething</code> (zakładają, że jest to własny hook).<li>Hooki przy każdym renderowaniu są wywoływane w tej samej kolejności.</ul><p>Jest jeszcze kilka innych heurystyk i mogą się one z czasem zmienić, gdy dostroimy reguły tak, aby zbalansować wyszukiwanie błędów i zmniejszyć liczbę fałszywych alarmów.</section></section><section id="from-classes-to-hooks"class="level2"><h2>Od klas do hooków</h2><section id="how-do-lifecycle-methods-correspond-to-hooks"class="level3"><h3>Jak wyglądają metody cyklu życia w odniesieniu do hooków?</h3><ul><li><p><code>constructor</code>: Komponenty funkcyjne nie potrzebują konstruktora. Stan jest inicjalizowany poprzez wywołanie <a href="./hooks-reference.html#usestate"><code>useState</code></a>. Jeżeli obliczenie stanu początkowego jest kosztowne obliczeniowo, możesz do <code>useState</code> przekazać funkcję.<li><p><code>getDerivedStateFromProps</code>: Zamiast tego zaplanuj aktualizację <a href="#how-do-i-implement-getderivedstatefromprops">podczas renderowania</a>.<li><p><code>shouldComponentUpdate</code>: Spójrz na <code>React.memo</code> <a href="#how-do-i-implement-shouldcomponentupdate">poniżej</a>.<li><p><code>render</code>: Jest to ciało komponentu funkcyjnego.<li><p><code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>: Hook <a href="./hooks-reference.html#useeffect"><code>useEffect</code></a> może z powodzeniem zastąpić wszelkie kombinacje tych metod (włączając w to <a href="#can-i-skip-an-effect-on-updates">mniej</a> <a href="#can-i-run-an-effect-only-on-updates">znane</a> przypadki).<li><p><code>getSnapshotBeforeUpdate</code>, <code>componentDidCatch</code> i <code>getDerivedStateFromError</code>: W tej chwili nie istnieje hook odzwierciedlający działanie tych metod, ale zostanie wkrótce dodany.</ul></section><section id="how-can-i-do-data-fetching-with-hooks"class="level3"><h3>Jak mogę pobrać dane wykorzystując hooki?</h3><p>Tutaj znajdziesz <a href="https://codesandbox.io/s/jvvkoo8pq3">małe demo</a>, które w tym pomoże. Aby dowiedzieć się więcej, przeczytaj artykuł <a href="https://www.robinwieruch.de/react-hooks-fetch-data/">o pobieraniu danych z wykorzystaniem hooków</a>.</section><section id="is-there-something-like-instance-variables"class="level3"><h3>Czy istnieje coś podobnego do zmiennych instancji?</h3><p>Tak! Hook <a href="./hooks-reference.html#useref"><code>useRef()</code></a> nie służy tylko do przechowywania referencji DOM. Obiekt "ref" jest generycznym kontenerem, którego właściwość <code>current</code> jest zmienna i może przechowywać każdą wartość, tak samo jak właściwości instancji w klasach.<p>Możesz do niej coś zapisać z wnętrza <code>useEffect</code>:<pre class="language-js{2,8}"><code class="language-js{2,8}">function Timer() {
  const intervalRef = useRef();

  useEffect(() => {
    const id = setInterval(() => {
      // ...
    });
    intervalRef.current = id;
    return () => {
      clearInterval(intervalRef.current);
    };
  });

  // ...
}</code></pre><p>Jeżeli chcielibyśmy po prostu ustawić interwał, nie potrzebowalibyśmy referencji (<code>id</code> mogłoby być lokalne dla efektu), jednakże jest to użyteczne w przypadku, gdy chcielibyśmy wyczyścić interwał z wnętrza procedury obsługi zdarzenia:<pre class="language-js{3}"><code class="language-js{3}">  // ...
  function handleCancelClick() {
    clearInterval(intervalRef.current);
  }
  // ...</code></pre><p>Działanie referencji jest takie samo jak użycie zmiennych instancji w klasie. Jeśli nie korzystasz z <a href="#how-to-create-expensive-objects-lazily">leniwej inicjalizacji</a>, unikaj używania referencji podczas renderowania -- może to prowadzić do niepożądanych zachowań. Zamiast tego modyfikuj referencje wewnątrz efektów lub procedur obsługi zdarzeń.</section><section id="should-i-use-one-or-many-state-variables"class="level3"><h3>Lepiej używać jednej czy wielu zmiennych stanu?</h3><p>Jeżeli na co dzień piszesz komponenty klasowe, kuszące może okazać się wywoływanie <code>useState()</code> jednokrotnie i umieszczanie całego stanu wewnątrz pojedynczego obiektu. Jeżeli chcesz, możesz tak robić. Poniżej znajdziesz przykład komponentu, który śledzi ruchy kursora. Jego pozycja i stan są trzymane w lokalnym stanie:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Box</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">left</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">top</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">width</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>Teraz przyjmimy, że chcemy napisać logikę, która zmienia <code>left</code> i <code>top</code>, kiedy użytkownik ruszy myszką. Zauważ, że musimy ręcznie scalać te pola z poprzednim obiektem stanu:<pre class="language-js{4,5}"><code class="language-js{4,5}">  // ...
  useEffect(() => {
    function handleWindowMouseMove(e) {
      // Rozszczepienie "...state" zapewnia, że nie "stracimy" szerokości i wysokości
      setState(state => ({ ...state, left: e.pageX, top: e.pageY }));
    }
    // Uwaga: ta implementacja jest dość uproszczona
    window.addEventListener('mousemove', handleWindowMouseMove);
    return () => window.removeEventListener('mousemove', handleWindowMouseMove);
  }, []);
  // ...</code></pre><p>Gdy aktualizujemy zmienną stanu, <em>zamieniamy</em> jej wartość. Różni się to od <code>this.setState</code> w klasach, które <em>scala</em> zaktualizowane pola do obiektu stanu.<p>Jeżeli tęsknisz za automatycznym scalaniem, możesz napisać własny hook <code>useLegacyState</code>, który scala aktualizacje obiektu stanu. Jednak <strong>zalecamy podzielenie stanu na wiele zmiennych stanu, bazując na tym, które wartości mają tendencję do zmieniania się jednocześnie.</strong><p>Dla przykładu, możemy podzielić stan naszego komponentu na obiekty <code>position</code> oraz <code>size</code> i zawsze nadpisywać wartość <code>position</code>, bez konieczności scalania stanu z poprzednim:<pre class="language-js{2,7}"><code class="language-js{2,7}">function Box() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  const [size, setSize] = useState({ width: 100, height: 100 });

  useEffect(() => {
    function handleWindowMouseMove(e) {
      setPosition({ left: e.pageX, top: e.pageY });
    }
    // ...</code></pre><p>Oddzielanie niezależnych zmiennych stanu ma także inną zaletę. Pozwala w przyszłości łatwo wyodrębnić powiązaną logikę do własnego hooka, na przykład:<pre class="language-js{2,7}"><code class="language-js{2,7}">function Box() {
  const position = useWindowPosition();
  const [size, setSize] = useState({ width: 100, height: 100 });
  // ...
}

function useWindowPosition() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  useEffect(() => {
    // ...
  }, []);
  return position;
}</code></pre><p>Zauważ, jak mogliśmy przenieść wywołanie <code>useState</code> dla zmiennej stanu <code>position</code> i powiązany z nią efekt do własnego hooka, bez konieczności zmiany jego kodu. Jeżeli cały stan znajdowałby się w pojedynczym obiekcie, wyodrębnienie go byłoby trudniejsze.<p>Zarówno umieszczanie całego stanu wewnątrz pojedynczego wywołania <code>useState</code>, jak i wywoływanie <code>useState</code> dla każdego pola, będzie działać. Komponenty będą najbardziej czytelne, jeżeli osiągniesz równowagę pomiędzy tymi dwoma skrajnościami i pogrupujesz powiązane ze sobą zmienne stany. Jeżeli logika stanu stanie się zbyt złożona, zalecamy <a href="./hooks-reference.html#usereducer">użycie reduktora</a> lub napisanie własnego hooka.</section><section id="can-i-run-an-effect-only-on-updates"class="level3"><h3>Czy mogę uruchomić efekt tylko podczas aktualizacji komponentu?</h3><p>Jest to rzadki przypadek. Jeżeli masz taką potrzebę, możesz <a href="#is-there-something-like-instance-variables">użyć zmiennej referencji</a>, aby przechować wartość logiczną, określającą czy jest to pierwsze, czy kolejne renderowanie, a następnie sprawdzać tę flagę w efekcie. (Jeżeli okaże się, że robisz to często, możesz w tym celu stworzyć własnego hooka.)</section><section id="how-to-get-the-previous-props-or-state"class="level3"><h3>Jak dostać poprzednie właściwości lub stan?</h3><p>Poprzednich właściwości i stanu możesz potrzebować w dwóch przypadkach.<p>Czasami będziesz potrzebować poprzednich właściwości, aby <strong>posprzątać po efekcie</strong>. Przykład: masz efekt, który subskrybuje się do socketu na podstawie właściwości <code>userId</code>. Jeśli wartość <code>userId</code> zmieni się, należałoby anulować subskrypcję z <em>poprzednim</em> <code>userId</code> i stworzyć nową z <em>następną</em> wartością. Aby to zrobić, nie potrzeba niczego nadzwyczajnego:<pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToSocket</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">userId</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromSocket</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">userId</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>props<span class="token punctuation">.</span><span class="token property-access">userId</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>W powyższym przykładzie, jeśli <code>userId</code> zmieni się z <code>3</code> na <code>4</code>, najpierw wywoła się <code>ChatAPI.unsubscribeFromSocket(3)</code>, a następnie <code>ChatAPI.subscribeToSocket(4)</code>. Nie ma potrzeby dostępu do "poprzedniego" <code>userId</code>, ponieważ funkcja sprzątająca uchwyci go w domknięciu (ang. <em>closure</em>).<p>Innym razem możesz potrzebować <strong>zaktualizować stan przy jakiejś zmianie właściwości lub innego stanu</strong>. Rzadko się tak zdarza i zwykle oznacza, że masz jakiś zduplikowany lub niepotrzebny kawałek stanu. Jeśli jednak naprawdę potrzebujesz skorzystać z tego wzorca, możesz <a href="#how-do-i-implement-getderivedstatefromprops">zapamiętać w stanie poprzednią wartość jakiegoś stanu lub właściwości i aktualizować ją podczas renderowania</a>.<p>Poprzednio do przechowywania poprzedniej wartości zasugerowaliśmy skorzystanie z hooka o nazwie <code>usePrevious</code>. Mimo to zauważyliśmy, że w większości przypadku mamy do czynienia z jednym z dwóch powyższych schematów. Jeśli twój przypadek jest inny, możesz <a href="#is-there-something-like-instance-variables">zapisać wartość w referencji (ang. <em>ref</em>)</a> i ręcznie aktualizować ją w razie potrzeby. Spróbuj jednak unikać odczytywania i aktualizowania referencji podczas renderowania, gdyż zmniejszy to przewidywalność i czytelność twojego komponentu.</section><section id="why-am-i-seeing-stale-props-or-state-inside-my-function"class="level3"><h3>Dlaczego widzę nieaktualne właściwości lub stan wewnątrz mojej funkcji?</h3><p>Każda funkcja wewnątrz komponentu, włączając w to procedury obsługi zdarzeń i efekty, "widzą" właściwości i stan z chwili renderowania, w którym zostały stworzone. Dla przykładu rozważ poniższy kod:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Example</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleAlertClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Kliknięto: '</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token maybe-class-name">Kliknięto</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span> razy<span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Naciśnij</span> mnie
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleAlertClick<span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Pokaż</span> okno ostrzegawcze
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Jeżeli najpierw klikniesz "Pokaż okno ostrzegawcze", a następnie zwiększysz licznik, okno ostrzegawcze wyświetli wartość zmiennej <code>count</code> <strong>z momentu kliknięcia na przycisk "Pokaż okno ostrzegawcze"</strong>. Zapobiega to błędom powodowanym przez kod zakładający, że właściwości i stan nie zmienią się w czasie.<p>Jeżeli celowo chcesz odczytać <em>najświeższy</em> stan z wnętrza asynchronicznej funkcji zwrotnej, możesz go przechowywać, zmieniać i odczytywać korzystając z <a href="./hooks-faq.html#is-there-something-like-instance-variables">referencji</a>.<p>Ostatecznie, inną możliwą przyczyną tego, że widzisz nieaktualne właściwości lub stan, może być użycie "tablicy zależności" do optymalizacji, ale niepoprawne sprecyzowanie wszystkich zależności. Dla przykładu, jeżeli efekt otrzymuje <code>[]</code> jako drugi argument, ale wewnątrz odczytuje <code>someProp</code>, efekt będzie stale "widział" początkową wartość <code>someProp</code>. Rozwiązaniem jest usunięcie tablicy zależności lub naprawienie jej. Tutaj znajdziesz informacje, <a href="#is-it-safe-to-omit-functions-from-the-list-of-dependencies">jak poradzić sobie z funkcjami</a>, a tutaj <a href="#what-can-i-do-if-my-effect-dependencies-change-too-often">inne powszechne sposoby na uruchamianie efektów rzadziej i bez błędów w zależnościach</a>.<blockquote><p>Uwaga<p>Stworzyliśmy regułę <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> dla ESLinta i dodaliśmy ją do paczki <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a>. Wtyczka ostrzega, gdy zależności są sprecyzowane niepoprawnie i zaleca poprawienie kodu.</blockquote></section><section id="how-do-i-implement-getderivedstatefromprops"class="level3"><h3>Jak zaimplementować <code>getDerivedStateFromProps</code>?</h3><p>Prawdopodobnie <a href="/blog/2018/06/07/you-probably-dont-need-derived-state.html">w ogóle nie potrzebujesz tej funkcjonalności</a>. W rzadkich przypadkach, w których naprawdę będziesz tego potrzebować (na przykład implementacja komponentu <code>&#x3C;Transition></code>), możesz zaktualizować stan w trakcie renderowania. React wywoła ponownie komponent z zaktualizowanym stanem natychmiast po pierwszym renderowaniu, więc nie wpłynie to znacząco na wydajność.<p>W poniższym kodzie przechowujemy poprzednią wartość właściwości <code>row</code> w zmiennej stanowej, dzięki czemu możemy wykonać porównanie:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ScrollView</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>row<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isScrollingDown<span class="token punctuation">,</span> setIsScrollingDown<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>prevRow<span class="token punctuation">,</span> setPrevRow<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>row <span class="token operator">!==</span> prevRow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Wiersz zmienił się od ostatniego renderowania. Zaktualizuj isScrollingDown.</span>
    <span class="token function">setIsScrollingDown</span><span class="token punctuation">(</span>prevRow <span class="token operator">!==</span> <span class="token keyword null nil">null</span> <span class="token operator">&#x26;&#x26;</span> row <span class="token operator">></span> prevRow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setPrevRow</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Przewijanie w dół: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isScrollingDown<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Na pierwszy rzut oka może to wyglądać dziwnie, ale aktualizacja podczas renderowania jest dokładnie tym samym, czym w założeniu metoda <code>getDerivedStateFromProps</code> była od zawsze.</section><section id="is-there-something-like-forceupdate"class="level3"><h3>Czy istnieje coś takiego jak <code>forceUpdate</code>?</h3><p>Zarówno <code>useState</code>, jak i <code>useReducer</code> <a href="./hooks-reference.html#bailing-out-of-a-state-update">wycofują się z aktualizacji</a>, jeżeli kolejna wartość jest taka sama jak poprzednia. Zmiana stanu bez użycia <code>setState</code>, a następnie wywołanie <code>setState</code> nie skutkuje ponownym renderowaniem komponentu.<p>Zazwyczaj nie powinno się bezpośrednio modyfikować lokalnego stanu w Reakcie. Możesz jednak inkrementować licznik, aby wymusić ponowne renderowanie, nawet jeśli stan się nie zmienił:<pre class="language-js"><code class="language-js">  <span class="token keyword">const</span> <span class="token punctuation">[</span>ignored<span class="token punctuation">,</span> forceUpdate<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token arrow operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">forceUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre><p>Jeżeli to możliwe, staraj się unikać tego wzorca.</section><section id="can-i-make-a-ref-to-a-function-component"class="level3"><h3>Czy mogę stworzyć referencję do komponentu funkcyjnego?</h3><p>Nie powinno się tego robić zbyt często, jednak możesz upublicznić niektóre imperatywne metody dla komponentu rodzica używając hooka <a href="./hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a>.</section><section id="how-can-i-measure-a-dom-node"class="level3"><h3>Jak mogę zmierzyć węzeł DOM?</h3><p>Aby zmierzyć pozycję lub rozmiar węzła DOM, możesz użyć <a href="./refs-and-the-dom.html#callback-refs">referencji z funkcją zwrotną</a>. React wywoła funkcję zwrotną, gdy referencja zostanie przypisana do innego węzła. Tutaj znajdziesz <a href="https://codesandbox.io/s/l7m0v5x4v9">prosty przykład</a>:<pre class="language-js{4-8,12}"><code class="language-js{4-8,12}">function MeasureExample() {
  const [height, setHeight] = useState(0);

  const measuredRef = useCallback(node => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  }, []);

  return (
    &#x3C;>
      &#x3C;h1 ref={measuredRef}>Witaj, świecie&#x3C;/h1>
      &#x3C;h2>Powyższy nagłówek ma {Math.round(height)} pikseli wysokości&#x3C;/h2>
    &#x3C;/>
  );
}</code></pre><p>W tym przykładzie nie zdecydowaliśmy się użyć <code>useRef</code>, ponieważ obiekt referencji nie powiadamia nas o <em>zmianach</em> jego aktualnej wartości. Użycie referencji z funkcją zwrotną daje pewność, że <a href="https://codesandbox.io/s/818zzk8m78">nawet jeśli komponent potomny wyświetli mierzony węzeł później</a> (np. w odpowiedzi na przyciśnięcie przycisku), komponent nadrzędny zostanie o tym powiadomiony i może zaktualizować swój pomiar.<p>Zauważ, że przekazaliśmy <code>[]</code> jako tablicę zależności do <code>useCallback</code>. Gwarantuje to nam niezmienialność funkcji zwrotnej pomiedzy ponownymi renderowaniami oraz że React nie wywoła jej bez potrzeby.<p>W tym przykładzie funkcja zwrotna referencji zostanie wywołana tylko w momencie zamontowania i odmontowania komponentu. Dzieje się tak dlatego, że komponent <code>&#x3C;h1></code> jest obecny w każdym renderowaniu. Jeśli chcesz otrzymywać powiadomienie przy każdej zmianie rozmiaru komponentu, proponujemy skorzystać z <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code>ResizeObserver</code></a> lub hooka z jakiejś biblioteki zewnętrznej opartej na tym mechanizmie.<p>W razie konieczności można <a href="https://codesandbox.io/s/m5o42082xy">wyodrębnić tę logikę</a> do osobnego hooka i używać wielokrotnie:<pre class="language-js{2}"><code class="language-js{2}">function MeasureExample() {
  const [rect, ref] = useClientRect();
  return (
    &#x3C;>
      &#x3C;h1 ref={ref}>Witaj, świecie&#x3C;/h1>
      {rect !== null &#x26;&#x26;
        &#x3C;h2>Powyższy nagłówek ma {Math.round(rect.height)} pikseli wysokości&#x3C;/h2>
      }
    &#x3C;/>
  );
}

function useClientRect() {
  const [rect, setRect] = useState(null);
  const ref = useCallback(node => {
    if (node !== null) {
      setRect(node.getBoundingClientRect());
    }
  }, []);
  return [rect, ref];
}</code></pre></section><section id="what-does-const-thing-setthing--usestate-mean"class="level3"><h3>Co oznacza <code>const [thing, setThing] = useState()</code>?</h3><p>Jeżeli nie rozpoznajesz tej składni, sprawdź <a href="./hooks-state.html#tip-what-do-square-brackets-mean">wyjaśnienie</a> w dokumentacji hooka stanu.</section></section><section id="performance-optimizations"class="level2"><h2>Optymalizacja wydajności</h2><section id="can-i-skip-an-effect-on-updates"class="level3"><h3>Czy mogę pominąć efekt podczas aktualizacji komponentu?</h3><p>Tak. Zapoznaj się z <a href="./hooks-reference.html#conditionally-firing-an-effect">warunkowym uruchamianiem efektów</a>. Pamiętaj jednak, że pomijanie aktualizacji często <a href="./hooks-effect.html#explanation-why-effects-run-on-each-update">prowadzi do błędów</a>, z tego też powodu nie jest to domyślnie działanie.</section><section id="is-it-safe-to-omit-functions-from-the-list-of-dependencies"class="level3"><h3>Czy bezpiecznie jest pomijać funkcje w liście zależności?</h3><p>Ogólnie rzecz biorąc, nie.<pre class="language-js{3,8}"><code class="language-js{3,8}">function Example({ someProp }) {
  function doSomething() {
    console.log(someProp);
  }

  useEffect(() => {
    doSomething();
  }, []); // 🔴 Niebezpieczne (wywołuje `doSomething`, które używa `someProp`)
}</code></pre><p>Trudno jest pamiętać, które właściwości lub stan są używane przez funkcje poza efektem. Dlatego też <strong>zazwyczaj lepiej jest deklarować funkcje <em>wewnątrz</em> efektu.</strong> Dzięki temu łatwo można zauważyć, od których wartości komponentu zależy efekt:<pre class="language-js{4,8}"><code class="language-js{4,8}">function Example({ someProp }) {
  useEffect(() => {
    function doSomething() {
      console.log(someProp);
    }

    doSomething();
  }, [someProp]); // ✅ OK (efekt używa wyłącznie `someProp`)
}</code></pre><p>Jeżeli po zmianach efekt nadal nie używa wartości z zakresu komponentu, można bezpiecznie użyć <code>[]</code>:<pre class="language-js{7}"><code class="language-js{7}">useEffect(() => {
  function doSomething() {
    console.log('Cześć!');
  }

  doSomething();
}, []); // ✅ OK, ponieważ *żadne* wartości z zakresu komponentu nie są używane wewnątrz efektu</code></pre><p>W zależności od przypadku użycia, istnieje kilka dodatkowych opcji, które opisaliśmy poniżej.<blockquote><p>Uwaga<p>Stworzyliśmy regułę <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> (pol. <em>wyczerpujące zależności</em>), będącą częścią paczki <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a>. Pomaga w znalezieniu komponentów, które nie obsługują aktualizacji w konsekwentny sposób.</blockquote><p>Spójrzmy, dlaczego ma to znaczenie.<p>Kiedy określasz <a href="./hooks-reference.html#conditionally-firing-an-effect">tablicę zależności</a>, ostatni argument dla <code>useEffect</code>, <code>useLayoutEffect</code>, <code>useMemo</code>, <code>useCallback</code>, lub <code>useImperativeHandle</code> powinien zawierać wszystkie wartości biorące udział w przepływie danych, włączając w to właściwości, stan i wszystkie ich pochodne.<p>Jedynym <strong>bezpiecznym</strong> przypadkiem pominięcia argumentu w tablicy zależności jest przekazanie funkcji, która w swoim wnętrzu nie ma odniesień do właściwości, stanu lub wartości z nich dziedziczących. Poniższy przykład zawiera błąd:<pre class="language-js{5,12}"><code class="language-js{5,12}">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);

  async function fetchProduct() {
    const response = await fetch('http://myapi/product/' + productId); // Używa właściwości productId
    const json = await response.json();
    setProduct(json);
  }

  useEffect(() => {
    fetchProduct();
  }, []); // 🔴 Błąd, ponieważ `fetchProduct` używa `productId`
  // ...
}</code></pre><p><strong>Zalecanym sposobem naprawienia tego, jest przeniesienie funkcji do <em>wnętrza</em> efektu</strong>. Dzięki temu łatwiej będzie nam dostrzec stan lub właściwości, których używa efekt, i upewnić się, że wszystkie z nich zostały zadeklarowane:<pre class="language-js{5-10,13}"><code class="language-js{5-10,13}">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);

  useEffect(() => {
    // Po przeniesienu funkcji do wnętrza efektu, możemy łatwo dostrzec, których wartości używa.
    async function fetchProduct() {
      const response = await fetch('http://myapi/product/' + productId);
      const json = await response.json();
      setProduct(json);
    }

    fetchProduct();
  }, [productId]); // ✅ Poprawnie, ponieważ efekt używa wyłącznie productId
  // ...
}</code></pre><p>Pozwala to również na obsłużenie asynchronicznych odpowiedzi, stosując zmienną lokalną wewnątrz efektu:<pre class="language-js{2,6,10}"><code class="language-js{2,6,10}">  useEffect(() => {
    let ignore = false;
    async function fetchProduct() {
      const response = await fetch('http://myapi/product/' + productId);
      const json = await response.json();
      if (!ignore) setProduct(json);
    }

    fetchProduct();
    return () => { ignore = true };
  }, [productId]);</code></pre><p>Przenieśliśmy funkcję do wnętrza efektu, dlatego też nie musi ona znajdować się w tablicy zależności.<blockquote><p>Wskazówka<p>Aby dowiedzieć się więcej o pobieraniu danych za pomocą hooków, sprawdź <a href="https://codesandbox.io/s/jvvkoo8pq3">ten przykład</a> i <a href="https://www.robinwieruch.de/react-hooks-fetch-data/">ten artykuł</a>.</blockquote><p><strong>Jeżeli z jakichś przyczyn <em>nie</em> możesz przenieść funkcji do wnętrza efektu, istnieje kilka innych opcji:</strong><ul><li><strong>Możesz spróbować przenieść funkcję poza swój komponent</strong>. W tym przypadku funkcja nie będzie odnosić się do żadnych właściwości czy stanu, dlatego też nie będzie potrzeby dodawania jej do tablicy zależności.<li>Jeżeli funkcja, którą wywołujesz, wykonuje jedynie obliczenia i można ją bezpiecznie wywołać podczas renderowania, możesz zechcieć <strong>wywołać ją poza efektem</strong> i uzależnić efekt od zwróconej przez nią wartości.<li>W ostateczności, możesz <strong>dodać funkcję do zależności efektu poprzez <em>opakowanie jej definicji</em></strong>, korzystając z hooka <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a>. Zapewnia to niezmienność podczas renderowania, dopóki nie zmieni się również <em>jej własna</em> tablica zależności:</ul><pre class="language-js{2-5}"><code class="language-js{2-5}">function ProductPage({ productId }) {
  // ✅ Opakowanie za pomocą useCallback, aby uniknąć zmian przy każdym renderowaniu
  const fetchProduct = useCallback(() => {
    // ... Korzysta z productId ...
  }, [productId]); // ✅ Zdefiniowane zostały wszystkie zależności useCallback

  return &#x3C;ProductDetails fetchProduct={fetchProduct} />;
}

function ProductDetails({ fetchProduct }) {
  useEffect(() => {
    fetchProduct();
  }, [fetchProduct]); // ✅ Zdefiniowane zostały wszystkie zależności useEffect
  // ...
}</code></pre><p>Zauważ, że w powyższym przykładzie <strong>musieliśmy</strong> przekazać funkcję do tablicy zależności. Dzięki temu zmiana właściwości <code>productId</code> w <code>ProductPage</code> będzie automatycznie uruchamiała ponowne pobranie danych w komponencie <code>ProductDetails</code>.</section><section id="what-can-i-do-if-my-effect-dependencies-change-too-often"class="level3"><h3>Co zrobić, gdy zależności mojego efektu zmieniają się zbyt często?</h3><p>Czasem twój efekt może korzystać ze stanu, który zmienia się zbyt często. Może cię kusić usunięcie go z listy zależności, jednak zwykle prowadzi to do błędów.:<pre class="language-js{6,9}"><code class="language-js{6,9}">function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(count + 1); // Ten efekt zależy od wartości `count`
    }, 1000);
    return () => clearInterval(id);
  }, []); // 🔴 Błąd: Zmienna `count` nie została wymieniona w zależnościach

  return &#x3C;h1>{count}&#x3C;/h1>;
}</code></pre><p>Pusty zbiór zależności, <code>[]</code>, oznacza, że efekt ten zostanie uruchomiony tylko jeden raz podczas montowania komponentu, ale już nie przy kolejnych renderowaniach. Problem polega na tym, iż wartość zmiennej <code>count</code> wewnątrz funkcji zwrotnej przekazanej do <code>setInterval</code> nie będzie się zmieniać. Dzieje się dlatego, że stworzyliśmy dla niej domknięcie (ang. <em>closure</em>), w którym <code>count</code> ma wartość <code>0</code>, ponieważ z taką wartością uruchomiono ten efekt. Co sekundę funkcja zwrotna będzie wywoływała <code>setCount(0 + 1)</code>, przez co wartość licznika nigdy nie przekroczy 1.<p>Podanie <code>[count]</code> jako listy zależności mogłoby naprawić ten błąd, jednak spowodowałoby to resetowanie się interwału przy każdej zmianie stanu. W konsekwencji, każdy <code>setInterval</code> miałby jedną szansę na wykonanie, zanim zostałby wyczyszczony (zachowanie podobne do <code>setTimeout</code>). Raczej nie o to nam chodzi. Aby temu zapobiec, możemy skorzystać z <a href="./hooks-reference.html#functional-updates">funkcyjnego wariantu aktualizacji poprzez <code>setState</code></a>. Pozwoli to nam określić, <em>jak</em> stan powinien się zmienić, bez odnoszenia się do konkretnego <em>aktualnego</em> stanu:<pre class="language-js{6,9}"><code class="language-js{6,9}">function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + 1); // ✅ Nie zależy od zewnętrznej zmiennej `count`
    }, 1000);
    return () => clearInterval(id);
  }, []); // ✅ Nasz efekt nie korzysta z żadnych zmiennych z zakresu komponentu

  return &#x3C;h1>{count}&#x3C;/h1>;
}</code></pre><p>(Stałość referencyjna funkcji <code>setCount</code> jest zagwarantowana przez Reacta, więc można ją pominąć na liście zależności.)<p>Teraz funkcja zwrotna przekazana do <code>setInterval</code> wywoływana jest co sekundę, lecz za każdym razem wywołanie <code>setCount</code> wewnątrz korzysta z aktualnej wartości licznika <code>count</code> (nazwanej lokalnie jako <code>c</code>).<p>W bardziej zawiłych przypadkach (np. gdy jeden stan zależy od drugiego), spróbuj przenieść logikę zmiany stanu poza efekt przy pomocy <a href="./hooks-reference.html#usereducer">hooka <code>useReducer</code></a>. <a href="https://adamrackis.dev/state-and-use-reducer/">W tym artykule</a> pokazano przykład jego zastosowania. <strong>Tożsamość funkcji <code>dispatch</code> zwróconej przez <code>useReducer</code> jest zawsze stabilna</strong> — nawet jeśli reduktor jest deklarowany wewnątrz komponentu i odczytuje jego właściwości.<p>Ostatecznie, jeśli zechcesz skorzystać z czegoś w rodzaju klasowego <code>this</code>, możesz <a href="./hooks-faq.html#is-there-something-like-instance-variables">użyć referencji</a> do przechowania mutowalnej zmiennej. Wtedy możliwe będzie jej nadpisywanie i odczytywanie w dowolnym momencie. Na przykład:<pre class="language-js{2-6,10-11,16}"><code class="language-js{2-6,10-11,16}">function Example(props) {
  // Trzymamy ostatnie właściwości w referencji.
  const latestProps = useRef(props);
  useEffect(() => {
    latestProps.current = props;
  });

  useEffect(() => {
    function tick() {
      // Odczytujemy ostatnie właściwości w dowolnym momencie
      console.log(latestProps.current);
    }

    const id = setInterval(tick, 1000);
    return () => clearInterval(id);
  }, []); // Ten efekt nigdy nie uruchomi się ponownie
}</code></pre><p>Rób tak tylko, gdy nie znajdziesz lepszej alternatywy, ponieważ poleganie na mutacjach negatywnie wpływa na przewidywalność zachowania się komponentów. Jeśli znasz jakiś wzorzec, którego nie da się w prosty sposób wyrazić za pomocą hooków, <a href="https://github.com/facebook/react/issues/new">zgłoś to nam</a>, załączając przykład działającego kodu, a my postaramy się pomóc.</section><section id="how-do-i-implement-shouldcomponentupdate"class="level3"><h3>Jak zaimplementować <code>shouldComponentUpdate</code>?</h3><p>Możesz opakować komponent funkcyjny za pomocą <code>React.memo</code>, aby zastosować płytkie porównanie jego właściwości:<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">Button</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// twój komponent</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Nie jest to hook, bo nie komponuje się jak hooki. <code>React.memo</code> jest odpowiednikiem klasy <code>PureComponent</code>, jednak ogranicza się do porównywania wyłącznie właściwości. (Możesz także jako drugi argument przekazać funkcję porównującą poprzednie i aktualne właściwości. Jeśli zwróci <code>true</code>, aktualizacja komponentu zostanie pominięta.)<p><code>React.memo</code> nie porównuje stanu komponentu, ponieważ komponenty funkcyjne nie mają jednego jedynego obiektu stanu, jak to ma miejsce w komponentach klasowych. Możesz jednak sprawić, by komponenty potomne również były "czystymi" komponentami (ang. <em>pure components</em>), a nawet <a href="./hooks-faq.html#how-to-memoize-calculations">zoptymalizować poszczególnych potomków za pomocą <code>useMemo</code></a>.</section><section id="how-to-memoize-calculations"class="level3"><h3>Jak memoizować obliczenia?</h3><p>Za pomocą hooka <a href="./hooks-reference.html#usememo"><code>useMemo</code></a> możesz zapamiętać wynik obliczeń pomiędzy kolejnymi renderowaniami:<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">computeExpensiveValue</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Powyższy kod wywołuje funkcję <code>computeExpensiveValue(a, b)</code>, która wykonuje kosztowne obliczenia. Jeśli jednak zależności <code>[a, b]</code> nie zmieniły się od ostatniego razu, <code>useMemo</code> pominie kolejne wywołanie funkcji i zamiast tego zwróci ostatni wynik.<p>Pamiętaj, że funkcja przekazana do <code>useMemo</code> wywoływana jest podczas renderowania. Nie rób w niej niczego, czego normalnie nie robisz podczas renderowania. Oznacza to, że, na przykład, efekty uboczne należy umieszczać w <code>useEffect</code>, a nie w <code>useMemo</code>.<p><strong>Traktuj użycie <code>useMemo</code> jako optymalizację szybkości programu, a nie "gwarancję semantyczną" (ang. <em>semantic guarantee</em>).</strong> W przyszłości React być może będzie "zapominał" niektóre zapisane wyniki i przeliczał je dopiero przy następnym renderowaniu, np. aby zwolnić pamięć przydzieloną dla komponentów, których nie widać na ekranie. Pisz swój kod tak, aby działał bez użycia <code>useMemo</code> — a dopiero później dodawaj ten hook w celach optymalizacyjnych. (W sporadycznych przypadkach, w których wynik <em>nigdy</em> nie powinien być przeliczany na nowo, zalecamy skorzystać z <a href="#how-to-create-expensive-objects-lazily">leniwie inicjalizowanej referencji</a>.)<p>Co więcej, <code>useMemo</code> pozwala także pominąć kosztowne renderowania komponentów potomnych:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Parent</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Ponownie renderowany tylko wtedy, gdy zmieni się `a`:</span>
  <span class="token keyword">const</span> child1 <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Child1</span> a<span class="token operator">=</span><span class="token punctuation">{</span>a<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Ponownie renderowany tylko wtedy, gdy zmieni się `b`:</span>
  <span class="token keyword">const</span> child2 <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Child2</span> b<span class="token operator">=</span><span class="token punctuation">{</span>b<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token punctuation">{</span>child1<span class="token punctuation">}</span>
      <span class="token punctuation">{</span>child2<span class="token punctuation">}</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>Pamiętaj jednak, że to podejście nie zadziała w pętli, ponieważ <a href="./hooks-rules.html">hooków nie można wywoływać w pętlach</a>. Możesz jednak wydzielić osobny komponent renderujący element listy, a następnie wywołać w nim <code>useMemo</code>.</section><section id="how-to-create-expensive-objects-lazily"class="level3"><h3>Jak w leniwy sposób tworzyć "ciężkie" obiekty?</h3><p><code>useMemo</code> pozwala na <a href="#how-to-memoize-calculations">memoizację kosztownych obliczeń</a>, pod warunkiem, że ich zależności są takie same. Jest to jednak tylko wskazówka i nie <em>gwarantuje</em>, że obliczenia nie zostaną uruchomione ponownie. Czasem jednak chcesz mieć pewność, że obiekt zostanie stworzony dokładnie raz.<p><strong>Pierwszy z częstych przypadków dotyczy kosztownego tworzenia stanu początkowego:</strong><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Table</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ⚠️ Funkcja createRows() będzie wywoływana przy każdym renderowaniu</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>rows<span class="token punctuation">,</span> setRows<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token function">createRows</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>Aby uniknąć ponownego tworzenia i tak ignorowanego stanu początkowego, możemy do <code>useState</code> przekazać <strong>funkcję inicjalizującą</strong>:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Table</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ✅ Funkcja createRows() będzie wywołana tylko raz</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>rows<span class="token punctuation">,</span> setRows<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">createRows</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>React wywoła funkcję tylko przy pierwszym renderowaniu. Po więcej informacji zajrzyj do <a href="./hooks-reference.html#usestate">dokumentacji API hooka <code>useState</code></a>.<p><strong>Czasem możesz chcieć uniknąć wielokrotnego tworzenia wartości początkowej dla hooka <code>useRef()</code>.</strong> Na przykład, jeśli chcesz mieć pewność, że zostanie utworzona tylko jedna instancja danej klasy:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ⚠️ Instancja klasy IntersectionObserver będzie tworzona przy każdym renderowaniu</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>onIntersect<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>Hook <code>useRef</code> <strong>nie przyjmuje</strong> alternatywnego argumentu w postaci funkcji, jak ma to miejsce w <code>useState</code>. Zamiast tego możesz napisać własną funkcję, która tworzy i ustawia wartość referencji w sposób leniwy:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ✅ Instancja klasy IntersectionObserver zostanie stworzona leniwie tylko raz</span>
  <span class="token keyword">function</span> <span class="token function">getObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>onIntersect<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> ref<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// W razie potrzeby możesz wywołać getObserver()</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>Pozwala to uniknąć tworzenia kosztownych obiektów do czasu, aż faktycznie będą potrzebne. Jeśli używasz Flow lub TypeScriptu, możesz dla pewności dodatkowo nadać funkcji <code>getObserver()</code> typ nie dopuszczający wartości <code>null</code> (ang. <em>non-nullable type</em>).</section><section id="are-hooks-slow-because-of-creating-functions-in-render"class="level3"><h3>Czy hooki są wolne z powodu tworzenia funkcji podczas renderowania?</h3><p>Nie. We współczesnych przeglądarkach wydajność domknięć w porównaniu z zastosowaniem klas nie różni się znacząco, za wyjątkiem sytuacji ekstremalnych.<p>Ponadto, warto zwrócić uwagę, że sposób działania hooków jest bardziej wydajny pod kilkoma względami:<ul><li><p>Hooki unikają sporej części narzutu, jaki wprowadzają klasy - jak choćby koszt tworzenia instancji klasy czy dowiązywanie procedur obsługi zdarzeń w konstruktorze.<li><p><strong>Kod idiomatyczny używający hooków nie wymaga głębokiego zagnieżdżania drzewa komponentów</strong>, co ma miejsce w kodzie korzystającym z komponentów wyższego rzędu (ang. <em>higher-order components</em>), właściwości renderujących (ang. <em>render props</em>) i kontekstu. W mniejszych drzewach komponentów React ma mniej do roboty.</ul><p>Tradycyjnie już, obawy dotyczące wydajności dla <em>funkcji inline</em> w Reakcie były związane z sytuacjami, w których przekazywanie każdorazowo nowych funkcji zwrotnych do komponentów potomnych niwelowało optymalizację zapewnioną przez <code>shouldComponentUpdate</code> w potomkach. Hooki rozwiązują ten problem na trzy sposoby.<ul><li><p>Hook <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a> pozwala na przechowywanie tej samej referencji do funkcji zwrotnej pomiędzy kolejnymi renderowaniami, dzięki czemu metoda <code>shouldComponentUpdate</code> może działać poprawnie:<pre class="language-js{2}"><code class="language-js{2}">// Nie zmieni się, dopóki nie zmienią się `a` lub `b`
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);</code></pre><li><p>Hook <a href="./hooks-faq.html#how-to-memoize-calculations"><code>useMemo</code></a> ułatwia kontrolowanie tego, kiedy aktualizowane są poszczególne komponenty potomne, zmniejszając potrzebę stosowania czystych komponentów (ang. <em>pure components</em>).<li><p>Wreszcie hook <a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> zmniejsza potrzebę przekazywania funkcji zwrotnych do dalekich potomków, co wyjaśniono poniżej.</ul></section><section id="how-to-avoid-passing-callbacks-down"class="level3"><h3>Jak unikać przekazywania funkcji zwrotnych w dół?</h3><p>Z naszych obserwacji wynika, że programiści nie lubią ręcznego przekazywania funkcji zwrotnych w dół przez kilka poziomów drzewa komponentów. Nawet jeśli kod w ten sposób staje się bardziej bezpośredni, możemy odnieść wrażenie, że zbyt dużo czasu poświęcamy "hydraulice" programu.<p>W dużych drzewach komponentów sugerujemy przekazywać funkcję <code>dispatch</code>, zwróconą przez hooka <a href="./hooks-reference.html#usereducer"><code>useReducer</code></a>, poprzez kontekst:<pre class="language-js{4,5}"><code class="language-js{4,5}">const TodosDispatch = React.createContext(null);

function TodosApp() {
  // Uwaga: `dispatch` nie zmieni się pomiędzy renderowaniami
  const [todos, dispatch] = useReducer(todosReducer);

  return (
    &#x3C;TodosDispatch.Provider value={dispatch}>
      &#x3C;DeepTree todos={todos} />
    &#x3C;/TodosDispatch.Provider>
  );
}</code></pre><p>Dowolny komponent poddrzewa wewnątrz <code>TodosApp</code> może użyć funkcji <code>dispatch</code>, aby uruchomić akcję z <code>TodosApp</code>:<pre class="language-js{2,3}"><code class="language-js{2,3}">function DeepChild(props) {
  // Jeśli chcemy wykonać jakąś akcję, możemy wyciągnąć funkcję `dispatch` z kontekstu.
  const dispatch = useContext(TodosDispatch);

  function handleClick() {
    dispatch({ type: 'add', text: 'zrobić pranie' });
  }

  return (
    &#x3C;button onClick={handleClick}>Dodaj zadanie&#x3C;/button>
  );
}</code></pre><p>Jest to wygodne zarówno z perspektywy utrzymania kodu (nie trzeba przekazywać funkcji zwrotnych w nieskończoność), jak i ogólnie uniknięcia problemów z tego typu funkcjami. Sugerujemy zatem wykonywać wszelkie "odległe" aktualizacje za pomocą przekazanej w dół funkcji <code>dispatch</code>.<p>Pamiętaj, że nadal możesz wybrać pomiędzy przekazywaniem <em>stanu</em> aplikacji w dół za pomocą właściwości (bardziej "wprost") lub za pomocą kontekstu (wygodniejsze w przypadku "odległych" aktualizacji). Jeśli chcesz użyć kontekstu także do przekazania stanu, sugerujemy skorzystać z dwóch niezależnych kontekstów. Kontekst przekazujący <code>dispatch</code> nigdy się nie zmienia, dzięki czemu używające go komponenty nie muszą być ponownie renderowane, o ile same w jawny sposób nie poproszą o stan.</section><section id="how-to-read-an-often-changing-value-from-usecallback"class="level3"><h3>Jak odczytywać często zmieniającą się wartość wewnątrz <code>useCallback</code>?</h3><blockquote><p>Uwaga<p>Zalecamy <a href="#how-to-avoid-passing-callbacks-down">przekazywać w dół funkcję <code>dispatch</code> za pomocą kontekstu</a>, a nie poszczególne funkcje zwrotne za pomocą właściwości. Poniższy sposób został tu umieszczony tylko jako uzupełnienie i "furtka awaryjna".</blockquote><p>W rzadkich przypadkach pojawia się potrzeba memoizowania funkcji zwrotnej za pomocą hooka <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a>, lecz nie przynosi to żadnej korzyści, ponieważ wewnętrzna funkcja i tak tworzona jest zbyt często. Jeśli memoizowana funkcja jest procedurą obsługi zdarzeń i nie jest wywoływana podczas renderowania, można stworzyć <a href="#is-there-something-like-instance-variables">referencję do zmiennej</a> i ręcznie aktualizować jej wartość:<pre class="language-js{6,10}"><code class="language-js{6,10}">function Form() {
  const [text, updateText] = useState('');
  const textRef = useRef();

  useEffect(() => {
    textRef.current = text; // Nadpisz wartość referencji
  });

  const handleSubmit = useCallback(() => {
    const currentText = textRef.current; // Odczytaj wartość referencji
    alert(currentText);
  }, [textRef]); // Nie twórz ponownie `handleSubmit`, jak byłoby przy `[text]`

  return (
    &#x3C;>
      &#x3C;input value={text} onChange={e => updateText(e.target.value)} />
      &#x3C;ExpensiveTree onSubmit={handleSubmit} />
    &#x3C;/>
  );
}</code></pre><p>Metoda ta może wydawać się mocno zagmatwana, lecz pokazuje, że można, w razie potrzeby, skorzystać z tego typu optymalizacji. Łatwiej z niej korzystać po wydzieleniu logiki do osobnego hooka:<pre class="language-js{4,16}"><code class="language-js{4,16}">function Form() {
  const [text, updateText] = useState('');
  // Podlega memoizacji, nawet gdy zmienia się `text`:
  const handleSubmit = useEventCallback(() => {
    alert(text);
  }, [text]);

  return (
    &#x3C;>
      &#x3C;input value={text} onChange={e => updateText(e.target.value)} />
      &#x3C;ExpensiveTree onSubmit={handleSubmit} />
    &#x3C;/>
  );
}

function useEventCallback(fn, dependencies) {
  const ref = useRef(() => {
    throw new Error('Niedozwolone wywołanie procedury obsługi zdarzeń podczas renderowania.');
  });

  useEffect(() => {
    ref.current = fn;
  }, [fn, ...dependencies]);

  return useCallback(() => {
    const fn = ref.current;
    return fn();
  }, [ref]);
}</code></pre><p>Tak czy inaczej, <strong>nie zalecamy korzystania z tego sposobu</strong>, a pokazujemy go tylko dla kompletności dokumentacji. Zamiast tego lepiej jest <a href="#how-to-avoid-passing-callbacks-down">unikać przekazywania funkcji zwrotnych głęboko w dół</a>.</section></section><section id="under-the-hood"class="level2"><h2>Pod maską</h2><section id="how-does-react-associate-hook-calls-with-components"class="level3"><h3>Jak React łączy wywołania hooków z komponentami?</h3><p>React sprawuje kontrolę nad aktualnie renderowanym komponentem. Dzięki <a href="./hooks-rules.html">zasadom korzystania z hooków</a> wiemy, że hooki mogą być wywoływane tylko z wnętrza komponentów reactowych (lub własnych hooków -- które również można wywoływać tylko w komponentach reactowych).<p>Do każdego komponentu przypisana jest wewnętrzna lista "komórek pamięci". Są to zwykłe obiekty javascriptowe, w których przechowujemy jakieś dane. Kiedy wywołujesz hook, np. <code>useState()</code>, odczytuje on aktualną zawartość komórki (lub tworzy nową podczas pierwszego renderowania), a następnie przesuwa "wskaźnik" na kolejną komórkę. To dzięki temu każde z kilku wywołań <code>useState()</code> może zarządzać niezależną porcją lokalnego stanu.</section><section id="what-is-the-prior-art-for-hooks"class="level3"><h3>Skąd wziął się pomysł na stworzenie hooków?</h3><p>Hooki łączą pomysły z wielu różnych źródeł:<ul><li>Nasze stare eksperymenty z funkcyjnymi API w repozytorium <a href="https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State">react-future</a>.<li>Eksperymenty społeczności reactowej z interfejsami dla właściwości renderujących, wliczając w to <a href="https://github.com/reactions/component">Reactions Component</a> autorstwa <a href="https://github.com/ryanflorence">Ryana Florence'a</a>.<li>Propozycję <a href="https://github.com/trueadm">Dominica Gannawaya</a> dotyczącą wprowadzenia <a href="https://gist.github.com/trueadm/17beb64288e30192f3aa29cad0218067">słowa kluczowego <code>adopt</code></a> jako nowej składni dla właściwości renderujących.<li>Zmienne stanu i komórki stanu w języku <a href="http://displayscript.org/introduction.html">DisplayScript</a>.<li><a href="https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html">Komponenty redukujące</a> w ReasonReact.<li><a href="http://reactivex.io/rxjs/class/es6/Subscription.js~Subscription.html">Subskrypcje</a> w Rx.<li><a href="https://github.com/ocamllabs/ocaml-effects-tutorial#2-effectful-computations-in-a-pure-setting">Efekty algebraiczne</a> w Multicore OCaml.</ul><p><a href="https://github.com/sebmarkbage">Sebastian Markbåge</a> wymyślił pierwowzór hooków, który później został udoskonalony przez <a href="https://github.com/acdlite">Andrewa Clarka</a>, <a href="https://github.com/sophiebits">Sophie Alpert</a>, <a href="https://github.com/trueadm">Dominica Gannawaya</a> i innych członków zespołu Reacta. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section></section>