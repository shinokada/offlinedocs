<!doctype html><html lang="pl"><meta charset="utf-8"><title>Renderowanie i aktualizowanie</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"type="text/css"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="renderowanie-i-aktualizowanie"><h1 id="renderowanie-i-aktualizowanie">Renderowanie i aktualizowanie</h1><intro><p>Zanim twoje komponenty zostaną wyświetlone na ekranie, muszą zostać wyrenderowane przez Reacta. Zrozumienie tego procesu pomoże ci zrozumieć, jak wykonuje się twój kod i wyjaśni jego zachowanie.</p></intro><youwilllearn><ul><li>Czym jest renderowanie w Reakcie<li>Kiedy i dlaczego React renderuje komponenty<li>Kroki związane z wyświetlaniem komponentów na ekranie<li>Dlaczego renderowanie nie zawsze powoduje aktualizację drzewa DOM</ul></youwilllearn><p>Wyobraź sobie, że twoje komponenty to kucharze w kuchni, którzy przygotowują smaczne dania z dostępnych składników. W tej sytuacji React jest kelnerem, który przyjmuje zamówienia od klientów i przynosi im zamówione potrawy. Ten proces zgłaszania i obsługi interfejsu użytkownika składa się z trzech kroków:<ol><li><strong>Wywołanie (ang. <em>triggering</em>)</strong> renderowania (przekazanie zamówienia od gościa do kuchni)<li><strong>Renderowanie (ang. <em>rendering</em>)</strong> komponentu (przygotowanie zamówienia w kuchni)<li><strong>Aktualizowanie (ang. <em>committing</em>)</strong> drzewa DOM (umieszczenie zamówienia na stole)</ol><illustrationblock sequential=""><illustration caption="Wywołanie"alt="React jako kelner w restauracji, pobierający zamówienia od użytkowników i dostarczający je do Kuchni Komponentów."src.=""docs=""illustrations=""i_render-and-commit1.png&#x22;=""><illustration caption="Renderowanie"alt="Kucharz komponentu Card przekazuje Reactowi świeży komponent Card."src.=""docs=""illustrations=""i_render-and-commit2.png&#x22;=""><illustration caption="Aktualizowanie"alt="React dostarcza komponent Card użytkownikowi do jego stołu."src.=""docs=""illustrations=""i_render-and-commit3.png&#x22;=""></illustration></illustration></illustration></illustrationblock><section class="level2"aria-labelledby="krok-1-wywołanie-renderowania-step-1-trigger-a-render"><h2 id="krok-1-wywołanie-renderowania-step-1-trigger-a-render">Krok 1: Wywołanie renderowania {/<em>step-1-trigger-a-render</em>/}</h2><p>Istnieją dwa powody, dla których komponent może zostać wyrenderowany:<ol><li>To jest <strong>początkowe renderowanie</strong> komponentu.<li>Stan komponentu (lub jednego z jego rodziców) <strong>został zaktualizowany</strong>.</ol><section class="level3"aria-labelledby="początkowe-renderowanie-initial-render"><h3 id="początkowe-renderowanie-initial-render">Początkowe renderowanie {/<em>initial-render</em>/}</h3><p>Przy uruchamianiu swojej aplikacji, musisz wywołać początkowe renderowanie. Frameworki i piaskownice czasem ukrywają ten kod, ale jest on wywoływany poprzez wywołanie funkcji <a href="/reference/react-dom/client/createRoot"><code>createRoot</code></a> z docelowym węzłem drzewa DOM, a następnie wywołanie na nim metody <code>render</code> z twoim komponentem:</p><sandpack><pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Image</span></span> <span class="token keyword module">from</span> <span class="token string">'./Image.js'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> createRoot <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react-dom/client'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">createRoot</span><span class="token punctuation">(</span><span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
root<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Image</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>img
      src<span class="token operator">=</span><span class="token string">"https://i.imgur.com/ZF6s192.jpg"</span>
      alt<span class="token operator">=</span><span class="token string">"Rzeźba 'Floralis Genérica' wykonana przez Eduardo Catalano: ogromny metalowy kwiat z zwierciadlanymi płatkami"</span>
    <span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></sandpack><p>Spróbuj zakomentować wywołanie <code>root.render()</code> i zauważ, że komponent znika!</section><section class="level3"aria-labelledby="przerenderowania-po-aktualizacji-stanu-re-renders-when-state-updates"><h3 id="przerenderowania-po-aktualizacji-stanu-re-renders-when-state-updates">Przerenderowania po aktualizacji stanu {/<em>re-renders-when-state-updates</em>/}</h3><p>Po początkowym renderowaniu komponentu, możesz wywołać kolejne przerenderowania poprzez aktualizację jego stanu za pomocą <a href="/reference/react/useState#setstate">funkcji <code>set</code></a>. Aktualizacja stanu komponentu automatycznie dodaje renderowanie do kolejki. (Możesz to sobie wyobrazić jako gościa restauracji zamawiającego herbatę, deser i wszelkiego rodzaju rzeczy już po złożeniu pierwszego zamówienia, w zależności od stanu jego pragnienia lub głodu.)</p><illustrationblock sequential=""><illustration caption="Aktualizacja stanu..."alt="React jako kelner w restauracji, serwujący interfejs użytkownika Card użytkownikowi, przedstawionym jako klient z kursorem jako głową. Klient mówi, że chce komponent Card w kolorze różowym, a nie czarnym!"src.=""docs=""illustrations=""i_rerender1.png&#x22;=""><illustration caption="...wywołuje..."alt="React wraca do Kuchni Komponentów i mówi Kucharzowi Komponentu Card, że potrzebuje komponent Card w kolorze różowym."src.=""docs=""illustrations=""i_rerender2.png&#x22;=""><illustration caption="...renderowanie!"alt="Kucharz Komponentu Card dostarcza Reactowi komponent Card w kolorze różowym."src.=""docs=""illustrations=""i_rerender3.png&#x22;=""></illustration></illustration></illustration></illustrationblock></section></section><section class="level2"aria-labelledby="krok-2-react-renderuje-twoje-komponenty-step-2-react-renders-your-components"><h2 id="krok-2-react-renderuje-twoje-komponenty-step-2-react-renders-your-components">Krok 2: React renderuje twoje komponenty {/<em>step-2-react-renders-your-components</em>/}</h2><p>Po wywołaniu renderowania, React wywołuje twoje komponenty, aby ustalić, co wyświetlić na ekranie. <strong>"Renderowanie" oznacza wywołanie twoich komponentów przez Reacta.</strong><ul><li><strong>Podczas początkowego renderowania,</strong> React wywoła główny komponent.<li><strong>Podczas kolejnych renderowań,</strong> React wywoła funkcję komponentu, którego aktualizacja stanu wywołała renderowanie.</ul><p>Proces ten jest rekurencyjny: jeśli zaktualizowany komponent zwraca inny komponent, React następnie wyrenderuje <em>ten</em> komponent, a jeśli ten komponent również coś zwraca, wyrenderuje <em>ten</em> komponent, i tak dalej. Proces będzie kontynuowany, aż nie będzie więcej zagnieżdżonych komponentów i React będzie dokładnie wiedział, co powinno być wyświetlane na ekranie.<p>W poniższym przykładzie React wywoła <code>Gallery()</code> i <code>Image()</code> kilkukrotnie:</p><sandpack><pre class="language-js"><code class="language-js"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Gallery</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>section<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token maybe-class-name">Inspirujące</span> rzeźby<span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Image</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Image</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Image</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>section<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>img
      src<span class="token operator">=</span><span class="token string">"https://i.imgur.com/ZF6s192.jpg"</span>
      alt<span class="token operator">=</span><span class="token string">"Rzeźba 'Floralis Genérica' wykonana przez Eduardo Catalano: ogromny metalowy kwiat z zwierciadlanymi płatkami"</span>
    <span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Gallery</span></span> <span class="token keyword module">from</span> <span class="token string">'./Gallery.js'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> createRoot <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react-dom/client'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">createRoot</span><span class="token punctuation">(</span><span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
root<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Gallery</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class="language-css"><code class="language-css"><span class="token selector">img</span> <span class="token punctuation">{</span> <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">10</span><span class="token unit">px</span> <span class="token number">10</span><span class="token unit">px</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></sandpack><ul><li><strong>Podczas początkowego renderowania,</strong> React <a href="https://developer.mozilla.org/docs/Web/API/Document/createElement">utworzy węzły DOM</a> dla znaczników <code>&#x3C;section></code>, <code>&#x3C;h1></code> i trzech znaczników <code>&#x3C;img></code>.<li><strong>Podczas ponownego renderowania,</strong> React obliczy, które z ich właściwości, jeśli jakiekolwiek, zostały zmienione od poprzedniego renderowania. Nic nie zrobi z tą informacją aż do następnego kroku, czyli fazy aktualizacji.</ul><pitfall><p>Renderowanie zawsze musi być <a href="/learn/keeping-components-pure">czystym obliczaniem</a>:<ul><li><strong>Takie same wejścia, taki sam wynik.</strong> Dla tych samych danych wejściowych, komponent powinien zawsze zwracać ten sam JSX - kiedy ktoś zamawia sałatkę z pomidorami, nie powinien otrzymać sałatki z cebulą!<li><strong>Dbanie o swoje własne sprawy.</strong> Komponent nie powinien zmieniać żadnych obiektów ani zmiennych, które już istniały przed renderowaniem - jedno zamówienie nie powinno móc zmieniać zamówienia kogoś innego.</ul><p>W przeciwnym razie możesz napotkać trudne do zrozumienia błędy i nieprzewidywalne zachowanie w miarę wzrostu złożoności kodu. Podczas pracy w "trybie rygorystycznym" (ang. <em>Strict Mode</em>) React wywołuje funkcję każdego komponentu dwa razy, co może pomóc w wykryciu błędów spowodowanych przez nieczyste funkcje.</p></pitfall><deepdive><section class="level4"aria-labelledby="optymalizacja-wydajności-optimizing-performance"><h4 id="optymalizacja-wydajności-optimizing-performance">Optymalizacja wydajności {/<em>optimizing-performance</em>/}</h4><p>Domyślne zachowanie polegające na renderowaniu wszystkich komponentów zagnieżdżonych w zaktualizowanym komponencie nie jest optymalne pod względem wydajności, jeśli zaktualizowany komponent znajduje się bardzo wysoko w drzewie komponentów. Jeśli napotkasz problemy z wydajnością, istnieje kilka możliwych rozwiązań opisanych w sekcji <a href="https://reactjs.org/docs/optimizing-performance.html">Wydajność</a>. <strong>Nie optymalizuj przedwcześnie!</strong></section></deepdive></section><section class="level2"aria-labelledby="krok-3-react-aktualizuje-zmiany-w-drzewie-dom-step-3-react-commits-changes-to-the-dom"><h2 id="krok-3-react-aktualizuje-zmiany-w-drzewie-dom-step-3-react-commits-changes-to-the-dom">Krok 3: React aktualizuje zmiany w drzewie DOM {/<em>step-3-react-commits-changes-to-the-dom</em>/}</h2><p>Po wyrenderowaniu (wywołaniu) twoich komponentów, React zmodyfikuje drzewo DOM.<ul><li><strong>Podczas początkowego renderowania,</strong> React użyje API drzewa DOM o nazwie <a href="https://developer.mozilla.org/docs/Web/API/Node/appendChild"><code>appendChild()</code></a>, aby umieścić na ekranie wszystkie węzły drzewa DOM, które utworzył.<li><strong>Podczas przerenderowań,</strong> React zastosuje minimum niezbędnych operacji (obliczonych podczas renderowania!), aby dopasować drzewo DOM do wyniku najnowszego renderowania.</ul><p><strong>React zmienia węzły drzewa DOM tylko wtedy, gdy występuje różnica pomiędzy renderowaniami.</strong> Na przykład, oto komponent, który przerenderowuje się co sekundę z różnymi właściwościami przekazywanymi z jego rodzica. Zauważ, że możesz dodać tekst do elementu <code>&#x3C;input></code>, aktualizując jego atrybut <code>value</code>, ale tekst nie znika, gdy komponent renderuje się ponownie:</p><sandpack><pre class="language-js"><code class="language-js"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Clock</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> time <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token punctuation">{</span>time<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>input <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Clock</span></span> <span class="token keyword module">from</span> <span class="token string">'./Clock.js'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">useTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>time<span class="token punctuation">,</span> setTime<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">setTime</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> time<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">App</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> time <span class="token operator">=</span> <span class="token function">useTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Clock</span> time<span class="token operator">=</span><span class="token punctuation">{</span>time<span class="token punctuation">.</span><span class="token method function property-access">toLocaleTimeString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></sandpack><p>To działa, ponieważ podczas ostatniego kroku React aktualizuje tylko zawartość znacznika <code>&#x3C;h1></code> nową wartością <code>time</code>. Widzi on, że znacznik <code>&#x3C;input></code> pojawia się w JSXie w tym samym miejscu co ostatnim razem, więc React nie zmienia tego znacznika ani jego atrybutu <code>value</code>! ## Epilog: Malowanie przez przeglądarkę {/<em>epilogue-browser-paint</em>/}<p>Po zakończeniu renderowania i zaktualizowaniu drzewa DOM przez Reacta, przeglądarka przemaluje ekran. Chociaż proces ten jest znany jako "renderowanie przez przeglądarkę", będziemy się odnosić do niego jako "malowanie", aby uniknąć nieporozumień w dokumentacji.<p>&#x3C;Illustration alt="Przeglądarka malująca 'martwą naturę z elementem komponentu Card'." src./docs/illustrations/i_browser-paint.png" /></p><recap><ul><li>Każda aktualizacja ekranu w aplikacji reactowej odbywa się w trzech krokach:<ol><li>Wywołanie<li>Renderowanie<li>Aktualizacja</ol><li>Możesz użyć trybu rygorystycznego, aby znaleźć błędy w swoich komponentach<li>React nie modyfikuje drzewa DOM, jeśli wynik renderowania jest taki sam jak poprzednio</ul></recap><p><span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>