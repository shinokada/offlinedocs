<!doctypehtml><html lang="pl"><meta charset="utf-8"><title>Przekazywanie referencji</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="przekazywanie-referencji"class="level1"><h1>Przekazywanie referencji</h1><p>Przekazywanie referencji (ang. <em>ref forwarding</em>) to technika, w której <a href="./refs-and-the-dom.html">referencję</a> do komponentu "podajemy dalej" do jego dziecka. Dla większości komponentów w aplikacji nie jest to potrzebne, jednak może okazać się przydatne w niektórych przypadkach, zwłaszcza w bibliotekach udostępniających uniwersalne komponenty. Najczęstsze scenariusze opisujemy poniżej.<section id="forwarding-refs-to-dom-components"class="level2"><h2>Przekazywanie referencji do komponentów DOM</h2><p>Rozważmy komponent <code>FancyButton</code>, który renderuje natywny element DOM - przycisk: <code>embed:forwarding-refs/fancy-button-simple.js</code><p>Komponenty reactowe ukrywają szczegóły swojej implementacji, w tym także wyrenderowany HTML. Inne komponenty używające <code>FancyButton</code> <strong>z reguły nie potrzebują</strong> <a href="./refs-and-the-dom.html">mieć dostępu do referencji</a> do wewnętrznego elementu <code>button</code>. Jest to korzystne, gdyż zapobiega sytuacji, w której komponenty są za bardzo uzależnione od struktury drzewa DOM innych komponentów.<p>Taka enkapsulacja jest pożądana na poziomie aplikacji, w komponentach takich jak <code>FeedStory</code> czy <code>Comment</code>. Natomiast może się okazać to niewygodne w przypadku komponentów wielokrotnego użytku, będących "liśćmi" drzewa. Np. <code>FancyButton</code> albo <code>MyTextInput</code>. Takie komponenty często używane są w wielu miejscach aplikacji, w podobny sposób jak zwyczajne elementy DOM typu <code>button</code> i <code>input</code>. W związku z tym, bezpośredni dostęp do ich DOM może okazać się konieczy, aby obsłużyć np. fokus, zaznaczenie czy animacje.<p><strong>Przekazywanie referencji jest opcjonalną funkcjonalnością, która pozwala komponentom wziąć przekazaną do nich referencję i "podać ją dalej" do swojego dziecka.</strong><p>W poniższym przykładzie <code>FancyButton</code> używa <code>React.forwardRef</code>, by przejąć przekazaną do niego referencję i przekazać ją dalej do elementu <code>button</code>, który renderuje:<p><code>embed:forwarding-refs/fancy-button-simple-ref.js</code><p>Tym sposobem komponenty używające <code>FancyButton</code> mają referencję do elementu <code>button</code> znajdującego się wewnątrz. Mogą więc, w razie potrzeby, operować na komponencie tak, jakby operowały bezpośrednio na natywnym elemencie DOM.<p>Oto wyjaśnienie krok po kroku, opisujące, co wydarzyło się w przykładzie powyżej:<ol><li>Tworzymy <a href="./refs-and-the-dom.html">referencję reactową</a> wywołując <code>React.createRef</code> i przypisujemy ją do stałej <code>ref</code>.<li>Przekazujemy <code>ref</code> do <code>&#x3C;FancyButton ref={ref}></code> przypisując ją do atrybutu JSX.<li>Wewnątrz <code>forwardRef</code> React przekazuje <code>ref</code> do funkcji <code>(props, ref) => ...</code> jako drugi argument.<li>Podajemy argument <code>ref</code> dalej do <code>&#x3C;button ref={ref}></code> przypisując go do atrybutu JSX.<li>Gdy referencja zostanie zamontowana, <code>ref.current</code> będzie wskazywać na element DOM <code>&#x3C;button></code>.</ol><blockquote><p>Uwaga<p>Drugi argument <code>ref</code> istnieje tylko, gdy definiujesz komponent przy pomocy wywołania <code>React.forwardRef</code>. Zwyczajna funkcja lub klasa nie dostanie argumentu <code>ref</code>, nawet jako jednej z właściwości (<code>props</code>).<p>Przekazywanie referencji nie jest ograniczone do elementów drzewa DOM. Możesz także przekazywać referencje do instancji komponentów klasowych.</blockquote></section><section id="note-for-component-library-maintainers"class="level2"><h2>Uwaga dla autorów bibliotek komponentów</h2><p><strong>Kiedy zaczniesz używać <code>forwardRef</code> w swojej bibliotece komponentów, potraktuj to jako zmianę krytyczną (ang. <em>breaking change</em>). W efekcie biblioteka powinna zostać wydana w nowej "wersji głównej" (ang. <em>major version</em>, <em>major release</em>).</strong> Należy tak postąpić, ponieważ najprawdopodobniej twoja biblioteka zauważalnie zmieniła zachowanie (np. inaczej przypinając referencje i eksportując inne typy). Może to popsuć działanie aplikacji, które są zależne od dawnego zachowania.<p>Stosowanie <code>React.forwardRef</code> warunkowo, gdy ono istnieje, także nie jest zalecane z tego samego powodu: zmienia to zachowanie biblioteki i może zepsuć działanie aplikacji użytkowników, gdy zmienią wersję Reacta.</section><section id="forwarding-refs-in-higher-order-components"class="level2"><h2>Przekazywanie referencji w komponentach wyższego rzędu</h2><p>Omawiana technika może okazać się wyjątkowo przydatna w <a href="./higher-order-components.html">komponentach wyższego rzędu</a> (KWR; ang. <em>Higher-Order Components</em> lub <em>HOC</em>). Zacznijmy od przykładu KWR-a, który wypisuje w konsoli wszystkie właściwości komponentu:<p><code>embed:forwarding-refs/log-props-before.js</code><p>KWR <code>logProps</code> przekazuje wszystkie atrybuty do komponentu, który opakowuje, więc wyrenderowany wynik będzie taki sam. Na przykład, możemy użyć tego KWRa do logowania atrybutów, które zostaną przekazane do naszego komponentu <code>FancyButton</code>: <code>embed:forwarding-refs/fancy-button.js</code><p>Powyższe rozwiązanie ma jeden minus: referencje nie zostaną przekazane do komponentu. Dzieje się tak, ponieważ <code>ref</code> nie jest atrybutem. Tak jak <code>key</code>, jest on obsługiwany przez Reacta w inny sposób. Referencja będzie w tym wypadku odnosiła się do najbardziej zewnętrznego kontenera, a nie do opakowanego komponentu.<p>Oznacza to, że referencje przeznaczone dla naszego komponentu <code>FancyButton</code> będą w praktyce wskazywać na komponent <code>LogProps</code>.<br><code>embed:forwarding-refs/fancy-button-ref.js</code><p>Na szczęście możemy jawnie przekazać referencję do wewnętrznego komponentu <code>FancyButton</code> używając API <code>React.forwardRef</code>. <code>React.forwardRef</code> przyjmuje funkcję renderującą, która otrzymuje parametry <code>props</code> oraz <code>ref</code>, a zwraca element reactowy. Na przykład: <code>embed:forwarding-refs/log-props-after.js</code></section><section id="displaying-a-custom-name-in-devtools"class="level2"><h2>Wyświetlanie własnej nazwy w narzędziach deweloperskich</h2><p><code>React.forwardRef</code> przyjmuje funkcję renderującą. Narzędzia deweloperskie Reacta (ang. <em>React DevTools</em>) używają tej funkcji do określenia, jak wyświetlać komponent, który przekazuje referencję.<p>Przykładowo, następujący komponent w narzędziach deweloperskich wyświetli się jako "<em>ForwardRef</em>":<p><code>embed:forwarding-refs/wrapped-component.js</code><p>Jeśli nazwiesz funkcję renderującą, narzędzia deweloperskie uwzględnią tę nazwę (np. "<em>ForwardRef(myFunction)</em>"):<p><code>embed:forwarding-refs/wrapped-component-with-function-name.js</code><p>Możesz nawet ustawić właściwość <code>displayName</code> funkcji tak, aby uwzględniała nazwę opakowanego komponentu:<p><code>embed:forwarding-refs/customized-display-name.js</code> <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>