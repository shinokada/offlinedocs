<!doctypehtml><html lang="pl"><meta charset="utf-8"><title>Główne API Reacta</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="główne-api-reacta"class="level1"><h1>Główne API Reacta</h1><p>Obiekt <code>React</code> jest punktem wejściowym do biblioteki React. Jeśli załadujesz ją używając tagu <code>&#x3C;script></code>, główny interfejs API będzie dostępny w zmiennej globalnej <code>React</code>. Jeśli używasz standardu ES6, możesz skorzystać ze składni <code>import React from 'react'</code>. Jeśli używasz starszego standardu ES5, użyj składni <code>var React = require('react')</code>.<section id="overview"class="level2"><h2>Ogólne informacje</h2><section id="components"class="level3"><h3>Komponenty</h3><p>Komponenty reaktowe pozwalają podzielić interfejs użytkownika na niezależne, enkapsulowane elementy, z których możesz korzystać w wielu miejscach. Komponenty w Reakcie mogą być definiowane poprzez dziedziczenie po klasie <code>React.Component</code> lub <code>React.PureComponent</code>.<ul><li><a href="#reactcomponent"><code>React.Component</code></a><li><a href="#reactpurecomponent"><code>React.PureComponent</code></a></ul><p>Jeśli nie używasz standardu ES6 do definiowania klas, możesz skorzystać z modułu <code>create-react-class</code>. W innym rozdziale opisaliśmy sposób na <a href="./react-without-es6.html">korzystanie z Reacta bez ES6</a>.<p>Komponenty reactowe można również zdefiniować jako funkcje, a następnie otoczyć:<ul><li><a href="#reactmemo"><code>React.memo</code></a></ul></section><section id="creating-react-elements"class="level3"><h3>Tworzenie elementów reactowych</h3><p>Do opisania wyglądu interfejsu użytkownika polecamy <a href="./introducing-jsx.html">korzystanie ze składni JSX</a>. W JSX elementy są tylko wygodniejszymi odpowiednikami wywołania metody <a href="#createelement"><code>React.createElement()</code></a>. Jeśli korzystasz z JSX, prawdopodobnie nigdy nie przyjdzie ci korzystać z tych metody bezpośrednio.<ul><li><a href="#createelement"><code>createElement()</code></a><li><a href="#createfactory"><code>createFactory()</code></a></ul><p>Aby dowiedzieć się więcej na ten temat, zajrzyj do rozdziału pt. <a href="./react-without-jsx.html">"React bez JSX"</a>.</section><section id="transforming-elements"class="level3"><h3>Przekształcanie elementów</h3><p><code>React</code> udostępnia kilka API do manipulowania elementami:<ul><li><a href="#cloneelement"><code>cloneElement()</code></a><li><a href="#isvalidelement"><code>isValidElement()</code></a><li><a href="#reactchildren"><code>React.Children</code></a></ul></section><section id="fragments"class="level3"><h3>Fragmenty</h3><p><code>React</code> pozwala także renderować wiele komponentów bez konieczności używania komponentu opakowującego.<ul><li><a href="#reactfragment"><code>React.Fragment</code></a></ul></section><section id="refs"class="level3"><h3>Referencje (ang. <em>refs</em>)</h3><ul><li><a href="#reactcreateref"><code>React.createRef</code></a><li><a href="#reactforwardref"><code>React.forwardRef</code></a></ul></section><section id="suspense"class="level3"><h3>Suspense</h3><p><code>Suspense</code> pozwala komponentowi "poczekać" na konkretne zdarzenie przez wyrenderowaniem. Obecnie <code>Suspense</code> obsługuje tylko jeden przypadek użycia: <a href="./code-splitting.html#reactlazy">dynamiczne ładowanie komponentów przy użyciu <code>React.lazy</code></a>. W przyszłości będzie wspierał także inne przypadki użycia, jak na przykład pobieranie danych.<ul><li><a href="#reactlazy"><code>React.lazy</code></a><li><a href="#reactsuspense"><code>React.Suspense</code></a></ul></section><section id="transitions"class="level3"><h3>Tranzycje</h3><p><em>Tranzycje</em> są nową funkcjonalnością współbieżną dodaną w Reakcie 18. Pozwalają oznaczyć aktualizacje stanu jako tranzycje, informując tym samym Reacta, że mogą one zostać przerwane i nie wymagają wyświetlenia komponentu zastępczego Suspense dla widocznej już treści.<ul><li><a href="#starttransition"><code>React.startTransition</code></a><li><a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a></ul></section><section id="hooks"class="level3"><h3>Hooki</h3><p><em>Hooki</em> są nowym dodatkiem w Reakcie 16.8. Pozwalają one używać stanu i innych funkcjonalności Reacta bez użycia klas. Hooki mają <a href="./hooks-intro.html">dedykowany rozdział w dokumentacji</a> oraz osobny interfejs API:<ul><li><a href="./hooks-reference.html#basic-hooks">Podstawowe hooki</a><ul><li><a href="./hooks-reference.html#usestate"><code>useState</code></a><li><a href="./hooks-reference.html#useeffect"><code>useEffect</code></a><li><a href="./hooks-reference.html#usecontext"><code>useContext</code></a></ul><li><a href="./hooks-reference.html#additional-hooks">Dodatkowe hooki</a><ul><li><a href="./hooks-reference.html#usereducer"><code>useReducer</code></a><li><a href="./hooks-reference.html#usecallback"><code>useCallback</code></a><li><a href="./hooks-reference.html#usememo"><code>useMemo</code></a><li><a href="./hooks-reference.html#useref"><code>useRef</code></a><li><a href="./hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a><li><a href="./hooks-reference.html#uselayouteffect"><code>useLayoutEffect</code></a><li><a href="./hooks-reference.html#usedebugvalue"><code>useDebugValue</code></a><li><a href="./hooks-reference.html#usedeferredvalue"><code>useDeferredValue</code></a><li><a href="./hooks-reference.html#usetransition"><code>useTransition</code></a><li><a href="./hooks-reference.html#useid"><code>useId</code></a></ul><li><a href="./hooks-reference.html#library-hooks">Library Hooks</a><ul><li><a href="./hooks-reference.html#usesyncexternalstore"><code>useSyncExternalStore</code></a><li><a href="./hooks-reference.html#useinsertioneffect"><code>useInsertionEffect</code></a></ul></ul><hr></section></section><section id="reference"class="level2"><h2>Dokumentacja</h2><section id="reactcomponent-reactcomponent"class="level3"><h3><code>React.Component</code> {#reactcomponent}</h3><p><code>React.Component</code> to klasa bazowa dla komponentów reaktowych, definiowanych przez użycie <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">klasy ze standardu ES6</a>:<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Greeting</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token maybe-class-name">Witaj</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Lista metod i właściwości związanych z klasą <code>React.Component</code> znajduje się w <a href="./react-component.html">dokumentacji API dla React.Component</a>.<hr></section><section id="reactpurecomponent-reactpurecomponent"class="level3"><h3><code>React.PureComponent</code> {#reactpurecomponent}</h3><p>Klasa <code>React.PureComponent</code> jest podobna do <a href="#reactcomponent"><code>React.Component</code></a>. Różnica między nimi jest taka, że <a href="#reactcomponent"><code>React.Component</code></a> nie posiada implementacji metody <a href="./react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a>, natomiast <code>React.PureComponent</code> implementuje ją z użyciem płytkiego porównania właściwości (<em>ang. props</em>) i stanu.<p>Jeśli metoda <code>render()</code> danego komponentu wyświetla ten sam rezultat przy tych samych właściwościach i stanie, możesz przekształcić go na <code>React.PureComponent</code>, by poprawić wydajność.<blockquote><p>Uwaga<p>Metoda <code>shouldComponentUpdate()</code> klasy <code>React.PureComponent</code> wykonuje jedynie płytkie porównanie obiektów. Jeśli zawierają one skomplikowaną strukturę danych, może to wprowadzić nieprawidłowości podczas zmian na głębszych poziomach struktury. Korzystaj z <code>PureComponent</code> tylko, jeśli spodziewasz się prostej struktury właściwości i stanu, lub użyj <a href="./react-component.html#forceupdate"><code>forceUpdate()</code></a>, jeśli wiesz, że dane umieszczone głęboko w strukturze uległy zmianie. Możesz także zastanowić się nad skorzystaniem z <a href="https://immutable-js.com/">niezmiennych obiektów (ang. <em>immutable objects</em>)</a>, by ułatwić szybkie porównanie zagnieżdżonych danych.<p>Dodatkowo, <code>shouldComponentUpdate()</code> klasy <code>React.PureComponent</code> pomija aktualizację właściwości dla całego poddrzewa komponentu. Upewnij się, że wszystkie komponenty potomne również korzystają z tego rozwiązania.</blockquote><hr></section><section id="reactmemo-reactmemo"class="level3"><h3><code>React.memo</code> {#reactmemo}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token maybe-class-name">MyComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* renderuj korzystając z właściwości */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>React.memo</code> jest <a href="./higher-order-components.html">komponentem wyższego rzędu (ang. <em>higher-order component</em>)</a>.<p>Jeśli twój komponent przy takich samych właściwościach zawsze renderuje tę samą strukturę, możesz opakować go w <code>React.memo</code> w celu poprawy wydajności. Oznacza to, że React pominie renderowanie tego komponentu i użyje jego ostatnio wyrenderowanej wersji.<p><code>React.memo</code> reaguje tylko na zmiany we właściwościach. Jeśli twój komponent funkcyjny opakowany w <code>React.memo</code> używa hooków <a href="./hooks-state.html"><code>useState</code></a>, <a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> lub <a href="./hooks-reference.html#usecontext"><code>useContext</code></a>, nadal będzie się aktualizował przy zmianie stanu komponentu lub kontekstu.<p>Domyślnie, komponent wykona jedynie płytkie porównanie obiektów przekazanych we właściwościach. Jeśli chcesz zastosować własny mechanizm porównujący, możesz przekazać odpowiednią funkcję jako drugi argument.<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* renderuj korzystając z właściwości */</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">areEqual</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*
  zwróć true, jeśli przekazując nextProps, komponent zwróciłby
  taki sam rezultat, jak po przekazaniu prevProps;
  w innym przypadku zwróć false
  */</span>
<span class="token punctuation">}</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token maybe-class-name">MyComponent</span><span class="token punctuation">,</span> areEqual<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Ta metoda wykorzystywana jest jedynie do <strong><a href="./optimizing-performance.html">optymalizacji wydajności</a>.</strong> Nie powinno się używać jej do "zapobiegania" renderowaniu, ponieważ może to doprowadzić do większej ilości błędów.<blockquote><p>Uwaga<p>W odróżnieniu od metody <a href="./react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a> w komponencie klasowym, funkcja <code>areEqual</code> zwraca <code>true</code>, jeśli właściwości są jednakowe, lub <code>false</code>, jeśli nie są. Jest to odwrócona logika metody <code>shouldComponentUpdate</code>.</blockquote><hr></section><section id="createelement-createelement"class="level3"><h3><code>createElement()</code> {#createelement}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">createElement</span><span class="token punctuation">(</span>
  type<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>props<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token spread operator">...</span>children<span class="token punctuation">]</span>
<span class="token punctuation">)</span></code></pre><p>Tworzy i zwraca nowy <a href="./rendering-elements.html">element reactowy</a> danego typu. Argument <code>type</code> może być zarówno nazwą znacznika HTML (np. <code>'div'</code> lub <code>'span'</code>), <a href="./components-and-props.html">komponentem reaktowym</a> (klasą lub funkcją), jak i <a href="#reactfragment">fragmentem reaktowym</a>.<p>Kod pisany w <a href="./introducing-jsx.html">JSX</a> jest konwertowany do wywołań funkcji <code>React.createElement()</code>. Jeśli korzystasz z JSX, w większości przypadków nie będziesz bezpośrednio wywoływać <code>React.createElement()</code>. Przeczytaj rozdział pt. <a href="./react-without-jsx.html">"React bez JSX"</a>, aby dowiedzieć się więcej.<hr></section><section id="cloneelement-cloneelement"class="level3"><h3><code>cloneElement()</code> {#cloneelement}</h3><pre class="language-text"><code class="language-text">React.cloneElement(
  element,
  [config],
  [...children]
)</code></pre><p>Zacznij od sklonowania i zwrócenia elementu reactowego przy pomocy argumentu <code>element</code>. <code>config</code> powinien zawierać wszystkie nowe właściwości, <code>key</code> lub <code>ref</code>. Nowo utworzony element będzie posiadał pierwotne właściwości scalone płytko z nowymi. Nowe elementy potomne zastąpią obecne. <code>key</code> oraz <code>ref</code> z pierwotnego elementu zostaną zachowane, jeśli nie przekażesz ich w <code>config</code>.<p>Wywołanie <code>React.cloneElement()</code> jest niemal równoznaczne z napisaniem:<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span>element<span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>element<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token spread operator">...</span>props<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>element<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token operator">></span></code></pre><p>Jednakże zachowuje on także wszystkie referencje <code>ref</code>. Oznacza to, że jeśli jeden z komponentów potomnych posiada <code>ref</code>, nie zostanie on przypadkowo zabrany z jednego z przodków. Nowy element będzie posiadał ten sam <code>ref</code> co przed klonowaniem. Nowy <code>ref</code> lub <code>key</code> zastąpią poprzednie, jeśli je przekażesz.<p>Powyższy interfejs API zastąpił przestarzałą funkcję <code>React.addons.cloneWithProps()</code>.<hr></section><section id="createfactory-createfactory"class="level3"><h3><code>createFactory()</code> {#createfactory}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">createFactory</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span></code></pre><p>Zwraca funkcję, która tworzy reaktowy element danego typu. Tak jak <a href="#createElement"><code>React.createElement()</code></a>, argument <code>type</code> może być zarówno nazwą znacznika HTML (np. <code>'div'</code> lub <code>'span'</code>), <a href="./components-and-props.html">komponentem reactowym</a> (klasą lub funkcją) lub <a href="#reactfragment">fragmentem reactowym</a>.<p>Ta funkcja pomocnicza jest uznawana za przestarzałą i radzimy korzystać z JSX lub bezpośrednio z <code>React.createElement()</code>.<p>Jeśli korzystasz z JSX, nie ma potrzeby korzystania z <code>React.createFactory()</code>. Przeczytaj rozdział pt. <a href="./react-without-jsx.html">React bez JSX</a>, aby dowiedzieć się więcej.<hr></section><section id="isvalidelement-isvalidelement"class="level3"><h3><code>isValidElement()</code> {#isvalidelement}</h3><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">isValidElement</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span></code></pre><p>Weryfikuje, czy obiekt jest elementem reactowym. Zwraca <code>true</code> lub <code>false</code>.<hr></section><section id="reactchildren-reactchildren"class="level3"><h3><code>React.Children</code> {#reactchildren}</h3><p><code>React.Children</code> udostępnia narzędzia do obsługi struktury danych przekazanej w <code>this.props.children</code>.<section id="reactchildrenmap-reactchildrenmap"class="level4"><h4><code>React.Children.map</code> {#reactchildrenmap}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">[</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>Wywołuje funkcję na każdym bezpośrednim komponencie potomnych zawartym w <code>children</code>, z <code>this</code> ustawionym na <code>thisArg</code>. Jeśli <code>children</code> jest tablicą, funkcja zostanie wywołana na każdym elemencie tej tablicy. Jeśli potomek jest wartością <code>null</code> lub <code>undefined</code>, metoda ta zamiast tablicy zwróci <code>null</code> lub <code>undefined</code><blockquote><p>Uwaga<p>Jeśli <code>children</code> jest typu <code>Fragment</code>, zostanie potraktowany jako pojedynczy potomek, nie jak tablica.</blockquote></section><section id="reactchildrenforeach-reactchildrenforeach"class="level4"><h4><code>React.Children.forEach</code> {#reactchildrenforeach}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">[</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>Działa tak samo jak <a href="#reactchildrenmap"><code>React.Children.map()</code></a>, ale nie zwraca tablicy.</section><section id="reactchildrencount-reactchildrencount"class="level4"><h4><code>React.Children.count</code> {#reactchildrencount}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">count</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p>Zwraca liczbę komponentów w <code>children</code>, równą liczbie potencjalnych wywołań funkcji zwrotnej (ang. <em>callback</em>) przekazanej do <code>map</code> lub <code>forEach</code>.</section><section id="reactchildrenonly-reactchildrenonly"class="level4"><h4><code>React.Children.only</code> {#reactchildrenonly}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">only</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p>Weryfikuje, czy <code>children</code> ma tylko jednego potomka (element reactowy), i zwraca go. W innym przypadku metoda rzuci wyjątkiem.<blockquote><p>Uwaga:<p><code>React.Children.only()</code> nie akceptuje wartości zwracanej przez <a href="#reactchildrenmap"><code>React.Children.map()</code></a>, ponieważ jest to tablica, a nie element reactowy.</blockquote></section><section id="reactchildrentoarray-reactchildrentoarray"class="level4"><h4><code>React.Children.toArray</code> {#reactchildrentoarray}</h4><pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Children</span></span><span class="token punctuation">.</span><span class="token method function property-access">toArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span></code></pre><p>Zwraca strukturę z <code>children</code> jako płaską tablicę, z kluczem przypisanym do każdego z potomków. Przydatne, jeśli chcemy manipulować grupą potomków w metodzie renderującej, zwłaszcza jeśli chcemy zmienić ich kolejność lub podzielić przed przekazaniem dalej.<blockquote><p>Uwaga:<p><code>React.Children.toArray()</code> zmienia klucze, by zachować semantyczną poprawność zagłębionych tablic podczas przygotowywania płaskiej struktury. Oznacza to, że <code>toArray</code> doda prefiks do nazwy każdego klucza, tak by każdy element należał do odpowiedniego zakresu.</blockquote><hr></section></section><section id="reactfragment-reactfragment"class="level3"><h3><code>React.Fragment</code> {#reactfragment}</h3><p>Komponent <code>React.Fragment</code> pozwala zwrócić wiele elementów w metodzie <code>render()</code> bez opakowywania ich w dodatkowy element DOM:<pre class="language-javascript"><code class="language-javascript"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Fragment</span></span><span class="token operator">></span>
      <span class="token maybe-class-name">Jakiś</span> tekst<span class="token punctuation">.</span>
      <span class="token operator">&#x3C;</span>h2<span class="token operator">></span><span class="token maybe-class-name">Nagłówek</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h2<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Fragment</span></span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Możesz także skorzystać ze skróconego zapisu <code>&#x3C;>&#x3C;/></code>. Po więcej informacji zajrzyj do wpisu na blogu - <a href="/blog/2017/11/28/react-v16.2.0-fragment-support.html">React v16.2.0: Improved Support for Fragments</a>.</section><section id="reactcreateref-reactcreateref"class="level3"><h3><code>React.createRef</code> {#reactcreateref}</h3><p><code>React.createRef</code> tworzy <a href="./refs-and-the-dom.html">referencję</a>, którą możesz przypiąć do dowolnego elementu reactowego poprzez właściwość <code>ref</code>. <code>embed:16-3-release-blog-post/create-ref-example.js</code></section><section id="reactforwardref-reactforwardref"class="level3"><h3><code>React.forwardRef</code> {#reactforwardref}</h3><p><code>React.forwardRef</code> tworzy komponent reactowy, który przekazuje właściwość <a href="./refs-and-the-dom.html"><code>ref</code></a> do kolejnego komponentu w dół drzewa. Ta technika nie jest zbyt popularna, ale przydatna w dwóch konkretnych przypadkach:<ul><li><a href="./forwarding-refs.html#forwarding-refs-to-dom-components">Przekazywanie referencji do komponentów DOM</a><li><a href="./forwarding-refs.html#forwarding-refs-in-higher-order-components">Przekazywanie referencji w komponentach wyższego rzędu</a></ul><p><code>React.forwardRef</code> przyjmuje funkcję renderującą jako argument. React wywoła tę funkcję, przekazując <code>props</code> oraz <code>ref</code> jako argumenty. Funkcja ta powinna zwrócić węzeł reactowy (ang. <em>React node</em>).<p><code>embed:reference-react-forward-ref.js</code><p>W powyższym przykładzie React przekazuje <code>ref</code> poprzez <code>&#x3C;FancyButton ref={ref}></code> jako drugi argument funkcji renderującej wewnątrz <code>React.forwardRef</code>. Funkcja renderująca przekaże <code>ref</code> do elementu <code>&#x3C;button ref={ref}></code>.<p>W rezultacie, po tym, jak referencja zostanie przypięta przez Reacta, <code>ref.current</code> będzie wskazywał bezpośrednio na element <code>&#x3C;button></code>.<p>Aby dowiedzieć się więcej, przeczytaj rozdział poświęcony <a href="./forwarding-refs.html">przekazywaniu referencji</a>.</section><section id="reactlazy-reactlazy"class="level3"><h3><code>React.lazy</code> {#reactlazy}</h3><p><code>React.lazy()</code> pozwala definiować komponenty, które są ładowane dynamicznie. Zmniejsza się w ten sposób rozmiar paczki, ponieważ wyodrębnione zostają komponenty, które nie są używane podczas wstępnego renderowania.<p>W naszej <a href="./code-splitting.html#reactlazy">dokumentacji poświęconej rozdzielaniu kodu</a> zamieściliśmy więcej informacji na ten temat. <a href="https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d">Ten artykuł</a> również może okazać się pomocny w wyjaśnieniu zasad działania tej metody.<pre class="language-js"><code class="language-js"><span class="token comment">// Ten komponent jest ładowany dynamicznie</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">SomeComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./SomeComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Pamiętaj, że renderowanie "leniwych komponentów" (ang. <em>lazy components</em>) wymaga użycia komponentu <code>&#x3C;React.Suspense></code> na wyższym poziomie drzewa. W ten sposób definiuje się wskaźnik ładowania.</section><section id="reactsuspense-reactsuspense"class="level3"><h3><code>React.Suspense</code> {#reactsuspense}</h3><p><code>React.Suspense</code> pozwala zdefiniować wskaźnik ładowania, w razie gdyby któryś z komponentów poniżej nie był jeszcze gotowy do wyrenderowania. W przyszłości planujemy dodanie do <code>Suspense</code> obsługi większej liczby scenariuszy, jak np. pobieranie danych. Możesz poczytać o tym więcej w <a href="/blog/2018/11/27/react-16-roadmap.html">naszym planie działania</a>.<p>Obecnie <strong>jedynym</strong> przypadkiem użycia <code>&#x3C;React.Suspense></code> jest dynamiczne ładowanie komponentów.<pre class="language-js"><code class="language-js"><span class="token comment">// Ten komponent jest ładowany dynamicznie</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">OtherComponent</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./OtherComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token comment">// Wyświetla &#x3C;Spinner> dopóki OtherComponent nie zostanie załadowany</span>
    <span class="token operator">&#x3C;</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Suspense</span></span> fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Spinner</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
        <span class="token operator">&#x3C;</span><span class="token maybe-class-name">OtherComponent</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Suspense</span></span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>W naszej <a href="./code-splitting.html#reactlazy">dokumentacji poświęconej rozdzielaniu kodu</a> zamieściliśmy więcej informacji na ten temat. Zwróć uwagę na to, że komponenty <code>lazy</code> mogą być zawarte w drzewie wiele poziomów poniżej <code>Suspense</code>. Dobrą praktyką jest umieszczanie <code>&#x3C;Suspense></code> w miejscu, w którym powinien pojawić się wskaźnik ładowania, natomiast <code>lazy()</code> w miejscu, w którym chcesz rozdzielić kod.<blockquote><p>Uwaga<p>Jeśli jakaś treść jest już wyświetlona na ekranie, przełączenie na wskaźnik aktywności może być dezorientujące dla użytkownika. Czasami lepiej jest wyświetlić "stary" interfejs, podczas gdy nowy jest jeszcze przygotowywany. Aby to zrobić, możesz użyć nowego API <a href="#starttransition"><code>startTransition</code></a> oraz <a href="./hooks-reference.html#usetransition"><code>useTransition</code></a>, oznaczając w ten sposób niektóre aktualizacje jako "tranzycje" i unikając niepotrzebnego mrugania ekranu.</blockquote><section id="reactsuspense-in-server-side-rendering"class="level4"><h4><code>React.Suspense</code> w renderowaniu po stronie serwera</h4><p>Podczas renderowania po stronie serwera granice zawieszenia (ang. <em>Suspense boundaries</em>) pozwalają wysłać aplikację w mniejszych kawałkach poprzez zawieszanie (ang. <em>suspending</em>) komponentów. Kiedy komponent jest zawieszony, React każe najbliższej granicy Suspense wyrenderować swój komponent zastępczy. Jeśli komponent się odwiesi przed wysłaniem kodu do klienta, komponent zastępczy jest wyrzucany, a w jego miejsce trafia właściwa zawartość.</section><section id="reactsuspense-during-hydration"class="level4"><h4><code>React.Suspense</code> podczas hydratacji</h4><p>Granice zawieszenia (ang. <em>Suspense boundaries</em>) są zależne od tego, czy ich granice nadrzędne ulegną hydratacji przed nimi, lecz nie muszą czekać na swoje "rodzeństwo", czyli granice na tym samym poziomie. W przypadku wystąpienia jakiegoś zdarzenia na którejś z granic przed jej całkowitą hydratacją, otrzyma ona wyższy priorytet niż pozostałe. <a href="https://github.com/reactwg/react-18/discussions/130">Czytaj więcej.</a></section></section><section id="reactstarttransition-starttransition"class="level3"><h3><code>React.startTransition</code> {#starttransition}</h3><pre class="language-js"><code class="language-js"><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">startTransition</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span></code></pre><p><code>React.startTransition</code> pozwala oznaczyć aktualizacje stanu wewnątrz jakiejś funkcji jako "tranzycję". Tej funkcji należy używać w miejscach, gdzie nie można skorzystać z <a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a>.<blockquote><p>Uwaga:<p>Aktualizacje w tranzycjach ustępują pierwszeństwa bardziej pilnym aktualizacjom, jak np. kliknięciom na ekranie.<p>Aktualizacje w tranzycji nie powodują wyświetlenia komponentu zastępczego (ang. <em>fallback</em>) przy ponownym zawieszeniu, dzięki czemu użytkownik może kontynuować interację ze "starym" interfejsem, dopóki nie zakończy się tranzycja.<p><code>React.startTransition</code> nie zwraca flagi <code>isPending</code>. Aby śledzić status tranzycji, użyj hooka <a href="./hooks-reference.html#usetransition"><code>React.useTransition</code></a>. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></blockquote></section></section></section>