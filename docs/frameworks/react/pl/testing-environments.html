<!doctypehtml><html lang="pl"><meta charset="utf-8"><title>Środowiska testujące</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="środowiska-testujące"class="level1"><h1>Środowiska testujące</h1><p>W tym rozdziale opisujemy czynniki wpływające na środowisko testujące i nasze rekomendacje dla niektórych scenariuszy.<section id="test-runners"class="level3"><h3>Narzędzia uruchamiające testy (ang. <em>test runners</em>)</h3><p>Narzędzia uruchamiające testy, jak np. <a href="https://jestjs.io/">Jest</a>, <a href="https://mochajs.org/">mocha</a> czy <a href="https://github.com/avajs/ava">ava</a>, pozwalają tworzyć zestawy testowe przy użyciu samego JavaScriptu, a także uruchamiać je jako część procesu tworzenia oprogramowania. Dodatkowo, testy mogą być uruchamiane w ramach procesu "ciągłej integracji" (ang. <em>Continuous Integration</em>, CI).<ul><li>Jest ma wysoką kompatybilność z projektami reactowymi i obsługuje wiele przydatnych funkcjonalności, jak <a href="#mocking-modules">mockowanie modułów</a> czy <a href="#mocking-timers">sztuczne timery</a>. Dobrze współpracuje również z <a href="#mocking-a-rendering-surface"><code>jsdom</code></a>. <strong>Jeśli używasz Create React App, <a href="https://facebook.github.io/create-react-app/docs/running-tests">domyślnie masz już dostęp do Jesta</a> z odpowiednią konfiguracją.</strong><li>Biblioteki takie jak <a href="https://mochajs.org/#running-mocha-in-the-browser">mocha</a> świetnie spisują się w środowiskach przeglądarkowych, dzięki czemu mogą okazać się pomocne w przypadku niektórych testów.<li>Testy kompleksowe end-to-end, stosowane w przypadku dłuższych ścieżek rozciągających się na wiele stron aplikacji, wymagają <a href="#end-to-end-tests-aka-e2e-tests">innej konfiguracji</a>.</ul></section><section id="mocking-a-rendering-surface"class="level3"><h3>Mockowanie warstwy renderującej</h3><p>Testy często uruchamiane są w środowiskach niemających dostępu do prawdziwej warstwy renderującej, np. przeglądarki. Zalecamy więc symulowanie zachowań przeglądarki za pomocą <a href="https://github.com/jsdom/jsdom"><code>jsdom</code></a>, niewielkiej implementacji przeglądarki działającej na Node.js.<p>W większości przypadków <code>jsdom</code> zachowuje się jak prawdziwa przeglądarka, lecz nie posiada niektórych funkcjonalności, jak np. <a href="https://github.com/jsdom/jsdom#unimplemented-parts-of-the-web-platform">generowanie układu strony czy nawigacja</a>. Mimo tego paczka z powodzeniem sprawdza się dla większości komponentów pisanych pod przeglądarkę; działa szybciej niż uruchamianie przeglądarki dla każdego testu z osobna. Ponadto, uruchamia ona testy w tym samym procesie, umożliwiając pisanie kodu sprawdzającego wyrenderowane drzewo DOM.<p>Podobnie jak prawdziwa przeglądarka, <code>jsdom</code> pozwala na modelowanie interakcji użytkownika; testy mogą wywoływać zdarzenia na węzłach DOM, a następnie obserwować i sprawdzać wyniki tych akcji <a href="./testing-recipes.html#events"><small>(przykład)</small></a>.<p>Przy takiej konfiguracji można śmiało napisać większość testów dla UI: Jest jako narzędzie uruchamiające testy, jsdom służący do renderowania, interakcje użytkownika określone jako sekwencje zdarzeń przeglądarkowych - a to wszystko "spięte" za pomocą funkcji pomocniczej <code>act()</code> <a href="./testing-recipes.html"><small>(przykład)</small></a>. Spora część testów samego Reacta jest napisana przy użyciu powyższej kombinacji.<p>Jeśli piszesz bibliotekę, która testuje głównie zachowania charakterystyczne dla przeglądarki, a w dodatku wymaga natywnych mechanizmów przeglądarki, jak generowanie układu strony, zalecamy skorzystanie z frameworka <a href="https://mochajs.org/">mocha</a>.<p>W środowisku, które <em>uniemożliwia</em> symulowanie modelu DOM (np. podczas testowania komponentów napisanych w React Native na Node.js), możesz skorzystać z <a href="./test-utils.html#simulate">narzędzi do symulowania zdarzeń</a> do symulowania interakcji z elementami. Alternatywnie możesz skorzystać z funkcji <code>fireEvent</code> dostarczonej przez <a href="https://testing-library.com/docs/react-native-testing-library/intro"><code>@testing-library/react-native</code></a>.<p>Frameworki jak <a href="https://www.cypress.io/">Cypress</a>, <a href="https://github.com/GoogleChrome/puppeteer">puppeteer</a> czy <a href="https://www.seleniumhq.org/projects/webdriver/">webdriver</a> służą do uruchamiania testów <a href="#end-to-end-tests-aka-e2e-tests">end-to-end</a>.</section><section id="mocking-functions"class="level3"><h3>Mockowanie funkcji</h3><p>Podczas pisania testów czasami chcemy podmienić części naszego kodu, które nie posiadają odpowiedników w używanym przez nas środowisku (np. sprawdzanie statusu <code>navigator.onLine</code> w Node.js). Testy mogą również śledzić niektóre funkcje i obserwować, jak pozostałe części kodu wchodzą z nimi w interakcje. Pomocna okazuje się wtedy możliwość wybiórczego zastąpienia niektórych funkcji wersjami odpowiednimi dla testów.<p>Szczególnie przydatne okazuje się to przy pobieraniu danych. Zazwyczaj lepiej w testach używać "sztucznych" danych, aby uniknąć spowolnień czy niestabilności z powodu odwołań do prawdziwego API <a href="./testing-recipes.html#data-fetching"><small>(przykład)</small></a>. Dzięki takiemu zabiegowi testy są przewidywalne. Biblioteki typu <a href="https://jestjs.io/">Jest</a> czy <a href="https://sinonjs.org/">sinon</a> wspierają mockowanie funkcji. W przypadku testów end-to-end, mockowanie sieci może okazać się trudniejsze, choć należy tego unikać i zamiast tego testować korzystając z prawdziwego API.</section><section id="mocking-modules"class="level3"><h3>Mockowanie modułów</h3><p>Niektóre komponenty mają zależności w modułach, które mogą nie działać w środowisku testowym lub które zwyczajnie nie są istotne z punktu widzenia naszych testów. Warto wtedy zastąpić te moduły czymś odpowiednim dla danego przypadku <a href="./testing-recipes.html#mocking-modules"><small>(przykład)</small></a>.<p>W Node.js <a href="https://jestjs.io/docs/en/manual-mocks">mockowanie modułów</a> jest wspierane np. przez bibliotekę Jest. Można to również osiągnąć z pomocą paczki <a href="https://www.npmjs.com/package/mock-require"><code>mock-require</code></a>.</section><section id="mocking-timers"class="level3"><h3>Mockowanie timerów</h3><p>Komponenty mogą korzystać z funkcji opartych na czasie, np. <code>setTimeout</code>, <code>setInterval</code> czy <code>Date.now</code>. W środowisku testowym warto zamieniać tego typu funkcje na ich zastępniki, które pozwalają ręcznie "sterować czasem". To świetny sposób na znaczne przyspieszenie działania testów. Testy korzystające z timerów nadal będą wykonywać się w odpowiedniej kolejności, ale zdecydowanie szybciej <a href="./testing-recipes.html#timers"><small>(przykład)</small></a>. Większość frameworków, również <a href="https://jestjs.io/docs/en/timer-mocks">Jest</a>, <a href="https://sinonjs.org/releases/v7.3.2/fake-timers/">sinon</a> oraz <a href="https://github.com/sinonjs/lolex">lolex</a>, pozwalają na mockowanie timerów w testach.<p>Niekiedy jednak możesz chcieć skorzystać z prawdziwych timerów, na przykład, gdy testujesz animację lub interakcję z endpointem, który zależy od czasu (np. ogranicza częstość odpytywania API). Biblioteki zawierające sztuczne timery pozwalają na łatwe włączanie i wyłączanie tego mechanizmu dla każdego zestawu testowego lub pojedynczego testu. Dzięki temu możesz zdecydować, jak poszczególne testy mają być uruchamiane.</section><section id="end-to-end-tests-aka-e2e-tests"class="level3"><h3>Testy end-to-end</h3><p>Testy end-to-end są efektywne przy testowaniu dłuższych sekwencji interakcji, zwłaszcza jeśli są one krytyczne dla twojego produktu (np. płatność czy rejestracja). W takich przypadkach konieczne jest przetestowanie, jak przeglądarka renderuje całą aplikację, jak pobiera dane z API, korzysta z sesji i ciasteczek lub nawiguje pomiędzy poszczególnymi stronami. Możesz w nich sprawdzać nie tylko stan drzewa DOM, lecz także sterujące nim dane (np. weryfikując, czy dane zostały zapisane w bazie danych).<p>Do takich scenariuszy możesz skorzystać z frameworka <a href="https://www.cypress.io/">Cypress</a>, <a href="https://playwright.dev">Playwright</a> lub biblioteki <a href="https://pptr.dev/">Puppeteer</a>, które pozwalają nawigować pomiędzy stronami i sprawdzać rezultaty nie tylko w samej przeglądarce, ale potencjalnie również na backendzie. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>