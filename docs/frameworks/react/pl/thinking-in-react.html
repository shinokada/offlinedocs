<!doctypehtml><html lang="pl"><meta charset="utf-8"><title>Myślenie reactowe</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="myślenie-reactowe"class="level1"><h1>Myślenie reactowe</h1><ul><li>'blog/2013/11/05/thinking-in-react.html'<li>'docs/thinking-in-react-zh-CN.html'</ul><p>Naszym zdaniem React dostarcza pierwszorzędnych narzędzi do budowy dużych, szybkich aplikacji webowych. Znakomicie sprawdza się, na przykład, w naszych zastosowaniach na Facebooku i w Instagramie.<p>Jedną z wielu zalet Reacta jest to, jak praca z tą biblioteką uczy cię myśleć o aplikacjach, które tworzysz. Poniżej przybliżymy ci proces myślowy towarzyszący budowie przykładowego programu. Będzie to tabela z danymi o produktach z funkcją wyszukiwania, w całości zbudowana w Reakcie.<section id="start-with-a-mock"class="level2"><h2>Zacznij od projektu</h2><p>Załóżmy, że mamy już gotowy interfejs JSON API oraz projekt graficzny, który wygląda następująco:<figure><img src="../images/blog/thinking-in-react-mock.png"alt="Projekt graficzny"><figcaption aria-hidden="true">Projekt graficzny</figcaption></figure><p>Nasz interfejs JSON API dostarcza następujących informacji:<pre class="language-text"><code class="language-text">[
];</code></pre></section><section id="step-1-break-the-ui-into-a-component-hierarchy"class="level2"><h2>Krok 1: Podziel interfejs użytkownika na zhierarchizowany układ komponentów</h2><p>W pierwszej kolejności zakreśl na projekcie wszystkie komponenty (i podkomponenty) oraz nadaj im nazwy. Jeśli współpracujesz z zespołem designerów, możliwe, że oni zrobili to już za ciebie. Koniecznie skontaktuj się z nimi. Nazwy komponentów reactowych często biorą się z nazw nadanych warstwom w Photoshopie.<p>Skąd wiadomo, co powinno być komponentem? Zastosuj te same metody, których używamy tworząc nowe funkcje lub obiekty. Jedną z takich metod jest <a href="https://pl.wikipedia.org/wiki/Zasada_jednej_odpowiedzialno%C5%9Bci">Zasada jednej odpowiedzialności</a>, zgodnie z którą każdy komponent powinien być odpowiedzialny za tylko jedną rzecz. Jeśli komponent nie spełnia tej zasady i odpowiada za więcej rzeczy, należy go rozbić na kilka mniejszych komponentów.<p>Model danych wyświetlanych użytkownikowi często odpowiada modelowi zawartemu w plikach JSON. Dlatego jeśli właściwie skonstruujesz swój model, twój interfejs użytkownika (a co za tym idzie także twój układ komponentów) zostanie właściwie zmapowany. Wiąże się to z faktem, że interfejsy użytkownika i modele danych zwykle stosują się do tych samych zasad <em>architektury informacji</em>. Wszystko to zaś oznacza, że zadanie podziału interfejsu użytkownika na komponenty jest zwykle zadaniem dziecinnie prostym. Po prostu podziel go tak, aby jednemu elementowi twojego modelu danych odpowiadał jeden komponent.<figure><img src="../images/blog/thinking-in-react-components.png"alt="Diagram pokazujący zagnieżdżenie komponentów"><figcaption aria-hidden="true">Diagram pokazujący zagnieżdżenie komponentów</figcaption></figure><p>Zwróć uwagę, że nasza prosta aplikacja składa się z pięciu komponentów. Dane, za które odpowiedzialne są poszczególne komponenty, zaznaczyliśmy kursywą. Numery umieszczone na obrazku odpowiadają numerom poniżej.<ol><li><strong><code>FilterableProductTable</code> (pol. tabela produktów z wyszukiwaniem; pomarańczowy):</strong> mieszczą się w nim wszystkie pozostałe komponenty<li><strong><code>SearchBar</code> (pol. pasek wyszukiwania; niebieski):</strong> odbiera wpisane przez użytkownika słowo lub frazę (<em>szukana fraza</em>)<li><strong><code>ProductTable</code> (pol. tabela produktów; zielony):</strong> wyświetla i filtruje <em>kolekcję danych</em> na podstawie <em>szukanej frazy</em><li><strong><code>ProductCategoryRow</code> (pol. wiersz rodzaju produktu; turkusowy):</strong> wyświetla nagłówek dla każdego <em>rodzaju</em> produktów<li><strong><code>ProductRow</code> (pol. wiersz produktu; czerwony):</strong> wyświetla wiersz dla każdego <em>produktu</em></ol><p>Zauważ, że nagłówek naszej <code>ProductTable</code> (zawierający nazwy kolumn "Name" i "Price") nie jest osobnym komponentem, chociaż mógłby nim być. W tym przypadku jest to bardziej kwestia naszych indywidualnych preferencji niż zasada ogólna dla tego typu elementów. W naszej przykładowej aplikacji uznaliśmy ten nagłówek za integralną część komponentu <code>ProductTable</code>, ponieważ wyświetlany jest razem z <em>danymi zebranymi</em>, a wyświetlanie <em>danych zebranych</em> jest odpowiedzialnością <code>ProductTable</code>. Jeśli jednak element ten miałby się w naszej aplikacji rozrosnąć (tzn. gdybyśmy mieli dodać do niego funkcję sortowania), jak najbardziej wskazane byłoby zrobienie z niego osobnego komponentu <code>ProductTableHeader</code>.<p>Teraz, kiedy już określiliśmy, które z elementów projektu graficznego mają być komponentami, ułożymy je w odpowiedniej hierarchii. Nie jest to zbyt trudne. Komponenty występujące wewnątrz innych komponentów przedstawimy w naszej hierarchii jako komponenty potomne.<ul><li><code>FilterableProductTable</code><ul><li><code>SearchBar</code><li><code>ProductTable</code><ul><li><code>ProductCategoryRow</code><li><code>ProductRow</code></ul></ul></ul></section><section id="step-2-build-a-static-version-in-react"class="level2"><h2>Krok 2: Zbuduj wersję statyczną w Reakcie</h2><p data-height="600"data-theme-id="0"data-slug-hash="BwWzwm"data-default-tab="js"data-user="lacker"data-embed-version="2"class="codepen">Zobacz kod dla podrozdziału <a href="https://codepen.io/gaearon/pen/BwWzwm">"Myślenie reactowe: Krok 2"</a> na <a href="https://codepen.io">CodePen</a>.</p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><p>Skoro wiemy już, jak wygląda hierarchia naszych komponentów, możemy zacząć ją wdrażać. Budowę aplikacji najłatwiej jest zacząć od wersji statycznej, tzn. takiej, która wyrenderuje interfejs użytkownika na podstawie naszego modelu danych, ale nie będzie zawierała żadnych elementów interaktywnych. Dobrze jest rozdzielić te procesy, ponieważ budowa wersji statycznej wymaga więcej pisania niż myślenia, podczas gdy dodawanie interaktywności wymaga więcej myślenia niż pisania. Za chwilę zobaczysz dlaczego.<p>Aby zbudować statyczną wersję aplikacji, która wyrenderuje nasz model danych, musimy stworzyć komponenty, które będą korzystać z innych komponentów i przekazywać dane za pomocą <em>atrybutów</em> (ang. <em>props</em>). <em>Atrybuty</em> umożliwiają przekazywanie danych z komponentu nadrzędnego do komponentu potomnego. Jeśli wiesz już, czym jest <em>stan</em> w Reakcie, powstrzymaj się przed zastosowaniem go tutaj. <strong>Nie należy używać stanu</strong> do budowy statycznych wersji aplikacji. Stan wiąże się wyłącznie z interaktywnością, tzn. danymi zmieniającymi się w czasie.<p>Tworzenie naszej aplikacji możemy rozpocząć albo od komponentów znajdujących się wysoko w hierarchii (w naszym przypadku od <code>FilterableProductTable</code>), albo od tych znajdujących się na samym dole (<code>ProductRow</code>). Zazwyczaj, budując proste aplikacje, zaczyna się od góry, natomiast w przypadku projektów większych łatwiej jest zacząć pracę od dołu hierarchii, jednocześnie pisząc testy dla poszczególnych funkcjonalności.<p>Kończąc ten etap pracy nad aplikacją będziemy mieli dostępną bibliotekę komponentów wielokrotnego użytku, które renderują nasz model danych. Komponenty te będą miały tylko jedną metodę <code>render()</code> (pol. <em>renderuj</em>) ponieważ jest to statyczna wersja aplikacji. Komponent na szczycie hierarchii komponentów (<code>FilterableProductTable</code>) wykorzysta nasz model danych jako atrybut. Każda zmiana w naszym modelu danych w połączeniu z ponownym wywołaniem <code>root.render()</code> spowoduje aktualizację interfejsu użytkownika. Cały proces aktualizacji interfejsu jest bardzo prosty, a ponieważ wszelkie zmiany są od razu widoczne, łatwo można się zorientować, które fragmenty kodu wymagają poprawy. <strong>Jednokierunkowy transfer danych</strong> w Reakcie (nazywany również <em>wiązaniem jednokierunkowym</em>, ang. <em>one-way binding</em>) zapewnia modularność kodu i szybkie działanie aplikacji.<p>Jeśli potrzebujesz pomocy na tym etapie budowy aplikacji, zajrzyj do <a href="./getting-started.html">Dokumentacji Reacta</a>.<section id="a-brief-interlude-props-vs-state"class="level3"><h3>Krótki przerywnik: atrybuty a stan</h3><p>W Reakcie wyróżniamy dwa modele danych: atrybuty i stan. Bardzo ważne jest zrozumienie, czym dokładnie modele te się różnią. Dla przypomnienia rzuć okiem na <a href="./state-and-lifecycle.html">oficjalną dokumentację Reacta</a>. Możesz także zajrzeć do odpowiedzi <a href="./faq-state.html#what-is-the-difference-between-state-and-props">FAQ: Jaka jest różnica między stanem a atrybutami?</a></section></section><section id="step-3-identify-the-minimal-but-complete-representation-of-ui-state"class="level2"><h2>Krok 3: Określ minimalne (ale kompletne) odwzorowanie stanu interfejsu użytkownika</h2><p>Aby interfejs użytkownika mógł zawierać elementy interaktywne, musimy mieć możliwość dokonywania zmian w modelu danych, na którym opiera się nasza aplikacja. W Reakcie jest to bardzo łatwe dzięki <strong>stanowi</strong>.<p>Poprawna budowa aplikacji wymaga w pierwszej kolejności określenia minimalnego zmiennego zestawu danych dla stanu aplikacji. Kluczowa jest tutaj reguła <a href="https://pl.wikipedia.org/wiki/DRY">DRY: <em>Don't Repeat Yourself</em></a> (pol. <em>Nie powtarzaj się</em>). Zadecyduj, jak ma wyglądać najprostsze możliwe odwzorowanie stanu aplikacji, a wszystko inne generuj dopiero wtedy, gdy pojawi się taka potrzeba. Przykładowo, jeśli tworzysz aplikację, która ma zarządzać "Listą rzeczy do zrobienia", zachowaj "pod ręką" jedynie tablicę z rzeczami do zrobienia; nie ma potrzeby tworzenia osobnej zmiennej stanu przechowującej liczbę tych rzeczy. Kiedy zachodzi potrzeba wyrenderowania liczby rzeczy do zrobienia, po prostu pobierz długość tablicy.<p>Przyjrzyjmy się wszystkim rodzajom informacji w naszej przykładowej aplikacji. Mamy tutaj:<ul><li>Początkową listę produktów<li>Frazę wyszukiwania podaną przez użytkownika<li>Wartość odznaczonego pola<li>Listę produktów spełniających kryteria wyszukiwania</ul><p>Aby zdecydować, która z powyższych informacji zalicza się do stanu, w przypadku każdej z nich musimy zadać sobie trzy pytania:<ol><li>Czy informacja ta jest przekazywana za pomocą atrybutu? Jeśli tak, to prawdopodobnie nie wchodzi w skład stanu.<li>Czy informacja ta pozostanie niezmienna na przestrzeni czasu? Jeśli tak, to prawdopodobnie nie wchodzi w skład stanu.<li>Czy informację tę można wygenerować na podstawie innego stanu lub atrybutu w danym komponencie. Jeśli tak, to nie należy zaliczyć jej do stanu.</ol><p>Początkowa lista produktów jest przekazywana jako atrybut, zatem nie jest stanem. Wyszukiwana fraza i wartość odznaczonego pola wydają się wchodzić w skład stanu, ponieważ mogą ulegać zmianom i nie da się ich w żaden sposób wygenerować. Jeśli chodzi o listę produktów spełniających kryteria wyszukiwania, to nie jest ona stanem, ponieważ może być wygenerowana na podstawie wyszukiwanej frazy i wartości odznaczonego pola.<p>Zatem ostatecznie nasz stan przestawia się następująco:<ul><li>Fraza wyszukiwania podana przez użytkownika<li>Wartość zaznaczonego pola</ul></section><section id="step-4-identify-where-your-state-should-live"class="level2"><h2>Krok 4: Określ, gdzie powinien mieścić się stan</h2><p data-height="600"data-theme-id="0"data-slug-hash="qPrNQZ"data-default-tab="js"data-user="lacker"data-embed-version="2"class="codepen">Zobacz kod dla podrozdziału <a href="https://codepen.io/gaearon/pen/qPrNQZ">"Myślenie reactowe: Krok 4"</a> na <a href="https://codepen.io">CodePen</a>.<p>Mamy zatem określony minimalny zestaw danych stanu aplikacji. Teraz musimy określić, który z naszych komponentów ulega zmianom, czyli do którego komponentu <em>należy</em> stan.<p>Pamiętaj: Dane w Reakcie płyną tylko w jedną stronę - z góry w dół hierarchii komponentów. Przynależność stanu do danego komponentu nie jest sprawą oczywistą i <em>często przysparza problemów na początku pracy z Reactem</em>. Aby to dobrze zrozumieć, postępuj zgodnie z następującymi wskazówkami:<p>Dla każdego elementu stanu w twojej aplikacji:<ul><li>Określ każdy komponent, który coś renderuje na podstawie danego elementu stanu.<li>Znajdź wspólnego właściciela stanu (tzn. komponent znajdujący się w hierarchii wyżej od wszystkich pozostałych komponentów wykorzystujących dany element stanu).<li>Stan powinien należeć do wspólnego właściciela lub po prostu do innego komponentu znajdującego się wyżej w hierarchii komponentów.<li>Jeśli trudno ci określić właściwe miejsce umieszczenia stanu, stwórz nowy komponent, którego jedynym celem będzie przechowywanie stanu. Ulokuj go w hierarchii komponentów gdzieś powyżej komponentu będącego wspólnym właścicielem.</ul><p>Zastosujmy tę strategię w pracy nad naszą aplikacją:<ul><li><code>ProductTable</code> wymaga stanu, aby filtrować listę produktów. <code>SearchBar</code> wymaga stanu, aby wyświetlać wyszukiwaną frazę i wartość zaznaczonego pola<li>Wspólnym właścicielem jest <code>FilterableProductTable</code>.<li>Sensownym rozwiązaniem jest umieszczenie wyszukiwanej frazy i wartości zaznaczonego pola w <code>FilterableProductTable</code></ul><p>No dobra. Zatem ustaliliśmy, że stan umieścimy w <code>FilterableProductTable</code>. Teraz do konstruktora tego komponentu dodajemy właściwość instancji <code>this.state = {filterText: '', inStockOnly: false}</code>, aby ustalić początkowy stan naszej aplikacji. Następnie za pomocą atrybutów podajemy <code>filterText</code> oraz <code>inStockOnly</code> do komponentów <code>ProductTable</code> i <code>SearchBar</code>. Na końcu użyjemy tych atrybutów, aby przefiltrować wiersze <code>ProductTable</code> i ustawić wartość pola formularza w <code>SearchBar</code>.<p>Teraz widać już, jak będzie działała nasza aplikacja: ustawiamy <code>filterText</code> na ciąg znaków <code>"ball"</code> i odświeżamy aplikację. Nasza tabela danych poprawnie wyświetla nowe informacje.</section><section id="step-5-add-inverse-data-flow"class="level2"><h2>Krok 5: Dodaj przepływ danych w drugą stronę</h2><p data-height="600"data-theme-id="0"data-slug-hash="LzWZvb"data-default-tab="js,result"data-user="rohan10"data-embed-version="2"data-pen-title="Myślenie reactowe: Krok 5"class="codepen">Zobacz kod dla podrozdziału <a href="https://codepen.io/gaearon/pen/LzWZvb">"Myślenie reactowe: Krok 5"</a> na <a href="https://codepen.io">CodePen</a>.<p>Jak dotąd zbudowaliśmy aplikację, która poprawnie wyświetla informacje dostarczone przez atrybuty i stan, spływające w dół hierarchii komponentów. Nadszedł czas, aby umożliwić przepływ danych w przeciwnym kierunku: komponenty formularza głęboko wewnątrz hierarchii muszą mieć możliwość aktualizowania stanu <code>FilterableProductTable</code>.<p>W Reakcie ten przepływ danych jest jawny. Pozwala to łatwo zobaczyć działanie aplikacji, ale zarazem wymaga trochę więcej kodu niż tradycyjne wiązanie dwukierunkowe (ang. <em>two-way binding</em>).<p>Jeśli spróbujesz wpisać coś do paska wyszukiwania albo zaznaczyć pole wyboru w poprzedniej wersji naszego przykładu (krok 4), React zignoruje dostarczone przez ciebie dane. Jest to działanie zamierzone, które wynika stąd, że wartość atrybutu <code>value</code> dla elementu <code>input</code> ustawiliśmy jako zawsze równą stanowi <code>state</code> podanemu z komponentu <code>FilterableProductTable</code>.<p>Zastanówmy się nad tym, co chcemy żeby się działo. Chcemy, aby stan aktualizował się i odzwierciedlał treść formularza za każdym razem, kiedy użytkownik dokona w formularzu zmian. Ponieważ komponenty powinny aktualizować jedynie własny stan, <code>FilterableProductTable</code> poda funkcję zwrotną (ang. <em>callback</em>) do paska wyszukiwania <code>SearchBar</code>, która to funkcja zostanie wywołana przy każdej aktualizacji stanu. Jeśli chcemy być o tym za każdym razem poinformowani, możemy dodać zdarzenie <code>onChange</code> do elementów naszego formularza. Funkcje zwrotne podane przez <code>FilterableProductTable</code> wywołają <code>setState()</code> i stan aplikacji zostanie zaktualizowany.<p>Może wydawać się, że powyższy proces jest skomplikowany, ale w rzeczywistości to tylko kilka linijek kodu, a przepływ danych w całej aplikacji jest naprawdę jawny i łatwy do prześledzenia.</section><section id="and-thats-it"class="level2"><h2>To byłoby na tyle</h2><p>Mamy nadzieję, że niniejszy przewodnik przybliżył ci myślenie reactowe, tzn. główne zasady, którymi kierujemy się tworząc komponenty i aplikacje z użyciem React.js. Być może stosowanie tej biblioteki wymaga pisania większej ilości kodu niż inne znane ci biblioteki i frameworki, pamiętaj jednak, że kod czyta się znacznie częściej niż tworzy, a czytanie kodu napisanego w Reakcie nie przysparza problemów ze względu na jego modularność i przejrzystość. Zalety tej przejrzystości i modularności na pewno docenisz tworząc duże biblioteki komponentów. Natomiast wielokrotne stosowanie gotowych kawałków kodu zaoszczędzi ci wiele pracy. :) <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>