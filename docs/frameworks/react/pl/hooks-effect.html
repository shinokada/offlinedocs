<!doctype html>
<html lang="pl">
  <head>
    <meta charset="utf-8">
    <title>Używanie hooka efektów</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="używanie-hooka-efektów" class="level1">
      <h1>Używanie hooka efektów</h1>
      <p><em>Hooki</em> są nowym dodatkiem w Reakcie 16.8. Pozwalają one używać stanu i innych funkcjonalności Reacta, bez użycia klas.</p>
      <p><em>Hook efektów</em> pozwala na przeprowadzanie efektów ubocznych w komponentach funkcyjnych:</p>
      <pre class="language-js{1,6-10}"><code class="language-js{1,6-10}">import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // Podobnie do metod componentDidMount i componentDidUpdate:
  useEffect(() => {
    // Zaktualizuj tytuł dokumentu korzystając z interfejsu API przeglądarki
    document.title = `Kliknięto ${count} razy`;
  });

  return (
    &#x3C;div>
      &#x3C;p>Kliknięto {count} razy&#x3C;/p>
      &#x3C;button onClick={() => setCount(count + 1)}>
        Kliknij mnie
      &#x3C;/button>
    &#x3C;/div>
  );
}</code></pre>
      <p>Ten fragment kodu oparty jest na <a href="./hooks-state.html">przykładzie licznika z poprzedniego rozdziału</a>, ale dodaliśmy do niego nową funkcjonalność: ustawiamy tytuł dokumentu na własną wiadomość, zawierającą liczbę kliknięć.</p>
      <p>Pobieranie danych, tworzenie subskrypcji czy ręczna ingerencja w drzewo DOM z wewnątrz komponentów - to wszystko przykłady efektów ubocznych. Niezależnie od tego, czy znasz je pod nazwą „efekty uboczne” (lub po prostu „efekty”), najprawdopodobniej masz je zaszyte gdzieś w swoim kodzie.</p>
      <blockquote>
        <p>Wskazówka</p>
        <p>Jeżeli znasz już metody cyklu życia (ang. <em>lifecycle methods</em>) Reacta, możesz myśleć o hooku <code>useEffect</code> jako o połączeniu metod <code>componentDidMount</code>, <code>componentDidUpdate</code> i <code>componentWillUnmount</code> w jedną.</p>
      </blockquote>
      <p>W komponentach reactowych występują powszechnie dwa rodzaje efektów ubocznych: te, po których należy „posprzątać” i te, po których nie. Przyjrzyjmy się uważniej temu podziałowi.</p>
      <section id="effects-without-cleanup" class="level2">
        <h2>Efekty niewymagające sprzątania</h2>
        <p>Czasami chcemy <strong>uruchomić jakiś dodatkowy kod po tym, jak React zaktualizuje drzewo DOM.</strong> Zapytania sieciowe, ręczna modyfikacja drzewa DOM czy logowanie to powszechne przykłady efektów, które nie wymagają sprzątania. Mówimy tak, ponieważ możemy je uruchomić i od razu o nich zapomnieć. Porównajmy teraz, jak klasy i hooki pozwalają na przeprowadzanie takich efektów ubocznych.</p>
        <section id="example-using-classes" class="level3">
          <h3>Przykład wykorzystujący klasy</h3>
          <p>W klasowych komponentach reactowych metoda <code>render</code> nie powinna wywoływać żadnych efektów ubocznych. Działo by się to bowiem zbyt wcześnie -- zwykle chcemy przeprowadzać efekty już <em>po tym</em>, jak React zaktualizuje drzewo DOM.</p>
          <p>Dlatego też w reactowych klasach umieszczamy efekty uboczne w specjalnych metodach <code>componentDidMount</code> i <code>componentDidUpdate</code>. Wracając do naszego przykładu, oto klasowy komponent licznika, który aktualizuje tytuł dokumentu po tym, jak React zaktualizuje drzewo DOM:</p>
          <pre class="language-js{9-15}"><code class="language-js{9-15}">class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    document.title = `Kliknięto ${this.state.count} razy`;
  }

  componentDidUpdate() {
    document.title = `Kliknięto ${this.state.count} razy`;
  }

  render() {
    return (
      &#x3C;div>
        &#x3C;p>Kliknięto {this.state.count} razy&#x3C;/p>
        &#x3C;button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Kliknij mnie
        &#x3C;/button>
      &#x3C;/div>
    );
  }
}</code></pre>
          <p>Zauważ, że <strong>musieliśmy powtórzyć ten sam kod w dwóch metodach cyklu życia.</strong></p>
          <p>Dzieje się tak dlatego, że w wielu przypadkach chcemy wywołać ten sam efekt uboczny, niezależnie od tego czy komponent właśnie został zamontowany, czy też zaktualizowany. Koncepcja jest taka, żeby działo się to po każdym wyrenderowaniu komponentu. Ale reactowe komponenty klasowe nie mają takiej metody. Moglibyśmy, co prawda, wydzielić osobną metodę, ale wciąż musielibyśmy wywoływać ją w dwóch miejscach.</p>
          <p>Teraz sprawdźmy, jak osiągnąć to samo korzystając z hooka <code>useEffect</code>.</p>
        </section>
        <section id="example-using-hooks" class="level3">
          <h3>Przykład wykorzystujący hooki</h3>
          <p>Widzieliśmy już ten przykład na początku tego rozdziału, ale spójrzmy raz jeszcze:</p>
          <pre class="language-js{1,6-8}"><code class="language-js{1,6-8}">import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `Kliknięto ${count} razy`;
  });

  return (
    &#x3C;div>
      &#x3C;p>Kliknięto {count} razy&#x3C;/p>
      &#x3C;button onClick={() => setCount(count + 1)}>
        Kliknij mnie
      &#x3C;/button>
    &#x3C;/div>
  );
}</code></pre>
          <p><strong>Co robi wywołanie <code>useEffect</code>?</strong> Poprzez użycie tego hooka mówisz Reactowi, że twój komponent musi wykonać jakąś czynność po jego wyrenderowaniu. React zapamięta funkcję, którą przekazano do hooka (będziemy odtąd odnosić się do niej jako naszego „efektu”), a potem wywoła ją, gdy już zaktualizuje drzewo DOM. W tym przypadku aktualizujemy tytuł dokumentu, ale moglibyśmy równie dobrze pobrać dane z serwera lub wywołać inne, imperatywne API.</p>
          <p><strong>Dlaczego funkcja <code>useEffect</code> jest wywoływana wewnątrz komponentu?</strong> Umiejscowienie <code>useEffect</code> wewnątrz komponentu daje nam dostęp do zmiennej stanu <code>count</code> (oraz wszystkich właściwości (ang. <em>props</em>)) z wewnątrz efektu. Nie potrzebujemy specjalnego interfejsu API do odczytania tych zmiennych -- znajdują się one w zasięgu funkcji. Hooki wykorzystują javascriptowe domknięcia (ang. <em>closure</em>) i unikają wprowadzania nowych, specyficznych dla Reacta interfejsów API -- JavaScript dostarcza przecież gotowe rozwiązanie.</p>
          <p><strong>Czy <code>useEffect</code> działa przy każdym renderze?</strong> Tak! Domyślnie działa on zarówno przy pierwszym wyrenderowaniu komponentu <em>oraz</em> każdej kolejnej jego aktualizacji. (W dalszej części dowiemy się, <a href="#tip-optimizing-performance-by-skipping-effects">jak dostosować to zachowanie</a>.) Zamiast myśleć w kategoriach „montowania” i „aktualizacji”, być może łatwiej będzie ci zrozumieć, że efekty wykonywane są „po wyrenderowaniu”. React daje ci gwarancję, że drzewo DOM zostanie zaktualizowane zanim wywoła efekty.</p>
        </section>
        <section id="detailed-explanation" class="level3">
          <h3>Szczegółowe objaśnienie</h3>
          <p>Teraz, kiedy wiemy już więcej o efektach, te linijki kodu powinny nabrać sensu:</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Example</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Kliknięto </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> razy</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
          <p>Deklarujemy zmienną stanu <code>count</code>, a następnie mówimy Reactowi, że będziemy chcieli użyć efektu. Zatem do hooka <code>useEffect</code> przekazujemy funkcję, która <em>jest</em> naszym efektem. Wewnątrz tego efektu ustawiamy tytuł dokumentu, korzystając z interfejsu API przeglądarki (<code>document.title</code>). Możemy odczytać ostatnią wartość zmiennej <code>count</code> z wewnątrz efektu, ponieważ znajduje się ona w zasięgu naszej funkcji. Kiedy React będzie renderować nasz komponent, zapamięta użyty przez nas efekt, a następnie wywoła go po zaktualizowaniu drzewa DOM. Dzieje się to przy każdym renderowaniu, włączając pierwsze.</p>
          <p>Doświadczeni programiści języka JavaScript mogli zauważyć, że funkcja, którą przekazujemy do <code>useEffect</code>, będzie inna przy każdym renderze. Jest to celowe działanie. Właściwie to tylko dzięki temu możemy przeczytać wartość zmiennej <code>count</code> z wewnątrz efektu, nie martwiąc się, że będzie ona nieaktualna. Za każdym razem, kiedy ponownie renderujemy komponent, planujemy wykonanie <em>innego</em> efektu, który zastąpi poprzedni. W pewnym sensie sprawia to, że efekty zachowują się jak część wyniku renderowania -- każdy efekt „należy” do konkretnego renderowania. W <a href="#explanation-why-effects-run-on-each-update">dalszej części tego rozdziału</a> przyjrzymy się dokładniej, dlaczego jest to przydatne.</p>
          <blockquote>
            <p>Wskazówka</p>
            <p>W przeciwieństwie do metod <code>componentDidMount</code> i <code>componentDidUpdate</code>, efekty zaplanowane przy użyciu <code>useEffect</code> nie blokują przeglądarki przed odświeżeniem ekranu. Sprawia to wrażenie, że aplikacja działa płynniej. Większość efektów nie musi działać synchronicznie. W sporadycznych przypadkach, gdy muszą to robić (na przykład do pomiaru układu strony (ang. <em>layout</em>)), można skorzystać z dedykowanego hooka -- <a href="./hooks-reference.html#uselayouteffect"><code>useLayoutEffect</code></a>, z identycznym do <code>useEffect</code> interfejsem API.</p>
          </blockquote>
        </section>
      </section>
      <section id="effects-with-cleanup" class="level2">
        <h2>Efekty wymagające sprzątania</h2>
        <p>Wcześniej omówiliśmy, jak wyrazić efekty uboczne, które nie potrzebują po sobie „posprzątać”. Jednakże istnieją efekty, które muszą to robić. Na przykład, <strong>możemy chcieć utworzyć subskrypcję</strong> do jakiegoś zewnętrznego źródła danych. W tym przypadku ważne jest, aby po sobie posprzątać i uniknąć tym samym potencjalnego wycieku pamięci! Porównajmy, jak możemy to zrobić z klasami, a jak z hookami.</p>
        <section id="example-using-classes-1" class="level3">
          <h3>Przykład wykorzystujący klasy</h3>
          <p>W klasowych komponentach reactowych zwykle tworzy się subskrypcję w metodzie <code>componentDidMount</code>, a następnie sprząta w metodzie <code>componentWillUnmount</code>. Załóżmy, że mamy moduł <code>ChatAPI</code>, który pozwala nam zasubskrybować się na zmianę statusu dostępności znajomego. Tak moglibyśmy zasubskrybować się i wyświetlać status znajomego przy użyciu klasy:</p>
          <pre class="language-js{8-26}"><code class="language-js{8-26}">class FriendStatus extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOnline: null };
    this.handleStatusChange = this.handleStatusChange.bind(this);
  }

  componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  handleStatusChange(status) {
    this.setState({
      isOnline: status.isOnline
    });
  }

  render() {
    if (this.state.isOnline === null) {
      return 'Ładowanie...';
    }
    return this.state.isOnline ? 'Dostępny' : 'Niedostępny';
  }
}</code></pre>
          <p>Zauważ, że metoda <code>componentDidMount</code> jest lustrzanym odbiciem metody <code>componentWillUnmount</code>. Metody cyklu życia zmuszają nas do podziału tej logiki, mimo że koncepcyjnie stanowią one część tego samego efektu.</p>
          <blockquote>
            <p>Uwaga</p>
            <p>Czytelnicy o sokolim wzroku mogli zauważyć, że powyższy przykład potrzebuje też metody <code>componentDidUpdate</code>, aby działać w pełni poprawnie. Na razie pominiemy to zagadnienie, ale wrócimy do niego <a href="#explanation-why-effects-run-on-each-update">w dalszej części tego rozdziału</a>.</p>
          </blockquote>
        </section>
        <section id="example-using-hooks-1" class="level3">
          <h3>Przykład wykorzystujący hooki</h3>
          <p>Zobaczmy, jak stworzyć ten sam komponent przy użyciu hooków.</p>
          <p>Być może zastanawiasz się, czy będziemy potrzebować jakiegoś osobnego efektu, aby przeprowadzić czyszczenie. Kod do tworzenia i anulowania subskrypcji jest tak ściśle ze sobą powiązany, że <code>useEffect</code> został specjalnie zaprojektowany w ten sposób, aby utrzymać go razem. Jeśli efekt zwróci funkcję, React uruchomi ją, gdy nadejdzie pora na sprzątanie:</p>
          <pre class="language-js{6-16}"><code class="language-js{6-16}">import React, { useState, useEffect } from 'react';

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    // Określ sposób sprzątania po tym efekcie:
    return function cleanup() {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) {
    return 'Ładowanie...';
  }
  return isOnline ? 'Dostępny' : 'Niedostępny';
}</code></pre>
          <p><strong>Dlaczego zwróciliśmy funkcję z naszego efektu?</strong> Jest to opcjonalny mechanizm sprzątania po efektach. Każdy efekt może zwrócić funkcję, która określa sposób, w jaki sposób należy po nim posprzątać. Pozwala nam to na trzymanie logiki dotyczącej tworzenia i usuwania subskrypcji w jednym miejscu. Są one częścią tego samego efektu!</p>
          <p><strong>Kiedy dokładnie React sprząta po naszym efekcie?</strong> Dzieje się to wtedy, gdy komponent jest odmontowywany. Jednakże, jak dowiedzieliśmy się wcześniej, efekty są wywoływane nie raz, ale przy każdym wyrenderowaniu komponentu. Dlatego React <em>również</em> sprząta po efektach poprzedniego renderowania, zanim wywoła kolejne efekty. Wyjaśnimy <a href="#explanation-why-effects-run-on-each-update">dlaczego pomaga to uniknąć błędów</a> i <a href="#tip-optimizing-performance-by-skipping-effects">jak zrezygnować z tego zachowania w przypadku problemów z wydajnością</a> w dalszej części tego rozdziału.</p>
          <blockquote>
            <p>Uwaga</p>
            <p>Nie musisz nazywać funkcji zwracanej z efektów. My nazwaliśmy ją <code>cleanup</code> (pol. <em>posprzątaj</em>) aby lepiej wyjaśnić jej zamysł. Możesz po prostu zwrócić funkcję strzałkową (ang. <em>arrow function</em>) albo nazwać funkcję inaczej.</p>
          </blockquote>
        </section>
      </section>
      <section id="recap" class="level2">
        <h2>Podsumowanie</h2>
        <p>Nauczyliśmy się, że hook <code>useEffect</code> pozwala nam wyrazić różnego rodzaju efekty uboczne po wyrenderowaniu komponentu. Niektóre efekty mogą wymagać sprzątania, dlatego zwracają odpowiednią funkcję:</p>
        <pre class="language-js"><code class="language-js">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">handleStatusChange</span><span class="token punctuation">(</span><span class="token parameter">status</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setIsOnline</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token property-access">isOnline</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">friend</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">friend</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>Inne efekty mogą nie mieć fazy czyszczenia, nie zwracają więc nic.</p>
        <pre class="language-js"><code class="language-js">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Kliknięto </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> razy</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <p>Hook efektów łączy oba przypadki użycia w jednym interfejsie API.</p>
        <hr>
        <p><strong>Jeżeli czujesz, że masz już przyzwoitą wiedzę na temat hooka efektów albo jeśli rozbolała cię głowa od natłoku wiedzy, możesz od razu przejść do kolejnego rozdziału pt. <a href="./hooks-rules.html">„Zasady korzystania z Hooków”</a>.</strong></p>
        <hr>
      </section>
      <section id="tips-for-using-effects" class="level2">
        <h2>Porady dotyczące używania efektów</h2>
        <p>W dalszej części tego rozdziału przyjrzymy się głębiej niektórym aspektom hooka <code>useEffect</code>, które najprawdopodobniej zainteresują bardziej doświadczonych użytkowników Reacta. Nie musisz jednak zgłębiać ich wszystkich od razu. Zawsze możesz wrócić do tego rozdziału kiedy indziej i doczytać więcej o hooku efektów.</p>
        <section id="tip-use-multiple-effects-to-separate-concerns" class="level3">
          <h3>Porada: Użyj kilku efektów do odseparowania logiki</h3>
          <p>Jednym z problemów, który przedstawiliśmy we wprowadzeniu do hooków, w podrozdziale pt. <a href="./hooks-intro.html#complex-components-become-hard-to-understand">„Motywacja”</a> jest to, że metody cyklu życia w klasach zazwyczaj zawierają niepowiązaną ze sobą logikę. Z kolei wzajemnie powiązana logika jest podzielona na kilka metod. Oto przykład komponentu, który łączy w sobie zarówno logikę licznika, jak i statusu dostępności znajomego z poprzednich przykładów:</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">FriendStatusWithCounter</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">isOnline</span><span class="token operator">:</span> <span class="token keyword null nil">null</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleStatusChange</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">handleStatusChange</span><span class="token punctuation">.</span><span class="token method function property-access">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Kliknięto </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> razy</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToFriendStatus</span><span class="token punctuation">(</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">friend</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleStatusChange</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Kliknięto </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> razy</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">friend</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleStatusChange</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">handleStatusChange</span><span class="token punctuation">(</span><span class="token parameter">status</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">isOnline</span><span class="token operator">:</span> status<span class="token punctuation">.</span><span class="token property-access">isOnline</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span></code></pre>
          <p>Zauważ, jak logika ustawiania właściwości <code>document.title</code> jest podzielona pomiędzy metody <code>componentDidMount</code> i <code>componentDidUpdate</code>. Logika tworzenia subskrypcji jest również rozrzucona pomiędzy <code>componentDidMount</code> i <code>componentWillUnmount</code>. A metoda <code>componentDidMount</code> zawiera kod dla obu tych zadań.</p>
          <p>Jak hooki rozwiązują ten problem? Podobnie <a href="./hooks-state.html#tip-using-multiple-state-variables">jak możesz używać hooka <em>stanu</em> więcej niż raz</a>, możesz też używać wielu efektów. Pozwala to na wydzielenie niepowiązanej logiki na osobne efekty:</p>
          <pre class="language-js{3,8}"><code class="language-js{3,8}">function FriendStatusWithCounter(props) {
  const [count, setCount] = useState(0);
  useEffect(() => {
    document.title = `Kliknięto ${count} times`;
  });

  const [isOnline, setIsOnline] = useState(null);
  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });
  // ...
}</code></pre>
          <p><strong>Hooki pozwalają na dzielenie kodu na mniejsze fragmenty pod względem ich odpowiedzialności</strong>, a nie ze względu na nazwę metody cyklu życia. React wywoła <em>każdy</em> efekt użyty w komponencie w takiej kolejności, w jakiej został dodany.</p>
        </section>
        <section id="explanation-why-effects-run-on-each-update" class="level3">
          <h3>Wyjaśnienie: Dlaczego efekty działają przy każdej aktualizacji</h3>
          <p>Jeżeli zwykle używasz klas, pewnie zastanawiasz się, dlaczego faza sprzątania po efektach następuje przy każdym kolejnym renderowaniu, a nie tylko raz, podczas odmontowywania komponentu. Spójrzmy na praktyczny przykład, aby lepiej zrozumieć dlaczego taka konstrukcja pozwala nam tworzyć komponenty z mniejszą liczbą błędów.</p>
          <p><a href="#example-using-classes-1">Wcześniej w tym rozdziale</a> pokazaliśmy przykład komponentu <code>FriendStatus</code>, który wyświetla status dostępności znajomego. Nasza klasa czyta wartość <code>friend.id</code> z właściwości <code>this.props</code> i tworzy subskrypcję, gdy komponent jest montowany, a następnie usuwa ją, gdy jest odmontowywany.</p>
          <pre class="language-js"><code class="language-js">  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToFriendStatus</span><span class="token punctuation">(</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">friend</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleStatusChange</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">friend</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">handleStatusChange</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre>
          <p><strong>Ale co wydarzy się, jeżeli właściwość <code>friend</code> zmieni się</strong>, podczas gdy komponent cały czas widnieje na ekranie? Nasz komponent wciąż będzie wyświetlał status dostępności znajomego, ale nie tego co trzeba. To błąd. Spowodowalibyśmy też wyciek pamięci lub inną katastrofę przy odmontowywaniu, jako że usuwamy subskrypcję z nieprawidłowym ID znajomego.</p>
          <p>W komponencie klasowym powinniśmy dodać metodę <code>componentDidUpdate</code>, aby obsłużyć ten przypadek:</p>
          <pre class="language-js{8-19}"><code class="language-js{8-19}">  componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentDidUpdate(prevProps) {
    // Usuń subskypcję dla poprzedniej wartości friend.id
    ChatAPI.unsubscribeFromFriendStatus(
      prevProps.friend.id,
      this.handleStatusChange
    );
    // Utwórz subskrypcję dla nowej wartości friend.id
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }</code></pre>
          <p>Pominięcie poprawnej obsługi metody <code>componentDidUpdate</code> jest częstym źródłem błędów w aplikacjach reactowych.</p>
          <p>A teraz rozważ wersję tego komponentu, która korzysta z hooków:</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">FriendStatus</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">friend</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">friend</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
          <p>Nie jest ona podatna na ten błąd. (Ale nie wprowadziliśmy też żadnych zmian.)</p>
          <p>Nie ma żadnego specjalnego kodu na obsługę aktualizacji, ponieważ hook <code>useEffect</code> obsługuje je <em>domyślnie</em>. Czyści on poprzednie efekty, zanim przeprowadzi kolejne. Aby to lepiej zilustrować pokażemy sekwencję tworzenia i usuwania subskrypcji, jakie wywoła ten komponent w określonym czasie:</p>
          <pre class="language-js"><code class="language-js"><span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToFriendStatus</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Wywołaj pierwszy efekt</span>

<span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Wyczyść poprzedni efekt</span>
<span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToFriendStatus</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Przeprowadź kolejny efekt</span>

<span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Wyczyść poprzedni efekt</span>
<span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToFriendStatus</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Przeprowadź kolejny efekt</span>

<span class="token comment">// Odmontowanie</span>
<span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Posprzątaj ostatni efekt</span></code></pre>
          <p>Takie zachowanie zapewnia spójność i zapobiega występowaniu błędów typowych dla komponentów klasowych, spowodowanych brakiem implementacji logiki dla aktualizacji.</p>
        </section>
        <section id="tip-optimizing-performance-by-skipping-effects" class="level3">
          <h3>Porada: Optymalizacja wydajności przez pomijanie efektów</h3>
          <p>W niektórych przypadkach sprzątanie i przeprowadzanie efektów przy każdym renderze może stworzyć problemy z wydajnością. W komponentach klasowych możemy rozwiązać ten problem, dokładając dodatkowe porównanie wartości <code>prevProps</code> i <code>prevState</code> wewnątrz metody <code>componentDidUpdate</code>:</p>
          <pre class="language-js"><code class="language-js"><span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>prevState<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Kliknięto </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> razy</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
          <p>To wymaganie jest na tyle powszechne, że zostało wbudowane w interfejs API hooka <code>useEffect</code>. Możesz powiedzieć Reactowi, aby pominął przeprowadzanie efektu, jeśli pewne wartości nie zmieniły się między kolejnymi renderowaniami. Aby to zrobić, przekaż tablicę jako opcjonalny drugi argument do funkcji <code>useEffect</code>:</p>
          <pre class="language-js{3}"><code class="language-js{3}">useEffect(() => {
  document.title = `Klknięto ${count} razy`;
}, [count]); // Uruchom ponownie efekt tylko wtedy, gdy zmieni się wartość count</code></pre>
          <p>W powyższym przykładzie przekazujemy <code>[count]</code> jako drugi argument. Co to oznacza? Jeśli <code>count</code> ma wartość <code>5</code>, a nasz komponent jest ponownie renderowany z <code>count</code> wciąż równym <code>5</code>, React porówna <code>[5]</code> z poprzedniego renderowania i <code>[5]</code> z kolejnego renderowania. Ponieważ wszystkie elementy w tablicy są takie same (<code>5 === 5</code>), React pominie efekt. Oto nasza optymalizacja.</p>
          <p>Kiedy renderujemy z wartością <code>count</code> zaktualizowaną do <code>6</code>, React porówna elementy tablicy <code>[5]</code> z poprzedniego renderowania do elementów w tablicy <code>[6]</code> z kolejnego renderowania. Tym razem React ponownie zastosuje efekt, ponieważ <code>5 !== 6</code>. Jeśli w tablicy jest wiele elementów, React ponownie uruchomi efekt, nawet jeśli tylko jeden z nich mą inną wartość.</p>
          <p>Działa to również w przypadku efektów z fazą czyszczenia:</p>
          <pre class="language-js{10}"><code class="language-js{10}">useEffect(() => {
  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
  return () => {
    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
  };
}, [props.friend.id]); // Zasubskrybuj ponownie tylko wtedy, gdy zmieni się wartość props.friend.id</code></pre>
          <p>W przyszłości drugi argument może być automatycznie dodawany przez odpowiednią transformację w kompilatorze.</p>
          <blockquote>
            <p>Uwaga</p>
            <p>Jeśli korzystasz z tej techniki optymalizacji, upewnij się, że przekazywana tablica zawiera <strong>wszystkie wartości z zasięgu komponentu (takie jak właściwości (ang. <em>props</em>) i stan), które zmieniają się w czasie i które są używane przez efekt.</strong> W przeciwnym razie twój kod odwoła się do starych wartości z poprzednich renderowań. Przeczytaj też, <a href="./hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">jak radzić sobie z funkcjami</a> i <a href="./hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often">co robić, gdy tablica zmienia się zbyt często</a>.</p>
            <p>Jeśli chcesz przeprowadzić efekt i posprzątać po nim tylko raz (podczas montowania i odmontowania), możesz przekazać pustą tablicę (<code>[]</code>) jako drugi argument. Dzięki temu React wie, że twój efekt nie zależy od <em>jakichkolwiek</em> wartości właściwości lub stanu, więc nigdy nie musi być ponownie uruchamiany. Nie jest to traktowane jako przypadek specjalny -- wynika to bezpośrednio z tego, jak działa tablica zależności.</p>
            <p>Jeśli przekażesz pustą tablicę (<code>[]</code>) właściwości i stan wewnątrz efektu zawsze przyjmą swoje początkowe wartości. Pomimo że przekazywanie <code>[]</code> jest bliższe temu, co znamy z metod <code>componentDidMount</code> i <code>componentWillUnmount</code>, zwykle istnieją <a href="./hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">lepsze</a> <a href="./hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often">rozwiązania</a> pomagające uniknąć zbyt częstego powtarzania efektów. Nie zapominaj też, że React opóźni wywołanie <code>useEffect</code> do momentu, aż przeglądarka nie skończy rysować widoku, więc dodatkowa praca tutaj nie jest dużym problemem.</p>
            <p>Polecamy użycie reguły <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a>, będącej częścią naszego pakietu <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a>. Ostrzega ona, gdy zależności są niepoprawnie zdefiniowane i sugeruje poprawki.</p>
          </blockquote>
        </section>
      </section>
      <section id="next-steps" class="level2">
        <h2>Kolejne kroki</h2>
        <p>Gratulacje! To był długi rozdział, ale miejmy nadzieję, że odpowiedzieliśmy na większość pytań dotyczących efektów ubocznych. Poznaliśmy już informacje zarówno o hooku stanu, jak i hooku efektów, a dzięki ich połączeniu możesz zrobić <em>naprawdę dużo</em>. Pokrywają one większość przypadków użycia klas -- a tam, gdzie tak nie jest, pomocne mogą okazać się <a href="./hooks-reference.html">dodatkowe hooki</a>.</p>
        <p>Zaczynamy również zauważać, jak hooki rozwiązują problemy opisane w podrozdziale pt. <a href="./hooks-intro.html#motivation">„Motywacja”</a>. Zaobserwowaliśmy, jak sprzątanie po efektach pozwala uniknąć duplikacji kodu w metodach <code>componentDidUpdate</code> i <code>componentWillUnmount</code>, przybliża wzajemnie powiązany kod i pomaga uniknąć błędów. Zobaczyliśmy również, w jaki sposób możemy podzielić efekty w zależności od ich celu, co w klasach nie było wcześniej w ogóle możliwe.</p>
        <p>
          W tym momencie mogłoby paść pytanie, jak działają hooki. Skąd React może wiedzieć, które wywołanie <code>useState</code> odpowiada którym zmiennym stanu pomiędzy kolejnymi renderowaniami? W jaki sposób React „dopasowuje” poprzednie i następne efekty przy każdej aktualizacji? <strong>W następnym rozdziale dowiemy się o <a href="./hooks-rules.html">zasadach korzystania z hooków</a> -- są one niezbędne do ich poprawnego działania.</strong>
          <span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span>
        </p>
      </section>
    </section>
  </body>
</html>
