<!doctypehtml><html lang="pl"><meta charset="utf-8"><title>Słownik terminów reactowych</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="słownik-terminów-reactowych"class="level1"><h1>Słownik terminów reactowych</h1><section id="single-page-application"class="level2"><h2>Aplikacja jednostronicowa</h2><p>Aplikacja jednostronicowa to taka, która wczytuje pojedynczą stronę HTML i wszystkie zasoby (takie jak JavaScript czy CSS) potrzebne do uruchomienia aplikacji. Wszelkie interakcje ze stroną i poszczególnymi podstronami nie wymagają ponownego łączenia z serwerem, co oznacza, że strona nie jest przeładowywana.<p>Pomimo tego, że aplikacje jednostronicowe można tworzyć za pomocą Reacta, nie jest on do tego konieczny. React może posłużyć do wzbogacania niewielkich fragmentów istniejących stron o dodatkową interaktywność. Napisany kod reactowy może z powodzeniem działać razem z kodem wygenerowanym po stronie serwera np. w PHP, lub innymi bibliotekami klienckimi. Prawdę mówiąc, właśnie w ten sposób React jest używany w Facebooku.</section><section id="es6-es2015-es2016-etc"class="level2"><h2>ES6, ES2015, ES2016 itp.</h2><p>Skróty te odnoszą się do najnowszych wersji standardu specyfikacji języka ECMAScript, którego implementacją jest język JavaScript. Wersja ES6 (znana również jako ES2015) zawiera wiele dodatkowych mechanizmów, jak np. funkcje strzałkowe, klasy, literały szablonowe, a także wyrażenia <code>let</code> oraz <code>const</code>. Po więcej informacji na temat poszczególnych wersji sięgnij do <a href="https://en.wikipedia.org/wiki/ECMAScript#Versions">Wikipedii</a>.</section><section id="compilers"class="level2"><h2>Kompilatory</h2><p>Kompilator javascriptowy wczytuje kod javascriptowy, przekształca go i zwraca go w innym formacie. Najczęściej stosuje się go przekształcania składni ES6 w kod zrozumiały dla starszych przeglądarek. <a href="https://babeljs.io/">Babel</a> jest najbardziej powszechnym kompilatorem używanym wraz z Reactem.</section><section id="bundlers"class="level2"><h2>Bundlery</h2><p>Bundlery wczytują kod JavaScript i CSS, napisany w formie odrębnych modułów (często liczonych w setkach) i łączą je w kilka plików zoptymalizowanych pod przeglądarki. W środowisku reactowym do najczęściej używanych bundlerów zaliczane są <a href="https://webpack.js.org/">Webpack</a> oraz <a href="http://browserify.org/">Browserify</a>.</section><section id="package-managers"class="level2"><h2>Menedżery pakietów</h2><p>Menedżery pakietów to narzędzia pozwalające zarządzać zależnościami projektu. W aplikacjach reactowych najczęściej używane są <a href="https://www.npmjs.com/">npm</a> oraz <a href="https://yarnpkg.com/">Yarn</a>, przy czym obydwa są klientami tego samego rejestru pakietów npm.</section><section id="cdn"class="level2"><h2>CDN</h2><p>CDN to skrót od Content Delivery Network (pol. <em>sieć dostarczania zawartości</em>). CDN-y dostarczają statyczną zawartość przechowywaną w pamięci podręcznej poprzez sieć serwerów rozproszonych po całej kuli ziemskiej.</section><section id="jsx"class="level2"><h2>JSX</h2><p>JSX jest rozszerzeniem składni JavaScript. Przypomina języki szablonów, jednak posiada pełną moc JavaScriptu. Kod napisany w JSX jest kompilowany do wywołań funkcji <code>React.createElement()</code>, które zwracają obiekty javascriptowe zwane "elementami reactowymi". Aby dowiedzieć się więcej, przeczytaj <a href="./introducing-jsx.html">wstęp do składni JSX</a> lub <a href="./jsx-in-depth.html">szczegółowy samouczek</a>.<p>React DOM do nazywania właściwości używa konwencji camelCase zamiast nazw atrybutów HTML. Na przykład, <code>tabindex</code> jest zapisywany w składni JSX jako <code>tabIndex</code>. Z kolei atrybut <code>class</code> piszemy jako <code>className</code> ze względu na fakt, iż <code>class</code> jest w JavaScripcie zarezerwowanym słowem kluczowym:<pre class="language-jsx"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>h1</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hello<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">Mam na imię Klementyna!</span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>h1</span><span class="token punctuation">></span></span></code></pre></section><section id="elementy-elements"class="level2"><h2><a href="./rendering-elements.html">Elementy</a> {#elements}</h2><p>Elementy reactowe są częściami składowymi aplikacji pisanych za pomocą Reacta. Nietrudno pomylić je z szerzej znanym pojęciem "komponentów". Element opisuje to, co zostanie wyświetlone na ekranie. Elementy reactowe są niezmienne (ang. <em>immutable</em>).<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token maybe-class-name">Witaj</span><span class="token punctuation">,</span> świecie<span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>Zazwyczaj jednak elementów nie używa się bezpośrednio jako wartości, lecz zwraca w komponentach.</section><section id="komponenty-components"class="level2"><h2><a href="./components-and-props.html">Komponenty</a> {#components}</h2><p>Komponenty reactowe są niewielkimi kawałkami kodu, często wielokrotnego użytku, które zwracają element reactowy, który ma zostać wyrenderowany na stronie. Najprostszym wariantem reactowego komponentu jest javascriptowa funkcja, która zwraca element reactowy.:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Welcome</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token maybe-class-name">Witaj</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Komponenty mogą także być klasami ze standardu ES6:<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Welcome</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>h1<span class="token operator">></span><span class="token maybe-class-name">Witaj</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Komponenty można podzielić na unikalne fragmenty funkcjonalności, a następnie używać wewnątrz innych komponentów. Komponenty mogą zwracać inne komponenty, ale także tablice, napisy czy liczby. Należy kierować się zasadą, że jeśli jakiś fragment interfejsu użytkownika jest używany wielokrotnie (np. przycisk, panel, awatar) lub sam w sobie jest dość złożony (np. aplikacja, news, komentarz), staje się odpowiednim kandydatem do bycia komponentem wielokrotnego użytku. Nazwy komponentów powinny zaczynać się od wielkiej litery (<code>&#x3C;Wrapper/></code>, a <strong>nie</strong> <code>&#x3C;wrapper/></code>). Po więcej informacji sięgnij do <a href="./components-and-props.html#rendering-a-component">dokumentacji dotyczącej renderowania komponentów</a>.<section id="props-props"class="level3"><h3><a href="./components-and-props.html"><code>props</code></a> {#props}</h3><p><code>props</code> (od ang. <em>properties</em> = pol. <em>właściwości</em>) są danymi wejściowymi dla reactowych komponentów. Przekazuje się je z komponentów nadrzędnych do ich potomków.<p>Pamiętaj, że właściwości <code>props</code> są tylko do odczytu. Nie należy ich w jakikolwiek sposób modyfikować:<pre class="language-js"><code class="language-js"><span class="token comment">// Źle!</span>
props<span class="token punctuation">.</span><span class="token property-access">number</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span></code></pre><p>Jeśli potrzebujesz zmienić którąś wartość w odpowiedzi na akcję użytkownika lub zapytanie do serwera, skorzystaj ze <code>stanu</code>.</section><section id="propschildren-propschildren"class="level3"><h3><code>props.children</code> {#propschildren}</h3><p>Właściwość <code>props.children</code> jest dostępna w każdym komponencie. Zawiera wszystko, co znajdzie się między znacznikiem otwierającym i zamykającym danego komponentu, na przykład:<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Welcome</span><span class="token operator">></span><span class="token maybe-class-name">Witaj</span><span class="token punctuation">,</span> świecie<span class="token operator">!</span><span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token maybe-class-name">Welcome</span><span class="token operator">></span></code></pre><p>Napis <code>Witaj, świecie!</code> znajdzie się we właściwości <code>props.children</code> komponentu <code>Welcome</code>:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Welcome</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span><span class="token property-access">children</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>W przypadku komponentów zdefiniowanych jako klasy należy skorzystać z <code>this.props.children</code>:<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Welcome</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">.</span><span class="token property-access">children</span><span class="token punctuation">}</span><span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></section><section id="state-state"class="level3"><h3><a href="./state-and-lifecycle.html#adding-local-state-to-a-class"><code>state</code></a> {#state}</h3><p>Komponent potrzebuje własnego stanu (<code>state</code>), gdy powiązane z nim dane zmieniają się w czasie. Na przykład, komponent <code>Checkbox</code> w zmiennej <code>isChecked</code> mógłby śledzić, czy jest zaznaczony, a komponent <code>NewsFeed</code> mógłby przechowywać pobrane posty w <code>fetchedPosts</code>.<p>Najistotniejszą różnicą pomiędzy <code>state</code> i <code>props</code> jest to, że właściwości <code>props</code> są dostarczane przez komponent nadrzędny, a stanem <code>state</code> zarządza sam komponent. Komponent nie może modyfikować swoich właściwości <code>props</code>, ale może zmieniać swój stan <code>state</code>.<p>Dla każdego fragmentu danych zmieniających się w czasie powinien istnieć tylko jeden komponent, które taki stan "posiada" na wyłączność. Nie próbuj synchronizować stanów dwóch komponentów. Zamiast tego <a href="./lifting-state-up.html">wynieś stan w górę</a> do najbliższego przodka i z niego przekaż stan w dół za pomocą właściwości <code>props</code>.</section></section><section id="metody-cyklu-życia-lifecycle-methods"class="level2"><h2><a href="./state-and-lifecycle.html#adding-lifecycle-methods-to-a-class">Metody cyklu życia</a> {#lifecycle-methods}</h2><p>Metody cyklu życia to specjalne funkcje uruchamiane w trakcie różnych faz życia komponentu. Istnieją takie, które uruchamiane są podczas tworzenia komponentu i wstawiania go do drzewa DOM (tzw. <a href="./react-component.html#mounting">montowanie</a>), inne gdy komponent jest aktualizowany, a jeszcze inne gdy jest odmontowywany lub usuwany z drzewa DOM.</section><section id="kontrolowane-vs-niekontrolowane-komponenty"class="level2"><h2><a href="./forms.html#controlled-components">Kontrolowane</a> vs. <a href="./uncontrolled-components.html">niekontrolowane komponenty</a></h2><p>React zapewnia dwa różne podejścia do obsługi pól formularza.<p>Pole formularza, którego wartością zarządza React, jest nazywane <em>komponentem kontrolowanym</em>. Gdy użytkownik wprowadzi do niego dane, wywoływana jest odpowiednia procedura obsługi zdarzenia i to twój kod decyduje, czy wartość jest poprawna (poprzez ponowne wyrenderowanie z nową wartością). Jeśli samodzielnie nie wyrenderujesz ponownie danego pola, nie zmieni się ono na ekranie.<p>Z kolej <em>komponent niekontrolowany</em> działa tak, jak wszystkie pola formularza istniejące poza Reactem. Gdy użytkownik wprowadzi do takiego pola (np. pola tekstowego, pola wyboru itp.), zmiana jego wartości następuje automatycznie, bez konieczności obsługiwania tego w kodzie Reactowym. Oznacza to również, że nie możesz wymusić określonej wartości pola.<p>W większości przypadków zalecamy korzystanie z komponentów kontrolowanych.</section><section id="klucze-keys"class="level2"><h2><a href="./lists-and-keys.html">Klucze</a> {#keys}</h2><p>Klucz <code>key</code> to specjalny atrybut tekstowy, wymagany przy tworzeniu tablic elementów. Klucze pozwalają Reactowi zidentyfikować, które elementy listy zostały zmienione, dodane bądź usunięte. Służą również do nadania elementom tablicy stabilnego identyfikatora.<p>Klucze muszą być unikalne tylko pośród "rodzeństwa" z tej samej tablicy, lecz mogą się powtarzać w ramach całej aplikacji czy nawet wewnątrz tego samego komponentu.<p>Do określania kluczy nie używaj wartości typu <code>Math.random()</code>. Ważne jest, by klucze były "stabilnymi identyfikatorami" w kolejnych renderowaniach. Dzięki temu React może wykryć, które elementy zostały dodane, usunięte lub zmieniły kolejność. Najlepiej nadają się do tego unikalne, stabilne identifykatory pochodzące z danych, np. <code>post.id</code>.</section><section id="referencje-ref-refs"class="level2"><h2><a href="./refs-and-the-dom.html">Referencje <code>ref</code></a> {#refs}</h2><p>React wspiera specjalny atrybut, którego można użyć na dowolnym komponencie. Atrybut <code>ref</code> może być obiektem utworzonym przy użyciu <a href="./react-api.html#reactcreateref"><code>funkcji React.createRef()</code></a>, dowolną funkcją zwrotną lub ciągiem znaków (w starym API). Gdy <code>ref</code> jest funkcją zwrotną, jest ona wywoływana jednym argumentem: elementem DOM odpowiadającym komponentowi lub instancją klasy (w zależności od typu komponentu). Pozwala to na bezpośredni dostęp do API elementu DOM lub instancji klasy.<p>Z referencji korzystaj sporadycznie. Jeśli zauważysz, że używasz ich dość często do sprawienia, żeby "coś zaczęło działać", sugerujemy zapoznać się z <a href="./lifting-state-up.html">przepływem danych z góry na dół</a>.</section><section id="zdarzenia-events"class="level2"><h2><a href="./handling-events.html">Zdarzenia</a> {#events}</h2><p>Obsługa zdarzeń w elementach reactowych ma kilka różnic składniowych:<ul><li>Nazwy procedur obsługi zdarzeń używają konwencji camelCase, a nie są pisane małymi literami.<li>W składni JSX procedury obsługi zdarzeń przekazuje się jako funkcje, a nie jako ciągi znaków.</ul></section><section id="rekoncyliacja-reconciliation"class="level2"><h2><a href="./reconciliation.html">Rekoncyliacja</a> {#reconciliation}</h2><p>Gdy zmieniają się właściwości lub stan komponentu, React decyduje, czy konieczna jest aktualizacja drzewa DOM, poprzez porównanie nowo zwróconego elementu z jego poprzednią wersją. Jeśli elementy różnią się, drzewo DOM jest aktualizowane. Proces ten nazywany jest "rekoncyliacją" (ang. <em>reconciliation</em>). <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>