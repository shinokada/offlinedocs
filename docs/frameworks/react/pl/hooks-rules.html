<!doctypehtml><html lang="pl"><meta charset="utf-8"><title>Zasady korzystania z hooków</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="zasady-korzystania-z-hooków"class="level1"><h1>Zasady korzystania z hooków</h1><p><em>Hooki</em> są nowym dodatkiem w Reakcie 16.8. Pozwalają one używać stanu i innych funkcjonalności Reacta, bez użycia klas.<p>Hooki są javascriptowymi funkcjami, ale podczas korzystania z nich musisz pamiętać o dwóch ważnych zasadach. Stworzyliśmy <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">wtyczkę do lintera</a>, która automatycznie wymusza stosowanie tych zasad:<section id="only-call-hooks-at-the-top-level"class="level3"><h3>Wywołuj hooki tylko z najwyższego poziomu kodu</h3><p><strong>Nie wywołuj hooków wewnątrz pętli, instrukcji warunkowych czy zagnieżdżonych funkcji.</strong> Korzystaj z hooków tylko z najwyższego poziomu kodu twoich komponentów funkcyjnych, jeszcze przed zwróceniem wartości. Przestrzegając tej zasady, zyskujesz pewność, że hooki zostaną wywołane w tej samej kolejności, za każdym razem gdy komponent jest renderowany. To właśnie pozwala Reactowi na właściwe przechowywanie stanu pomiędzy kolejnymi wywołaniami <code>useState</code> i <code>useEffect</code> (Jeśli ciekawi cię ten temat, dogłębnie wyjaśnimy go <a href="#explanation">w kolejnym podrozdziale</a>.)</section><section id="only-call-hooks-from-react-functions"class="level3"><h3>Wywołuj hooki tylko w komponentach funkcyjnych</h3><p><strong>Nie wywołuj hooków wewnątrz zwykłych javascriptowych funkcji.</strong> Zamiast tego możesz:<ul><li>✅ Wywoływać hooki wewnątrz reactowych komponentów funkcyjnych.<li>✅ Wywoływać hooki wewnątrz własnych hooków (więcej na ten temat dowiemy się <a href="./hooks-custom.html">w następnym rozdziale</a>).</ul><p>Przestrzegając tej zasady, upewniasz się, że cała logika związana ze stanem komponentu jest wyraźnie widoczna w jego kodzie źródłowym.</section><section id="eslint-plugin"class="level2"><h2>Wtyczka dla ESLinta</h2><p>Wydaliśmy wtyczkę dla ESLinta o nazwie <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks"><code>eslint-plugin-react-hooks</code></a>, która wymusza stosowanie tych dwóch zasad. Jeśli chcesz ją wypróbować, możesz dodać ją do swojego projektu w następujący sposób:<p>Wtyczka ta jest instalowana domyślnie w <a href="./create-a-new-react-app.html#create-react-app">Create React App</a>.<pre class="language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> eslint-plugin-react-hooks --save-dev</code></pre><pre class="language-js"><code class="language-js"><span class="token comment">// Twoja konfiguracja ESLint</span>
<span class="token punctuation">{</span>
  <span class="token string-property property">"plugins"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token comment">// ...</span>
    <span class="token string">"react-hooks"</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string-property property">"rules"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token string-property property">"react-hooks/rules-of-hooks"</span><span class="token operator">:</span> <span class="token string">"error"</span><span class="token punctuation">,</span> <span class="token comment">// Sprawdza stosowanie zasad hooków</span>
    <span class="token string-property property">"react-hooks/exhaustive-deps"</span><span class="token operator">:</span> <span class="token string">"warn"</span> <span class="token comment">// Sprawdza zależności efektów</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p><strong>Możesz teraz przejść do następnego rozdziału, gdzie wyjaśniamy, <a href="./hooks-custom.html">jak pisać własne hooki</a>.</strong> W tym rozdziale postaramy się uzasadnić, dlaczego narzucamy takie zasady.</section><section id="explanation"class="level2"><h2>Wyjaśnienie</h2><p>Jak <a href="./hooks-state.html#tip-using-multiple-state-variables">dowiedzieliśmy się wcześniej</a>, w ramach pojedynczego komponentu możemy używać wielu hooków stanu i efektów:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Form</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1. Użyj zmiennej stanu do przechowania imienia</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'Mary'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 2. Użyj efektu, aby zapisać dane formularza</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">persistForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token dom variable">localStorage</span><span class="token punctuation">.</span><span class="token method function property-access">setItem</span><span class="token punctuation">(</span><span class="token string">'formData'</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 3. Użyj zmiennej stanu do przechowania nazwiska</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>surname<span class="token punctuation">,</span> setSurname<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'Poppins'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 4. Użyj efektu, aby zaktualizować tytuł strony</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">updateTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> name <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> surname<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>Skąd zatem React wie, jaką wartość stanu zwrócić przy kolejnych wywołaniach funkcji <code>useState</code>? Tajemnica tkwi w tym, że <strong>React polega na kolejności, w jakiej hooki są wywoływane.</strong> Nasz przykład zadziała, ponieważ kolejność wywoływania hooków jest taka sama przy każdym renderowaniu:<pre class="language-js"><code class="language-js"><span class="token comment">// ---------</span>
<span class="token comment">// Pierwsze renderowanie</span>
<span class="token comment">// ---------</span>
<span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'Mary'</span><span class="token punctuation">)</span>           <span class="token comment">// 1. Zainicjalizuj zmienną stanu imienia wartością „Mary”</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span>persistForm<span class="token punctuation">)</span>     <span class="token comment">// 2. Dodaj efekt odpowiedzialny za przechowywanie danych formularza</span>
<span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'Poppins'</span><span class="token punctuation">)</span>        <span class="token comment">// 3. Zainicjalizuj zmienną stanu nazwiska wartością „Poppins”</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span>updateTitle<span class="token punctuation">)</span>     <span class="token comment">// 4. Dodaj efekt odpowiedzialny za aktualizację tytułu</span>

<span class="token comment">// ----------</span>
<span class="token comment">// Drugie renderowanie</span>
<span class="token comment">// ----------</span>
<span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'Mary'</span><span class="token punctuation">)</span>           <span class="token comment">// 1. Odczytaj zmienną stanu przechowującą imię (argument został zignorowany)</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span>persistForm<span class="token punctuation">)</span>     <span class="token comment">// 2. Zastąp efekt odpowiedzialny za przechowywanie danych</span>
<span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'Poppins'</span><span class="token punctuation">)</span>        <span class="token comment">// 3. Odczytaj zmienną stanu przechowującą nazwisko (argument został zignorowany)</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span>updateTitle<span class="token punctuation">)</span>     <span class="token comment">// 4. Zastąp efekt odpowiedzialny za aktualizację tytułu</span>

<span class="token comment">// ...</span></code></pre><p>Tak długo, jak kolejność wywoływania hooków pozostaje taka sama pomiędzy kolejnymi renderowaniami, React może powiązać lokalny stan z każdym z nich. A co wydarzy się, jeśli umieścimy wywołanie hooka (na przykład efektu <code>persistForm</code>) wewnątrz instrukcji warunkowej?<pre class="language-js"><code class="language-js">  <span class="token comment">// 🔴 Łamiemy pierwszą zasadę, używając hooka wewnątrz instrukcji warunkowej</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>name <span class="token operator">!==</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">persistForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token dom variable">localStorage</span><span class="token punctuation">.</span><span class="token method function property-access">setItem</span><span class="token punctuation">(</span><span class="token string">'formData'</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre><p>Warunek <code>name !== ''</code> jest spełniony przy pierwszym renderze, więc uruchamiany jest ten hook. Jednakże przy kolejnym renderze użytkownik może wyczyścić wartości formularza, powodując, że warunek nie będzie spełniony. Teraz, w związku z tym, że pominęliśmy hook podczas renderowania, kolejność wywoływania hooków zostaje zachwiana:<pre class="language-js"><code class="language-js"><span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'Mary'</span><span class="token punctuation">)</span>           <span class="token comment">// 1.Odczytaj zmienną stanu przechowującą imię (argument został zignorowany)</span>
<span class="token comment">// useEffect(persistForm)  // 🔴 Ten hook został pominięty!</span>
<span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'Poppins'</span><span class="token punctuation">)</span>        <span class="token comment">// 🔴 2 (a był 3). Nie uda się odczytać zmiennej stanu</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span>updateTitle<span class="token punctuation">)</span>     <span class="token comment">// 🔴 3 (a był 4). Nie uda się zastąpić efektu</span></code></pre><p>React nie wiedziałby, co zwrócić dla drugiego wywołania hooka <code>useState</code>. React spodziewał się, że drugie wywołanie hooka w tym komponencie będzie odpowiadało wywołaniu efektu <code>persistForm</code>, tak jak podczas poprzedniego renderowania. Nie jest to już jednak prawdą. Od tej chwili każde kolejne wywołanie hooka, po tym, jak jeden został pominięty, również przesunęłoby się o jeden, prowadząc do błędów.<p><strong>Dlatego właśnie hooki muszą być wywoływane z najwyższego poziomu kodu komponentów.</strong> Jeśli chcesz, żeby efekt działał pod jakimś warunkiem, możesz umieścić ten warunek <em>wewnątrz</em> hooka:<pre class="language-js"><code class="language-js">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">persistForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 👍 Tym razem nie łamiemy pierwszej zasady</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>name <span class="token operator">!==</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token dom variable">localStorage</span><span class="token punctuation">.</span><span class="token method function property-access">setItem</span><span class="token punctuation">(</span><span class="token string">'formData'</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>Zauważ, że nie musisz o tym pamiętać, jeśli użyjesz <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">dostarczonej przez nas reguły lintera</a>.</strong> Teraz jednak wiesz także, <em>dlaczego</em> hooki działają w ten sposób i jakim problemom zapobiega stosowanie tej reguły.</section><section id="next-steps"class="level2"><h2>Kolejne kroki</h2><p>W końcu jesteśmy gotowi na to, aby nauczyć się <a href="./hooks-custom.html">pisać własne hooki</a>! Własne hooki pozwalają łączyć hooki dostarczone przez Reacta we własne abstrakcje i współdzielić logikę związaną ze stanem pomiędzy komponentami. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>