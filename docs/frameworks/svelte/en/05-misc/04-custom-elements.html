<!doctype html><html lang="en"><meta charset="utf-8"><title>Custom elements</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"type="text/css"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="custom-elements"><h1 id="custom-elements">Custom elements</h1><ul><li><a href="https://svelte.dev/docs/custom-elements-api">basically what we have today</a></ul><p>Svelte components can also be compiled to custom elements (aka web components) using the <code>customElement: true</code> compiler option. You should specify a tag name for the component using the <code>&#x3C;svelte:options></code> <a href="special-elements#svelte:options">element</a>.<pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:options customElement="my-element" />

&#x3C;script>
	let { name = 'world' } = $props();
&#x3C;/script>

&#x3C;h1>Hello {name}!&#x3C;/h1>
&#x3C;slot /></code></pre><p>You can leave out the tag name for any of your inner components which you don't want to expose and use them like regular Svelte components. Consumers of the component can still name it afterwards if needed, using the static <code>element</code> property which contains the custom element constructor and which is available when the <code>customElement</code> compiler option is <code>true</code>.<pre class="language-js"><code class="language-js"><span class="token comment">// @noErrors</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">MyElement</span></span> <span class="token keyword module">from</span> <span class="token string">'./MyElement.svelte'</span><span class="token punctuation">;</span>

customElements<span class="token punctuation">.</span><span class="token method function property-access">define</span><span class="token punctuation">(</span><span class="token string">'my-element'</span><span class="token punctuation">,</span> <span class="token maybe-class-name">MyElement</span><span class="token punctuation">.</span><span class="token property-access">element</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Once a custom element has been defined, it can be used as a regular DOM element:<pre class="language-js"><code class="language-js"><span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">body</span><span class="token punctuation">.</span><span class="token property-access">innerHTML</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token html language-html">
	<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>my-element</span><span class="token punctuation">></span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>p</span><span class="token punctuation">></span></span>This is some slotted content<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>p</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>my-element</span><span class="token punctuation">></span></span>
</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span></code></pre><p>Any <a href="basic-markup#Attributes-and-props">props</a> are exposed as properties of the DOM element (as well as being readable/writable as attributes, where possible).<pre class="language-js"><code class="language-js"><span class="token comment">// @noErrors</span>
<span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">querySelector</span><span class="token punctuation">(</span><span class="token string">'my-element'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// get the current value of the 'name' prop</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>el<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// set a new value, updating the shadow DOM</span>
el<span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> <span class="token string">'everybody'</span><span class="token punctuation">;</span></code></pre><section class="level2"aria-labelledby="component-lifecycle"><h2 id="component-lifecycle">Component lifecycle</h2><p>Custom elements are created from Svelte components using a wrapper approach. This means the inner Svelte component has no knowledge that it is a custom element. The custom element wrapper takes care of handling its lifecycle appropriately.<p>When a custom element is created, the Svelte component it wraps is <em>not</em> created right away. It is only created in the next tick after the <code>connectedCallback</code> is invoked. Properties assigned to the custom element before it is inserted into the DOM are temporarily saved and then set on component creation, so their values are not lost. The same does not work for invoking exported functions on the custom element though, they are only available after the element has mounted. If you need to invoke functions before component creation, you can work around it by using the <a href="#Component-options"><code>extend</code> option</a>.<p>When a custom element written with Svelte is created or updated, the shadow DOM will reflect the value in the next tick, not immediately. This way updates can be batched, and DOM moves which temporarily (but synchronously) detach the element from the DOM don't lead to unmounting the inner component.<p>The inner Svelte component is destroyed in the next tick after the <code>disconnectedCallback</code> is invoked.</section><section class="level2"aria-labelledby="component-options"><h2 id="component-options">Component options</h2><p>When constructing a custom element, you can tailor several aspects by defining <code>customElement</code> as an object within <code>&#x3C;svelte:options></code> since Svelte 4. This object may contain the following properties:<ul><li><code>tag: string</code>: an optional <code>tag</code> property for the custom element's name. If set, a custom element with this tag name will be defined with the document's <code>customElements</code> registry upon importing this component.<li><code>shadow</code>: an optional property that can be set to <code>"none"</code> to forgo shadow root creation. Note that styles are then no longer encapsulated, and you can't use slots<li><code>props</code>: an optional property to modify certain details and behaviors of your component's properties. It offers the following settings:<ul><li><code>attribute: string</code>: To update a custom element's prop, you have two alternatives: either set the property on the custom element's reference as illustrated above or use an HTML attribute. For the latter, the default attribute name is the lowercase property name. Modify this by assigning <code>attribute: "&#x3C;desired name>"</code>.<li><code>reflect: boolean</code>: By default, updated prop values do not reflect back to the DOM. To enable this behavior, set <code>reflect: true</code>.<li><code>type: 'String' | 'Boolean' | 'Number' | 'Array' | 'Object'</code>: While converting an attribute value to a prop value and reflecting it back, the prop value is assumed to be a <code>String</code> by default. This may not always be accurate. For instance, for a number type, define it using <code>type: "Number"</code> You don't need to list all properties, those not listed will use the default settings.</ul><li><code>extend</code>: an optional property which expects a function as its argument. It is passed the custom element class generated by Svelte and expects you to return a custom element class. This comes in handy if you have very specific requirements to the life cycle of the custom element or want to enhance the class to for example use <a href="https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals#examples">ElementInternals</a> for better HTML form integration.</ul><pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:options
	customElement={{
		tag: 'custom-element',
		shadow: 'none',
		props: {
			name: { reflect: true, type: 'Number', attribute: 'element-index' }
		},
		extend: (customElementConstructor) => {
			// Extend the class so we can let it participate in HTML forms
			return class extends customElementConstructor {
				static formAssociated = true;

				constructor() {
					super();
					this.attachedInternals = this.attachInternals();
				}

				// Add the function here, not below in the component so that
				// it's always available, not just when the inner Svelte component
				// is mounted
				randomIndex() {
					this.elementIndex = Math.random();
				}
			};
		}
	}}
/>

&#x3C;script>
	let { elementIndex, attachedInternals } = $props();
	// ...
	function check() {
		attachedInternals.checkValidity();
	}
&#x3C;/script>

...</code></pre></section><section class="level2"aria-labelledby="caveats-and-limitations"><h2 id="caveats-and-limitations">Caveats and limitations</h2><p>Custom elements can be a useful way to package components for consumption in a non-Svelte app, as they will work with vanilla HTML and JavaScript as well as <a href="https://custom-elements-everywhere.com/">most frameworks</a>. There are, however, some important differences to be aware of:<ul><li>Styles are <em>encapsulated</em>, rather than merely <em>scoped</em> (unless you set <code>shadow: "none"</code>). This means that any non-component styles (such as you might have in a <code>global.css</code> file) will not apply to the custom element, including styles with the <code>:global(...)</code> modifier<li>Instead of being extracted out as a separate .css file, styles are inlined into the component as a JavaScript string<li>Custom elements are not generally suitable for server-side rendering, as the shadow DOM is invisible until JavaScript loads<li>In Svelte, slotted content renders <em>lazily</em>. In the DOM, it renders <em>eagerly</em>. In other words, it will always be created even if the component's <code>&#x3C;slot></code> element is inside an <code>{#if ...}</code> block. Similarly, including a <code>&#x3C;slot></code> in an <code>{#each ...}</code> block will not cause the slotted content to be rendered multiple times<li>The deprecated <code>let:</code> directive has no effect, because custom elements do not have a way to pass data to the parent component that fills the slot<li>Polyfills are required to support older browsers<li>You can use Svelte's context feature between regular Svelte components within a custom element, but you can't use them across custom elements. In other words, you can't use <code>setContext</code> on a parent custom element and read that with <code>getContext</code> in a child custom element. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></ul></section></section>