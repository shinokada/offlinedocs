<!doctype html><html lang="en"><meta charset="utf-8"><title>Special elements</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"type="text/css"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="special-elements"><h1 id="special-elements">Special elements</h1><ul><li><a href="https://svelte.dev/docs/special-elements">basically what we have in the docs today</a></ul><p>Some of Svelte's concepts need special elements. Those are prefixed with <code>svelte:</code> and listed here.<section class="level2"><h2 id=""><code>&#x3C;svelte:self></code></h2><p>The <code>&#x3C;svelte:self></code> element allows a component to include itself, recursively.<p>It cannot appear at the top level of your markup; it must be inside an if or each block or passed to a component's slot to prevent an infinite loop.<pre class="language-svelte"><code class="language-svelte">&#x3C;script>
	let { count } = $props();
&#x3C;/script>

{#if count > 0}
	&#x3C;p>counting down... {count}&#x3C;/p>
	&#x3C;svelte:self count={count - 1} />
{:else}
	&#x3C;p>lift-off!&#x3C;/p>
{/if}</code></pre></section><section class="level2"aria-labelledby="-1"><h2 id="-1"><code>&#x3C;svelte:component></code></h2><pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:component this={expression} /></code></pre><p>The <code>&#x3C;svelte:component></code> element renders a component dynamically, using the component constructor specified as the <code>this</code> property. When the property changes, the component is destroyed and recreated.<p>If <code>this</code> is falsy, no component is rendered.<pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:component this={currentSelection.component} foo={bar} /></code></pre></section><section class="level2"aria-labelledby="-2"><h2 id="-2"><code>&#x3C;svelte:element></code></h2><pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:element this={expression} /></code></pre><p>The <code>&#x3C;svelte:element></code> element lets you render an element of a dynamically specified type. This is useful for example when displaying rich text content from a CMS. Any properties and event listeners present will be applied to the element.<p>The only supported binding is <code>bind:this</code>, since the element type-specific bindings that Svelte does at build time (e.g. <code>bind:value</code> for input elements) do not work with a dynamic tag type.<p>If <code>this</code> has a nullish value, the element and its children will not be rendered.<p>If <code>this</code> is the name of a <a href="https://developer.mozilla.org/en-US/docs/Glossary/Void_element">void element</a> (e.g., <code>br</code>) and <code>&#x3C;svelte:element></code> has child elements, a runtime error will be thrown in development mode.<pre class="language-svelte"><code class="language-svelte">&#x3C;script>
	let { handler } = $props();

	let tag = $state('div');
&#x3C;/script>

&#x3C;svelte:element this={tag} onclick={handler}>Foo&#x3C;/svelte:element></code></pre><p>Svelte tries its best to infer the correct namespace from the element's surroundings, but it's not always possible. You can make it explicit with an <code>xmlns</code> attribute:<pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:element this={tag} xmlns="http://www.w3.org/2000/svg" /></code></pre></section><section class="level2"aria-labelledby="-3"><h2 id="-3"><code>&#x3C;svelte:window></code></h2><pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:window onevent={handler} /></code></pre><pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:window bind:prop={value} /></code></pre><p>The <code>&#x3C;svelte:window></code> element allows you to add event listeners to the <code>window</code> object without worrying about removing them when the component is destroyed, or checking for the existence of <code>window</code> when server-side rendering.<p>Unlike <code>&#x3C;svelte:self></code>, this element may only appear at the top level of your component and must never be inside a block or element.<pre class="language-svelte"><code class="language-svelte">&#x3C;script>
	function handleKeydown(event) {
		alert(`pressed the ${event.key} key`);
	}
&#x3C;/script>

&#x3C;svelte:window onkeydown={handleKeydown} /></code></pre><p>You can also bind to the following properties:<ul><li><code>innerWidth</code><li><code>innerHeight</code><li><code>outerWidth</code><li><code>outerHeight</code><li><code>scrollX</code><li><code>scrollY</code><li><code>online</code> — an alias for <code>window.navigator.onLine</code><li><code>devicePixelRatio</code></ul><p>All except <code>scrollX</code> and <code>scrollY</code> are readonly.<pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:window bind:scrollY={y} /></code></pre><blockquote><p>[!NOTE] Note that the page will not be scrolled to the initial value to avoid accessibility issues. Only subsequent changes to the bound variable of <code>scrollX</code> and <code>scrollY</code> will cause scrolling. However, if the scrolling behaviour is desired, call <code>scrollTo()</code> in <code>onMount()</code>.</blockquote></section><section class="level2"aria-labelledby="-4"><h2 id="-4"><code>&#x3C;svelte:document></code></h2><pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:document onevent={handler} /></code></pre><pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:document bind:prop={value} /></code></pre><p>Similarly to <code>&#x3C;svelte:window></code>, this element allows you to add listeners to events on <code>document</code>, such as <code>visibilitychange</code>, which don't fire on <code>window</code>. It also lets you use <a href="actions">actions</a> on <code>document</code>.<p>As with <code>&#x3C;svelte:window></code>, this element may only appear the top level of your component and must never be inside a block or element.<pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:document onvisibilitychange={handleVisibilityChange} use:someAction /></code></pre><p>You can also bind to the following properties:<ul><li><code>activeElement</code><li><code>fullscreenElement</code><li><code>pointerLockElement</code><li><code>visibilityState</code></ul><p>All are readonly.</section><section class="level2"aria-labelledby="-5"><h2 id="-5"><code>&#x3C;svelte:body></code></h2><pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:body onevent={handler} /></code></pre><p>Similarly to <code>&#x3C;svelte:window></code>, this element allows you to add listeners to events on <code>document.body</code>, such as <code>mouseenter</code> and <code>mouseleave</code>, which don't fire on <code>window</code>. It also lets you use <a href="actions">actions</a> on the <code>&#x3C;body></code> element.<p>As with <code>&#x3C;svelte:window></code> and <code>&#x3C;svelte:document></code>, this element may only appear the top level of your component and must never be inside a block or element.<pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:body onmouseenter={handleMouseenter} onmouseleave={handleMouseleave} use:someAction /></code></pre></section><section class="level2"aria-labelledby="-6"><h2 id="-6"><code>&#x3C;svelte:head></code></h2><pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:head>...&#x3C;/svelte:head></code></pre><p>This element makes it possible to insert elements into <code>document.head</code>. During server-side rendering, <code>head</code> content is exposed separately to the main <code>html</code> content.<p>As with <code>&#x3C;svelte:window></code>, <code>&#x3C;svelte:document></code> and <code>&#x3C;svelte:body></code>, this element may only appear at the top level of your component and must never be inside a block or element.<pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:head>
	&#x3C;title>Hello world!&#x3C;/title>
	&#x3C;meta name="description" content="This is where the description goes for SEO" />
&#x3C;/svelte:head></code></pre></section><section class="level2"aria-labelledby="-7"><h2 id="-7"><code>&#x3C;svelte:options></code></h2><pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:options option={value} /></code></pre><p>The <code>&#x3C;svelte:options></code> element provides a place to specify per-component compiler options, which are detailed in the <a href="svelte-compiler#compile">compiler section</a>. The possible options are:<ul><li><code>immutable={true}</code> — you never use mutable data, so the compiler can do simple referential equality checks to determine if values have changed<li><code>immutable={false}</code> — the default. Svelte will be more conservative about whether or not mutable objects have changed<li><code>accessors={true}</code> — adds getters and setters for the component's props<li><code>accessors={false}</code> — the default<li><code>namespace="..."</code> — the namespace where this component will be used, most commonly "svg"; use the "foreign" namespace to opt out of case-insensitive attribute names and HTML-specific warnings<li><code>customElement={...}</code> — the <a href="custom-elements#Component-options">options</a> to use when compiling this component as a custom element. If a string is passed, it is used as the <code>tag</code> option</ul><pre class="language-svelte"><code class="language-svelte">&#x3C;svelte:options customElement="my-custom-element" /></code></pre><p><span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>