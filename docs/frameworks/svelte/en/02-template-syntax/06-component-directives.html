<!doctype html><html lang="en"><meta charset="utf-8"><title>Component directives</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="component-directives"><h1 id="component-directives">Component directives</h1><section class="level2"aria-labelledby="oneventname"><h2 id="oneventname">on:<em>eventname</em></h2><pre class="language-svelte"><code class="language-svelte">&#x3C;! copy: false --->
on:eventname={handler}</code></pre><p>Components can emit events using <a href="./svelte#createeventdispatcher"><code>createEventDispatcher</code></a> or by forwarding DOM events.<pre class="language-svelte"><code class="language-svelte">&#x3C;script>
	import { createEventDispatcher } from 'svelte';

	const dispatch = createEventDispatcher();
&#x3C;/script>

&#x3C;!-- programmatic dispatching -->
&#x3C;button on:click={() => dispatch('hello')}> one &#x3C;/button>

&#x3C;!-- declarative event forwarding -->
&#x3C;button on:click> two &#x3C;/button></code></pre><p>Listening for component events looks the same as listening for DOM events:<pre class="language-svelte"><code class="language-svelte">&#x3C;SomeComponent on:whatever={handler} /></code></pre><p>As with DOM events, if the <code>on:</code> directive is used without a value, the event will be forwarded, meaning that a consumer can listen for it.<pre class="language-svelte"><code class="language-svelte">&#x3C;SomeComponent on:whatever /></code></pre></section><section class="level2"aria-labelledby="--style-props"><h2 id="--style-props">--style-props</h2><pre class="language-svelte"><code class="language-svelte">&#x3C;! copy: false --->
--style-props="anycssvalue"</code></pre><p>You can also pass styles as props to components for the purposes of theming, using CSS custom properties.<p>Svelte's implementation is essentially syntactic sugar for adding a wrapper element. This example:<pre class="language-svelte"><code class="language-svelte">&#x3C;Slider bind:value min={0} --rail-color="black" --track-color="rgb(0, 0, 255)" /></code></pre><p>Desugars to this:<pre class="language-svelte"><code class="language-svelte">&#x3C;div style="display: contents; --rail-color: black; --track-color: rgb(0, 0, 255)">
	&#x3C;Slider bind:value min={0} max={100} />
&#x3C;/div></code></pre><p><strong>Note</strong>: Since this is an extra <code>&#x3C;div></code>, beware that your CSS structure might accidentally target this. Be mindful of this added wrapper element when using this feature.<p>For SVG namespace, the example above desugars into using <code>&#x3C;g></code> instead:<pre class="language-svelte"><code class="language-svelte">&#x3C;g style="--rail-color: black; --track-color: rgb(0, 0, 255)">
	&#x3C;Slider bind:value min={0} max={100} />
&#x3C;/g></code></pre><p><strong>Note</strong>: Since this is an extra <code>&#x3C;g></code>, beware that your CSS structure might accidentally target this. Be mindful of this added wrapper element when using this feature.<p>Svelte's CSS Variables support allows for easily themeable components:<pre class="language-svelte"><code class="language-svelte">&#x3C;style>
	.potato-slider-rail {
		background-color: var(--rail-color, var(--theme-color, 'purple'));
	}
&#x3C;/style></code></pre><p>So you can set a high-level theme color:<pre class="language-css"><code class="language-css"><span class="token comment">/* global.css */</span>
<span class="token selector">html</span> <span class="token punctuation">{</span>
	<span class="token variable">--theme-color</span><span class="token punctuation">:</span> <span class="token color">black</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Or override it at the consumer level:<pre class="language-svelte"><code class="language-svelte">&#x3C;Slider --rail-color="goldenrod" /></code></pre></section><section class="level2"aria-labelledby="bindproperty"><h2 id="bindproperty">bind:<em>property</em></h2><pre class="language-svelte"><code class="language-svelte">bind:property={variable}</code></pre><p>You can bind to component props using the same syntax as for elements.<pre class="language-svelte"><code class="language-svelte">&#x3C;Keypad bind:value={pin} /></code></pre><p>While Svelte props are reactive without binding, that reactivity only flows downward into the component by default. Using <code>bind:property</code> allows changes to the property from within the component to flow back up out of the component.</section><section class="level2"aria-labelledby="bindthis"><h2 id="bindthis">bind:this</h2><pre class="language-svelte"><code class="language-svelte">&#x3C;! copy: false --->
bind:this={component_instance}</code></pre><p>Components also support <code>bind:this</code>, allowing you to interact with component instances programmatically.<pre class="language-svelte"><code class="language-svelte">&#x3C;ShoppingCart bind:this={cart} />

&#x3C;button on:click={() => cart.empty()}> Empty shopping cart &#x3C;/button></code></pre><blockquote><p>Note that we can't do <code>{cart.empty}</code> since <code>cart</code> is <code>undefined</code> when the button is first rendered and throws an error. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></blockquote></section></section>