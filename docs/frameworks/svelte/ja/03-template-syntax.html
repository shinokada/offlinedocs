<!doctype html><html lang="ja"><meta charset="utf-8"><title>Template syntax</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="template-syntax"class="level1"><h1>Template syntax</h1><section id="tags"class="level2"><h2>Tags</h2><p><code>&#x3C;div></code> のような小文字のタグは、通常の HTML 要素を表します。大文字のタグ、例えば <code>&#x3C;Widget></code> や <code>&#x3C;Namespace.Widget></code> は <em>コンポーネント</em> を表します。<pre class="language-sv"><code class="language-sv">&#x3C;script>
	import Widget from './Widget.svelte';
&#x3C;/script>

&#x3C;div>
	&#x3C;Widget/>
&#x3C;/div></code></pre></section><section id="attributes-and-props"class="level2"><h2>Attributes and props</h2><p>デフォルトでは、属性はHTMLと全く同じように動作します。<pre class="language-sv"><code class="language-sv">&#x3C;div class="foo">
	&#x3C;button disabled>can't touch this&#x3C;/button>
&#x3C;/div></code></pre><p>HTMLのように、値は引用符で囲まれていない場合があります。<pre class="language-sv"><code class="language-sv">&#x3C;input type=checkbox></code></pre><p>属性値には JavaScript の式を含めることができます。<pre class="language-sv"><code class="language-sv">&#x3C;a href="page/{p}">page {p}&#x3C;/a></code></pre><p>あるいは、JavaScript の式にすることもできます。<pre class="language-sv"><code class="language-sv">&#x3C;button disabled={!clickable}>...&#x3C;/button></code></pre><p>Boolean の属性は、その値が <a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">truthy</a> であれば要素に含まれ、<a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">falsy</a> であれば除外されます。<p>それ以外の属性は、その値が <a href="https://developer.mozilla.org/en-US/docs/Glossary/Nullish">nullish</a> (<code>null</code> または <code>undefined</code>) でない限り含まれます。<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>input</span> <span class="token attr-name">required</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>{false}</span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>This input field is not required<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>div</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>{null}</span><span class="token punctuation">></span></span>This div has no title attribute<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>式には、通常の HTML ではシンタックスハイライトに失敗するような文字が含まれている可能性があるので、値を引用符で囲むことが許可されています。引用符は値の解析方法には影響しません。<pre class="language-sv"><code class="language-sv">&#x3C;button disabled="{number !== 42}">...&#x3C;/button></code></pre><p>属性名と値が一致する場合(<code>name={name}</code>)は、<code>{name}</code>で置き換えることができます。<pre class="language-sv"><code class="language-sv">&#x3C;!-- These are equivalent -->
&#x3C;button disabled={disabled}>...&#x3C;/button>
&#x3C;button {disabled}>...&#x3C;/button></code></pre><p>慣習として、コンポーネントに渡される値は DOM の機能である <em>属性</em> ではなく、<em>プロパティ</em> または <em>props</em> と呼ばれます。<p>要素の場合と同様に、<code>name={name}</code> は <code>{name}</code> の短縮形に置き換えることができます。<pre class="language-sv"><code class="language-sv">&#x3C;Widget foo={bar} answer={42} text="hello"/></code></pre><p><em>スプレッド属性</em> は、多くの属性やプロパティを一度に要素やコンポーネントに渡すことを可能にします。<p>要素またはコンポーネントは、通常のものと混在させて、複数のスプレッド属性を持つことができます。<pre class="language-sv"><code class="language-sv">&#x3C;Widget {...things}/></code></pre><p><em><code>$$props</code></em> は、<code>export</code> で宣言されていないものも含めて、コンポーネントに渡されるすべてのプロパティ(props)を参照します。これは Svelte の最適化が難しいので、一般的には推奨されません。しかし、コンパイル時にどのようなプロパティがコンポーネントに渡されるかわからない場合など、稀なケースでは便利です。<pre class="language-sv"><code class="language-sv">&#x3C;Widget {...$$props}/></code></pre><p><em><code>$$restProps</code></em> には、<code>export</code> で宣言されて <em>いない</em> プロパティ(props)のみが含まれます。これは他の未知の属性をコンポーネントの要素に渡すために使用できます。 <em><code>$$props</code></em> と同じ最適化の問題を共有しており、同様に推奨されません。<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>input</span> <span class="token attr-name">{...$$restProps}</span><span class="token punctuation">></span></span></code></pre><blockquote><p><code>input</code> 要素やその子要素である <code>option</code> 要素の <code>value</code> 属性は、<code>bind:group</code> や <code>bind:checked</code> を使用している場合、スプレッド属性で設定してはいけません。このような場合、バインドされる変数にリンクできるように、Svelteがその要素の<code>value</code>をマークアップの中で直接見ることができる必要があります。</blockquote><blockquote><p>Svelte は JavaScript で属性を順番に設定するため、その属性の順番が問題になることがあります。例えば、<code>&#x3C;input type="range" min="0" max="1" value={0.5} step="0.1"/></code> の場合、Svelte は value に <code>1</code> を設定し (step のデフォルトが 1 であるため、0.5 から切り上げられてしまいます)、そしてそのあとで step に <code>0.1</code> を設定します。これを修正するには、順序を <code>&#x3C;input type="range" min="0" max="1" step="0.1" value={0.5}/></code> のように変更してください。</blockquote><blockquote><p>別の例としては <code>&#x3C;img src="..." loading="lazy" /></code> があります。Svelte は、img 要素を <code>loading="lazy"</code> にする前に、img の <code>src</code> を設定しますが、これでは遅すぎます。画像を遅延読み込みさせるには、<code>&#x3C;img loading="lazy" src="..."></code> のように変更してください。</blockquote></section><section id="text-expressions"class="level2"><h2>Text expressions</h2><pre class="language-sv"><code class="language-sv">{expression}</code></pre><p>テキストにもJavaScriptの式を含めることができます。<blockquote><p>正規表現 (<code>RegExp</code>) の <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#literal_notation_and_constructor">リテラル記法</a>、括弧で囲う必要があります。</blockquote><pre class="language-sv"><code class="language-sv">&#x3C;h1>Hello {name}!&#x3C;/h1>
&#x3C;p>{a} + {b} = {a + b}.&#x3C;/p>

&#x3C;div>{(/^[A-Za-z ]+$/).test(value) ? x : y}&#x3C;/div></code></pre></section><section id="comments"class="level2"><h2>Comments</h2><p>コンポーネント内でHTMLコメントを使用することができます。<pre class="language-sv"><code class="language-sv">&#x3C;!-- this is a comment! -->
&#x3C;h1>Hello world&#x3C;/h1></code></pre><p><code>svelte-ignore</code> で始まるコメントは、マークアップの次のブロックに対する警告を無効にします。通常、これらはアクセシビリティの警告です。正当な理由で警告を無効にしていることを確認してください。<pre class="language-sv"><code class="language-sv">&#x3C;!-- svelte-ignore a11y-autofocus -->
&#x3C;input bind:value={name} autofocus></code></pre></section><section id="if-"class="level2"><h2>{#if ...}</h2><pre class="language-sv"><code class="language-sv">{#if 式}...{/if}</code></pre><pre class="language-sv"><code class="language-sv">{#if 式}...{:else if 式}...{/if}</code></pre><pre class="language-sv"><code class="language-sv">{#if 式}...{:else}...{/if}</code></pre><p>条件付きでレンダリングされるコンテンツは、if ブロックで囲むことができます。<pre class="language-sv"><code class="language-sv">{#if answer === 42}
	&#x3C;p>what was the question?&#x3C;/p>
{/if}</code></pre><p>追加の条件は <code>{:else if 式}</code> で付け足すことができ、<code>{:else}</code> 句で終わらせることもできます。<pre class="language-sv"><code class="language-sv">{#if porridge.temperature > 100}
	&#x3C;p>too hot!&#x3C;/p>
{:else if 80 > porridge.temperature}
	&#x3C;p>too cold!&#x3C;/p>
{:else}
	&#x3C;p>just right!&#x3C;/p>
{/if}</code></pre></section><section id="each-"class="level2"><h2>{#each ...}</h2><pre class="language-sv"><code class="language-sv">{#each 式 as name}...{/each}</code></pre><pre class="language-sv"><code class="language-sv">{#each 式 as name, index}...{/each}</code></pre><pre class="language-sv"><code class="language-sv">{#each 式 as name (key)}...{/each}</code></pre><pre class="language-sv"><code class="language-sv">{#each 式 as name, index (key)}...{/each}</code></pre><pre class="language-sv"><code class="language-sv">{#each 式 as name}...{:else}...{/each}</code></pre><p>each ブロックで値のリストの反復処理ができます。<pre class="language-sv"><code class="language-sv">&#x3C;h1>Shopping list&#x3C;/h1>
&#x3C;ul>
	{#each items as item}
		&#x3C;li>{item.name} x {item.qty}&#x3C;/li>
	{/each}
&#x3C;/ul></code></pre><p>配列や配列のような値（つまり <code>length</code> プロパティを持つオブジェクト）を反復処理するのに each ブロックを使用できます。<p>each ブロックは <code>array.map(...)</code> のコールバックの第2数に相当する<em>インデックス</em>を指定することもできます。<pre class="language-sv"><code class="language-sv">{#each items as item, i}
	&#x3C;li>{i + 1}: {item.name} x {item.qty}&#x3C;/li>
{/each}</code></pre><p><em>key</em> の式（各リストアイテムを一意に識別できる必要があります）が与えられた場合、Svelte は、データが変化したときに（末尾にアイテムを追加したり削除するのではなく）キーを使用してリストの差分を取ります。key はどんなオブジェクトでもよいですが、そのオブジェクト自体が変更されたときに同一性を維持できるため、文字列か数値をお勧めします。<pre class="language-sv"><code class="language-sv">{#each items as item (item.id)}
	&#x3C;li>{item.name} x {item.qty}&#x3C;/li>
{/each}

&#x3C;!-- もしくはインデックスを追加 -->
{#each items as item, i (item.id)}
	&#x3C;li>{i + 1}: {item.name} x {item.qty}&#x3C;/li>
{/each}</code></pre><p>each ブロックでは分割代入や残余構文のパターンを自由に使えます。<pre class="language-sv"><code class="language-sv">{#each items as { id, name, qty }, i (id)}
	&#x3C;li>{i + 1}: {name} x {qty}&#x3C;/li>
{/each}

{#each objects as { id, ...rest }}
	&#x3C;li>&#x3C;span>{id}&#x3C;/span>&#x3C;MyComponent {...rest}/>&#x3C;/li>
{/each}

{#each items as [id, ...rest]}
	&#x3C;li>&#x3C;span>{id}&#x3C;/span>&#x3C;MyComponent values={rest}/>&#x3C;/li>
{/each}</code></pre><p>each ブロックには <code>{:else}</code> 句を入れることもできます。これはリストが空の場合にレンダリングされます。<pre class="language-sv"><code class="language-sv">{#each todos as todo}
	&#x3C;p>{todo.text}&#x3C;/p>
{:else}
	&#x3C;p>No tasks today!&#x3C;/p>
{/each}</code></pre></section><section id="await-"class="level2"><h2>{#await ...}</h2><pre class="language-sv"><code class="language-sv">{#await 式}...{:then name}...{:catch name}...{/await}</code></pre><pre class="language-sv"><code class="language-sv">{#await 式}...{:then name}...{/await}</code></pre><pre class="language-sv"><code class="language-sv">{#await 式 then name}...{/await}</code></pre><pre class="language-sv"><code class="language-sv">{#await 式 catch name}...{/await}</code></pre><p>await ブロックを使用すると、Promise が取りうる 3 つの状態（pending(保留中)、fulfilled(成功)、rejected(失敗)）に分岐できます。<pre class="language-sv"><code class="language-sv">{#await promise}
	&#x3C;!-- promise is pending -->
	&#x3C;p>waiting for the promise to resolve...&#x3C;/p>
{:then value}
	&#x3C;!-- promise was fulfilled -->
	&#x3C;p>The value is {value}&#x3C;/p>
{:catch error}
	&#x3C;!-- promise was rejected -->
	&#x3C;p>Something went wrong: {error.message}&#x3C;/p>
{/await}</code></pre><p>promise が失敗した時に何もレンダリングする必要がない場合（もしくはエラーが発生しない場合）は <code>catch</code> ブロックを省略できます。<pre class="language-sv"><code class="language-sv">{#await promise}
	&#x3C;!-- promise is pending -->
	&#x3C;p>waiting for the promise to resolve...&#x3C;/p>
{:then value}
	&#x3C;!-- promise was fulfilled -->
	&#x3C;p>The value is {value}&#x3C;/p>
{/await}</code></pre><p>保留中の状態を気にしない場合は、最初のブロックを省略することもできます。<pre class="language-sv"><code class="language-sv">{#await promise then value}
	&#x3C;p>The value is {value}&#x3C;/p>
{/await}</code></pre><p>同様に、エラー状態のみを表示したい場合は <code>then</code> ブロックを省略できます。<pre class="language-sv"><code class="language-sv">{#await promise catch error}
	&#x3C;p>The error is {error}&#x3C;/p>
{/await}</code></pre></section><section id="key-"class="level2"><h2>{#key ...}</h2><pre class="language-sv"><code class="language-sv">{#key 式}...{/key}</code></pre><p>key ブロックは式の値が変更されたときに、その中身を破棄して再作成します。<p>これは、ある値が変更されるたびに要素のトランジションを再生したい場合に便利です。<pre class="language-sv"><code class="language-sv">{#key value}
	&#x3C;div transition:fade>{value}&#x3C;/div>
{/key}</code></pre><p>コンポーネントを囲んで使用した場合、コンポーネントの再インスタンス化と再初期化をもたらします。<pre class="language-sv"><code class="language-sv">{#key value}
	&#x3C;Component />
{/key}</code></pre></section><section id="html-"class="level2"><h2>{@html ...}</h2><pre class="language-sv"><code class="language-sv">{@html 式}</code></pre><p>テキスト式（<code>{式}</code> の構文）では、 <code>&#x3C;</code> や <code>></code> のような文字はエスケープされますが、HTML 式ではエスケープされません。<p>式は単独で正しい HTML になっている必要があります。<code>{@html "&#x3C;div>"}content{@html "&#x3C;/div>"}</code> は <code>&#x3C;/div></code> の部分が正しい HTML ではないため、動作<em>しません</em>。また、Svelteコードをコンパイルすることもできません。<blockquote><p>Svelte は HTML を挿入する前に式をサニタイズしません。データが信頼できないソースからのものである場合は自分でサニタイズする必要があります。そうしないと、ユーザーを XSS の脆弱性にさらしてしまいます。</blockquote><pre class="language-sv"><code class="language-sv">&#x3C;div class="blog-post">
	&#x3C;h1>{post.title}&#x3C;/h1>
	{@html post.content}
&#x3C;/div></code></pre></section><section id="debug-"class="level2"><h2>{@debug ...}</h2><pre class="language-sv"><code class="language-sv">{@debug}</code></pre><pre class="language-sv"><code class="language-sv">{@debug 変数1, 変数2, ..., 変数N}</code></pre><p><code>{@debug ...}</code> タグは <code>console.log(...)</code> の代わりになります。指定した変数の値が変更されるたびログに出力し、devtools が開いているとコードの実行を一時停止します。<pre class="language-sv"><code class="language-sv">&#x3C;script>
	let user = {
		firstname: 'Ada',
		lastname: 'Lovelace'
	};
&#x3C;/script>

{@debug user}

&#x3C;h1>Hello {user.firstname}!&#x3C;/h1></code></pre><p><code>{@debug ...}</code> はカンマ区切りの（任意の式ではなく）変数名のリストを受け取ります。<pre class="language-sv"><code class="language-sv">&#x3C;!-- コンパイルされる -->
{@debug user}
{@debug user1, user2, user3}

&#x3C;!-- コンパイルできない -->
{@debug user.firstname}
{@debug myArray[0]}
{@debug !isReady}
{@debug typeof user === 'object'}</code></pre><p>引数なしの <code>{@debug}</code> タグは、（変数を指定した場合とは逆に）状態の<em>どれか</em>が変化した時にトリガされる <code>debugger</code> 文を挿入します。</section><section id="const-"class="level2"><h2>{@const ...}</h2><pre class="language-sv"><code class="language-sv">{@const assignment}</code></pre><p><code>{@const ...}</code> タグはローカル定数を定義します。<pre class="language-sv"><code class="language-sv">&#x3C;script>
	export let boxes;
&#x3C;/script>

{#each boxes as box}
	{@const area = box.width * box.height}
	{box.width} * {box.height} = {area}
{/each}</code></pre><p><code>{@const}</code> は、<code>{#if}</code>、<code>{:else if}</code>、<code>{:else}</code>、<code>{#each}</code>、<code>{:then}</code>、<code>{:catch}</code>、<code>&#x3C;Component /></code>、<code>&#x3C;svelte:fragment /></code> の直下にのみ配置することができます。</section><section id="element-directives"class="level2"><h2>Element directives</h2><p>要素には、属性と同じように<em>ディレクティブ</em>を持たせることができます。これは何らかの方法で要素の動作を制御します。<section id="oneventname"class="level3"><h3>on:<em>eventname</em></h3><pre class="language-sv"><code class="language-sv">on:eventname={handler}</code></pre><pre class="language-sv"><code class="language-sv">on:eventname|modifiers={handler}</code></pre><p>DOM イベントをリッスンするには <code>on:</code> ディレクティブを使用します。<pre class="language-sv"><code class="language-sv">&#x3C;script>
	let count = 0;

	function handleClick(event) {
		count += 1;
	}
&#x3C;/script>

&#x3C;button on:click={handleClick}>
	count: {count}
&#x3C;/button></code></pre><p>ハンドラはパフォーマンスを低下させることなくインラインで宣言できます。 属性と同様、ディレクティブの値はシンタックスハイライトのために引用符で囲むことができます。<pre class="language-sv"><code class="language-sv">&#x3C;button on:click="{() => count += 1}">
	count: {count}
&#x3C;/button></code></pre><p><code>|</code> の文字を使って DOM イベントに<em>修飾子</em>を追加します。<pre class="language-sv"><code class="language-sv">&#x3C;form on:submit|preventDefault={handleSubmit}>
	&#x3C;!-- `submit` イベントの規定の動作が妨げられ
	     ページはリロードされません -->
&#x3C;/form></code></pre><p>次の修飾子を使用できます:<ul><li><code>preventDefault</code> — ハンドラを実行する前に <code>event.preventDefault()</code> を呼び出します<li><code>stopPropagation</code> — <code>event.stopPropagation()</code> を呼び出し、イベントが次の要素に到達するのを防ぎます<li><code>passive</code> — タッチ/ホイールイベントのスクロールパフォーマンスを向上させます（Svelte は追加することが安全な箇所には自動的に追加します）<li><code>nonpassive</code> — 明示的に <code>passive: false</code> を設定します<li><code>capture</code> — <em>バブリング</em>フェーズではなく<em>キャプチャ</em>フェーズ中にハンドラを実行します<li><code>once</code> — ハンドラが最初に実行された後、削除します<li><code>self</code> — event.target がその要素自体だった場合のみハンドラをトリガします<li><code>trusted</code> — <code>event.isTrusted</code> が <code>true</code> の場合にのみハンドラをトリガします。つまり、ユーザーのアクションによってイベントがトリガされた場合です。</ul><p>修飾子は連鎖させることができます。例 <code>on:click|once|capture={...}</code><p><code>on:</code> ディレクティブが値なしで使用された場合、コンポーネントはイベントを<em>転送</em>します。つまりコンポーネントの使用者がイベントをリッスンできます。<pre class="language-sv"><code class="language-sv">&#x3C;button on:click>
	コンポーネント自体がクリックイベントを発火します
&#x3C;/button></code></pre><p>同じイベントに対して複数のイベントリスナを持つことができます。<pre class="language-sv"><code class="language-sv">&#x3C;script>
	let counter = 0;
	function increment() {
		counter = counter + 1;
	}

	function track(event) {
		trackEvent(event)
	}
&#x3C;/script>

&#x3C;button on:click={increment} on:click={track}>Click me!&#x3C;/button></code></pre></section><section id="bindproperty"class="level3"><h3>bind:<em>property</em></h3><pre class="language-sv"><code class="language-sv">bind:property={variable}</code></pre><p>データは通常、親から子へと流れていきます。<code>bind:</code> ディレクティブにより、データを子から親へと逆方向に流すことができます。ほとんどのバインディングは個々の要素に特有です。<p>もっともシンプルなバインディングは、<code>input.value</code> のようなプロパティの値を示します。<pre class="language-sv"><code class="language-sv">&#x3C;input bind:value={name}>
&#x3C;textarea bind:value={text}>&#x3C;/textarea>

&#x3C;input type="checkbox" bind:checked={yes}></code></pre><p>名前が値と一致する場合は、省略形を使用できます。<pre class="language-sv"><code class="language-sv">&#x3C;!-- These are equivalent -->
&#x3C;input bind:value={value}>
&#x3C;input bind:value></code></pre><p>数値の入力値は強制されます。つまり、DOM に関する限り <code>input.value</code> は文字列ですが、Svelte はそれを数値として扱います。入力が empty や 無効な値の場合 (<code>type="number"</code> であれば) 値は <code>undefined</code> になります。<pre class="language-sv"><code class="language-sv">&#x3C;input type="number" bind:value={num}>
&#x3C;input type="range" bind:value={num}></code></pre><p><code>type="file"</code> である <code>&#x3C;input></code> 要素では、<a href="https://developer.mozilla.org/en-US/docs/Web/API/FileList">選択ファイルの <code>FileList</code></a> を取得するために <code>bind:files</code> を使用できます。これは読み取り専用です。<pre class="language-sv"><code class="language-sv">&#x3C;label for="avatar">Upload a picture:&#x3C;/label>
&#x3C;input
	accept="image/png, image/jpeg"
	bind:files
	id="avatar"
	name="avatar"
	type="file"
/></code></pre><p><code>bind:</code> ディレクティブと <code>on:</code> ディレクティブを一緒に使用する場合、イベントハンドラが呼ばれた際には、定義された順番がバインドされた変数の値に影響します。<pre class="language-sv"><code class="language-sv">&#x3C;script>
	let value = 'Hello World';
&#x3C;/script>

&#x3C;input
	on:input="{() => console.log('Old value:', value)}"
	bind:value
	on:input="{() => console.log('New value:', value)}"
/></code></pre><p>ここではテキストの input の値を、<code>input</code> イベントを使用してバインドしています。他の要素のバインディングでは、例えば <code>change</code> などの異なるイベントが使用されることになります。<section id="binding-select-value"class="level4"><h4>Binding <code>&#x3C;select></code> value</h4><p><code>&#x3C;select></code> 値のバインディングは、選択された <code>&#x3C;option></code> の <code>value</code> プロパティに対応しており、(通常の DOM のように文字列だけでなく)どんな値でも設定できます。<pre class="language-sv"><code class="language-sv">&#x3C;select bind:value={selected}>
	&#x3C;option value={a}>a&#x3C;/option>
	&#x3C;option value={b}>b&#x3C;/option>
	&#x3C;option value={c}>c&#x3C;/option>
&#x3C;/select></code></pre><p><code>&#x3C;select multiple></code> 要素はチェックボックスのグループと同様の動作になります。<pre class="language-sv"><code class="language-sv">&#x3C;select multiple bind:value={fillings}>
	&#x3C;option value="Rice">Rice&#x3C;/option>
	&#x3C;option value="Beans">Beans&#x3C;/option>
	&#x3C;option value="Cheese">Cheese&#x3C;/option>
	&#x3C;option value="Guac (extra)">Guac (extra)&#x3C;/option>
&#x3C;/select></code></pre><p><code>&#x3C;option></code> の値がテキスト内容と一致する場合、<code>value</code> 属性は省略できます。<pre class="language-sv"><code class="language-sv">&#x3C;select multiple bind:value={fillings}>
	&#x3C;option>Rice&#x3C;/option>
	&#x3C;option>Beans&#x3C;/option>
	&#x3C;option>Cheese&#x3C;/option>
	&#x3C;option>Guac (extra)&#x3C;/option>
&#x3C;/select></code></pre><p><code>contenteditable</code> 属性を持つ要素は <code>innerHTML</code> と <code>textContent</code> のバインディングをサポートします。<pre class="language-sv"><code class="language-sv">&#x3C;div contenteditable="true" bind:innerHTML={html}>&#x3C;/div></code></pre><p><code>&#x3C;details></code> elements support binding to the <code>open</code> property.<pre class="language-sv"><code class="language-sv">&#x3C;details bind:open={isOpen}>
	&#x3C;summary>Details&#x3C;/summary>
	&#x3C;p>
		Something small enough to escape casual notice.
	&#x3C;/p>
&#x3C;/details></code></pre></section><section id="media-element-bindings"class="level4"><h4>Media element bindings</h4><p>メディア要素 (<code>&#x3C;audio></code> と <code>&#x3C;video></code>) には、独自のバインディングのセットがあります -- 6つの <em>readonly</em> と…<ul><li><code>duration</code> (readonly) — 動画の総再生時間(秒単位)です。<li><code>buffered</code> (readonly) — <code>{start, end}</code> オブジェクトの配列です。<li><code>played</code> (readonly) — 同上<li><code>seekable</code> (readonly) — 同上<li><code>seeking</code> (readonly) — Boolean<li><code>ended</code> (readonly) — Boolean</ul><p>…そして5つの <em>双方向</em> バインディング。<ul><li><code>currentTime</code> — 動画の現在の再生時間、秒単位です。<li><code>playbackRate</code> — どれぐらい早く、または遅く動画を再生するか、1 が '通常値' です。<li><code>paused</code> — これは自明のはずです。<li><code>volume</code> — 0 から 1 の間の値です。<li><code>muted</code> — Booleanの値で、<code>true</code> はミュートになります。</ul><p>動画にはさらに、<code>videoWidth</code> と <code>videoHeight</code> という読み取り専用のバインディングがあります。<pre class="language-sv"><code class="language-sv">&#x3C;video
	src={clip}
	bind:duration
	bind:buffered
	bind:played
	bind:seekable
	bind:seeking
	bind:ended
	bind:currentTime
	bind:playbackRate
	bind:paused
	bind:volume
	bind:muted
	bind:videoWidth
	bind:videoHeight
>&#x3C;/video></code></pre></section><section id="block-level-element-bindings"class="level4"><h4>Block-level element bindings</h4><p>ブロックレベル要素は、<a href="http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/">これ</a>と同様の手法で測定された4つの読み取り専用バインディングを持っています。<ul><li><code>clientWidth</code><li><code>clientHeight</code><li><code>offsetWidth</code><li><code>offsetHeight</code></ul><pre class="language-sv"><code class="language-sv">&#x3C;div
	bind:offsetWidth={width}
	bind:offsetHeight={height}
>
	&#x3C;Chart {width} {height}/>
&#x3C;/div></code></pre></section></section><section id="bindgroup"class="level3"><h3>bind:group</h3><pre class="language-sv"><code class="language-sv">bind:group={variable}</code></pre><p>グループ化させたい入力には<code>bind:group</code>を使用できます。<pre class="language-sv"><code class="language-sv">&#x3C;script>
	let tortilla = 'Plain';
	let fillings = [];
&#x3C;/script>

&#x3C;!-- こちらのグループ化されたラジオinputは相互に排他的です -->
&#x3C;input type="radio" bind:group={tortilla} value="Plain">
&#x3C;input type="radio" bind:group={tortilla} value="Whole wheat">
&#x3C;input type="radio" bind:group={tortilla} value="Spinach">

&#x3C;!-- こちらのグループ化されたチェックボックスinputは配列にデータを挿入します -->
&#x3C;input type="checkbox" bind:group={fillings} value="Rice">
&#x3C;input type="checkbox" bind:group={fillings} value="Beans">
&#x3C;input type="checkbox" bind:group={fillings} value="Cheese">
&#x3C;input type="checkbox" bind:group={fillings} value="Guac (extra)"></code></pre></section><section id="bindthis"class="level3"><h3>bind:this</h3><pre class="language-sv"><code class="language-sv">bind:this={dom_node}</code></pre><p>DOM ノードを参照するには <code>bind:this</code> を使用します。<pre class="language-sv"><code class="language-sv">&#x3C;script>
	import { onMount } from 'svelte';

	let canvasElement;

	onMount(() => {
		const ctx = canvasElement.getContext('2d');
		drawStuff(ctx);
	});
&#x3C;/script>

&#x3C;canvas bind:this={canvasElement}>&#x3C;/canvas></code></pre></section><section id="classname"class="level3"><h3>class:<em>name</em></h3><pre class="language-sv"><code class="language-sv">class:name={value}</code></pre><pre class="language-sv"><code class="language-sv">class:name</code></pre><p><code>class:</code>というディレクティブは要素のクラスを切り替えるための簡単な方法を提供してくれます。<pre class="language-sv"><code class="language-sv">&#x3C;!-- この二つは同等です -->
&#x3C;div class="{active ? 'active' : ''}">...&#x3C;/div>
&#x3C;div class:active={active}>...&#x3C;/div>

&#x3C;!-- 名前と値が一致する場合の省略形がこちらです -->
&#x3C;div class:active>...&#x3C;/div>

&#x3C;!-- 複数のクラスの切り替えを含めることができます -->
&#x3C;div class:active class:inactive={!active} class:isAdmin>...&#x3C;/div></code></pre></section><section id="styleproperty"class="level3"><h3>style:<em>property</em></h3><pre class="language-sv"><code class="language-sv">style:property={value}</code></pre><pre class="language-sv"><code class="language-sv">style:property="value"</code></pre><pre class="language-sv"><code class="language-sv">style:property</code></pre><p><code>style:</code> ディレクティブは、要素に対して複数のスタイルをセットするためのショートハンドを提供します。<pre class="language-sv"><code class="language-sv">&#x3C;!-- These are equivalent -->
&#x3C;div style:color="red">...&#x3C;/div>
&#x3C;div style="color: red;">...&#x3C;/div>

&#x3C;!-- Variables can be used -->
&#x3C;div style:color={myColor}>...&#x3C;/div>

&#x3C;!-- Shorthand, for when property and variable name match -->
&#x3C;div style:color>...&#x3C;/div>

&#x3C;!-- Multiple styles can be included -->
&#x3C;div style:color style:width="12rem" style:background-color={darkMode ? "black" : "white"}>...&#x3C;/div>

&#x3C;!-- Styles can be marked as important -->
&#x3C;div style:color|important="red">...&#x3C;/div></code></pre><p><code>style:</code> ディレクティブが <code>style</code> 属性と一緒に使用されている場合、<code>style:</code> ディレクティブのほうが優先されます。<pre class="language-sv"><code class="language-sv">&#x3C;div style="color: blue;" style:color="red">This will be red&#x3C;/div></code></pre></section><section id="useaction"class="level3"><h3>use:<em>action</em></h3><pre class="language-sv"><code class="language-sv">use:action</code></pre><pre class="language-sv"><code class="language-sv">use:action={parameters}</code></pre><pre class="language-js"><code class="language-js"><span class="token function-variable function">action</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">node</span><span class="token operator">:</span> <span class="token maybe-class-name">HTMLElement</span><span class="token punctuation">,</span> <span class="token literal-property property">parameters</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
	update<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">parameters</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">,</span>
	destroy<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span>
<span class="token punctuation">}</span></code></pre><p>アクションは、要素が作成されたときに呼び出される関数です。要素がアンマウントされたときに呼び出される <code>destroy</code> メソッドをもつオブジェクトを返すことができます。<pre class="language-sv"><code class="language-sv">&#x3C;script>
	function foo(node) {
		// the node has been mounted in the DOM

		return {
			destroy() {
				// the node has been removed from the DOM
			}
		};
	}
&#x3C;/script>

&#x3C;div use:foo>&#x3C;/div></code></pre><p>アクションはパラメータを取ることができます。戻り値に <code>update</code> メソッドがあると、そのパラメータが変化するときはいつも、Svelte がマークアップに更新を適用した直後にそのメソッドが呼び出されます。<blockquote><p>すべてのコンポーネントインスタンスに対して <code>foo</code> 関数を再宣言しているという事実について心配する必要はありません。Svelte は、ローカル状態に依存しない関数をコンポーネント定義から巻き上げます。</blockquote><pre class="language-sv"><code class="language-sv">&#x3C;script>
	export let bar;

	function foo(node, bar) {
		// the node has been mounted in the DOM

		return {
			update(bar) {
				// the value of `bar` has changed
			},

			destroy() {
				// the node has been removed from the DOM
			}
		};
	}
&#x3C;/script>

&#x3C;div use:foo={bar}>&#x3C;/div></code></pre></section><section id="transitionfn"class="level3"><h3>transition:<em>fn</em></h3><pre class="language-sv"><code class="language-sv">transition:fn</code></pre><pre class="language-sv"><code class="language-sv">transition:fn={params}</code></pre><pre class="language-sv"><code class="language-sv">transition:fn|local</code></pre><pre class="language-sv"><code class="language-sv">transition:fn|local={params}</code></pre><pre class="language-js"><code class="language-js">transition <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token operator">:</span> <span class="token maybe-class-name">HTMLElement</span><span class="token punctuation">,</span> <span class="token literal-property property">params</span><span class="token operator">:</span> any<span class="token punctuation">,</span> <span class="token literal-property property">options</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">direction</span><span class="token operator">:</span> <span class="token string">'in'</span> <span class="token operator">|</span> <span class="token string">'out'</span> <span class="token operator">|</span> <span class="token string">'both'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
	delay<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	duration<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	easing<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">t</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> number<span class="token punctuation">,</span>
	css<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">t</span><span class="token operator">:</span> number<span class="token punctuation">,</span> <span class="token literal-property property">u</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> string<span class="token punctuation">,</span>
	tick<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">t</span><span class="token operator">:</span> number<span class="token punctuation">,</span> <span class="token literal-property property">u</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span>
<span class="token punctuation">}</span></code></pre><p>トランジションは、状態変化の結果として DOM に出入りする要素によってトリガーされます。<p>ブロックが外へのトランジションをしているとき、ブロック内のすべての要素（独自のトランジションを持たない要素を含む）は、ブロック内のすべてのトランジジョンが完了するまで DOM に保持されます。<p><code>transition:</code> ディレクティブは <em>双方向</em> トランジションを示しており、トランジションが進行している間、円滑に反転させることができることを意味しています。<pre class="language-sv"><code class="language-sv">{#if visible}
	&#x3C;div transition:fade>
		fades in and out
	&#x3C;/div>
{/if}</code></pre><blockquote><p>デフォルトでは、イントロトランジションは最初のレンダリングでは再生されません。この動作は、<a href="04-run-time.html">コンポーネントを作成する</a> ときに <code>intro: true</code> を設定することで変更できます。</blockquote><section id="transition-parameters"class="level4"><h4>Transition parameters</h4><p>アクションと同様に、トランジションはパラメータを持つことができます。<p>(ダブル <code>{{中括弧}}</code> は特殊な構文ではありません。これは式タグ内のオブジェクトリテラルです)<pre class="language-sv"><code class="language-sv">{#if visible}
	&#x3C;div transition:fade="{{ duration: 2000 }}">
		fades in and out over two seconds
	&#x3C;/div>
{/if}</code></pre></section><section id="custom-transition-functions"class="level4"><h4>Custom transition functions</h4><p>トランジションはカスタム関数を使うことができます。返されたオブジェクトに <code>css</code> 関数があれば、Svelte は要素上で再生される CSS アニメーションを作成します。<p><code>css</code> に渡される <code>t</code> 引数は <code>easing</code> 関数を適用した後の <code>0</code> から <code>1</code> の間の値です。 <em>In</em> トランジションは <code>0</code> から <code>1</code> まで、<em>out</em> トランジションは <code>1</code> から <code>0</code> までの間で実行されます。-- 言い換えれば、<code>1</code> はトランジションが適用されていないかのような要素の自然な状態です。 引数 <code>u</code> は <code>1 - t</code> と等しくなります。<p>この関数はトランジションが始まる <em>前に</em> 繰り返し呼び出され、異なる <code>t</code> と <code>u</code> の引数を持ちます。<pre class="language-sv"><code class="language-sv">&#x3C;script>
	import { elasticOut } from 'svelte/easing';

	export let visible;

	function whoosh(node, params) {
		const existingTransform = getComputedStyle(node).transform.replace('none', '');

		return {
			delay: params.delay || 0,
			duration: params.duration || 400,
			easing: params.easing || elasticOut,
			css: (t, u) => `transform: ${existingTransform} scale(${t})`
		};
	}
&#x3C;/script>

{#if visible}
	&#x3C;div in:whoosh>
		whooshes in
	&#x3C;/div>
{/if}</code></pre><p>カスタムのトランジション関数は <code>tick</code> 関数を返すこともでき、これは同じ <code>t</code> と <code>u</code> の引数を持つトランジションの <em>最中に</em> 呼び出されます。<blockquote><p><code>tick</code> の代わりに <code>css</code> を使うことが可能ならば、そうしてください。-- CSS アニメーションはメインスレッドの外で実行することができるため、遅いデバイスでのジャンクを防ぐことができます。</blockquote><pre class="language-sv"><code class="language-sv">&#x3C;script>
	export let visible = false;

	function typewriter(node, { speed = 1 }) {
		const valid = (
			node.childNodes.length === 1 &#x26;&#x26;
			node.childNodes[0].nodeType === Node.TEXT_NODE
		);

		if (!valid) {
			throw new Error(`This transition only works on elements with a single text node child`);
		}

		const text = node.textContent;
		const duration = text.length / (speed * 0.01);

		return {
			duration,
			tick: t => {
				const i = ~~(text.length * t);
				node.textContent = text.slice(0, i);
			}
		};
	}
&#x3C;/script>

{#if visible}
	&#x3C;p in:typewriter="{{ speed: 1 }}">
		The quick brown fox jumps over the lazy dog
	&#x3C;/p>
{/if}</code></pre><p>トランジションがトランジションオブジェクトではなく関数を返す場合、その関数は次のマイクロタスクで呼び出されます。これにより、複数のトランジションを調整することができ、<a href="/tutorial/deferred-transitions">クロスフェード効果</a> が可能になります。<p>Transition functions also receive a third argument, <code>options</code>, which contains information about the transition.<p>Available values in the <code>options</code> object are:<ul><li><code>direction</code> - one of <code>in</code>, <code>out</code>, or <code>both</code> depending on the type of transition</ul></section><section id="transition-events"class="level4"><h4>Transition events</h4><p>トランジションを持つ要素は、標準的なDOMイベントに加えて以下のイベントをディスパッチします。<ul><li><code>introstart</code><li><code>introend</code><li><code>outrostart</code><li><code>outroend</code></ul><pre class="language-sv"><code class="language-sv">{#if visible}
	&#x3C;p
		transition:fly="{{ y: 200, duration: 2000 }}"
		on:introstart="{() => status = 'intro started'}"
		on:outrostart="{() => status = 'outro started'}"
		on:introend="{() => status = 'intro ended'}"
		on:outroend="{() => status = 'outro ended'}"
	>
		Flies in and out
	&#x3C;/p>
{/if}</code></pre><p>ローカルトランジションは、親ブロックが作成または破棄されたときには再生されず、所属するブロックが作成または破棄されたときにのみ再生されます。<pre class="language-sv"><code class="language-sv">{#if x}
	{#if y}
		&#x3C;p transition:fade>
			fades in and out when x or y change
		&#x3C;/p>

		&#x3C;p transition:fade|local>
			fades in and out only when y changes
		&#x3C;/p>
	{/if}
{/if}</code></pre></section></section><section id="infnoutfn"class="level3"><h3>in:<em>fn</em>/out:<em>fn</em></h3><pre class="language-sv"><code class="language-sv">in:fn</code></pre><pre class="language-sv"><code class="language-sv">in:fn={params}</code></pre><pre class="language-sv"><code class="language-sv">in:fn|local</code></pre><pre class="language-sv"><code class="language-sv">in:fn|local={params}</code></pre><pre class="language-sv"><code class="language-sv">out:fn</code></pre><pre class="language-sv"><code class="language-sv">out:fn={params}</code></pre><pre class="language-sv"><code class="language-sv">out:fn|local</code></pre><pre class="language-sv"><code class="language-sv">out:fn|local={params}</code></pre><p><code>transition:</code> に似ていますが、<code>in:</code> は DOM に入る要素だけに、<code>out:</code> は出る要素だけに適用されます。<p><code>transition:</code> とは違って、<code>in:</code> と <code>out:</code> を適用したトランジションは双方向ではありません。つまり、もしトランジションの最中にブロックがアウトロされた場合、逆転するのではなく、イントロトランジションはアウトロトランジションと一緒に「再生」し続けます。アウトロトランジションが中止された場合、トランジションは最初から再開されます。<pre class="language-sv"><code class="language-sv">{#if visible}
	&#x3C;div in:fly out:fade>
		flies in, fades out
	&#x3C;/div>
{/if}</code></pre></section><section id="animatefn"class="level3"><h3>animate:<em>fn</em></h3><pre class="language-sv"><code class="language-sv">animate:name</code></pre><pre class="language-sv"><code class="language-sv">animate:name={params}</code></pre><pre class="language-js"><code class="language-js"><span class="token function-variable function">animation</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">node</span><span class="token operator">:</span> <span class="token maybe-class-name">HTMLElement</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword module">from</span><span class="token operator">:</span> <span class="token maybe-class-name">DOMRect</span><span class="token punctuation">,</span> <span class="token literal-property property">to</span><span class="token operator">:</span> <span class="token maybe-class-name">DOMRect</span> <span class="token punctuation">}</span> <span class="token punctuation">,</span> <span class="token literal-property property">params</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
	delay<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	duration<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	easing<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">t</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> number<span class="token punctuation">,</span>
	css<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">t</span><span class="token operator">:</span> number<span class="token punctuation">,</span> <span class="token literal-property property">u</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> string<span class="token punctuation">,</span>
	tick<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">t</span><span class="token operator">:</span> number<span class="token punctuation">,</span> <span class="token literal-property property">u</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span>
<span class="token punctuation">}</span></code></pre><pre class="language-js"><code class="language-js"><span class="token maybe-class-name">DOMRect</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">bottom</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	<span class="token literal-property property">height</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	<span class="token literal-property property">​​left</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	<span class="token literal-property property">right</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	<span class="token literal-property property">​top</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	<span class="token literal-property property">width</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	<span class="token literal-property property">x</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
	<span class="token literal-property property">y</span><span class="token operator">:</span> number
<span class="token punctuation">}</span></code></pre><p>アニメーションは、<a href="03-template-syntax.html">keyed each block</a> の内容が並び替えられたときに発生します。アニメーションは、要素が削除されたときには実行されず、each ブロックのデータが並べ替えられたときにのみ実行されます。animate ディレクティブは、キー付き each ブロックの <em>直接の</em> 子要素になければいけません。<p>アニメーションは Svelte の<a href="04-run-time.html">組み込みアニメーション関数</a> または <a href="03-template-syntax.html">カスタムアニメーション関数</a> を使用することができます。<pre class="language-sv"><code class="language-sv">&#x3C;!-- When `list` is reordered the animation will run-->
{#each list as item, index (item)}
	&#x3C;li animate:flip>{item}&#x3C;/li>
{/each}</code></pre><section id="animation-parameters"class="level4"><h4>Animation Parameters</h4><p>アクションやトランジションと同様に、アニメーションはパラメータを持つことができます。<p>(ダブル <code>{{中括弧}}</code> は特殊な構文ではありません。これは式タグ内のオブジェクトリテラルです)<pre class="language-sv"><code class="language-sv">{#each list as item, index (item)}
	&#x3C;li animate:flip="{{ delay: 500 }}">{item}&#x3C;/li>
{/each}</code></pre></section><section id="custom-animation-functions"class="level4"><h4>Custom animation functions</h4><p>アニメーションは、<code>node</code>、<code>animation</code> オブジェクト、および任意の <code>parameters</code> を引数として指定するカスタム関数を使用することができます。<code>animation</code> パラメータは、<code>from</code> と <code>to</code> プロパティを含むオブジェクトで、それぞれ要素の <code>start</code> と <code>end</code> の位置におけるジオメトリを記述した <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMRect#Properties">DOMRect</a> を含みます。<code>from</code> プロパティは要素の開始位置の DOMRect であり、<code>to</code> プロパティはリストが並び替えられ DOM が更新された後の最終位置の DOMRect です。<p>返されたオブジェクトが <code>css</code> メソッドを持つ場合、Svelte は要素上で再生される CSS アニメーションを作成します。<p><code>css</code> に渡される <code>t</code> 引数は <code>easing</code> 関数が適用された後の <code>0</code> と <code>1</code> の値です。引数 <code>u</code> は <code>1 - t</code> に等しい値です。<p>この関数はアニメーションが始まる <em>前に</em> 繰り返し呼ばれ、異なる <code>t</code> と <code>u</code> の引数を持ちます。<pre class="language-sv"><code class="language-sv">&#x3C;script>
	import { cubicOut } from 'svelte/easing';

	function whizz(node, { from, to }, params) {

		const dx = from.left - to.left;
		const dy = from.top - to.top;

		const d = Math.sqrt(dx * dx + dy * dy);

		return {
			delay: 0,
			duration: Math.sqrt(d) * 120,
			easing: cubicOut,
			css: (t, u) =>
				`transform: translate(${u * dx}px, ${u * dy}px) rotate(${t*360}deg);`
		};
	}
&#x3C;/script>

{#each list as item, index (item)}
	&#x3C;div animate:whizz>{item}&#x3C;/div>
{/each}</code></pre><p>カスタムアニメーション関数は <code>tick</code> 関数を返すこともできます。<code>tick</code> 関数はアニメーションの <em>最中</em> に呼び出され、同じ <code>t</code> と <code>u</code> を引数に取ります。<blockquote><p><code>tick</code> の代わりに <code>css</code> を使うことが可能ならば、そうしてください。-- CSS アニメーションはメインスレッドの外で実行することができるため、遅いデバイスでのジャンクを防ぐことができます。</blockquote><pre class="language-sv"><code class="language-sv">&#x3C;script>
	import { cubicOut } from 'svelte/easing';

	function whizz(node, { from, to }, params) {

		const dx = from.left - to.left;
		const dy = from.top - to.top;

		const d = Math.sqrt(dx * dx + dy * dy);

		return {
		delay: 0,
		duration: Math.sqrt(d) * 120,
		easing: cubicOut,
		tick: (t, u) =>
			Object.assign(node.style, {
				color: t > 0.5 ? 'Pink' : 'Blue'
			});
	};
	}
&#x3C;/script>

{#each list as item, index (item)}
	&#x3C;div animate:whizz>{item}&#x3C;/div>
{/each}</code></pre></section></section></section><section id="component-directives"class="level2"><h2>Component directives</h2><section id="oneventname-1"class="level3"><h3>on:<em>eventname</em></h3><pre class="language-sv"><code class="language-sv">on:eventname={handler}</code></pre><p>コンポーネントは <a href="04-run-time.html">createEventDispatcher</a> を用いるか、または DOM イベントをフォワードすることでイベントを発火することができます。コンポーネントのイベントをリッスンするための書き方は、DOM イベントをリッスンする書き方と同じです:<pre class="language-sv"><code class="language-sv">&#x3C;SomeComponent on:whatever={handler}/></code></pre><p>DOM イベントと同様に、<code>on:</code> ディレクティブが値なしに使われる場合、コンポーネントはイベントを<em>フォワード</em>しますが、これはコンポーネントのユーザーがイベントをリッスンできることを意味します。<pre class="language-sv"><code class="language-sv">&#x3C;SomeComponent on:whatever/></code></pre></section><section id="--style-props"class="level3"><h3>--style-props</h3><pre class="language-sv"><code class="language-sv">--style-props="anycssvalue"</code></pre><p><a href="https://github.com/sveltejs/svelte/issues/6268">Svelte 3.38</a> (<a href="https://github.com/sveltejs/rfcs/pull/13">RFC</a>) から、テーマ設定のためにスタイルをプロパティとしてコンポーネントに渡すことができます。これには CSS カスタムプロパティを使用します。<p>Svelte の実装は、基本的にラッパー要素を追加するためのシンタックスシュガー(糖衣構文)です。この例では:<pre class="language-sv"><code class="language-sv">&#x3C;Slider
  bind:value
  min={0}
  --rail-color="black"
  --track-color="rgb(0, 0, 255)"
/></code></pre><p>デシュガー(脱糖)すると:<pre class="language-sv"><code class="language-sv">&#x3C;div style="display: contents; --rail-color: black; --track-color: rgb(0, 0, 255)">
  &#x3C;Slider
    bind:value
    min={0}
    max={100}
  />
&#x3C;/div></code></pre><p><strong>注意</strong>: 余分なdivが追加されるため、あなたのCSS構造が誤ってこれをターゲットにしてしまう可能性があるので注意してください。この機能を使用する際は、この追加されるラッパー要素に気をつけてください。また、全てのブラウザが <code>display: contents</code> をサポートしているわけではないことに注意してください: <a href="https://caniuse.com/css-display-contents">https://caniuse.com/css-display-contents</a><p>SVG namespace の場合、上記の例はデシュガー(脱糖)すると <code>&#x3C;g></code> が代わりに使用されます:<pre class="language-sv"><code class="language-sv">&#x3C;g style="--rail-color: black; --track-color: rgb(0, 0, 255)">
  &#x3C;Slider
    bind:value
    min={0}
    max={100}
  />
&#x3C;/g></code></pre><p><strong>Note</strong>: 余分な <code>&#x3C;g></code> が追加されるため、あなたのCSS構造が誤ってこれをターゲットにしてしまう可能性があるので注意してください。この機能を利用する際は、この追加されるラッパー要素に気をつけてください。<p>Svelte の CSS Variables サポートによって、テーマに沿ったコンポーネントを作るのは容易です:<pre class="language-sv"><code class="language-sv">&#x3C;!-- Slider.svelte -->
&#x3C;style>
  .potato-slider-rail {
    background-color: var(--rail-color, var(--theme-color, 'purple'));
  }
&#x3C;/style></code></pre><p>ハイレベルなテーマカラーを設定できますし、<pre class="language-css"><code class="language-css"><span class="token comment">/* global.css */</span>
<span class="token selector">html</span> <span class="token punctuation">{</span>
  <span class="token variable">--theme-color</span><span class="token punctuation">:</span> <span class="token color">black</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>コンシューマーレベルでそれをオーバーライドできます。<pre class="language-sv"><code class="language-sv">&#x3C;Slider --rail-color="goldenrod"/></code></pre></section><section id="bindproperty-1"class="level3"><h3>bind:<em>property</em></h3><pre class="language-sv"><code class="language-sv">bind:property={variable}</code></pre><p>要素と同じ構文を用いてコンポーネントのプロパティにバインドすることができます。<pre class="language-sv"><code class="language-sv">&#x3C;Keypad bind:value={pin}/></code></pre></section><section id="bindthis-1"class="level3"><h3>bind:this</h3><pre class="language-sv"><code class="language-sv">bind:this={component_instance}</code></pre><p>コンポーネントは <code>bind:this</code> もサポートしており、これを用いることでコンポーネントのインスタンスをプログラムで操作できるようになります。<blockquote><p>ボタンが最初にレンダリングされるときには <code>cart</code> が <code>undefined</code> であり、エラーを投げるので<code>{cart.empty}</code>を実行できないことに注意してください。</blockquote><pre class="language-sv"><code class="language-sv">&#x3C;ShoppingCart bind:this={cart}/>

&#x3C;button on:click={() => cart.empty()}>
	Empty shopping cart
&#x3C;/button></code></pre></section></section><section id="slot"class="level2"><h2><code>&#x3C;slot></code></h2><pre class="language-sv"><code class="language-sv">&#x3C;slot>&#x3C;!-- optional fallback -->&#x3C;/slot></code></pre><pre class="language-sv"><code class="language-sv">&#x3C;slot name="x">&#x3C;!-- optional fallback -->&#x3C;/slot></code></pre><pre class="language-sv"><code class="language-sv">&#x3C;slot prop={value}>&#x3C;/slot></code></pre><p>コンポーネントは要素と同じ様に、子コンテンツを持つことができます。<p>コンテンツは <code>&#x3C;slot></code> 要素を用いて子コンポーネントに公開され、子が何も提供されない場合、レンダリングされるフォールバックのコンテンツを含みます。<pre class="language-sv"><code class="language-sv">&#x3C;!-- Widget.svelte -->
&#x3C;div>
	&#x3C;slot>
		this fallback content will be rendered when no content is provided, like in the first example
	&#x3C;/slot>
&#x3C;/div>

&#x3C;!-- App.svelte -->
&#x3C;Widget>&#x3C;/Widget> &#x3C;!-- this component will render the default content -->

&#x3C;Widget>
	&#x3C;p>this is some child content that will overwrite the default slot content&#x3C;/p>
&#x3C;/Widget></code></pre><section id="slot-namename"class="level3"><h3><code>&#x3C;slot name="</code><em>name</em><code>"></code></h3><p>名前付きスロットは、特定の場所をターゲットにすることを可能にします。 また、フォールバックのコンテンツを含むこともできます。<pre class="language-sv"><code class="language-sv">&#x3C;!-- Widget.svelte -->
&#x3C;div>
	&#x3C;slot name="header">No header was provided&#x3C;/slot>
	&#x3C;p>Some content between header and footer&#x3C;/p>
	&#x3C;slot name="footer">&#x3C;/slot>
&#x3C;/div>

&#x3C;!-- App.svelte -->
&#x3C;Widget>
	&#x3C;h1 slot="header">Hello&#x3C;/h1>
	&#x3C;p slot="footer">Copyright (c) 2019 Svelte Industries&#x3C;/p>
&#x3C;/Widget></code></pre><p>コンポーネントは、<code>&#x3C;Component slot="name" /></code>という構文を使って、名前付きスロットに入れることができます。 ラッパー要素を使うことなくスロットに内容を入れるために、特殊な要素<code>&#x3C;svelte:fragment></code>を使うことができます。<pre class="language-sv"><code class="language-sv">&#x3C;!-- Widget.svelte -->
&#x3C;div>
	&#x3C;slot name="header">No header was provided&#x3C;/slot>
	&#x3C;p>Some content between header and footer&#x3C;/p>
	&#x3C;slot name="footer">&#x3C;/slot>
&#x3C;/div>

&#x3C;!-- App.svelte -->
&#x3C;Widget>
	&#x3C;HeaderComponent slot="header" />
	&#x3C;svelte:fragment slot="footer">
		&#x3C;p>All rights reserved.&#x3C;/p>
		&#x3C;p>Copyright (c) 2019 Svelte Industries&#x3C;/p>
	&#x3C;/svelte:fragment>
&#x3C;/Widget></code></pre></section><section id="slots"class="level3"><h3><code>$$slots</code></h3><p><code>$$slots</code> は、親からコンポーネントに渡されたスロットの名前がキーとなるオブジェクトです。親が特定の名前のスロットを渡さなかった場合、その名前は <code>$$slots</code> には存在しません。これにより、親がスロットを指定した場合にのみコンポーネントがスロット (と他の要素、例えばスタイリング用のラッパーなど)をレンダリングすることができます。<p>注意してください、明示的に空の名前付きスロットを渡すと、そのスロットの名前が <code>$$slots</code> に追加されます。例えば、親が <code>&#x3C;div slot="title" /></code> を子コンポーネントに渡した場合、<code>$$slots.title</code> は子コンポーネント内で有効になります。<pre class="language-sv"><code class="language-sv">&#x3C;!-- Card.svelte -->
&#x3C;div>
	&#x3C;slot name="title">&#x3C;/slot>
	{#if $$slots.description}
		&#x3C;!-- この&#x3C;hr>とスロットは、"description"という名前のスロットが提供されている場合にのみレンダリングされます。 -->
		&#x3C;hr>
		&#x3C;slot name="description">&#x3C;/slot>
	{/if}
&#x3C;/div>

&#x3C;!-- App.svelte -->
&#x3C;Card>
	&#x3C;h1 slot="title">Blog Post Title&#x3C;/h1>
	&#x3C;!-- "description"という名前のスロットは提供されていないので、該当しないスロットはレンダリングされません。 -->
&#x3C;/Card></code></pre></section><section id="slot-keyvalue"class="level3"><h3><code>&#x3C;slot key={</code><em>value</em><code>}></code></h3><p>スロットは0回以上レンダリングすることができ、プロパティ(props)を使って親に値を <em>戻す</em> ことができます。親は <code>let:</code> ディレクティブを使ってスロットテンプレートに値を公開します。<p>通常の短縮ルールが適用されます -- <code>let:item</code> は <code>let:item={item}</code> と同等であり、<code>&#x3C;slot {item}></code> は <code>&#x3C;slot item={item}></code> と同等です。<pre class="language-sv"><code class="language-sv">&#x3C;!-- FancyList.svelte -->
&#x3C;ul>
	{#each items as item}
		&#x3C;li class="fancy">
			&#x3C;slot prop={item}>&#x3C;/slot>
		&#x3C;/li>
	{/each}
&#x3C;/ul>

&#x3C;!-- App.svelte -->
&#x3C;FancyList {items} let:prop={thing}>
	&#x3C;div>{thing.text}&#x3C;/div>
&#x3C;/FancyList></code></pre><p>名前付きスロットは値を公開することもできます。<code>let:</code> ディレクティブは <code>slot</code> 属性を持つ要素に適用されます。<pre class="language-sv"><code class="language-sv">&#x3C;!-- FancyList.svelte -->
&#x3C;ul>
	{#each items as item}
		&#x3C;li class="fancy">
			&#x3C;slot name="item" {item}>&#x3C;/slot>
		&#x3C;/li>
	{/each}
&#x3C;/ul>

&#x3C;slot name="footer">&#x3C;/slot>

&#x3C;!-- App.svelte -->
&#x3C;FancyList {items}>
	&#x3C;div slot="item" let:item>{item.text}&#x3C;/div>
	&#x3C;p slot="footer">Copyright (c) 2019 Svelte Industries&#x3C;/p>
&#x3C;/FancyList></code></pre></section></section><section id="svelteself"class="level2"><h2><code>&#x3C;svelte:self></code></h2><p><code>&#x3C;svelte:self></code> 要素を使用すると、コンポーネントにそれ自体を再帰的に含めることができます。<p>マークアップのトップレベルに表示することはできません。また、無限ループを防ぐために、 <code>if</code> や <code>each</code> ブロックの内側に入れるか、コンポーネントのスロットに渡す必要があります。<pre class="language-sv"><code class="language-sv">&#x3C;script>
	export let count;
&#x3C;/script>

{#if count > 0}
	&#x3C;p>counting down... {count}&#x3C;/p>
	&#x3C;svelte:self count="{count - 1}"/>
{:else}
	&#x3C;p>lift-off!&#x3C;/p>
{/if}</code></pre></section><section id="sveltecomponent"class="level2"><h2><code>&#x3C;svelte:component></code></h2><pre class="language-sv"><code class="language-sv">&#x3C;svelte:component this={expression}/></code></pre><p><code>&#x3C;svelte:component></code> 要素は、 <code>this</code> プロパティで指定されたコンポーネントのコンストラクタを用いて、コンポーネントを動的にレンダリングします。プロパティが変更されると、コンポーネントは破棄されて再生成されます。<p><code>this</code> の値が falsy である場合、コンポーネントはレンダリングされません。<pre class="language-sv"><code class="language-sv">&#x3C;svelte:component this={currentSelection.component} foo={bar}/></code></pre></section><section id="svelteelement"class="level2"><h2><code>&#x3C;svelte:element></code></h2><pre class="language-sv"><code class="language-sv">&#x3C;svelte:element this={expression}/></code></pre><p><code>&#x3C;svelte:element></code> 要素は、動的に指定されたタイプの要素をレンダリングさせることができます。これは例えば、CMS のリッチなテキストコンテンツを表示する場合などに便利です。プロパティやリスナーが存在する場合は、その要素に適用されます。<p>Svelte がビルド時に処理する要素タイプ固有のバインディング (例: input 要素 の <code>bind:value</code>) は動的なタグタイプでは動作しないため、サポートされているバインディングは <code>bind:this</code> のみです。<p><code>this</code> が nullish な値である場合、この要素と子要素はレンダリングされません。<p><code>this</code> が void 要素のタグ名 (例えば <code>br</code>) で、<code>&#x3C;svelte:element></code> が子要素を持っている場合、開発モードの場合はランタイムエラーがスローされます。<pre class="language-sv"><code class="language-sv">&#x3C;script>
	let tag = 'div';
	export let handler;
&#x3C;/script>

&#x3C;svelte:element this={tag} on:click={handler}>Foo&#x3C;/svelte:element></code></pre></section><section id="sveltewindow"class="level2"><h2><code>&#x3C;svelte:window></code></h2><pre class="language-sv"><code class="language-sv">&#x3C;svelte:window on:event={handler}/></code></pre><pre class="language-sv"><code class="language-sv">&#x3C;svelte:window bind:prop={value}/></code></pre><p><code>&#x3C;svelte:window></code> 要素を使うと、コンポーネントが破棄されたときにイベントリスナを削除したり、サーバサイドでレンダリングするときに <code>window</code> が存在するかどうかをチェックしたりすることなく、<code>window</code> オブジェクトにイベントリスナを追加することができます。<p><code>&#x3C;svelte:self></code>とは逆に、この要素はコンポーネントのトップレベルにのみ置くことができ、ブロックや要素の中に置くことはできません。<pre class="language-sv"><code class="language-sv">&#x3C;script>
	function handleKeydown(event) {
		alert(`pressed the ${event.key} key`);
	}
&#x3C;/script>

&#x3C;svelte:window on:keydown={handleKeydown}/></code></pre><p>また、以下のプロパティにバインドすることもできます。<ul><li><code>innerWidth</code><li><code>innerHeight</code><li><code>outerWidth</code><li><code>outerHeight</code><li><code>scrollX</code><li><code>scrollY</code><li><code>online</code> — window.navigator.onLine の別名です</ul><p><code>scrollX</code> と <code>scrollY</code> 以外はすべて読み込み専用です。<pre class="language-sv"><code class="language-sv">&#x3C;svelte:window bind:scrollY={y}/></code></pre><blockquote><p>アクセシビリティの問題を避けるため、ページは初期値にスクロールされないことにご注意ください。<code>scrollX</code> と <code>scrollY</code> にバインドされている変数が変更された後にのみ、スクロールが発生します。ただし、スクロールの挙動が必要であれば、<code>onMount()</code> 内で <code>scrollTo()</code> を呼び出してください。</blockquote></section><section id="sveltebody"class="level2"><h2><code>&#x3C;svelte:body></code></h2><pre class="language-sv"><code class="language-sv">&#x3C;svelte:body on:event={handler}/></code></pre><p><code>&#x3C;svelte:window></code> と同様に、この要素を使うことで <code>document.body</code> のイベント、例えば <code>window</code> では発生しない <code>mouseenter</code> や <code>mouseleave</code> などのリスナを追加することができます。また、<code>&#x3C;body></code> 要素に <a href="03-template-syntax.html">action</a> を使用することもできます。<p><code>&#x3C;svelte:window></code> と同様に、この要素はコンポーネントのトップレベルにのみ置くことができ、ブロックや要素の中に置くことはできません。<pre class="language-sv"><code class="language-sv">&#x3C;svelte:body
	on:mouseenter={handleMouseenter}
	on:mouseleave={handleMouseleave}
	use:someAction
/></code></pre></section><section id="sveltehead"class="level2"><h2><code>&#x3C;svelte:head></code></h2><pre class="language-sv"><code class="language-sv">&#x3C;svelte:head>...&#x3C;/svelte:head></code></pre><p>この要素を使うと、 <code>document.head</code> に要素を挿入することができます。サーバサイドのレンダリングでは、<code>head</code> の内容はメインの <code>html</code> の内容とは別に公開されます。<p><code>&#x3C;svelte:window></code> と <code>&#x3C;svelte:body></code> と同様に、この要素はコンポーネントのトップレベルにのみ置くことができ、ブロックや要素の中に置くことはできません。<pre class="language-sv"><code class="language-sv">&#x3C;svelte:head>
	&#x3C;link rel="stylesheet" href="/tutorial/dark-theme.css">
&#x3C;/svelte:head></code></pre></section><section id="svelteoptions"class="level2"><h2><code>&#x3C;svelte:options></code></h2><pre class="language-sv"><code class="language-sv">&#x3C;svelte:options option={value}/></code></pre><p><code>&#x3C;svelte:options></code> 要素は、コンポーネントごとのコンパイラオプションを指定する場所を提供します。これらは <a href="05-compile-time.html">コンパイラセクション</a> で詳しく説明されています。使用できるオプションは以下の通りです。<ul><li><code>immutable={true}</code> — 変異可能なデータは絶対に使いません。そのため、コンパイラは値が変更されたかどうかを判断するために単純な参照等価性チェックを行うことができます。<li><code>immutable={false}</code> — デフォルトです。Svelte は、変更可能なオブジェクトが変更されたかどうかについて、より保守的になります。<li><code>accessors={true}</code> — コンポーネントのプロパティ(props)のゲッターとセッターを追加します。<li><code>accessors={false}</code> — 初期値です<li><code>namespace="..."</code> — このコンポーネントが使用される名前空間、最も一般的には "svg "です。大文字小文字を区別しない属性名とHTML固有の警告を除外するために "外部の" 名前空間を使用します。<li><code>tag="..."</code> — このコンポーネントをカスタム要素としてコンパイルする際に使用する名前。</ul><pre class="language-sv"><code class="language-sv">&#x3C;svelte:options tag="my-custom-element"/></code></pre></section><section id="sveltefragment"class="level2"><h2><code>&#x3C;svelte:fragment></code></h2><p><code>&#x3C;svelte:fragment></code>要素によって、コンテナとなるDOM要素でラップすることなく<a href="03-template-syntax.html">名前付きスロット</a>に内容を入れることができます。<pre class="language-sv"><code class="language-sv">&#x3C;!-- Widget.svelte -->
&#x3C;div>
	&#x3C;slot name="header">No header was provided&#x3C;/slot>
	&#x3C;p>Some content between header and footer&#x3C;/p>
	&#x3C;slot name="footer">&#x3C;/slot>
&#x3C;/div>

&#x3C;!-- App.svelte -->
&#x3C;Widget>
	&#x3C;h1 slot="header">Hello&#x3C;/h1>
	&#x3C;svelte:fragment slot="footer">
		&#x3C;p>All rights reserved.&#x3C;/p>
		&#x3C;p>Copyright (c) 2019 Svelte Industries&#x3C;/p>
	&#x3C;/svelte:fragment>
&#x3C;/Widget></code></pre><p><span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>