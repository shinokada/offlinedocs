<!doctype html><html lang="en"><meta charset="utf-8"><title>Extending Matchers | Guide</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="extending-matchers"><h1 id="extending-matchers">Extending Matchers</h1><p>Since Vitest is compatible with both Chai and Jest, you can use either the <code>chai.use</code> API or <code>expect.extend</code>, whichever you prefer.<p>This guide will explore extending matchers with <code>expect.extend</code>. If you are interested in Chai's API, check <a href="https://www.chaijs.com/guide/plugins/">their guide</a>.<p>To extend default matchers, call <code>expect.extend</code> with an object containing your matchers.<pre class="language-ts"><code class="language-ts">expect<span class="token punctuation">.</span><span class="token method function property-access">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">toBeFoo</span><span class="token punctuation">(</span>received<span class="token punctuation">,</span> expected<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> isNot <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
      <span class="token comment">// do not alter your "pass" based on isNot. Vitest does it for you</span>
      pass<span class="token operator">:</span> received <span class="token operator">===</span> <span class="token string">'foo'</span><span class="token punctuation">,</span>
      <span class="token function-variable function">message</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>received<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isNot <span class="token operator">?</span> <span class="token string">' not'</span> <span class="token operator">:</span> <span class="token string">''</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> foo</span><span class="token template-punctuation string">`</span></span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>If you are using TypeScript, you can extend default Matchers interface in an ambient declaration file (e.g: <code>vitest.d.ts</code>) with the code below:<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">CustomMatchers</span><span class="token operator">&#x3C;</span><span class="token constant">R</span> <span class="token operator">=</span> <span class="token builtin">unknown</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  <span class="token function">toBeFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">R</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">namespace</span> <span class="token maybe-class-name">Vi</span> <span class="token punctuation">{</span>
  <span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Assertion</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">CustomMatchers</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">AsymmetricMatchersContaining</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">CustomMatchers</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// Note: augmenting jest.Matchers interface will also work.</span>

<span class="token punctuation">}</span></code></pre><blockquote>Don't forget to include the ambient declaration file in your `tsconfig.json`.</blockquote><p>The return value of a matcher should be compatible with the following interface:<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">MatcherResult</span></span> <span class="token punctuation">{</span>
  pass<span class="token operator">:</span> <span class="token builtin">boolean</span>
  <span class="token function-variable function">message</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">string</span>
  <span class="token comment">// If you pass these, they will automatically appear inside a diff when</span>
  <span class="token comment">// the matcher does not pass, so you don't need to print the diff yourself</span>
  actual<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">unknown</span>
  expected<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">unknown</span>
<span class="token punctuation">}</span></code></pre><blockquote>If you create an asynchronous matcher, don't forget to `await` the result (`await expect('foo').toBeFoo()`) in the test itself.</blockquote><p>The first argument inside a matcher's function is the received value (the one inside <code>expect(received)</code>). The rest are arguments passed directly to the matcher.<p>Matcher function have access to <code>this</code> context with the following properties:<ul><li><p><code>isNot</code><p>Returns true, if matcher was called on <code>not</code> (<code>expect(received).not.toBeFoo()</code>).<li><p><code>promise</code><p>If matcher was called on <code>resolved/rejected</code>, this value will contain the name of modifier. Otherwise, it will be an empty string.<li><p><code>equals</code><p>This is a utility function that allows you to compare two values. It will return <code>true</code> if values are equal, <code>false</code> otherwise. This function is used internally for almost every matcher. It supports objects with asymmetric matchers by default.<li><p><code>utils</code><p>This contains a set of utility functions that you can use to display messages.</ul><p><code>this</code> context also contains information about the current test. You can also get it by calling <code>expect.getState()</code>. The most useful properties are:<ul><li><p><code>currentTestName</code><p>Full name of the current test (including describe block).<li><p><code>testPath</code><p>Path to the current test. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></ul></section>