<!doctype html><html lang="en"><meta charset="utf-8"><title>Testing Types | Guide</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"type="text/css"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="testing-types"><h1 id="testing-types">Testing Types</h1><blockquote>Sample Project<p><a href="https://github.com/vitest-dev/vitest/tree/main/examples/typecheck">GitHub</a> - <a href="https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/typecheck?initialPath=__vitest__/">Play Online</a></blockquote><p>Vitest allows you to write tests for your types, using <code>expectTypeOf</code> or <code>assertType</code> syntaxes. By default all tests inside <code>*.test-d.ts</code> files are considered type tests, but you can change it with <a href="../config.html#typecheck-include"><code>typecheck.include</code></a> config option.<p>Under the hood Vitest calls <code>tsc</code> or <code>vue-tsc</code>, depending on your config, and parses results. Vitest will also print out type errors in your source code, if it finds any. You can disable it with <a href="../config.html#typecheck-ignoresourceerrors"><code>typecheck.ignoreSourceErrors</code></a> config option.<p>Keep in mind that Vitest doesn't run these files, they are only statically analyzed by the compiler. Meaning, that if you use a dynamic name or <code>test.each</code> or <code>test.for</code>, the test name will not be evaluated - it will be displayed as is.<blockquote>Before Vitest 2.1, your `typecheck.include` overrode the `include` pattern, so your runtime tests did not actually run; they were only type-checked.<p>Since Vitest 2.1, if your <code>include</code> and <code>typecheck.include</code> overlap, Vitest will report type tests and runtime tests as separate entries.</blockquote><p>Using CLI flags, like <code>--allowOnly</code> and <code>-t</code> are also supported for type checking.<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> assertType<span class="token punctuation">,</span> expectTypeOf <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest'</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> mount <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./mount.js'</span>

<span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'my types work properly'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">expectTypeOf</span><span class="token punctuation">(</span>mount<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">toBeFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">expectTypeOf</span><span class="token punctuation">(</span>mount<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">parameter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">toMatchTypeOf</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token comment">// @ts-expect-error name is a string</span>
  <span class="token function">assertType</span><span class="token punctuation">(</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>Any type error triggered inside a test file will be treated as a test error, so you can use any type trick you want to test types of your project.<p>You can see a list of possible matchers in <a href="/api/expect-typeof">API section</a>.<section class="level2"aria-labelledby="reading-errors"><h2 id="reading-errors">Reading Errors</h2><p>If you are using <code>expectTypeOf</code> API, refer to the <a href="https://github.com/mmkal/expect-type#error-messages">expect-type documentation on its error messages</a>.<p>When types don't match, <code>.toEqualTypeOf</code> and <code>.toMatchTypeOf</code> use a special helper type to produce error messages that are as actionable as possible. But there's a bit of an nuance to understanding them. Since the assertions are written "fluently", the failure should be on the "expected" type, not the "actual" type (<code>expect&#x3C;Actual>().toEqualTypeOf&#x3C;Expected>()</code>). This means that type errors can be a little confusing - so this library produces a <code>MismatchInfo</code> type to try to make explicit what the expectation is. For example:<pre class="language-ts"><code class="language-ts"><span class="token function">expectTypeOf</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">toEqualTypeOf</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>Is an assertion that will fail, since <code>{a: 1}</code> has type <code>{a: number}</code> and not <code>{a: string}</code>. The error message in this case will read something like this:<pre class="language-text"><code class="language-text">test/test.ts:999:999 - error TS2344: Type '{ a: string; }' does not satisfy the constraint '{ a: \\"Expected: string, Actual: number\\"; }'.
  Types of property 'a' are incompatible.
    Type 'string' is not assignable to type '\\"Expected: string, Actual: number\\"'.

999 expectTypeOf({a: 1}).toEqualTypeOf&#x3C;{a: string}>()</code></pre><p>Note that the type constraint reported is a human-readable messaging specifying both the "expected" and "actual" types. Rather than taking the sentence <code>Types of property 'a' are incompatible // Type 'string' is not assignable to type "Expected: string, Actual: number"</code> literally - just look at the property name (<code>'a'</code>) and the message: <code>Expected: string, Actual: number</code>. This will tell you what's wrong, in most cases. Extremely complex types will of course be more effort to debug, and may require some experimentation. Please <a href="https://github.com/mmkal/expect-type">raise an issue</a> if the error messages are actually misleading.<p>The <code>toBe...</code> methods (like <code>toBeString</code>, <code>toBeNumber</code>, <code>toBeVoid</code> etc.) fail by resolving to a non-callable type when the <code>Actual</code> type under test doesn't match up. For example, the failure for an assertion like <code>expectTypeOf(1).toBeString()</code> will look something like this:<pre class="language-text"><code class="language-text">test/test.ts:999:999 - error TS2349: This expression is not callable.
  Type 'ExpectString&#x3C;number>' has no call signatures.

999 expectTypeOf(1).toBeString()
                    ~~~~~~~~~~</code></pre><p>The <code>This expression is not callable</code> part isn't all that helpful - the meaningful error is the next line, <code>Type 'ExpectString&#x3C;number> has no call signatures</code>. This essentially means you passed a number but asserted it should be a string.<p>If TypeScript added support for <a href="https://github.com/microsoft/TypeScript/pull/40468">"throw" types</a> these error messages could be improved significantly. Until then they will take a certain amount of squinting.<section class="level4"aria-labelledby="concrete-expected-objects-vs-typeargs"><h4 id="concrete-expected-objects-vs-typeargs">Concrete "expected" objects vs typeargs</h4><p>Error messages for an assertion like this:<pre class="language-ts"><code class="language-ts"><span class="token function">expectTypeOf</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">toEqualTypeOf</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token string">''</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>Will be less helpful than for an assertion like this:<pre class="language-ts"><code class="language-ts"><span class="token function">expectTypeOf</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">toEqualTypeOf</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>This is because the TypeScript compiler needs to infer the typearg for the <code>.toEqualTypeOf({a: ''})</code> style, and this library can only mark it as a failure by comparing it against a generic <code>Mismatch</code> type. So, where possible, use a typearg rather than a concrete type for <code>.toEqualTypeOf</code> and <code>toMatchTypeOf</code>. If it's much more convenient to compare two concrete types, you can use <code>typeof</code>:<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> one <span class="token operator">=</span> <span class="token function">valueFromFunctionOne</span><span class="token punctuation">(</span><span class="token punctuation">{</span> some<span class="token operator">:</span> <span class="token punctuation">{</span> complex<span class="token operator">:</span> inputs <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> two <span class="token operator">=</span> <span class="token function">valueFromFunctionTwo</span><span class="token punctuation">(</span><span class="token punctuation">{</span> some<span class="token operator">:</span> <span class="token punctuation">{</span> other<span class="token operator">:</span> inputs <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">expectTypeOf</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">toEqualTypeof</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token keyword">typeof</span> two<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>If you find it hard working with <code>expectTypeOf</code> API and figuring out errors, you can always use more simple <code>assertType</code> API:<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> answer <span class="token operator">=</span> <span class="token number">42</span>

<span class="token generic-function"><span class="token function">assertType</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>answer<span class="token punctuation">)</span>
<span class="token comment">// @ts-expect-error answer is not a string</span>
<span class="token generic-function"><span class="token function">assertType</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>answer<span class="token punctuation">)</span></code></pre><blockquote>When using `@ts-expect-error` syntax, you might want to make sure that you didn't make a typo. You can do that by including your type files in [`test.include`](../config.html#include) config option, so Vitest will also actually *run* these tests and fail with `ReferenceError`.<p>This will pass, because it expects an error, but the word “answer” has a typo, so it's a false positive error:<pre class="language-ts"><code class="language-ts"><span class="token comment">// @ts-expect-error answer is not a string</span>
<span class="token generic-function"><span class="token function">assertType</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>answr<span class="token punctuation">)</span> <span class="token comment">//</span></code></pre></blockquote></section></section><section class="level2"aria-labelledby="run-typechecking"><h2 id="run-typechecking">Run Typechecking</h2><p>To enable typechecking, just add <a href="../config.html#typecheck"><code>--typecheck</code></a> flag to your Vitest command in <code>package.json</code>:<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"test"</span><span class="token operator">:</span> <span class="token string">"vitest --typecheck"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Now you can run typecheck:</section>code-group ```bash [npm] npm run test ``` ```bash [yarn] yarn test ``` ```bash [pnpm] pnpm run test ``` ```bash [bun] bun test ```<p>Vitest uses <code>tsc --noEmit</code> or <code>vue-tsc --noEmit</code>, depending on your configuration, so you can remove these scripts from your pipeline. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section>