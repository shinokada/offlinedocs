<!doctype html><html lang="cn"><meta charset="utf-8"><title>Comparisons with Other Test Runners | Guide</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../Vivliostyle/read-html-download-pdf/docs/themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="跟其他的测试框架进行对比"><h1 id="跟其他的测试框架进行对比">跟其他的测试框架进行对比</h1><section class="level2"aria-labelledby="jest"><h2 id="jest">Jest</h2><p><a href="https://jestjs.io/zh-Hans/">Jest</a> 通过为大多数的 JavaScript 项目提供了开箱即用的测试支持，填补了测试框架的空白，有着舒适的 API（例如 <code>it</code> 和 <code>expect</code>），以及大多数所需要的全套测试功能（例如快照，对象模拟，代码测试覆盖率）。我们十分感谢 Jest 团队和社区创建了完美的 API ，并推动了很多测试模式的发展，这些模式现在已经成为 Web 生态系统的标准。现在也可以在 Vite 中使用 Jest。<a href="https://twitter.com/haoqunjiang">@sodatea</a> 正在编写 <a href="https://github.com/sodatea/vite-jest#readme">vite-jest</a>，准备提供一套完美跟 Vite 集成的 <a href="https://jestjs.io/">Jest</a>。最后一个 <a href="https://github.com/sodatea/vite-jest/blob/main/packages/vite-jest/README.md#vite-jest">Jest 中的阻碍</a> 也已经解决，所以 Jest 也是 Vite 生态下单元测试框架的可选项。然而，在我们将 <a href="https://vitejs.dev">Vite</a> 作为常见的 Web 工具（TypeScript，JSX，流行的 UI 框架）所支持的工具里面，Jest 有着重复的复杂性。如果你的项目由 Vite 驱动，那么配置和维护两个不同的容器是一件极其不合理的操作。使用 Vitest，你就可以将开发，构建和测试环境的配置定义为单个容器，共享相同的插件和 <code>vite.config.js</code> 。即使项目并不是由 Vite 提供支持（例如，使用了 esbuild 或者 rollup 进行构建），Vitest 也将会是一个有趣的选择，因为它为你的单元测试提供更快的运行速度，并且由于使用 Vite 即时热模块重载（HMR）的默认监听模式，你的开发体验将会有飞跃的提升。Vitest 与大多数 Jest API 和生态系统库都有较好的兼容性，因此在大多数项目中，我们应该可以无缝的将 Jest 替换成 Vitest 。</section><section class="level2"aria-labelledby="cypress"><h2 id="cypress">Cypress</h2><p><a href="https://www.cypress.io/">Cypress</a> 是基于浏览器的测试工具，是 Vitest 的补充工具之一。如果你想使用 Cypress，建议将 Vitest 用于测试项目中非浏览器逻辑，将 Cypress 用于测试依赖浏览器的逻辑。<p>Cypress 是著名的端到端测试工具，他们<a href="https://on.cypress.io/component">最新的组件测试运行器</a> 对测试 Vite 组件有很好的支持，是测试任何在浏览器中渲染的东西的理想选择。<p>基于浏览器运行测试的框架，例如 Cypress, WebdriverIO 和 Web Test Runner，会捕获到 Vitest 无法捕获的问题，因为他们都是使用真实的浏览器和 APIs。<p>Cypress 的测试更加专注于确定元素是否可见，是否可以访问和交互。Cypress 专门为 UI 开发和测试而构建，它的开发体验趋向于测试你的视觉组件，你会看到程序的组件和测试报告一起出现。测试完成后，组件将保持交互状态，您可以使用浏览器开发工具调试发生的任何故障。<p>相比之下，Vitest 专注于为非浏览器逻辑提供最佳的开发体验。像 Vitest 这样的基于 Node.js 的测试框架支持各种实现部分浏览器环境的第三方包，例如 <code>jsdom</code>，他们实现的足够多，就可以让我们快速的对于任何引用浏览器 APIs 的代码进行单元测试。其代价是，这些浏览器环境在实现上有局限性。例如，<a href="https://github.com/jsdom/jsdom/issues?q=is%3Aissue+is%3Aopen+sort%3Acomments-desc">jsdom 缺少相当数量的特性</a>，诸如 <code>window.navigation</code> 或者布局引擎（<code>offsetTop</code> 等）。<p>最后，与 Web Test Runner 相比，Cypress 更像是一个 IDE 而不是测试框架，因为您还可以在浏览器中看到真实呈现的组件，以及它的测试结果和日志。<p>Cypress 还一直在 <a href="https://www.youtube.com/watch?v=7S5cbY8iYLk">尝试将 Vite 集成进他们自己的产品中</a>：使用 <a href="https://github.com/antfu/vitesse">Vitesse</a> 重新构建他们的应用程序的 UI，并使用 Vite 来测试驱动他们项目的开发。<p>我们认为 Cypress 不是对业务代码进行单元测试好选择，但使用 Cypress（用于端对端和组件测试）配合 Vitest（用于非浏览器逻辑的单元测试）将满足你应用程序的测试需求。</section><section class="level2"aria-labelledby="webdriverio"><h2 id="webdriverio">WebdriverIO</h2><p><a href="https://webdriver.io/">WebdriverIO</a> 类似于 Cypress，一个基于浏览器的替代测试运行器和 Vitest 的补充工具。它可以用作端到端测试工具以及测试 <a href="https://webdriver.io/docs/component-testing">web 组件</a>。它甚至在底层使用了 Vitest 的组件，例如对于组件测试中的 <a href="https://webdriver.io/docs/component-testing/mocks-and-spies">mocking and stubing</a>。<p>WebdriverIO 具有与 Cypress 相同的优势，允许你在真实浏览器中测试您的逻辑。然而，它使用实际的 <a href="https://w3c.github.io/webdriver/">web 标准</a> 进行自动化，这克服了在 Cypress 中运行测试时的一些权衡和限制。此外，它还允许你在移动设备上运行测试，让你可以在更多环境中测试你的应用程序。</section><section class="level2"aria-labelledby="web-test-runner"><h2 id="web-test-runner">Web Test Runner</h2><p><a href="https://modern-web.dev/docs/test-runner/overview/">@web/test-runner</a> 在无头浏览器中进行测试，提供与你的 Web 应用程序相同的运行环境，而不需要模拟浏览器的 API 和 DOM 。虽然没有像 Cypress 那样显示用于单步执行测试的 UI，但也使得我们可以使用 devtools 在浏览器中进行调试。@web/test-runner 有一个监听模式，但是不如 Vitest 智能，而且有时候不一定运行你想要的那个测试。要在 Vite 项目中使用 @web/test-runner，有一个 <a href="https://github.com/material-svelte/vite-web-test-runner-plugin">plugin</a>，尽管某些功能还 <a href="https://github.com/material-svelte/vite-web-test-runner-plugin/issues/11">尚不可用</a>（例如在测试中更改视口大小）。同时 @web/test-runner 不包含断言或对象模拟库，因此要靠你自己来添加它们。</section><section class="level2"aria-labelledby="uvu"><h2 id="uvu">uvu</h2><p><a href="https://github.com/lukeed/uvu">uvu</a> 是用于 Node.js 和浏览器的测试框架。它在单线程中进行测试，所以测试没有被隔离，可以跨文件测试，而 Vitest 使用 Worker 线程来隔离测试并且并发运行它们。为了转换我们的代码，uvu 依赖于 require 和 loader 方法。但是 Vitest 使用 <a href="https://vitejs.dev">Vite</a>，因此文件可以使用 Vite 插件系统的全部功能进行代码的转换。在我们将 Vite 作为常见的 Web 工具（TypeScript，JSX，常见的 UI 框架）所支持的工具里面，uvu 有着重复的复杂性。但是如果项目由 Vite 提供支持，那么配置和维护两个不同的容器是一件极其不合理的操作。使用 Vitest，就可以将开发、构建和测试环境的配置定义为单个容器，共享插件和 <code>vite.config.js</code>。uvu 不提供智能监听模式来重新运行已更改的测试，但 Vitest 为你提供了惊人开发体验，这都归功于默认的监听模式中使用了 Vite 的即时热重载模块（HMR）。uvu 是运行简单测试的快速选项，但对于更复杂的测试和项目，Vitest 可以更快、更可靠。 <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>