<!doctype html><html lang="cn"><meta charset="utf-8"><title>Comparisons with Other Test Runners | Guide</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="跟其他的测试框架进行对比"><h1 id="跟其他的测试框架进行对比">跟其他的测试框架进行对比</h1><section class="level2"aria-labelledby="jest"><h2 id="jest">Jest</h2><p><a href="https://jestjs.io/">Jest</a> 通过为大多数 JavaScript 项目提供开箱即用的支持、舒适的 API（<code>it</code> 和 <code>expect</code>）以及大多数设置所需的完整测试功能（快照、模拟和覆盖率），在测试框架领域占据了主导地位。我们感谢 Jest 团队和社区创建了一个令人愉悦的测试 API，并推动了许多现在成为 Web 生态系统标准的测试模式。<p>可以在 Vite 设置中使用 Jest 。<a href="https://twitter.com/haoqunjiang">@sodatea</a> 开发了 <a href="https://github.com/sodatea/vite-jest#readme">vite-jest</a> ，旨在为 <a href="https://jestjs.io/">Jest</a> 提供一流的 Vite 集成。最后，<a href="https://github.com/sodatea/vite-jest/blob/main/packages/vite-jest/README.md#vite-jest">Jest 中的阻碍问题</a>已经解决，因此这是你单元测试的有效选项。<p>然而，在一个有 <a href="https://vitejs.dev">Vite</a> 为最常见的Web工具（ TypeScript ，JSX ，最流行的 UI 框架）提供支持的世界中，Jest代表了复杂性的重复。如果你的应用程序由 Vite 驱动，则拥有两个不同的管道来配置和维护是不可证明的。使用 Vitest ，你可以定义开发、构建和测试环境的配置作为单个管道，并共享相同的插件和相同的 <code>vite.config.js</code> 文件。<p>即使你的库没有使用 Vite（例如，如果它是使用 esbuild 或 rollup 构建的），Vitest 也是一个有趣的选择，因为它可以让你更快地运行单元测试，并通过默认使用 Vite 的即时热模块重载（ HMR ）观察模式来提高 DX。 Vitest 提供了与大多数 Jest API 和生态系统库兼容性，因此在大多数项目中，它应该可以作为 Jest 的替代品直接使用。</section><section class="level2"aria-labelledby="cypress"><h2 id="cypress">Cypress</h2><p><a href="https://www.cypress.io/">Cypress</a> 是基于浏览器的测试工具，是 Vitest 的补充工具之一。如果你想使用 Cypress，建议将 Vitest 用于测试项目中非浏览器逻辑，将 Cypress 用于测试依赖浏览器的逻辑。<p>Cypress 是著名的端到端测试工具，他们<a href="https://on.cypress.io/component">最新的组件测试运行器</a> 对测试 Vite 组件有很好的支持，是测试任何在浏览器中渲染的东西的理想选择。<p>基于浏览器运行测试的框架，例如 Cypress, WebdriverIO 和 Web Test Runner，会捕获到 Vitest 无法捕获的问题，因为他们都是使用真实的浏览器和 APIs。<p>Cypress 的测试更加专注于确定元素是否可见，是否可以访问和交互。Cypress 专门为 UI 开发和测试而构建，它的开发体验趋向于测试你的视觉组件，你会看到程序的组件和测试报告一起出现。测试完成后，组件将保持交互状态，您可以使用浏览器开发工具调试发生的任何故障。<p>相比之下，Vitest 专注于为非浏览器逻辑提供最佳的开发体验。像 Vitest 这样的基于 Node.js 的测试框架支持各种实现部分浏览器环境的第三方包，例如 <code>jsdom</code> ，他们实现的足够多，就可以让我们快速的对于任何引用浏览器 APIs 的代码进行单元测试。其代价是，这些浏览器环境在实现上有局限性。例如，<a href="https://github.com/jsdom/jsdom/issues?q=is%3Aissue+is%3Aopen+sort%3Acomments-desc">jsdom 缺少相当数量的特性</a>，诸如 <code>window.navigation</code> 或者布局引擎（ <code>offsetTop</code> 等）。<p>最后，与 Web Test Runner 相比，Cypress 更像是一个 IDE 而不是测试框架，因为你还可以在浏览器中看到真实呈现的组件，以及它的测试结果和日志。<p>Cypress 还一直在 <a href="https://www.youtube.com/watch?v=7S5cbY8iYLk">尝试将 Vite 集成进他们自己的产品中</a>：使用 <a href="https://github.com/antfu/vitesse">Vitesse</a> 重新构建他们的应用程序的 UI，并使用 Vite 来测试驱动他们项目的开发。<p>我们认为 Cypress 不是对业务代码进行单元测试好选择，但使用 Cypress（用于端对端和组件测试）配合 Vitest（用于非浏览器逻辑的单元测试）将满足你应用程序的测试需求。</section><section class="level2"aria-labelledby="webdriverio"><h2 id="webdriverio">WebdriverIO</h2><p><a href="https://webdriver.io/">WebdriverIO</a> 类似于 Cypress，一个基于浏览器的替代测试运行器和 Vitest 的补充工具。它可以用作端到端测试工具以及测试 <a href="https://webdriver.io/docs/component-testing">web 组件</a>。它甚至在底层使用了 Vitest 的组件，例如对于组件测试中的 <a href="https://webdriver.io/docs/mocksandspies/">mocking and stubing</a>。<p>WebdriverIO 具有与 Cypress 相同的优点，允许你在真实浏览器中测试逻辑。然而，它使用实际的<a href="https://w3c.github.io/webdriver/"> web 标准</a>进行自动化，在运行 Cypress 测试时克服了一些权衡和限制。此外，它还允许你在移动设备上运行测试，使你可以在更多环境中测试应用程序。</section><section class="level2"aria-labelledby="web-test-runner"><h2 id="web-test-runner">Web Test Runner</h2><p><a href="https://modern-web.dev/docs/test-runner/overview/">@web/test-runner</a> 在无头浏览器中进行测试，提供与你的 Web 应用程序相同的运行环境，而不需要模拟浏览器的 API 和 DOM 。虽然没有像 Cypress 那样显示用于单步执行测试的 UI，但也使得我们可以使用 devtools 在浏览器中进行调试。@web/test-runner 有一个监听模式，但是不如 Vitest 智能，而且有时候不一定运行你想要的那个测试。要在 Vite 项目中使用 @web/test-runner，有一个 <a href="https://github.com/material-svelte/vite-web-test-runner-plugin">plugin</a>，尽管某些功能还 <a href="https://github.com/material-svelte/vite-web-test-runner-plugin/issues/11">尚不可用</a>（例如在测试中更改视口大小）。同时 @web/test-runner 不包含断言或对象模拟库，因此要靠你自己来添加它们。</section><section class="level2"aria-labelledby="uvu"><h2 id="uvu">uvu</h2><p><a href="https://github.com/lukeed/uvu">uvu</a> 是一个适用于 Node.js 和浏览器的测试运行器。它在单个线程中运行测试，因此测试不是隔离的，可能会跨文件泄漏。然而，Vitest 使用工作线程来隔离测试并并行运行它们。对于转换你的代码，uvu 依赖 require 和 loader 钩子。Vitest 使用 <a href="https://vitejs.dev">Vite</a> ，因此文件使用 Vite 的插件系统进行转换。在我们拥有 Vite 提供支持最常见 Web 工具（ TypeScript 、JSX 、最流行的 UI 框架）的世界中，uvu 代表了复杂性重复。如果你的应用程序由 Vite 提供支持，则配置和维护两个不同管道是不可接受的。通过 Vitest，你可以定义开发、构建和测试环境配置为单一管道，并共享相同插件和 <code>vite.config.js</code> 文件夹下面. uvu 不提供智能监视模式以重新运行更改后的测试, 而 Vitest 则通过默认监视模式使用 Vite 实时热更新 (HMR) 功能带给你惊人 DX 。 uvu 是运行简单测试快速选项, 但对于更复杂的测试和项目,Vitest 可能更快、更可靠. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>