<!doctype html><html lang="cn"><meta charset="utf-8"><title>命令行界面 | 指南</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="outline"content="deep"><link rel="stylesheet"type="text/css"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="命令行界面"><h1 id="命令行界面">命令行界面</h1><section class="level2"aria-labelledby="命令"><h2 id="命令">命令</h2><section class="level3"aria-labelledby="vitest"><h3 id="vitest"><code>vitest</code></h3><p>在当前目录中启动 Vitest。在开发环境会自动进入监听(<code>watch</code>)模式，在 CI 环境会自动进入运行(<code>run</code>)模式。<p>你可以通过添加参数作为过滤器来运行测试文件，比如：<pre class="language-bash"><code class="language-bash">vitest foobar</code></pre><p>将仅运行路径中包含 <code>foobar</code> 的测试文件。 此过滤器仅检查包含，不支持正则表达式或 glob 模式（除非你的终端在 Vitest 接收过滤器之前对其进行处理）。</section><section class="level3"aria-labelledby="vitest-run"><h3 id="vitest-run"><code>vitest run</code></h3><p>在没有监听模式的情况下执行单次运行。</section><section class="level3"aria-labelledby="vitest-watch"><h3 id="vitest-watch"><code>vitest watch</code></h3><p>运行所有测试套件，监听变化并在变化时重新运行测试。与没有参数的情况下调用 <code>vitest</code> 一样。在 CI 环境中，此命令将回退到 <code>vitest run</code>。</section><section class="level3"aria-labelledby="vitest-dev"><h3 id="vitest-dev"><code>vitest dev</code></h3><p><code>vitest watch</code> 的别名。</section><section class="level3"aria-labelledby="vitest-related"><h3 id="vitest-related"><code>vitest related</code></h3><p>仅运行涵盖源文件列表的测试。 适用于静态惰性导入(例如, <code>import('./index.ts')</code> 或者 <code>import index from './index.ts</code>)，但不适用于动态导入(例如, <code>import(filepath)</code>)。 所有文件都应该相对于根文件夹。<p>与 <a href="https://github.com/okonet/lint-staged"><code>lint-staged</code></a> 或你的 CI 设置一起运行很有用。<pre class="language-bash"><code class="language-bash">vitest related /src/index.ts /src/hello-world.js</code></pre><blockquote>不要忘记 Vitest 默认情况下以启用的监视模式运行。如果你使用的是 `lint-staged` 之类的工具，你还应该传递 `--run` 选项，以便该命令可以正常退出。<pre class="language-js"><code class="language-js"><span class="token comment">// .lintstagedrc.js</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>
  <span class="token string-property property">'*.{js,ts}'</span><span class="token operator">:</span> <span class="token string">'vitest related --run'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></code></pre></blockquote></section><section class="level3"aria-labelledby="vitest-bench"><h3 id="vitest-bench"><code>vitest bench</code></h3><p>仅运行 <a href="https://vitest.dev/guide/features.html#benchmarking-experimental">基准</a> 测试，比较性能结果。</section><section class="level3"aria-labelledby="vitest-init"><h3 id="vitest-init"><code>vitest init</code></h3><p><code>vitest-init&#x3C;name></code> 可以用于设置项目配置。目前，它只支持 <a href="/guide/browser/"><code>browser</code></a> 值：<pre class="language-bash"><code class="language-bash">vitest init browser</code></pre></section><section class="level3"aria-labelledby="vitest-list"><h3 id="vitest-list"><code>vitest list</code></h3><p><code>vitest list</code> 命令继承所有的 <code>vitest</code> 选项以打印所有匹配测试的列表。此命令忽略 <code>reporters</code> 选项。默认情况下，它将打印与文件过滤器和名称模式匹配的所有测试的名称：<pre class="language-shell"><code class="language-shell">vitest list filename.spec.ts -t<span class="token operator">=</span><span class="token string">"some-test"</span></code></pre><pre class="language-txt"><code class="language-txt">describe > some-test
describe > some-test > test 1
describe > some-test > test 2</code></pre><p>你可以传递 <code>--json</code> 标志以 JSON 格式打印测试，也可以将其保存在单独的文件中：<pre class="language-bash"><code class="language-bash">vitest list filename.spec.ts -t<span class="token operator">=</span><span class="token string">"some-test"</span> --json<span class="token operator">=</span>./file.json</code></pre><p>如果 <code>--json</code> 标志没有接收到值，它将把 JSON 输出到 stdout 中。<p>你还可以传递 <code>--filesOnly</code> 标志来仅打印测试文件：<pre class="language-bash"><code class="language-bash">vitest list --filesOnly</code></pre><pre class="language-txt"><code class="language-txt">tests/test1.test.ts
tests/test2.test.ts</code></pre></section></section><section class="level2"aria-labelledby="选项"><h2 id="选项">选项</h2><blockquote>Vitest 支持 CLI 参数的 both camel case 和 kebab case 。例如，`--passWithNoTests` 和 `--pass-with-no-tests` 都有效（`--no-color` 和 `--inspect-brk` 是例外）。<p>Vitest 还支持不同的指定值的方式：<code>--reporter dot</code> 和 <code>--reporter=dot</code> 都是有效的。<p>如果选项支持值数组，则需要多次传递选项：<pre class="language-bash"><code class="language-bash">vitest --reporter<span class="token operator">=</span>dot --reporter<span class="token operator">=</span>default</code></pre><p>布尔值选项可以用 <code>no-</code> 前缀来否定。将值指定为 <code>false</code> 也有效：<pre class="language-bash"><code class="language-bash">vitest --no-api
vitest --api<span class="token operator">=</span>false</code></pre></blockquote><section class="level3"aria-labelledby="changed"><h3 id="changed">changed</h3><ul><li><p><strong>类型</strong>: <code>boolean | string</code><li><p><strong>默认值</strong>: false<p>设置为 true 时，仅对已更改的文件运行测试。默认情况下，将考虑所有未提交的更改（包括已暂存和未暂存的文件）。<p>要对最近一次提交中的更改运行测试，可以使用 <code>--changed HEAD~1</code>。还可以使用提交哈希（<code>commit hash</code>）或分支名称。<p>如果与 <code>forceRerunTriggers</code> 配置选项配合使用，并找到与更改的文件匹配的内容，将运行整个测试套件。<p>与代码覆盖一起使用时，报告将只包含与更改相关的文件。<p>如果与 <a href="../config.html#forcereruntriggers"><code>forceRerunTriggers</code></a>配置选项搭配使用，则在 <code>forceRerunTriggers</code> 列表中列出的文件至少有一个发生变化时，将运行整个测试套件。默认情况下，Vitest 配置文件和 <code>package.json</code> 的更改将始终重新运行整个套件。</ul></section><section class="level3"aria-labelledby="shard"><h3 id="shard">shard</h3><ul><li><p><strong>类型</strong>: <code>string</code><li><p><strong>默认值</strong>: disabled<p>测试套件分片，格式为 <code>&#x3C;index>/&#x3C;count></code>，其中<ul><li><code>count</code> 是正整数，表示分割的部分数<li><code>index</code> 是正整数，表示当前分片的索引</ul><p>该命令将将所有测试分成 <code>count</code> 个相等的部分，并只运行位于 <code>index</code> 部分的测试。例如，要将测试套件分成三个部分，请使用以下命令：</ul><pre class="language-sh"><code class="language-sh">vitest run --shard=1/3
vitest run --shard=2/3
vitest run --shard=3/3</code></pre><blockquote>警告 无法在启用 `--watch`（默认情况下在开发中启用）时使用此选项。</blockquote><blockquote>如果在没有输出文件的情况下使用 `--reporter=blob`，则默认路径将包括当前碎片配置，以避免与其他 Vitest 进程发生冲突。</blockquote></section><section class="level3"aria-labelledby="merge-reports"><h3 id="merge-reports">merge-reports</h3><ul><li><strong>类型:</strong> <code>boolean | string</code></ul><p>合并位于指定文件夹中的每个 blob 报告（默认情况下为<code>.vitest-reports</code>）。你可以将任何报告程序与此命令一起使用（<a href="/guide/reporters#blob-reporter"><code>blob</code></a> 除外）：<pre class="language-sh"><code class="language-sh">vitest --merge-reports --reporter=junit</code></pre><p><span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section></section>