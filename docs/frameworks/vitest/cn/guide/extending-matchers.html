<!doctype html><html lang="cn"><meta charset="utf-8"><title>扩展断言 | 指南</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"type="text/css"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="扩展断言matchers"><h1 id="扩展断言matchers">扩展断言(Matchers)</h1><p>由于 Vitest 兼容 Chai 和 Jest，所以可以根据个人喜好使用 <code>chai.use</code> API 或者 <code>expect.extend</code>。<p>本文将以 <code>expect.extend</code> 为例探讨扩展断言。如果你对 Chai 的 API 更感兴趣，可以查看<a href="https://www.chaijs.com/guide/plugins/">它的指南</a>。<p>为了扩展默认的断言，可以使用对象包裹断言的形式调用 <code>expect.extend</code> 方法。<pre class="language-ts"><code class="language-ts">expect<span class="token punctuation">.</span><span class="token method function property-access">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">toBeFoo</span><span class="token punctuation">(</span>received<span class="token punctuation">,</span> expected<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> isNot <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
      <span class="token comment">// 请勿根据 isNot 参数更改你的 "pass" 值，Vitest 为你做了这件事情</span>
      pass<span class="token operator">:</span> received <span class="token operator">===</span> <span class="token string">'foo'</span><span class="token punctuation">,</span>
      <span class="token function-variable function">message</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>received<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isNot <span class="token operator">?</span> <span class="token string">' not'</span> <span class="token operator">:</span> <span class="token string">''</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> foo</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>如果你使用 TypeScript，你可以使用以下代码在环境声明文件（例如：<code>vitest.d.ts</code>）中扩展默认的 <code>Assertion</code> 接口：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token string">'vitest'</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">CustomMatchers</span><span class="token operator">&#x3C;</span><span class="token constant">R</span> <span class="token operator">=</span> <span class="token builtin">unknown</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  <span class="token function-variable function">toBeFoo</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">R</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'vitest'</span> <span class="token punctuation">{</span>
  <span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Assertion</span><span class="token operator">&#x3C;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token builtin">any</span><span class="token operator">></span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">CustomMatchers</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">AsymmetricMatchersContaining</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">CustomMatchers</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><blockquote>不要忘记在 `tsconfig.json` 中包含声明文件。</blockquote><p>断言的返回值应该兼容如下接口：<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">ExpectationResult</span></span> <span class="token punctuation">{</span>
  pass<span class="token operator">:</span> <span class="token builtin">boolean</span>
  <span class="token function-variable function">message</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">string</span>
  <span class="token comment">// 如果你传了这些参数，它们将自动出现在 diff 信息中，</span>
  <span class="token comment">// 所以即便断言不通过，你也不必自己输出 diff</span>
  actual<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">unknown</span>
  expected<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">unknown</span>
<span class="token punctuation">}</span></code></pre><blockquote>如果你创建了一个异步断言，记得在测试代码的结果前使用 `await` 关键字(`await expect('foo').toBeFoo()`)</blockquote><p>断言的第一个参数是接收值(即 <code>expect(received)</code> 中的 received )，其余参数将直接传给断言。<p>断言方法可以访问上下文 <code>this</code> 对象中的这些属性:<ul><li><p><code>isNot</code><p>如果断言是在 <code>not</code> 方法上调用的( <code>expect(received).not.toBeFoo()</code> )，则返回 true。<li><p><code>promise</code><p>如果断言是在 <code>resolved/rejected</code> 中调用的，它的值将包含此断言的名称。否则，它将是一个空字符串。<li><p><code>equals</code><p>这是一个工具函数，他可以帮助你比较两个值。如果是相同的则返回 true，反之返回 false。这个方法几乎在每个断言内部都有使用。默认情况下，它支持非对称的断言。<li><p><code>utils</code><p>它包含了一系列工具函数，你可以使用它们来显示信息。</ul><p><code>this</code> 上下文也包含了当前测试的信息，你可以通过调用 <code>expect.getState()</code> 来获取它，其中最有用的属性是：<ul><li><p><code>currentTestName</code><p>当前测试的全称(包括 describe 块)。<li><p><code>testPath</code><p>当前测试的路径。 <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></ul></section>