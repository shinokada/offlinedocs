<!doctype html><html lang="cn"><meta charset="utf-8"><title>类型测试 | 指南</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"type="text/css"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="类型测试"><h1 id="类型测试">类型测试</h1><blockquote>Sample Project<p><a href="https://github.com/vitest-dev/vitest/tree/main/examples/typecheck">GitHub</a> - <a href="https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/typecheck?initialPath=__vitest__/">Play Online</a></blockquote><p>Vitest 允许你使用 <code>expectTypeOf</code> 或 <code>assertType</code> 语法为你的类型编写测试。默认情况下，<code>*.test-d.ts</code> 文件中的所有测试都被视为类型测试，但你可以使用 <a href="../config.html#typecheck-include"><code>typecheck.include</code></a> 配置选项更改它。<p>在这里，Vitest 调用 <code>tsc</code> 或 <code>vue-tsc</code>，具体取决于你的配置，并解析结果。如果发现任何类型错误，Vitest 还会在你的源代码中打印出类型错误。你可以使用 <a href="../config.html#typecheck-ignoresourceerrors"><code>typecheck.ignoreSourceErrors</code></a> 配置选项禁用它。<p>请记住，Vitest 不会运行这些文件，编译器只会对它们进行静态分析。也就是说，如果您使用动态名称或 <code>test.each</code> 或 <code>test.for</code>，测试名称将不会被评估 - 它将原样显示。<blockquote>在 Vitest 2.1 之前，您的 `typecheck.include` 覆盖了 `include` 模式，因此您的运行时测试并没有实际运行；它们只是被类型检查。<p>自 Vitest 2.1 起，如果您的 <code>include</code> 和 <code>typecheck.include</code> 重叠，Vitest 将分别报告类型测试和运行时测试。</blockquote><p>使用 CLI 标志，如 <code>--allowOnly</code> 和 <code>-t</code> 也支持类型检查。<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> assertType<span class="token punctuation">,</span> expectTypeOf <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest'</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> mount <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./mount.js'</span>

<span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'my types work properly'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">expectTypeOf</span><span class="token punctuation">(</span>mount<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">toBeFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">expectTypeOf</span><span class="token punctuation">(</span>mount<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">parameter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">toMatchTypeOf</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token comment">// @ts-expect-error name is a string</span>
  <span class="token function">assertType</span><span class="token punctuation">(</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>在测试文件中触发的任何类型错误都将被视为测试错误，因此你可以使用任何类型技巧来测试项目中的类型。<p>你可以在 <a href="../api.html#expecttypeof">API 部分</a> 中查看可能的匹配器列表。<section class="level2"aria-labelledby="读取错误"><h2 id="读取错误">读取错误</h2><p>如果使用的是 <code>expectTypeOf</code> API，请参阅 <a href="https://github.com/mmkal/expect-type#error-messages">expect-type 关于其错误信息的文档</a>。<p>当类型不匹配时，<code>.toEqualTypeOf</code> 和 <code>.toMatchTypeOf</code>会使用一种特殊的辅助类型来生成尽可能可操作的错误信息。但要理解它们还有一些细微差别。由于断言是 "流畅地 "编写的，所以失败应该发生在 "预期 "类型上，而不是 "实际 "类型上（<code>expect&#x3C;Actual>().toEqualTypeOf&#x3C;Expected>()</code>）。这意味着类型错误可能有点令人困惑，因此该库生成了一个 <code>MismatchInfo</code> 类型，试图明确说明期望是什么。例如<pre class="language-ts"><code class="language-ts"><span class="token function">expectTypeOf</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">toEqualTypeOf</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>是一个将失败的断言，因为 <code>{a: 1}</code> 的类型是 <code>{a: number}</code> 而不是 <code>{a: string}</code>。 这种情况下的错误信息如下<pre class="language-text"><code class="language-text">test/test.ts:999:999 - error TS2344: Type '{ a: string; }' does not satisfy the constraint '{ a: \\"Expected: string, Actual: number\\"; }'.
  Types of property 'a' are incompatible.
    Type 'string' is not assignable to type '\\"Expected: string, Actual: number\\"'.

999 expectTypeOf({a: 1}).toEqualTypeOf&#x3C;{a: string}>()</code></pre><p>请注意，报告的类型约束是一个可读性强的消息，指定了"期望"和"实际"类型。不要字面上解读句子 <code>Types of property 'a' are incompatible // Type 'string' is not assignable to type "Expected: string, Actual: number"</code> ，而是看属性名（<code>'a'</code>）和消息内容：<code>Expected: string, Actual: number</code>。这将告诉你出了什么问题，在大多数情况下。当然，对于非常复杂的类型，调试可能需要更多的努力，并且可能需要一些试验。如果错误消息实际上是误导性的，请<a href="https://github.com/mmkal/expect-type">提出问题</a>。<p>对于像 <code>expectTypeOf(1).toBeString()</code> 这样的断言，<code>toBe...</code> 方法（如 <code>toBeString</code>、<code>toBeNumber</code>、<code>toBeVoid</code> 等）在被测试的 <code>Actual</code> 类型不匹配时会解析为一个不可调用的类型。例如，失败的断言可能会显示如下内容：<pre class="language-text"><code class="language-text">test/test.ts:999:999 - error TS2349: This expression is not callable.
  Type 'ExpectString&#x3C;number>' has no call signatures.

999 expectTypeOf(1).toBeString()
                    ~~~~~~~~~~</code></pre><p>这部分的<code>This expression is not callable</code>并没有太大的帮助 - 有意义的错误在下一行，<code>Type 'ExpectString&#x3C;number> has no call signatures</code>。这基本上意味着你传递了一个数字，但断言它应该是一个字符串。<p>如果 TypeScript 添加了对 <a href="https://github.com/microsoft/TypeScript/pull/40468">"throw" 类型</a> 的支持，这些错误消息将会显著改进。在那之前，它们需要一定程度的仔细观察。<section class="level4"aria-labelledby="具体的-expected--对象与类型参数"><h4 id="具体的-expected--对象与类型参数">具体的 "expected " 对象与类型参数</h4><p>像这样的断言的错误消息：<pre class="language-ts"><code class="language-ts"><span class="token function">expectTypeOf</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">toEqualTypeOf</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token string">''</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>对于像这样的断言，错误消息将不够有帮助：<pre class="language-ts"><code class="language-ts"><span class="token function">expectTypeOf</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">toEqualTypeOf</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>这是因为 TypeScript 编译器需要推断 <code>.toEqualTypeOf({a: ''})</code> 样式的类型参数，并且该库只能通过将其与通用的 <code>Mismatch</code> 类型进行比较来标记它为失败。因此，在可能的情况下，使用类型参数而不是具体类型来使用 <code>.toEqualTypeOf</code> 和 <code>toMatchTypeOf</code>。如果使用两个具体类型进行比较更加方便，可以使用 <code>typeof</code>：<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> one <span class="token operator">=</span> <span class="token function">valueFromFunctionOne</span><span class="token punctuation">(</span><span class="token punctuation">{</span> some<span class="token operator">:</span> <span class="token punctuation">{</span> complex<span class="token operator">:</span> inputs <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> two <span class="token operator">=</span> <span class="token function">valueFromFunctionTwo</span><span class="token punctuation">(</span><span class="token punctuation">{</span> some<span class="token operator">:</span> <span class="token punctuation">{</span> other<span class="token operator">:</span> inputs <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">expectTypeOf</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">toEqualTypeof</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token keyword">typeof</span> two<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>如果你发现很难使用 <code>expectTypeOf</code> API 并找出错误，你始终可以使用更简单的 <code>assertType</code> API：<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> answer <span class="token operator">=</span> <span class="token number">42</span>

<span class="token generic-function"><span class="token function">assertType</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>answer<span class="token punctuation">)</span>
<span class="token comment">// @ts-expect-error answer is not a string</span>
<span class="token generic-function"><span class="token function">assertType</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>answer<span class="token punctuation">)</span></code></pre><blockquote>使用 `@ts-expect-error` 语法时，你可能想确保没有输入错误。你可以通过在 [`test.include`](../config.html#include) 配置选项中包含你的类型文件来做到这一点，因此 Vitest 实际上也会*运行*这些测试并因 `ReferenceError` 而失败。<p>这将通过，因为它预计会出现错误，但 “answer” 这个词有错别字，所以这是一个误报错误：<pre class="language-ts"><code class="language-ts"><span class="token comment">// @ts-expect-error answer is not a string</span>
<span class="token generic-function"><span class="token function">assertType</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>answr<span class="token punctuation">)</span> <span class="token comment">//</span></code></pre></blockquote></section></section><section class="level2"aria-labelledby="运行类型检查"><h2 id="运行类型检查">运行类型检查</h2><p>要启用类型检查，只需在 <code>package.json</code> 文件中的 Vitest 命令中添加 <a href="../config.html#typecheck"><code>--typecheck</code></a> 标志：<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"test"</span><span class="token operator">:</span> <span class="token string">"vitest --typecheck"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>现在你可以运行 typecheck:</section>code-group<pre class="language-bash"><code class="language-bash"><span class="token function">npm</span> run <span class="token builtin class-name">test</span></code></pre><pre class="language-bash"><code class="language-bash"><span class="token function">yarn</span> <span class="token builtin class-name">test</span></code></pre><pre class="language-bash"><code class="language-bash"><span class="token function">pnpm</span> run <span class="token builtin class-name">test</span></code></pre><pre class="language-bash"><code class="language-bash">bun <span class="token builtin class-name">test</span></code></pre><p>Vitest 使用 <code>tsc --noEmit</code> 或 <code>vue-tsc --noEmit</code>，具体取决于你的配置，因此可以从管道中删除这些脚本。 <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section>