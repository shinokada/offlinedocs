<!doctype html><html lang="cn"><meta charset="utf-8"><title>迁移指南 | 指南</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="outline"content="deep"><link rel="stylesheet"type="text/css"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="迁移指南"><h1 id="迁移指南">迁移指南</h1><section class="level2"aria-labelledby="迁移到-vitest-20"><h2 id="迁移到-vitest-20">迁移到 Vitest 2.0</h2><section class="level3"aria-labelledby="默认数据池为-forks"><h3 id="默认数据池为-forks">默认数据池为 <code>forks</code></h3><p>为了提高稳定性，Vitest 2.0 将 <code>pool</code> 的默认配置改为 <code>'fork'</code>。您可以在 <a href="https://github.com/vitest-dev/vitest/pull/5047">PR</a>中阅读完整的动机。<p>如果使用了 <code>poolOptions</code> 而未指定一个 <code>pool</code>，则可能需要更新配置：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    poolOptions<span class="token operator">:</span> <span class="token punctuation">{</span>
      threads<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// [!code --]</span>
        singleThread<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// [!code --]</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// [!code --]</span>
      forks<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// [!code ++]</span>
        singleFork<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// [!code ++]</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// [!code ++]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section><section class="level3"aria-labelledby="钩子函数在堆栈中运行"><h3 id="钩子函数在堆栈中运行">钩子函数在堆栈中运行</h3><p>在 Vitest 2.0 之前，所有钩子函数都是并行运行的。 在 2.0 中，所有钩子都是串行运行的。 除此之外，<code>afterAll</code>/<code>afterEach</code> 以相反的顺序运行。<p>要恢复钩子的并行执行，请将 <a href="../config.html#sequence-hooks"><code>sequence.hooks</code></a> 改为 <code>'parallel'</code>：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    sequence<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// [!code ++]</span>
      hooks<span class="token operator">:</span> <span class="token string">'parallel'</span><span class="token punctuation">,</span> <span class="token comment">// [!code ++]</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// [!code ++]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section><section class="level3"aria-labelledby="suiteconcurrent-同时运行所有测试"><h3 id="suiteconcurrent-同时运行所有测试"><code>suite.concurrent</code> 同时运行所有测试</h3><p>以前，在套件上指定 <code>concurrent</code> 时，并发测试仍会按套件分组并逐个运行。现在，它会遵循 jest 的行为，一次运行所有测试（仍受 <a href="../config.html#maxConcurrency"><code>maxConcurrency</code></a>限制）。</section><section class="level3"aria-labelledby="默认启用-v8-覆盖的-coverageignoreemptylines"><h3 id="默认启用-v8-覆盖的-coverageignoreemptylines">默认启用 V8 覆盖的 <code>coverage.ignoreEmptyLines</code></h3><p>将 <code>coverage.ignoreEmptyLines</code> 的默认值改为 <code>true</code>。此更改将对用户的代码覆盖率报告产生重大影响。使用覆盖率阈值的项目很可能需要在此之后调整这些值。此更改仅影响默认的 <code>coverage.provider.'v8'</code>： 'v8'`.</section><section class="level3"aria-labelledby="不再有watchexclude选项"><h3 id="不再有watchexclude选项">不再有<code>watchExclude</code>选项</h3><p>Vitest 使用 Vite 的监视器。您可以将排除项添加到 <code>server.watch.ignored</code>：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  server<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// [!code ++]</span>
    watch<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// [!code ++]</span>
      ignored<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'!node_modules/examplejs'</span><span class="token punctuation">]</span> <span class="token comment">// [!code ++]</span>
    <span class="token punctuation">}</span> <span class="token comment">// [!code ++]</span>
  <span class="token punctuation">}</span> <span class="token comment">// [!code ++]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section><section class="level3"aria-labelledby="--segfault-retry-删除"><h3 id="--segfault-retry-删除"><code>--segfault-retry</code> 删除</h3><p>默认程序池更改后，不再需要此选项。如果遇到分离故障错误，请尝试切换到<code>'forks'</code>池。如果问题仍然存在，请重现问题并打开一个新问题。 ### 删除套件任务中的空任务<p>这是对高级<a href="/advanced/runner#your-task-function">task API</a>的更改。以前，遍历 <code>.suite</code>最终会导致使用空的内部套件，而不是文件任务。<p>这使得 <code>.suite</code>成为可选项；如果任务是在顶层定义的，则不会有 suite。您可以回退到 <code>.file</code>属性，该属性现在存在于所有任务中（包括文件任务本身，因此要小心不要陷入无休止的递归）。<p>这一更改还删除了 <code>expect.getState().currentTestName</code> 中的文件，并使 <code>expect.getState().testPath</code> 成为必填项。</section><section class="level3"aria-labelledby="taskmeta-已添加到-json-报告器中"><h3 id="taskmeta-已添加到-json-报告器中"><code>task.meta</code> 已添加到 JSON 报告器中</h3><p>JSON 报告器现在会为每个断言结果打印 <code>task.meta</code> 。</section><section class="level3"aria-labelledby="简化的模拟函数通用类型-eg-vifn-mock"><h3 id="简化的模拟函数通用类型-eg-vifn-mock">简化的模拟函数通用类型 (e.g. <code>vi.fn&#x3C;T></code>, <code>Mock&#x3C;T></code>)</h3><p>以前 <code>vi.fn&#x3C;TArgs, TReturn></code> 分别接受参数和返回值的两个泛型。现在改为直接接受一个函数类型 <code>vi.fn&#x3C;T></code> 以简化用法。<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token punctuation">{</span> <span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Mock</span></span><span class="token punctuation">,</span> vi <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">'vitest'</span>

<span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token arrow operator">=></span> x <span class="token operator">+</span> y

<span class="token comment">// using vi.fn&#x3C;T></span>
<span class="token keyword">const</span> mockAdd <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">fn</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Parameters</span><span class="token operator">&#x3C;</span><span class="token keyword">typeof</span> add<span class="token operator">></span><span class="token punctuation">,</span> <span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;</span><span class="token keyword">typeof</span> add<span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// [!code --]</span>
<span class="token keyword">const</span> mockAdd <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">fn</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token keyword">typeof</span> add<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// [!code ++]</span>

<span class="token comment">// using Mock&#x3C;T></span>
<span class="token keyword">const</span> mockAdd<span class="token operator">:</span> <span class="token maybe-class-name">Mock</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Parameters</span><span class="token operator">&#x3C;</span><span class="token keyword">typeof</span> add<span class="token operator">></span><span class="token punctuation">,</span> <span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;</span><span class="token keyword">typeof</span> add<span class="token operator">>></span> <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token method function property-access">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// [!code --]</span>
<span class="token keyword">const</span> mockAdd<span class="token operator">:</span> <span class="token maybe-class-name">Mock</span><span class="token operator">&#x3C;</span><span class="token keyword">typeof</span> add<span class="token operator">></span> <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token method function property-access">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// [!code ++]</span></code></pre></section><section class="level3"aria-labelledby="accessing-resolved-mockresults"><h3 id="accessing-resolved-mockresults">Accessing Resolved <code>mock.results</code></h3><p>Previously Vitest resolved <code>mock.results</code> values if the function returned a Promise. Now there is a separate <a href="/api/mock#mock-settledresults"><code>mock.settledResults</code></a> property that populates only when the returned Promise is resolved or rejected.<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> fn <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token method function property-access">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">mockResolvedValueOnce</span><span class="token punctuation">(</span><span class="token string">'result'</span><span class="token punctuation">)</span>
<span class="token keyword control-flow">await</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> result <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token property-access">mock</span><span class="token punctuation">.</span><span class="token property-access">results</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// 'result' // [!code --]</span>
<span class="token keyword">const</span> result <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token property-access">mock</span><span class="token punctuation">.</span><span class="token property-access">results</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// 'Promise&#x3C;result>' // [!code ++]</span>

<span class="token keyword">const</span> settledResult <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token property-access">mock</span><span class="token punctuation">.</span><span class="token property-access">settledResults</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// 'result'</span></code></pre><p>With this change, we also introduce new <a href="/api/expect#tohaveresolved"><code>toHaveResolved*</code></a> matchers similar to <code>toHaveReturned</code> to make migration easier if you used <code>toHaveReturned</code> before:<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> fn <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token method function property-access">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">mockResolvedValueOnce</span><span class="token punctuation">(</span><span class="token string">'result'</span><span class="token punctuation">)</span>
<span class="token keyword control-flow">await</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">expect</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">toHaveReturned</span><span class="token punctuation">(</span><span class="token string">'result'</span><span class="token punctuation">)</span> <span class="token comment">// [!code --]</span>
<span class="token function">expect</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">toHaveResolved</span><span class="token punctuation">(</span><span class="token string">'result'</span><span class="token punctuation">)</span> <span class="token comment">// [!code ++]</span></code></pre></section><section class="level3"aria-labelledby="浏览器模式"><h3 id="浏览器模式">浏览器模式</h3><p>Vitest 浏览器模式在测试周期内发生了很多变化。您可以在<a href="https://github.com/vitest-dev/vitest/discussions/5828">GitHub discussion</a>上阅读我们关于浏览器模式的理念。<p>大多数改动都是附加的，但也有一些小的突破性改动：<ul><li><code>none</code> provider 更名为 <code>preview</code> <a href="https://github.com/vitest-dev/vitest/pull/5826">#5842</a><li><code>preview</code> provider 现在是默认的 <a href="https://github.com/vitest-dev/vitest/pull/5826">#5842</a><li><code>indexScripts</code> 更名为 <code>orchestratorScripts</code> <a href="https://github.com/vitest-dev/vitest/pull/5842">#5842</a></ul></section><section class="level3"aria-labelledby="删除过时的选项"><h3 id="删除过时的选项">删除过时的选项</h3><p>删除了一些过时的选项：<ul><li><code>vitest typecheck</code> 命令 - 使用 <code>vitest --typecheck</code> 代替<li><code>VITEST_JUNIT_CLASSNAME</code> 和 <code>VITEST_JUNIT_SUITE_NAME</code> 环境变量（改用 reporter 选项）<li>检查 <code>c8</code> 覆盖率（使用 coverage-v8 代替）<li>从 <code>vitest</code> 导出 <code>SnapshotEnvironment</code> - 改为从 <code>vitest/snapshot</code> 导入<li>删除 <code>SpyInstance</code> 改用 <code>MockInstance</code></ul></section></section><section class="level2"aria-labelledby="迁移到-vitest-10"><h2 id="迁移到-vitest-10">迁移到 Vitest 1.0</h2><section class="level3"aria-labelledby="最低要求"><h3 id="最低要求">最低要求</h3><p>Vitest 1.0 需要 Vite 5.0 和 Node.js 18 或更高版本。<p>所有 <code>@vitest/*</code> 子软件包都需要 Vitest 1.0 版本。</section><section class="level3"aria-labelledby="snapshots-更新-3961"><h3 id="snapshots-更新-3961">Snapshots 更新 <a href="https://github.com/vitest-dev/vitest/pull/3961">#3961</a></h3><p>快照中的引号不再转义，即使字符串只有一行，所有快照也都使用回车引号 (`)。<ol><li>引号不再转义：</ol><pre class="language-diff"><code class="language-diff">expect({ foo: 'bar' }).toMatchInlineSnapshot(`
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> Object {
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    \\"foo\\": \\"bar\\",
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    "foo": "bar",
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> }
</span></span>`)</code></pre><ol start="2"><li>单行快照现在使用"`"引号，而不是"'"：</ol><pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> expect('some string').toMatchInlineSnapshot('"some string"')
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> expect('some string').toMatchInlineSnapshot(`"some string"`)</span></span></code></pre><p>对 <code>@vitest/snapshot</code> 也有<a href="https://github.com/vitest-dev/vitest/pull/4076">修改</a>。如果不直接使用它，则无需做任何更改。<ul><li>我们不再需要扩展 <code>SnapshotClient</code> 以覆盖 <code>equalityCheck</code> 方法：只需在启动实例时将其作为 <code>isEqual</code> 传递即可。<li><code>client.setTest</code> 更名为 <code>client.startCurrentRun</code><li><code>client.resetCurrent</code> 更名为 <code>client.finishCurrentRun</code> 。</ul></section><section class="level3"aria-labelledby="pools-标准化-4172"><h3 id="pools-标准化-4172">Pools 标准化 <a href="https://github.com/vitest-dev/vitest/pull/4172">#4172</a></h3><p>We removed a lot of configuration options to make it easier to configure the runner to your needs. Please, have a look at migration examples if you rely on <code>--threads</code> or other related flags.<p>我们删除了大量配置选项，以便根据需要配置运行程序。如果你已经使用了 <code>--threads</code> 或其他相关标记，请查看迁移示例。<ul><li><code>--threads</code> 现在是 <code>--pool=threads</code><li><code>--no-threads</code> 现在是 <code>--pool=forks</code><li><code>--single-thread</code> 现在是 <code>--poolOptions.threads.singleThread</code><li><code>--experimental-vm-threads</code> 现在是 <code>--pool=vmThreads</code><li><code>--experimental-vm-worker-memory-limit</code> 现在是 <code>--poolOptions.vmThreads.memoryLimit</code><li><code>--isolate</code> 现在是 <code>--poolOptions.&#x3C;pool-name>.isolate</code> 和 <code>browser.isolate</code><li><code>test.maxThreads</code> 现在是 <code>test.poolOptions.&#x3C;pool-name>.maxThreads</code><li><code>test.minThreads</code> 现在是 <code>test.poolOptions.&#x3C;pool-name>.minThreads</code><li><code>test.useAtomics</code> 现在是 <code>test.poolOptions.&#x3C;pool-name>.useAtomics</code><li><code>test.poolMatchGlobs.child_process</code> 现在是 <code>test.poolMatchGlobs.forks</code><li><code>test.poolMatchGlobs.experimentalVmThreads</code> 现在是 <code>test.poolMatchGlobs.vmThreads</code></ul><pre class="language-diff"><code class="language-diff">{
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> scripts: {
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    "test": "vitest --no-threads"
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    // For identical behaviour:
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    "test": "vitest --pool forks --poolOptions.forks.singleFork"
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    // Or multi parallel forks:
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    "test": "vitest --pool forks"
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> }
</span></span>}</code></pre><pre class="language-diff"><code class="language-diff">{
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> scripts: {
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    "test": "vitest --experimental-vm-threads"
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    "test": "vitest --pool vmThreads"
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> }
</span></span>}</code></pre><pre class="language-diff"><code class="language-diff">{
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> scripts: {
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    "test": "vitest --isolate false"
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    "test": "vitest --poolOptions.threads.isolate false"
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> }
</span></span>}</code></pre><pre class="language-diff"><code class="language-diff">{
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> scripts: {
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    "test": "vitest --no-threads --isolate false"
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    "test": "vitest --pool forks --poolOptions.forks.isolate false"
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> }
</span></span>}</code></pre></section><section class="level3"aria-labelledby="coverage-的变化-4265-4442"><h3 id="coverage-的变化-4265-4442">Coverage 的变化 <a href="https://github.com/vitest-dev/vitest/pull/4265">#4265</a>, <a href="https://github.com/vitest-dev/vitest/pull/4442">#4442</a></h3><p>选项 <code>coverage.all</code> 现在默认启用。这意味着，所有符合 <code>coverage.include</code> 模式的项目文件都将被处理，即使它们未被执行。<p>更改了覆盖阈值 API 的形状，现在它支持使用 glob 模式为特定文件指定阈值：<pre class="language-diff"><code class="language-diff">export default defineConfig({
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> test: {
</span><span class="token prefix unchanged"> </span><span class="token line">   coverage: {
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">      perFile: true,
</span><span class="token prefix deleted">-</span><span class="token line">      thresholdAutoUpdate: true,
</span><span class="token prefix deleted">-</span><span class="token line">      100: true,
</span><span class="token prefix deleted">-</span><span class="token line">      lines: 100,
</span><span class="token prefix deleted">-</span><span class="token line">      functions: 100,
</span><span class="token prefix deleted">-</span><span class="token line">      branches: 100,
</span><span class="token prefix deleted">-</span><span class="token line">      statements: 100,
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      thresholds: {
</span><span class="token prefix inserted">+</span><span class="token line">        perFile: true,
</span><span class="token prefix inserted">+</span><span class="token line">        autoUpdate: true,
</span><span class="token prefix inserted">+</span><span class="token line">        100: true,
</span><span class="token prefix inserted">+</span><span class="token line">        lines: 100,
</span><span class="token prefix inserted">+</span><span class="token line">        functions: 100,
</span><span class="token prefix inserted">+</span><span class="token line">        branches: 100,
</span><span class="token prefix inserted">+</span><span class="token line">        statements: 100,
</span><span class="token prefix inserted">+</span><span class="token line">      }
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   }
</span><span class="token prefix unchanged"> </span><span class="token line"> }
</span></span>})</code></pre></section><section class="level3"aria-labelledby="mock-类型-4400"><h3 id="mock-类型-4400">Mock 类型 <a href="https://github.com/vitest-dev/vitest/pull/4400">#4400</a></h3><p>删除了一些类型，改用 Jest 风格的 "Mock "命名。<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> import { EnhancedSpy, SpyInstance } from 'vitest'
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> import { MockInstance } from 'vitest'</span></span></code></pre><blockquote>`SpyInstance` 已被弃用，取而代之的是 `MockInstance` ，并会在下一个主要版本中移除。</blockquote></section><section class="level3"aria-labelledby="timer-mocks-3925"><h3 id="timer-mocks-3925">Timer mocks <a href="https://github.com/vitest-dev/vitest/pull/3925">#3925</a></h3><p><code>vi.useFakeTimers()</code> 不再自动模拟 <a href="https://nodejs.org/api/process.html#processnexttickcallback-args"><code>process.nextTick</code></a> 。 仍然可以通过使用 <code>vi.useFakeTimers({ toFake: ['nextTick'] })</code> 明确指定来模拟 <code>process.nextTick</code>。<p>但是，在使用 <code>--pool=forks</code> 时，无法模拟 <code>process.nextTick</code> 。如果需要模拟 <code>process.nextTick</code> ，请使用不同的 <code>--pool</code> 选项。</section></section><section class="level2"aria-labelledby="从-jest-迁移"><h2 id="从-jest-迁移">从 Jest 迁移</h2><p>Vitest 设计了与 Jest 兼容的 API ，方便你从 Jest 的迁移尽可能简单。尽管做出了这些努力，你仍然可能会遇到以下差异：<section class="level3"aria-labelledby="全局变量作为默认值"><h3 id="全局变量作为默认值">全局变量作为默认值</h3><p>Jest 默认启用<a href="https://jestjs.io/zh-Hans/docs/api">全局 API</a>。然而 Vitest 没有。你既可以通过 <a href="../config.html#globals"><code>globals</code> 配置选项</a>启用全局 API，也可以通过更新你的代码以便使用来自 <code>vitest</code> 模块的导入。<p>如果你决定禁用全局 API，请注意像 <a href="https://testing-library.com/"><code>testing-library</code></a> 这样的通用库不会自动运行 DOM <a href="https://testing-library.com/docs/svelte-testing-library/api/#cleanup">cleanup</a>。</section><section class="level3"aria-labelledby="模拟模块"><h3 id="模拟模块">模拟模块</h3><p>在 Jest 中模拟一个模块时，工厂参数的返回值是默认导出。在 Vitest 中，工厂参数必须返回一个明确定义了每个导出的对象。例如，下面的 <code>jest.mock</code> 必须更新如下：<pre class="language-ts"><code class="language-ts">jest<span class="token punctuation">.</span><span class="token method function property-access">mock</span><span class="token punctuation">(</span><span class="token string">'./some-path'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token string">'hello'</span><span class="token punctuation">)</span> <span class="token comment">// [!code --]</span>
vi<span class="token punctuation">.</span><span class="token method function property-access">mock</span><span class="token punctuation">(</span><span class="token string">'./some-path'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// [!code ++]</span>
  <span class="token keyword module">default</span><span class="token operator">:</span> <span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token comment">// [!code ++]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [!code ++]</span></code></pre><p>有关更深入的详细描述，请参阅 <a href="../api.html#vi-mock"><code>vi.mock</code> api section</a>。</section><section class="level3"aria-labelledby="自动模拟行为"><h3 id="自动模拟行为">自动模拟行为</h3><p>区别于 Jest，在 <code>&#x3C;root>/__mocks__</code> 中的模拟模块只有在 <code>vi.mock()</code> 被调用时才会加载。如果你需要它们像在 Jest 中一样，在每个测试中都被模拟，你可以在 <a href="../config.html#setupfiles"><code>setupFiles</code></a> 中模拟它们。</section><section class="level3"aria-labelledby="导入模拟包的原始版本"><h3 id="导入模拟包的原始版本">导入模拟包的原始版本</h3><p>如果你只需要模拟一个 package 的部分功能，你可能之前使用了 Jest 的 <code>requireActual</code> 函数。在 Vitest 中，你应该将这些调用替换为 <code>vi.importActual</code>。<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> <span class="token punctuation">{</span> cloneDeep <span class="token punctuation">}</span> <span class="token operator">=</span> jest<span class="token punctuation">.</span><span class="token method function property-access">requireActual</span><span class="token punctuation">(</span><span class="token string">'lodash/cloneDeep'</span><span class="token punctuation">)</span> <span class="token comment">// [!code --]</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> cloneDeep <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword control-flow">await</span> vi<span class="token punctuation">.</span><span class="token method function property-access">importActual</span><span class="token punctuation">(</span><span class="token string">'lodash/cloneDeep'</span><span class="token punctuation">)</span> <span class="token comment">// [!code ++]</span></code></pre></section><section class="level3"aria-labelledby="将模拟扩展到外部库"><h3 id="将模拟扩展到外部库">将模拟扩展到外部库</h3><p>在 Jest 的默认情况下，当模拟一个模块并希望将此模拟扩展到使用相同模块的其他外部库时，您应该明确告知您希望模拟哪个第三方库，这样外部库就会成为您源代码的一部分，方法是使用 <a href="https://vitest.dev/config/#server-deps-inline">server.deps.inline</a>.<pre class="language-text"><code class="language-text">server.deps.inline: ["lib-name"]</code></pre></section><section class="level3"aria-labelledby="expectgetstatecurrenttestname"><h3 id="expectgetstatecurrenttestname">expect.getState().currentTestName</h3><p>Vitest 的 <code>test</code> 名称用 <code>></code> 符号连接，以便于区分测试和套件，而 Jest 则使用空格 (<code></code>)。<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> `${describeTitle} ${testTitle}`
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> `${describeTitle} > ${testTitle}`</span></span></code></pre></section><section class="level3"aria-labelledby="envs"><h3 id="envs">Envs</h3><p>Jest 导出各种 <a href="https://jasmine.github.io/"><code>jasmine</code></a> 全局 API (例如 <code>jasmine.any()</code> )。任何此类实例都需要迁移成 <a href="/api/">Vitest 的对应 API </a>。</section><section class="level3"aria-labelledby="测试环境"><h3 id="测试环境">测试环境</h3><p>如果之前没有设置，Vitest 会像 Jest 一样，把 <code>NODE_ENV</code> 设置为 <code>test</code>。 Vitest 也有一个 <code>JEST_WORKER_ID</code> 的对应项，是 <code>VITEST_WORKER_ID</code>，所以如果你依赖它，不要忘记重命名它。</section><section class="level3"aria-labelledby="属性替换"><h3 id="属性替换">属性替换</h3><p>如果你想修改测试环境，你会在 Jest 中使用 <a href="https://jestjs.io/docs/jest-object#jestreplacepropertyobject-propertykey-value">replaceProperty API</a>，你可以使用 <a href="/api/vi#vi-stubenv">vi.stubEnv</a> 或者 <a href="/api/vi#vi-spyon"><code>vi.spyOn</code></a> 也可以在 Vitest 中执行此操作。<p>从 Vitest v0.10.0 开始，声明测试的回调样式被弃用。 你可以重写它们以使用 <code>async</code>/<code>await</code> 函数，或者使用 Promise 来模仿回调样式。<pre class="language-text"><code class="language-text">it('should work', (done) => {  // [!code --]
it('should work', () => new Promise(done => { // [!code ++]
  // ...
  done()
}) // [!code --]
})) // [!code ++]</code></pre></section><section class="level3"aria-labelledby="钩子"><h3 id="钩子">钩子</h3><p><code>beforeAll</code>/<code>beforeEach</code> 钩子可能在 Vitest 的 <a href="../api.html#setup-and-teardown">teardown 函数</a>中返回。因此，如果它们返回的不是 <code>undefined</code> 或 <code>null</code>，你可能需要重写你的钩子声明：<pre class="language-ts"><code class="language-ts"><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setActivePinia</span><span class="token punctuation">(</span><span class="token function">createTestingPinia</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [!code --]</span>
<span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">setActivePinia</span><span class="token punctuation">(</span><span class="token function">createTestingPinia</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// [!code ++]</span></code></pre><p>在 Jest 中，钩子是按顺序调用的（一个接一个）。默认情况下，Vitest 并行运行钩子。要使用 Jest 的行为，请更新 <a href="../config.html#sequence-hooks"><code>sequence.hooks</code></a> 选项：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    sequence<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// [!code ++]</span>
      hooks<span class="token operator">:</span> <span class="token string">'list'</span><span class="token punctuation">,</span> <span class="token comment">// [!code ++]</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// [!code ++]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section><section class="level3"aria-labelledby="类型"><h3 id="类型">类型</h3><p>Vitest 没有等效于 <code>jest</code> 的命名空间，因此你需要直接从 <code>Vitest</code> 导入类型：<pre class="language-ts"><code class="language-ts"><span class="token comment">// [!code --]</span>
<span class="token keyword">let</span> fn<span class="token operator">:</span> jest<span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Mock</span></span><span class="token operator">&#x3C;</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">number</span><span class="token operator">></span> <span class="token comment">// [!code --]</span>
<span class="token keyword module">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">Mock</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">'vitest'</span> <span class="token comment">// [!code ++]</span>
<span class="token keyword">let</span> fn<span class="token operator">:</span> <span class="token maybe-class-name">Mock</span><span class="token operator">&#x3C;</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">number</span><span class="token operator">></span> <span class="token comment">// [!code ++]</span></code></pre></section><section class="level3"aria-labelledby="定时器"><h3 id="定时器">定时器</h3><p>如果你之前在测试中使用了 jest.setTimeout ，那么你需要迁移到 Vitest 中的<code>vi.setConfig</code> :<pre class="language-ts"><code class="language-ts">jest<span class="token punctuation">.</span><span class="token method function property-access">setTimeout</span><span class="token punctuation">(</span><span class="token number">5_000</span><span class="token punctuation">)</span> <span class="token comment">// [!code --]</span>
vi<span class="token punctuation">.</span><span class="token method function property-access">setConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span> testTimeout<span class="token operator">:</span> <span class="token number">5_000</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// [!code ++]</span></code></pre></section><section class="level3"aria-labelledby="vue-快照"><h3 id="vue-快照">Vue 快照</h3><p>如果你以前在 vue-cli preset 中使用 Jest，那么这不是一个 Jest 独有的新特性。你可能需要安装 <a href="https://github.com/eddyerburgh/jest-serializer-vue"><code>jest-serializer-vue</code></a> 包，然后在 <a href="../config.html#setupfiles">setupFiles</a> 中配置：</p>code-group ```js [vite.config.js] import { defineConfig } from 'vite' export default defineConfig({ test: { setupFiles: ['./tests/unit/setup.js'], }, }) ``` ```js [tests/unit/setup.js] import vueSnapshotSerializer from 'jest-serializer-vue' expect.addSnapshotSerializer(vueSnapshotSerializer) ```<p>否则你的快照将出现大量的 <code>"</code> 字符。 <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section></section>