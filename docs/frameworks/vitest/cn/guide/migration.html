<!doctype html><html lang="cn"><meta charset="utf-8"><title>Migration Guide | Guide</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="迁移指南"class="level1"><h1>迁移指南</h1><section id="从-jest-迁移"class="level2"><h2>从 Jest 迁移</h2><p>Vitest 设计了与 Jest 兼容的 API ，方便你从 Jest 的迁移尽可能简单。尽管做出了这些努力，你仍然可能会遇到以下差异：<p><strong>全局变量作为默认值</strong><p>Jest 默认启用<a href="https://jestjs.io/zh-Hans/docs/api">全局 API</a>。然而 Vitest 没有。你既可以通过 <a href="../config.html#globals"><code>globals</code> 配置选项</a>启用全局 API，也可以通过更新你的代码以便使用来自 <code>vitest</code> 模块的导入。<p>如果你决定禁用全局 API，请注意像 <a href="https://testing-library.com/"><code>testing-library</code></a> 这样的通用库不会自动运行 DOM <a href="https://testing-library.com/docs/svelte-testing-library/api/#cleanup">cleanup</a>。<p><strong>模拟模块</strong><p>在 Jest 中模拟一个模块时，工厂参数的返回值是默认导出。在 Vitest 中，工厂参数必须返回一个明确定义了每个导出的对象。例如，下面的 <code>jest.mock</code> 必须更新如下：<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> jest.mock('./some-path', () => 'hello')
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> vi.mock('./some-path', () => ({
</span><span class="token prefix inserted">+</span><span class="token line">   default: 'hello',
</span><span class="token prefix inserted">+</span><span class="token line"> })</span></span></code></pre><p>有关更深入的详细描述，请参阅 <a href="../api.html#vi-mock"><code>vi.mock</code> api section</a>。<p><strong>自动模拟行为</strong><p>区别于 Jest，在 <code>&#x3C;root>/__mocks__</code> 中的模拟模块只有在 <code>vi.mock()</code> 被调用时才会加载。如果你需要它们像在 Jest 中一样，在每个测试中都被模拟，你可以在 <a href="../config.html#setupfiles"><code>setupFiles</code></a> 中模拟它们。<p><strong>导入模拟包的原始版本</strong><p>如果你只需要模拟一个 package 的部分功能，你可能之前使用了 Jest 的 <code>requireActual</code> 函数。在 Vitest 中，你应该将这些调用替换为 <code>vi.importActual</code>。<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> const { cloneDeep } = jest.requireActual('lodash/cloneDeep')
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> const { cloneDeep } = await vi.importActual('lodash/cloneDeep')</span></span></code></pre><p><strong>Jasmine API</strong><p>Jest 导出各种 <a href="https://jasmine.github.io/"><code>jasmine</code></a> 全局 API (例如 <code>jasmine.any()</code> )。任何此类实例都需要迁移成 <a href="/api/">Vitest 的对应 API </a>。<p><strong>测试环境</strong><p>如果之前没有设置，Vitest 会像 Jest 一样，把 <code>NODE_ENV</code> 设置为 <code>test</code>。 Vitest 也有一个 <code>JEST_WORKER_ID</code> 的对应项，是 <code>VITEST_WORKER_ID</code>，所以如果你依赖它，不要忘记重命名它。<p>如果你想修改测试环境，你会在 Jest 中使用 <a href="https://jestjs.io/docs/jest-object#jestreplacepropertyobject-propertykey-value">replaceProperty API</a>，你可以使用 <a href="https://cn.vitest.dev/api/vi.html#vi-stubenv">vi.stubEnv</a> 也可以在 Vitest 中执行此操作。<p><strong>回调完成</strong><p>从 Vitest v0.10.0 开始，声明测试的回调样式被弃用。 你可以重写它们以使用 <code>async</code>/<code>await</code> 函数，或者使用 Promise 来模仿回调样式。<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> it('should work', (done) => {
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> it('should work', () => new Promise(done => {
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   // ...
</span><span class="token prefix unchanged"> </span><span class="token line">   done()
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> })
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> }))</span></span></code></pre><p><strong>钩子</strong><p><code>beforeAll</code>/<code>beforeEach</code> 钩子可能在 Vitest 的 <a href="../api.html#setup-and-teardown">teardown 函数</a>中返回。因此，如果它们返回的不是 <code>undefined</code> 或 <code>null</code>，你可能需要重写你的钩子声明：<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> beforeEach(() => setActivePinia(createTestingPinia()))
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> beforeEach(() => { setActivePinia(createTestingPinia()) })</span></span></code></pre><p><strong>类型</strong><p>Vitest 没有在 <code>Vi</code> 命名空间上导出很多类型，它的存在主要是为了与匹配器兼容，因此你可能需要直接从 <code>vitest</code> 导入类型，而不是依赖 <code>Vi</code> 命名空间：<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> let fn: jest.Mock&#x3C;string, [string]>
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> import type { Mock } from 'vitest'
</span><span class="token prefix inserted">+</span><span class="token line"> let fn: Mock&#x3C;[string], string></span></span></code></pre><p>此外，Vitest 将 <code>Args</code> 类型作为第一个参数，而不是 <code>Returns</code>，正如你在 diff 中看到的那样。<p><strong>定时器</strong><p>Vitest 不支持 jest 的传统计时器。<p><strong>Vue 快照</strong><p>如果你以前在 vue-cli preset 中使用 Jest，那么这不是一个 Jest 独有的新特性。你可能需要安装 <a href="https://github.com/eddyerburgh/jest-serializer-vue"><code>jest-serializer-vue</code></a> 包，然后在 <a href="../config.html#setupfiles">setupFiles</a> 中配置：<p><code>vite.config.js</code><pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vite'</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">setupFiles</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'./tests/unit/setup.js'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>tests/unit/setup.js</code><pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports">vueSnapshotSerializer</span> <span class="token keyword module">from</span> <span class="token string">'jest-serializer-vue'</span>
expect<span class="token punctuation">.</span><span class="token method function property-access">addSnapshotSerializer</span><span class="token punctuation">(</span>vueSnapshotSerializer<span class="token punctuation">)</span></code></pre><p>否则你的快照将出现大量的 <code>"</code> 字符。 <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>