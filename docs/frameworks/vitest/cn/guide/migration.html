<!doctype html><html lang="cn"><meta charset="utf-8"><title>迁移指南 | 指南</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="outline"content="deep"><link rel="stylesheet"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="迁移指南"><h1 id="迁移指南">迁移指南</h1><section class="level2"aria-labelledby="从-vitest-0346-迁移"><h2 id="从-vitest-0346-迁移">从 Vitest 0.34.6 迁移</h2><section class="level3"aria-labelledby="最低要求"><h3 id="最低要求">最低要求</h3><p>Vitest 1.0 需要 Vite 5.0 和 Node.js 18 或更高版本。<p>所有 <code>@vitest/*</code> 子软件包都需要 Vitest 1.0 版本。</section><section class="level3"aria-labelledby="snapshots-更新-3961"><h3 id="snapshots-更新-3961">Snapshots 更新 <a href="https://github.com/vitest-dev/vitest/pull/3961">#3961</a></h3><p>快照中的引号不再转义，即使字符串只有一行，所有快照也都使用回车引号 (`)。<ol><li>引号不再转义：</ol><pre class="language-diff"><code class="language-diff">expect({ foo: 'bar' }).toMatchInlineSnapshot(`
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> Object {
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    \\"foo\\": \\"bar\\",
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    "foo": "bar",
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> }
</span></span>`)</code></pre><ol start="2"><li>单行快照现在使用"`"引号，而不是"'"：</ol><pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> expect('some string').toMatchInlineSnapshot('"some string"')
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> expect('some string').toMatchInlineSnapshot(`"some string"`)</span></span></code></pre><p>对 <code>@vitest/snapshot</code> 也有<a href="https://github.com/vitest-dev/vitest/pull/4076">修改</a>。如果不直接使用它，则无需做任何更改。<ul><li>我们不再需要扩展 <code>SnapshotClient</code> 以覆盖 <code>equalityCheck</code> 方法：只需在启动实例时将其作为 <code>isEqual</code> 传递即可。<li><code>client.setTest</code> 更名为 <code>client.startCurrentRun</code><li><code>client.resetCurrent</code> 更名为 <code>client.finishCurrentRun</code> 。</ul></section><section class="level3"aria-labelledby="pools-标准化-4172"><h3 id="pools-标准化-4172">Pools 标准化 <a href="https://github.com/vitest-dev/vitest/pull/4172">#4172</a></h3><p>We removed a lot of configuration options to make it easier to configure the runner to your needs. Please, have a look at migration examples if you rely on <code>--threads</code> or other related flags.<p>我们删除了大量配置选项，以便根据需要配置运行程序。如果你已经使用了 <code>--threads</code> 或其他相关标记，请查看迁移示例。<ul><li><code>--threads</code> 现在是 <code>--pool=threads</code><li><code>--no-threads</code> 现在是 <code>--pool=forks</code><li><code>--single-thread</code> 现在是 <code>--poolOptions.threads.singleThread</code><li><code>--experimental-vm-threads</code> 现在是 <code>--pool=vmThreads</code><li><code>--experimental-vm-worker-memory-limit</code> 现在是 <code>--poolOptions.vmThreads.memoryLimit</code><li><code>--isolate</code> 现在是 <code>--poolOptions.&#x3C;pool-name>.isolate</code> 和 <code>browser.isolate</code><li><code>test.maxThreads</code> 现在是 <code>test.poolOptions.&#x3C;pool-name>.maxThreads</code><li><code>test.minThreads</code> 现在是 <code>test.poolOptions.&#x3C;pool-name>.minThreads</code><li><code>test.useAtomics</code> 现在是 <code>test.poolOptions.&#x3C;pool-name>.useAtomics</code><li><code>test.poolMatchGlobs.child_process</code> 现在是 <code>test.poolMatchGlobs.forks</code><li><code>test.poolMatchGlobs.experimentalVmThreads</code> 现在是 <code>test.poolMatchGlobs.vmThreads</code></ul><pre class="language-diff"><code class="language-diff">{
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> scripts: {
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    "test": "vitest --no-threads"
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    // For identical behaviour:
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    "test": "vitest --pool forks --poolOptions.forks.singleFork"
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    // Or multi parallel forks:
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    "test": "vitest --pool forks"
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> }
</span></span>}</code></pre><pre class="language-diff"><code class="language-diff">{
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> scripts: {
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    "test": "vitest --experimental-vm-threads"
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    "test": "vitest --pool vmThreads"
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> }
</span></span>}</code></pre><pre class="language-diff"><code class="language-diff">{
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> scripts: {
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    "test": "vitest --isolate false"
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    "test": "vitest --poolOptions.threads.isolate false"
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> }
</span></span>}</code></pre><pre class="language-diff"><code class="language-diff">{
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> scripts: {
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    "test": "vitest --no-threads --isolate false"
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    "test": "vitest --pool forks --poolOptions.forks.isolate false"
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> }
</span></span>}</code></pre></section><section class="level3"aria-labelledby="coverage-的变化-4265-4442"><h3 id="coverage-的变化-4265-4442">Coverage 的变化 <a href="https://github.com/vitest-dev/vitest/pull/4265">#4265</a>, <a href="https://github.com/vitest-dev/vitest/pull/4442">#4442</a></h3><p>选项 <code>coverage.all</code> 现在默认启用。这意味着，所有符合 <code>coverage.include</code> 模式的项目文件都将被处理，即使它们未被执行。<p>更改了覆盖阈值 API 的形状，现在它支持使用 glob 模式为特定文件指定阈值：<pre class="language-diff"><code class="language-diff">export default defineConfig({
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> test: {
</span><span class="token prefix unchanged"> </span><span class="token line">   coverage: {
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">      perFile: true,
</span><span class="token prefix deleted">-</span><span class="token line">      thresholdAutoUpdate: true,
</span><span class="token prefix deleted">-</span><span class="token line">      100: true,
</span><span class="token prefix deleted">-</span><span class="token line">      lines: 100,
</span><span class="token prefix deleted">-</span><span class="token line">      functions: 100,
</span><span class="token prefix deleted">-</span><span class="token line">      branches: 100,
</span><span class="token prefix deleted">-</span><span class="token line">      statements: 100,
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      thresholds: {
</span><span class="token prefix inserted">+</span><span class="token line">        perFile: true,
</span><span class="token prefix inserted">+</span><span class="token line">        autoUpdate: true,
</span><span class="token prefix inserted">+</span><span class="token line">        100: true,
</span><span class="token prefix inserted">+</span><span class="token line">        lines: 100,
</span><span class="token prefix inserted">+</span><span class="token line">        functions: 100,
</span><span class="token prefix inserted">+</span><span class="token line">        branches: 100,
</span><span class="token prefix inserted">+</span><span class="token line">        statements: 100,
</span><span class="token prefix inserted">+</span><span class="token line">      }
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   }
</span><span class="token prefix unchanged"> </span><span class="token line"> }
</span></span>})</code></pre></section><section class="level3"aria-labelledby="mock-类型-4400"><h3 id="mock-类型-4400">Mock 类型 <a href="https://github.com/vitest-dev/vitest/pull/4400">#4400</a></h3><p>删除了一些类型，改用 Jest 风格的 "Mock "命名。<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> import { EnhancedSpy, SpyInstance } from 'vitest'
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> import { MockInstance } from 'vitest'</span></span></code></pre><blockquote>`SpyInstance` 已被弃用，取而代之的是 `MockInstance` ，并会在下一个主要版本中移除。</blockquote></section><section class="level3"aria-labelledby="timer-mocks-3925"><h3 id="timer-mocks-3925">Timer mocks <a href="https://github.com/vitest-dev/vitest/pull/3925">#3925</a></h3><p><code>vi.useFakeTimers()</code> 不再自动模拟 <a href="https://nodejs.org/api/process.html#processnexttickcallback-args"><code>process.nextTick</code></a> 。 仍然可以通过使用 <code>vi.useFakeTimers({ toFake: ['nextTick'] })</code> 明确指定来模拟 <code>process.nextTick</code>。<p>但是，在使用 <code>--pool=forks</code> 时，无法模拟 <code>process.nextTick</code> 。如果需要模拟 <code>process.nextTick</code> ，请使用不同的 <code>--pool</code> 选项。</section></section><section class="level2"aria-labelledby="从-jest-迁移"><h2 id="从-jest-迁移">从 Jest 迁移</h2><p>Vitest 设计了与 Jest 兼容的 API ，方便你从 Jest 的迁移尽可能简单。尽管做出了这些努力，你仍然可能会遇到以下差异：<section class="level3"aria-labelledby="全局变量作为默认值"><h3 id="全局变量作为默认值">全局变量作为默认值</h3><p>Jest 默认启用<a href="https://jestjs.io/zh-Hans/docs/api">全局 API</a>。然而 Vitest 没有。你既可以通过 <a href="../config.html#globals"><code>globals</code> 配置选项</a>启用全局 API，也可以通过更新你的代码以便使用来自 <code>vitest</code> 模块的导入。<p>如果你决定禁用全局 API，请注意像 <a href="https://testing-library.com/"><code>testing-library</code></a> 这样的通用库不会自动运行 DOM <a href="https://testing-library.com/docs/svelte-testing-library/api/#cleanup">cleanup</a>。</section><section class="level3"aria-labelledby="模拟模块"><h3 id="模拟模块">模拟模块</h3><p>在 Jest 中模拟一个模块时，工厂参数的返回值是默认导出。在 Vitest 中，工厂参数必须返回一个明确定义了每个导出的对象。例如，下面的 <code>jest.mock</code> 必须更新如下：<pre class="language-ts"><code class="language-ts">jest<span class="token punctuation">.</span><span class="token method function property-access">mock</span><span class="token punctuation">(</span><span class="token string">'./some-path'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token string">'hello'</span><span class="token punctuation">)</span> <span class="token comment">// [!code --]</span>
vi<span class="token punctuation">.</span><span class="token method function property-access">mock</span><span class="token punctuation">(</span><span class="token string">'./some-path'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// [!code ++]</span>
  <span class="token keyword module">default</span><span class="token operator">:</span> <span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token comment">// [!code ++]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [!code ++]</span></code></pre><p>有关更深入的详细描述，请参阅 <a href="../api.html#vi-mock"><code>vi.mock</code> api section</a>。</section><section class="level3"aria-labelledby="自动模拟行为"><h3 id="自动模拟行为">自动模拟行为</h3><p>区别于 Jest，在 <code>&#x3C;root>/__mocks__</code> 中的模拟模块只有在 <code>vi.mock()</code> 被调用时才会加载。如果你需要它们像在 Jest 中一样，在每个测试中都被模拟，你可以在 <a href="../config.html#setupfiles"><code>setupFiles</code></a> 中模拟它们。</section><section class="level3"aria-labelledby="导入模拟包的原始版本"><h3 id="导入模拟包的原始版本">导入模拟包的原始版本</h3><p>如果你只需要模拟一个 package 的部分功能，你可能之前使用了 Jest 的 <code>requireActual</code> 函数。在 Vitest 中，你应该将这些调用替换为 <code>vi.importActual</code>。<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> <span class="token punctuation">{</span> cloneDeep <span class="token punctuation">}</span> <span class="token operator">=</span> jest<span class="token punctuation">.</span><span class="token method function property-access">requireActual</span><span class="token punctuation">(</span><span class="token string">'lodash/cloneDeep'</span><span class="token punctuation">)</span> <span class="token comment">// [!code --]</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> cloneDeep <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword control-flow">await</span> vi<span class="token punctuation">.</span><span class="token method function property-access">importActual</span><span class="token punctuation">(</span><span class="token string">'lodash/cloneDeep'</span><span class="token punctuation">)</span> <span class="token comment">// [!code ++]</span></code></pre><p><strong>Jasmine API</strong><p>Jest 导出各种 <a href="https://jasmine.github.io/"><code>jasmine</code></a> 全局 API (例如 <code>jasmine.any()</code> )。任何此类实例都需要迁移成 <a href="/api/">Vitest 的对应 API </a>。</section><section class="level3"aria-labelledby="测试环境"><h3 id="测试环境">测试环境</h3><p>如果之前没有设置，Vitest 会像 Jest 一样，把 <code>NODE_ENV</code> 设置为 <code>test</code>。 Vitest 也有一个 <code>JEST_WORKER_ID</code> 的对应项，是 <code>VITEST_WORKER_ID</code>，所以如果你依赖它，不要忘记重命名它。</section><section class="level3"aria-labelledby="属性替换"><h3 id="属性替换">属性替换</h3><p>如果你想修改测试环境，你会在 Jest 中使用 <a href="https://jestjs.io/docs/jest-object#jestreplacepropertyobject-propertykey-value">replaceProperty API</a>，你可以使用 <a href="https://cn.vitest.dev/api/vi.html#vi-stubenv">vi.stubEnv</a> 或者 <a href="/api/vi#vi-spyon"><code>vi.spyOn</code></a> 也可以在 Vitest 中执行此操作。</section><section class="level3"aria-labelledby="回调完成"><h3 id="回调完成">回调完成</h3><p>从 Vitest v0.10.0 开始，声明测试的回调样式被弃用。 你可以重写它们以使用 <code>async</code>/<code>await</code> 函数，或者使用 Promise 来模仿回调样式。<pre class="language-text"><code class="language-text">it('should work', (done) => {  // [!code --]
it('should work', () => new Promise(done => { // [!code ++]
  // ...
  done()
}) // [!code --]
})) // [!code ++]</code></pre></section><section class="level3"aria-labelledby="钩子"><h3 id="钩子">钩子</h3><p><code>beforeAll</code>/<code>beforeEach</code> 钩子可能在 Vitest 的 <a href="../api.html#setup-and-teardown">teardown 函数</a>中返回。因此，如果它们返回的不是 <code>undefined</code> 或 <code>null</code>，你可能需要重写你的钩子声明：<pre class="language-ts"><code class="language-ts"><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setActivePinia</span><span class="token punctuation">(</span><span class="token function">createTestingPinia</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [!code --]</span>
<span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">setActivePinia</span><span class="token punctuation">(</span><span class="token function">createTestingPinia</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// [!code ++]</span></code></pre><p>在 Jest 中，钩子是按顺序调用的（一个接一个）。默认情况下，Vitest 并行运行钩子。要使用 Jest 的行为，请更新 <a href="../config.html#sequence-hooks"><code>sequence.hooks</code></a> 选项：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    sequence<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// [!code ++]</span>
      hooks<span class="token operator">:</span> <span class="token string">'list'</span><span class="token punctuation">,</span> <span class="token comment">// [!code ++]</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// [!code ++]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section><section class="level3"aria-labelledby="类型"><h3 id="类型">类型</h3><p>Vitest 没有等效于 <code>jest</code> 的命名空间，因此你需要直接从 <code>Vitest</code> 导入类型：<pre class="language-ts"><code class="language-ts"><span class="token comment">// [!code --]</span>
<span class="token keyword module">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">Mock</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">'vitest'</span> <span class="token keyword">let</span> fn<span class="token operator">:</span> jest<span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">Mock</span></span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token comment">// [!code ++]</span>
<span class="token keyword">let</span> fn<span class="token operator">:</span> <span class="token maybe-class-name">Mock</span><span class="token operator">&#x3C;</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token operator">></span> <span class="token comment">// [!code ++]</span></code></pre><p>此外，Vitest 将 <code>Args</code> 类型作为第一个参数，而不是 <code>Returns</code>，正如你在 diff 中看到的那样。</section><section class="level3"aria-labelledby="定时器"><h3 id="定时器">定时器</h3><p>如果你之前在测试中使用了 jest.setTimeout ，那么你需要迁移到 Vitest 中的<code>vi.setConfig</code> :<pre class="language-ts"><code class="language-ts">jest<span class="token punctuation">.</span><span class="token method function property-access">setTimeout</span><span class="token punctuation">(</span><span class="token number">5_000</span><span class="token punctuation">)</span> <span class="token comment">// [!code --]</span>
vi<span class="token punctuation">.</span><span class="token method function property-access">setConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span> testTimeout<span class="token operator">:</span> <span class="token number">5_000</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// [!code ++]</span></code></pre></section><section class="level3"aria-labelledby="vue-快照"><h3 id="vue-快照">Vue 快照</h3><p>如果你以前在 vue-cli preset 中使用 Jest，那么这不是一个 Jest 独有的新特性。你可能需要安装 <a href="https://github.com/eddyerburgh/jest-serializer-vue"><code>jest-serializer-vue</code></a> 包，然后在 <a href="../config.html#setupfiles">setupFiles</a> 中配置：<p><code>vite.config.js</code><pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vite'</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">setupFiles</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'./tests/unit/setup.js'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>tests/unit/setup.js</code><pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports">vueSnapshotSerializer</span> <span class="token keyword module">from</span> <span class="token string">'jest-serializer-vue'</span>
expect<span class="token punctuation">.</span><span class="token method function property-access">addSnapshotSerializer</span><span class="token punctuation">(</span>vueSnapshotSerializer<span class="token punctuation">)</span></code></pre><p>否则你的快照将出现大量的 <code>"</code> 字符。 <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section></section>