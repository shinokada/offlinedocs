<!doctype html><html lang="cn"><meta charset="utf-8"><title>配置索引</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="outline"content="deep"><link rel="stylesheet"type="text/css"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="配置索引"><h1 id="配置索引">配置索引</h1><section class="level2"aria-labelledby="配置"><h2 id="配置">配置</h2><p><code>vitest</code> 将读取你的项目根目录的 <code>vite.config.ts</code> 文件以匹配插件并设置为你的 Vite 应用。如果想使用不同的配置进行测试，你可以：<ul><li>创建 <code>vitest.config.ts</code>，优先级更高。<li>将 <code>--config</code> 选项传递给 CLI，例如 <code>vitest --config ./path/to/vitest.config.ts</code> 。<li>在 <code>defineConfig</code> 中使用 <code>process.env.VITEST</code> 或 <code>mode</code> 属性（默认值是 <code>test</code>）在 <code>vite.config.ts</code> 中有条件的应用不同的配置。</ul><p>要配置 <code>vitest</code> 本身，请在你的 Vite 配置中添加 <code>test</code> 属性。如果你使用 <code>vite</code> 的 <code>defineConfig</code> 你还需要将 <a href="https://www.tslang.cn/docs/handbook/triple-slash-directives.html#-reference-types-">三斜线指令</a> 写在配置文件的顶部。<p>使用 <code>vite</code> 的 <code>defineConfig</code> 可以参考下面的格式：<pre class="language-ts"><code class="language-ts"><span class="token comment">/// &#x3C;reference types="vitest" /></span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vite'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// ... Specify options here.</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>使用 <code>vitest/config</code> 中的 <code>defineConfig</code> 可以参考下面的格式：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// ... Specify options here.</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>如果有需要，你可以获取到 Vitest 的默认选项以扩展它们：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> configDefaults<span class="token punctuation">,</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    exclude<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token spread operator">...</span>configDefaults<span class="token punctuation">.</span><span class="token property-access">exclude</span><span class="token punctuation">,</span> <span class="token string">'packages/template/*'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section><section class="level2"aria-labelledby="选项"><h2 id="选项">选项</h2><p>当使用单独的 <code>vitest.config.js</code> 时，如果需要，你还可以从另一个配置文件扩展 Vite 的选项：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig<span class="token punctuation">,</span> mergeConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>
<span class="token keyword module">import</span> <span class="token imports">viteConfig</span> <span class="token keyword module">from</span> <span class="token string">'./vite.config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">mergeConfig</span><span class="token punctuation">(</span>
  viteConfig<span class="token punctuation">,</span>
  <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    test<span class="token operator">:</span> <span class="token punctuation">{</span>
      exclude<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'packages/template/*'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span></code></pre><blockquote>`mergeConfig` helper 在 Vitest v0.30.0 之后可用。如果使用低版本，你可以直接从 `vite` 导入它。</blockquote><p>如果你的 vite 配置被定义为一个函数，可以像这样定义配置：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig<span class="token punctuation">,</span> mergeConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>
<span class="token keyword module">import</span> <span class="token imports">viteConfig</span> <span class="token keyword module">from</span> <span class="token string">'./vite.config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span>configEnv <span class="token arrow operator">=></span>
  <span class="token function">mergeConfig</span><span class="token punctuation">(</span>
    <span class="token function">viteConfig</span><span class="token punctuation">(</span>configEnv<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      test<span class="token operator">:</span> <span class="token punctuation">{</span>
        exclude<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'packages/template/*'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">)</span></code></pre></section><section class="level2"aria-labelledby="配置选项"><h2 id="配置选项">配置选项</h2><blockquote>除了以下选项，你还可以使用 [Vite](https://vitejs.dev/config/) 中的任何配置选项。 例如，`define` 定义全局变量，或 `resolve.alias` 定义别名。<p><em>此处列出的</em>所有选项都位于配置中的 <code>test</code> 属性上：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    exclude<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></blockquote><blockquote>所有不支持在 [workspace](/guide/workspace) 项目配置中的配置选项都会有<nonprojectoption>标记。</nonprojectoption></blockquote><section class="level3"aria-labelledby="include"><h3 id="include">include</h3><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值:</strong> <code>['**/*.{test,spec}.?(c|m)[jt]s?(x)']</code></ul><p>匹配包含测试文件的 glob 规则。<blockquote>NOTE 使用 coverage 时，Vitest 会自动将测试文件的 `include` 模式添加到 coverage 的默认 `exclude` 模式中。请参见 [`coverage.exclude`](#coverage-exclude)。</blockquote></section><section class="level3"aria-labelledby="exclude"><h3 id="exclude">exclude</h3><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值:</strong> <code>['**/node_modules/**', '**/dist/**', '**/cypress/**', '**/.{idea,git,cache,output,temp}/**', '**/{karma,rollup,webpack,vite,vitest,jest,ava,babel,nyc,cypress,tsup,build}.config.*']</code></ul><p>匹配排除测试文件的 glob 规则。</section><section class="level3"aria-labelledby="includesource"><h3 id="includesource">includeSource</h3><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值:</strong> <code>[]</code></ul><p>包括源代码中的测试文件的通配符。<p>当定义时，Vitest 将运行所有包含 <code>import.meta.vitest</code> 的匹配文件。</section><section class="level3"aria-labelledby="server"><h3 id="server">server</h3><ul><li><strong>类型:</strong> <code>{ sourcemap?, deps?, ... }</code><li><strong>版本:</strong> Since Vitest 0.34.0</ul><p>Vite-Node 服务端选项。<section class="level4"aria-labelledby="serversourcemap"><h4 id="serversourcemap">server.sourcemap</h4><ul><li><strong>类型:</strong> <code>'inline' | boolean</code><li><strong>默认值:</strong> <code>'inline'</code></ul><p>通过内联方式注入到模块。</section><section class="level4"aria-labelledby="serverdebug"><h4 id="serverdebug">server.debug</h4><ul><li><strong>类型:</strong> <code>{ dumpModules?, loadDumppedModules? }</code></ul><p>Vite-Node 调试器选项。</section><section class="level4"aria-labelledby="serverdebugdumpmodules"><h4 id="serverdebugdumpmodules">server.debug.dumpModules</h4><ul><li><strong>类型:</strong> <code>boolean | string</code></ul><p>将转换后的模块转储到文件系统。传递字符串将转储到指定路径。</section><section class="level4"aria-labelledby="serverdebugloaddumppedmodules"><h4 id="serverdebugloaddumppedmodules">server.debug.loadDumppedModules</h4><ul><li><strong>类型:</strong> <code>boolean</code></ul><p>不管是否存在，就从文件系统中读取转储的模块。通过修改文件系统的转储结果对于调试会有帮助。</section><section class="level4"aria-labelledby="serverdeps"><h4 id="serverdeps">server.deps</h4><ul><li><strong>类型:</strong> <code>{ external?, inline?, ... }</code></ul><p>对依赖关系进行内联或外联的处理</section><section class="level4"aria-labelledby="serverdepsexternal"><h4 id="serverdepsexternal">server.deps.external</h4><ul><li><strong>类型:</strong> <code>(string | RegExp)[]</code><li><strong>默认值:</strong> <code>[/\/node_modules\//]</code></ul><p>外部化（Externalize）意味着 Vite 将绕过原生 Node 的包。外部化依赖不会应用于 Vite 的转换器和解析器，因此它们不支持重新加载时的 HMR。 <code>node_modules</code> 下的所有包都被外部化。<p>这些选项支持在 <code>node_modules</code> 中编写的包名称或在 <a href="#deps-moduledirectories"><code>deps.moduleDirectories</code></a> 中指定的包名称。例如，位于 <code>packages/some-name</code> 内的包<code>@company/some-name</code> 应指定为 <code>some-name</code>，并且 <code>packages</code> 应包含在 <code>deps.moduleDirectories</code> 中。基本上，Vitest 总是检查文件路径，而不是实际的包名称。<p>如果成功匹配，Vitest 会在 <em>file path</em> 上调用它，而不是包名称。</section><section class="level4"aria-labelledby="serverdepsinline"><h4 id="serverdepsinline">server.deps.inline</h4><ul><li><strong>类型:</strong> <code>(string | RegExp)[] | true</code><li><strong>默认值:</strong> <code>[]</code></ul><p>Vite 将处理内联模块。这可能有助于处理以 ESM 格式传送 <code>.js</code> 的包（Node 无法处理）。<p>如果设置为 <code>true</code>，则每个依赖项都将被内联。默认情况下，将内联 <a href="https://cn.vitejs.dev/guide/ssr.html#ssr-externals"><code>ssr.noExternal</code></a> 中指定的所有依赖项。</section><section class="level4"aria-labelledby="serverdepsfallbackcjs"><h4 id="serverdepsfallbackcjs">server.deps.fallbackCJS</h4><ul><li><strong>类型</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>当依赖项是有效的 ESM 包时，尝试根据路径猜测 cjs 版本。如果依赖项是有错误的 ESM 文件，这可能会有所帮助。<p>如果包在 ESM 和 CJS 模式下具有不同的逻辑，这可能会导致一些错位。</section><section class="level4"aria-labelledby="serverdepscachedir"><h4 id="serverdepscachedir">server.deps.cacheDir</h4><ul><li><strong>类型</strong> <code>string</code><li><strong>默认值</strong>: <code>'node_modules/.vite'</code></ul><p>保存缓存文件的目录。</section></section><section class="level3"aria-labelledby="deps"><h3 id="deps">deps</h3><ul><li><strong>类型:</strong> <code>{ optimizer?, ... }</code></ul><p>处理依赖关系解析。<section class="level4"aria-labelledby="deps-optimizer"><h4 id="deps-optimizer">deps.optimizer</h4><ul><li><strong>类型:</strong> <code>{ ssr?, web? }</code><li><strong>参考:</strong> <a href="https://cn.vitejs.dev/config/dep-optimization-options.html">依赖优化选项</a></ul><p>启用依赖优化。如果你有很多测试，这可能会提高它们的性能。<p>当 Vitest 遇到 <code>include</code> 中列出的外部库时，它将使用 esbuild 打包到单个文件中，并作为整个模块导入。这很好，原因如下：<ul><li>导入大量导入的包很昂贵。通过将它们捆绑到一个文件中，我们可以节省大量时间<li>导入 UI 库很昂贵，因为它们并不意味着在 Node.js 中运行<li>你的 <code>alias</code> 配置现在在捆绑包中得到处理<li>测试中的代码更接近于它在浏览器中的运行方式</ul><p>请注意，只有 <code>deps.experimentalOptimizer?.[mode].include</code> 选项中的包会被捆绑（一些插件会自动填充它，比如 Svelte）。 你可以在 <a href="/config/dep-optimization-options">Vite</a> 文档中阅读有关可用选项的更多信息。默认情况，Vitest 的 <code>experimentalOptimizer.web</code> 用在 <code>jsdom</code> 和 <code>happy-dom</code>, 在 <code>node</code> 和 <code>edge</code> 环境下使用 <code>experimentalOptimizer.ssr</code>，但这可以在 <a href="#transformmode"><code>transformMode</code></a> 进行配置。<p>此选项还继承了你的 <code>optimizeDeps</code> 配置（对于 web 环境， Vitest 将会继承 <code>optimizeDeps</code>，对于 ssr 则是 <code>ssr.optimizeDeps</code>）。如果你在 <code>deps.experimentalOptimizer</code> 中重新定义 <code>include</code>/<code>exclude</code>/<code>entries</code> 选项，它将在运行测试时覆盖你的 <code>optimizeDeps</code>。如果它们在 <code>exclude</code> 中配置，Vitest 会自动从 <code>include</code> 中删除相同的选项。<blockquote>你将无法编辑用于调试的 `node_modules` 代码，因为该代码实际上位于你的 `cacheDir` 或 `test.cache.dir` 目录中。如果你想使用 `console.log` 语句进行调试，请直接编辑它或使用 `deps.experimentalOptimizer?.[mode].force` 选项强制重新绑定。</blockquote></section><section class="level4"aria-labelledby="depsoptimizermodeenabled"><h4 id="depsoptimizermodeenabled">deps.optimizer.{mode}.enabled</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>启用依赖优化。<blockquote>此选项仅适用于 Vite 4.3.2 及更高版本。</blockquote></section><section class="level4"aria-labelledby="depsweb-0342"><h4 id="depsweb-0342">deps.web<badge type="info">0.34.2+</badge></h4></section><section class="level4"aria-labelledby="depsweb"><h4 id="depsweb">deps.web</h4><ul><li><strong>类型:</strong> <code>{ transformAssets?, ... }</code></ul><p>当转换模式设置为 <code>web</code> 时应用于外部文件的选项。默认情况下，<code>jsdom</code> 和 <code>happy-dom</code> 使用 <code>web</code> 模式，而 <code>node</code> 和 <code>edge</code> 环境使用 <code>ssr</code> 转换模式，因此这些选项不会影响这些环境中的文件。<p>通常，<code>node_modules</code> 内的文件是外部化的，但这些选项也会影响 <a href="#server-deps-external"><code>server.deps.external</code></a> 中的文件。</section><section class="level4"aria-labelledby="depswebtransformassets"><h4 id="depswebtransformassets">deps.web.transformAssets</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>true</code></ul><p>Vitest 是否应该像 Vite 在浏览器中一样处理静态资源（.png、.svg、.jpg 等）文件并解析它们。<p>如果未指定查询，此模块将具有等同于静态资源路径的默认导出。<blockquote>目前，此选项适用于 [`vmThreads`](#vmthreads) 和 [`vmForks`](#vmForks) 池。</blockquote></section><section class="level4"aria-labelledby="depswebtransformcss"><h4 id="depswebtransformcss">deps.web.transformCss</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>true</code></ul><p>Vitest 是否应该像 Vite 在浏览器中一样处理静态资源（.css, .scss, .sass 等）文件并解析它们。<p>如果使用 <a href="#css"><code>css</code></a> 选项禁用 CSS 文件，则此选项只会消除 <code>ERR_UNKNOWN_FILE_EXTENSION</code> 错误。<blockquote>目前，此选项仅适用于 [`vmThreads`](#vmthreads) 和 [`vmForks`](#vmForks) 池。</blockquote></section><section class="level4"aria-labelledby="depswebtransformglobpattern"><h4 id="depswebtransformglobpattern">deps.web.transformGlobPattern</h4><ul><li><strong>类型:</strong> <code>RegExp | RegExp[]</code><li><strong>默认值:</strong> <code>[]</code></ul><p>正则表达式模式匹配应转换的外部文件。<p>默认情况下，<code>node_modules</code> 内的文件是外部化的，不会被转换，除非它是 CSS 或静态资源，并且相应的选项不会被禁用。<blockquote>目前，此选项仅适用于 [`vmThreads`](#vmthreads) 和 [`vmForks`](#vmForks) 池。</blockquote></section><section class="level4"aria-labelledby="depsinteropdefault"><h4 id="depsinteropdefault">deps.interopDefault</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>true</code></ul><p>将 CJS 模块的默认值视为命名导出。某些依赖项仅捆绑 CJS 模块，不使用命名导出，Node.js 可以在使用 <code>import</code> 语法而不是 <code>require</code> 导入包时对其进行静态分析。使用命名导出在 Node 环境中导入此类依赖项时，你将看到此错误：<pre class="language-text"><code class="language-text">import { read } from 'fs-jetpack';
         ^^^^
SyntaxError: Named export 'read' not found. The requested module 'fs-jetpack' is a CommonJS module, which may not support all module.exports as named exports.
CommonJS modules can always be imported via the default export.</code></pre><p>Vitest 不进行静态分析，并且不会在你运行代码之前失败，因此当该特性禁用时你在运行测试时很可能会看到此错误：<pre class="language-text"><code class="language-text">TypeError: createAsyncThunk is not a function
TypeError: default is not a function</code></pre><p>如果你使用的是绕过此 Node.js 限制的捆绑器或转译器，则可以手动启用此选项。默认情况下，当 <code>environment</code> 为 <code>node</code> 时，Vitest 假定你使用的是 Node ESM 语法，并且不关心命名导出。</section><section class="level4"aria-labelledby="depsmoduledirectories"><h4 id="depsmoduledirectories">deps.moduleDirectories</h4><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值</strong>: <code>['node_modules']</code></ul><p>配置一个视为模块目录的目录列表。此配置选项会影响 <a href="/api/vi#vi-mock"><code>vi.mock</code></a> 的行为：当未提供工厂并且你正在模拟的路径与 <code>moduleDirectories</code> 值之一匹配时，Vitest 将尝试 通过在项目的 <a href="../config.html#root">root</a> 中查找 <code>__mocks__</code> 文件夹来解析 mock。<p>此选项还将影响在外部化依赖项时是否应将文件视为模块。默认情况下，Vitest 绕过 Vite 转换步骤导入带有原生 Node.js 的外部模块。<p>设置此选项将 <em>覆盖</em> 默认值，如果你仍希望搜索 <code>node_modules</code> 包包括它连同任何其他选项：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    deps<span class="token operator">:</span> <span class="token punctuation">{</span>
      moduleDirectories<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'node_modules'</span><span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span><span class="token string">'../../packages'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section></section><section class="level3"aria-labelledby="runner"><h3 id="runner">runner</h3><ul><li><strong>类型</strong>: <code>VitestRunnerConstructor</code><li><strong>默认值</strong>: <code>node</code>, when running tests, or <code>benchmark</code>, when running benchmarks</ul><p>自定义测试运行程序的路径。这是一项高级功能，应与自定义库运行器一起使用。你可以在 <a href="/advanced/runner">文档</a> 中阅读更多相关信息。</section><section class="level3"aria-labelledby="benchmark"><h3 id="benchmark">benchmark</h3><ul><li><strong>类型:</strong> <code>{ include?, exclude?, ... }</code></ul><p>运行 <code>vitest bench</code> 时使用的选项。<section class="level4"aria-labelledby="benchmarkinclude"><h4 id="benchmarkinclude">benchmark.include</h4><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值:</strong> <code>['**/*.{bench,benchmark}.?(c|m)[jt]s?(x)']</code></ul><p>匹配包含基准测试文件的 glob 规则。</section><section class="level4"aria-labelledby="benchmarkexclude"><h4 id="benchmarkexclude">benchmark.exclude</h4><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值:</strong> <code>['node_modules', 'dist', '.idea', '.git', '.cache']</code></ul><p>匹配排除基准测试文件的 glob 规则。</section><section class="level4"aria-labelledby="benchmarkincludesource"><h4 id="benchmarkincludesource">benchmark.includeSource</h4><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值:</strong> <code>[]</code></ul><p>匹配包含内联基准测试文件的 glob 规则。此选项类似于 <a href="#includesource"><code>includeSource</code></a>。<p>定义后，Vitest 将运行所有匹配的文件，其中包含 <code>import.meta.vitest</code>。</section><section class="level4"aria-labelledby="benchmarkreporters"><h4 id="benchmarkreporters">benchmark.reporters</h4><ul><li><strong>类型:</strong> <code>Arrayable&#x3C;BenchmarkBuiltinReporters | Reporter></code><li><strong>默认值:</strong> <code>'default'</code></ul><p>用于定义输出的自定义报告器。它可以包含一个或多个内置报告名称、报告实例和(或)自定义报告的路径。</section><section class="level4"aria-labelledby="benchmarkoutputfile"><h4 id="benchmarkoutputfile">benchmark.outputFile</h4><p>已弃用，尝试使用 <code>benchmark.outputJson</code>。</section><section class="level4"aria-labelledby="benchmark-outputJson"><h4 id="benchmark-outputJson">benchmark.outputJson</h4><ul><li><strong>类型:</strong> <code>string | undefined</code><li><strong>默认值:</strong> <code>undefined</code></ul><p>存储基准测试结果的文件路径，可用于稍后的 <code>--compare</code> 选项。<p>例如:<pre class="language-sh"><code class="language-sh"># save main branch's result
git checkout main
vitest bench --outputJson main.json

# change a branch and compare against main
git checkout feature
vitest bench --compare main.json</code></pre></section><section class="level4"aria-labelledby="benchmark-compare"><h4 id="benchmark-compare">benchmark.compare</h4><ul><li><strong>类型:</strong> <code>string | undefined</code><li><strong>默认值:</strong> <code>undefined</code></ul><p>与当前运行结果进行比较的以前基准结果的文件路径。</section></section><section class="level3"aria-labelledby="alias"><h3 id="alias">alias</h3><ul><li><strong>类型:</strong> <code>Record&#x3C;string, string> | Array&#x3C;{ find: string | RegExp, replacement: string, customResolver?: ResolverFunction | ResolverObject }></code></ul><p>在测试内部运行时定义自定义别名。它们将与来自 <code>resolve.alias</code> 的别名合并。<blockquote>Vitest 使用 Vite SSR 基元来运行测试，这有[一定的缺陷](https://vitejs.dev/guide/ssr.html#ssr-externals)。<ol><li>别名只影响由<a href="#server-deps-inline">inlined</a>模块直接用<code>import</code>关键字导入的模块（默认情况下所有源代码都是内联的）。<li>Vitest 不支持对 <code>require</code> 调用进行别名。<li>如果您要别名外部依赖（例如，<code>react</code> -> <code>preact</code>），您可能需要别名实际的 <code>node_modules</code> 包，以使其适用于外部依赖。<a href="https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias">Yarn</a> 和 <a href="https://pnpm.io/aliases/">pnpm</a> 都支持通过 <code>npm:</code> 前缀进行别名。</ol></blockquote></section><section class="level3"aria-labelledby="globals"><h3 id="globals">globals</h3><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code><li><strong>命令行终端:</strong> <code>--globals</code>, <code>--globals=false</code></ul><p>默认情况下，<code>vitest</code> 不显式提供全局 API。如果你更倾向于使用类似 jest 中的全局 API，可以将 <code>--globals</code> 选项传递给 CLI 或在配置中添加 <code>globals: true</code>。<pre class="language-ts"><code class="language-ts"><span class="token comment">// vitest.config.ts</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    globals<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>为了可以让全局 API 支持 TypeScript，请将 <code>vitest/globals</code> 添加到 <code>tsconfig.json</code> 中的 <code>types</code> 选项中<pre class="language-json"><code class="language-json"><span class="token comment">// tsconfig.json</span>
<span class="token punctuation">{</span>
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"types"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"vitest/globals"</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>如果你已经在项目中使用 <a href="https://github.com/antfu/unplugin-auto-import"><code>unplugin-auto-import</code></a>，你也可以直接用它来自动导入这些 API。<pre class="language-ts"><code class="language-ts"><span class="token comment">// vitest.config.ts</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">AutoImport</span></span> <span class="token keyword module">from</span> <span class="token string">'unplugin-auto-import/vite'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token function"><span class="token maybe-class-name">AutoImport</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      imports<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'vitest'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      dts<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// generate TypeScript declaration</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section><section class="level3"aria-labelledby="environment"><h3 id="environment">environment</h3><ul><li><strong>类型:</strong> <code>'node' | 'jsdom' | 'happy-dom' | 'edge-runtime' | string</code><li><strong>默认值:</strong> <code>'node'</code><li><strong>命令行终端:</strong> <code>--environment=&#x3C;env></code></ul><p>Vitest 中的默认测试环境是一个 Node.js 环境。如果你正在构建 Web 端应用，你可以使用 <a href="https://github.com/jsdom/jsdom"><code>jsdom</code></a> 或 <a href="https://github.com/capricorn86/happy-dom"><code>happy-dom</code></a> 这种类似浏览器(browser-like)的环境来替代 Node.js。 如果你正在构建边缘计算函数，你可以使用 <a href="https://edge-runtime.vercel.app/packages/vm"><code>edge-runtime</code></a> 环境<blockquote>你还可以使用 [浏览器模式](/guide/browser/) 在浏览器中运行集成或单元测试，而无需模拟环境。</blockquote><p>你可以通过在文件顶部添加包含 <code>@vitest-environment</code> 的文档块或注释，为某个测试文件中的所有测试指定环境：<p>文档块格式:<pre class="language-js"><code class="language-js"><span class="token doc-comment comment">/**
 * <span class="token keyword">@vitest-environment</span> jsdom
 */</span>

<span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'use jsdom in this test file'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>
  <span class="token function">expect</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">not</span><span class="token punctuation">.</span><span class="token method function property-access">toBeNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>注释格式:<pre class="language-js"><code class="language-js"><span class="token comment">// @vitest-environment happy-dom</span>

<span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'use happy-dom in this test file'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>
  <span class="token function">expect</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">not</span><span class="token punctuation">.</span><span class="token method function property-access">toBeNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>为了与 Jest 兼容，还存在一个配置 <code>@jest-environment</code>：<pre class="language-js"><code class="language-js"><span class="token doc-comment comment">/**
 * <span class="token keyword">@jest-environment</span> jsdom
 */</span>

<span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'use jsdom in this test file'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>
  <span class="token function">expect</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">not</span><span class="token punctuation">.</span><span class="token method function property-access">toBeNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>如果使用 <a href="#isolate"><code>--isolate=false</code></a> 运行 Vitest，测试将按以下顺序运行：<code>node</code>、<code>jsdom</code>、<code>happy-dom</code>、<code>edge-runtime</code>、<code>custom environments</code>。也就是说，具有相同环境的每个测试都会被分组，但仍会按顺序运行。<p>从 0.23.0 开始，你还可以定义自定义环境。 当使用非内置环境时，Vitest 将尝试加载包 <code>vitest-environment-${name}</code>。 该包应导出一个具有 <code>Environment</code> 属性的对象：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">Environment</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">'vitest'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Environment</span><span class="token operator">></span><span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'custom'</span><span class="token punctuation">,</span>
  transformMode<span class="token operator">:</span> <span class="token string">'ssr'</span><span class="token punctuation">,</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// custom setup</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
      <span class="token function">teardown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// called after all tests with this env have been run</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></code></pre><p>Vitest 还通过 <code>vitest/environments</code> 入口导出 <code>builtinEnvironments</code>，以防你只想扩展它。 你可以在 <a href="/guide/environment">测试环境指南</a> 中阅读有关扩展测试环境的更多信息。<blockquote>jsdom 环境变量导出了等同于当前[JSDOM](https://github.com/jsdom/jsdom) 的 `jsdom` 全局变量实例。如果你想让 TypeScript 识别它，可以在使用此环境时将 `vitest/jsdom`添加到 `tsconfig.json` 中：<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"types"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"vitest/jsdom"</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></blockquote></section><section class="level3"aria-labelledby="environmentoptions"><h3 id="environmentoptions">environmentOptions</h3><ul><li><strong>类型:</strong> <code>Record&#x3C;'jsdom' | string, unknown></code><li><strong>默认值:</strong> <code>{}</code></ul><p>这些选项被传递给当前 <a href="#environment"><code>environment</code></a> 的 <code>setup</code> 方法。 默认情况下，如果你将其用作测试环境，则只能配置 JSDOM 选项。</section><section class="level3"aria-labelledby="environmentmatchglobs"><h3 id="environmentmatchglobs">environmentMatchGlobs</h3><ul><li><strong>类型:</strong> <code>[string, EnvironmentName][]</code><li><strong>默认值:</strong> <code>[]</code></ul><p>基于 globs 自动匹配执行环境。将使用第一个匹配项。<p>例如：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    environmentMatchGlobs<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token comment">// all tests in tests/dom will run in jsdom</span>
      <span class="token punctuation">[</span><span class="token string">'tests/dom/**'</span><span class="token punctuation">,</span> <span class="token string">'jsdom'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token comment">// all tests in tests/ with .edge.test.ts will run in edge-runtime</span>
      <span class="token punctuation">[</span><span class="token string">'**/*.edge.test.ts'</span><span class="token punctuation">,</span> <span class="token string">'edge-runtime'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section><section class="level3"aria-labelledby="poolmatchglobs"><h3 id="poolmatchglobs">poolMatchGlobs</h3><ul><li><strong>类型:</strong> <code>[string, 'threads' | 'forks' | 'vmThreads' | 'vmForks' | 'typescript'][]</code><li><strong>默认值:</strong> <code>[]</code></ul><p>基于 globs 模式来匹配运行池中的测试并运行，将使用第一个匹配项。<p>例如:<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    poolMatchGlobs<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token comment">// all tests in "worker-specific" directory will run inside a worker as if you enabled `--pool=threads` for them,</span>
      <span class="token punctuation">[</span><span class="token string">'**/tests/worker-specific/**'</span><span class="token punctuation">,</span> <span class="token string">'threads'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token comment">// run all tests in "browser" directory in an actual browser</span>
      <span class="token punctuation">[</span><span class="token string">'**/tests/browser/**'</span><span class="token punctuation">,</span> <span class="token string">'browser'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token comment">// all other tests will run based on "browser.enabled" and "threads" options, if you didn't specify other globs</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section><section class="level3"aria-labelledby="update"><h3 id="update">update<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code><li><strong>命令行终端:</strong> <code>-u</code>, <code>--update</code>, <code>--update=false</code></ul><p>更新快照文件。这将更新所有更改的快照并删除过时的快照。</section><section class="level3"aria-labelledby="watch"><h3 id="watch">watch<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>!process.env.CI</code><li><strong>命令行终端:</strong> <code>-w</code>, <code>--watch</code>, <code>--watch=false</code></ul><p>启动监听模式</section><section class="level3"aria-labelledby="root"><h3 id="root">root</h3><ul><li><strong>类型:</strong> <code>string</code><li><strong>命令行终端:</strong> <code>-r &#x3C;path></code>, <code>--root=&#x3C;path></code></ul><p>项目的根目录</section><section class="level3"aria-labelledby="dir"><h3 id="dir">dir</h3><ul><li><strong>类型:</strong> <code>string</code><li><strong>命令行终端:</strong> <code>--dir=&#x3C;path></code><li><strong>默认值:</strong> same as <code>root</code></ul><p>扫描测试文件的基本目录。如果您的根目录覆盖整个项目，您可以指定此选项以加快测试发现速度</section><section class="level3"aria-labelledby="reporters"><h3 id="reporters">reporters<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型:</strong> <code>Reporter | Reporter[]</code><li><strong>默认值:</strong> <code>'default'</code><li><strong>命令行终端:</strong> <code>--reporter=&#x3C;name></code>, <code>--reporter=&#x3C;name1> --reporter=&#x3C;name2></code></ul><p>用于输出的自定义 reporters 。 Reporters 可以是 <a href="https://github.com/vitest-dev/vitest/blob/main/packages/vitest/src/node/types/reporter.ts">一个 Reporter 实例</a> 或选择内置的 reporters 字符串：<ul><li><code>'default'</code> - 当他们经过测试套件<li><code>'basic'</code> - 给定一个类似于 CI 中的默认报告实例<li><code>'verbose'</code> - 保持完整的任务树可见<li><code>'dot'</code> - 将每个任务显示为一个点<li><code>'junit'</code> - JUnit XML 报告器（你可以使用 <code>VITEST_JUNIT_SUITE_NAME</code> 环境变量配置 <code>test suites</code> 标签名称）<li><code>'json'</code> - 给出一个简单的 JSON 总结<li><code>'html'</code> - 根据 <a href="/guide/ui"><code>@vitest/ui</code></a> 输出 HTML 报告<li><code>'hanging-process'</code> - 如果 Vitest 无法安全退出进程，则显示挂起进程列表。 这可能是一个复杂的操作，只有在 Vitest 始终无法退出进程时才启用它<li>自定义报告的路径 (例如 <code>'./path/to/reporter.ts'</code>, <code>'@scope/reporter'</code>)</ul></section><section class="level3"aria-labelledby="outputfile"><h3 id="outputfile">outputFile<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型:</strong> <code>string | Record&#x3C;string, string></code><li><strong>命令行终端:</strong> <code>--outputFile=&#x3C;path></code>, <code>--outputFile.json=./path</code></ul><p>当指定 <code>--reporter=json</code>、<code>--reporter=html</code> 或 <code>--reporter=junit</code> 时，将测试结果写入一个文件。通过提供对象而不是字符串，你可以在使用多个报告器时定义单独的输出。</section><section class="level3"aria-labelledby="pool-pool"><h3 id="pool-pool">pool<nonprojectoption>{#pool}</nonprojectoption></h3><ul><li><strong>类型:</strong> <code>'threads' | 'forks' | 'vmThreads' | 'vmForks'</code><li><strong>默认值:</strong> <code>'forks'</code><li><strong>命令行终端:</strong> <code>--pool=threads</code></ul><p>用于运行测试的线程池。<section class="level4"aria-labelledby="threads"><h4 id="threads">threads<nonprojectoption></nonprojectoption></h4><p>使用 <a href="https://github.com/tinylibs/tinypool">tinypool</a>（一个轻量级的 <a href="https://github.com/piscinajs/piscina">Piscina</a> 分支）来启用多线程。当使用线程时，你无法使用与进程相关的 API，如 <code>process.chdir()</code> 。一些使用原生语言编写的库，如 Prisma 、<code>bcrypt</code> 和 <code>canvas</code> ，在多线程环境下可能会遇到问题并导致段错误。在这些情况下，建议使用 <code>forks</code> 线程池。</section><section class="level4"aria-labelledby="forks"><h4 id="forks">forks<nonprojectoption></nonprojectoption></h4><p>与 <code>threads</code> 线程池类似，但是使用 <code>child_process</code> 而不是 <code>worker_threads</code> ，通过 <a href="https://github.com/tinylibs/tinypool">tinypool</a> 实现。与 <code>threads</code> 线程池相比，测试与主进程之间的通信速度不够快。在 <code>forks</code> 线程池中，可以使用与进程相关的 API ，如 <code>process.chdir()</code> 。</section><section class="level4"aria-labelledby="vmthreads"><h4 id="vmthreads">vmThreads<nonprojectoption></nonprojectoption></h4><p>在 <code>threads</code> 线程池中使用<a href="https://nodejs.org/api/vm.html"> VM 上下文</a>（在受限环境中）运行测试。<p>这样可以加快测试速度，但是当运行<a href="https://github.com/nodejs/node/issues/37648"> ESM 代码</a>时，VM 模块可能不稳定。你的测试可能会<a href="https://github.com/nodejs/node/issues/33439">泄漏内存</a>，为了解决这个问题，考虑手动编辑 <a href="#pooloptions-vmthreads-memorylimit"><code>poolOptions.vmThreads.memoryLimit</code></a> 的值。<blockquote>在沙箱中运行代码有一些优点（测试速度更快），但也有许多缺点。<ul><li>原生模块中的全局变量，例如（<code>fs</code>、<code>path</code>等），与测试环境中存在的全局变量不同。因此，这些原生模块引发的任何错误都将引用与代码中使用的错误构造函数不同的错误构造函数：</ul><pre class="language-ts"><code class="language-ts"><span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>
  fs<span class="token punctuation">.</span><span class="token method function property-access">writeFileSync</span><span class="token punctuation">(</span><span class="token string">'/doesnt exist'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword control-flow">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>err <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token known-class-name class-name">Error</span></span><span class="token punctuation">)</span> <span class="token comment">// false</span>
<span class="token punctuation">}</span></code></pre><ul><li>导入 ES 模块会无限期地缓存它们，如果你有很多上下文（测试文件），这会导致内存泄漏。Node.js 中没有可以清除该缓存的 API。<li>在沙盒环境中访问全局变量<a href="https://github.com/nodejs/node/issues/31658">需要更长的时间</a>。</ul><p>使用此选项时请注意这些问题。Vitest 团队无法解决我们这边的任何问题。</blockquote></section><section class="level4"aria-labelledby="vmforks"><h4 id="vmforks">vmForks<nonprojectoption></nonprojectoption></h4><p>与 <code>vmThreads</code> 池类似，但通过 <a href="https://github.com/tinylibs/tinypool">tinypool</a> 使用 <code>child_process</code> 而不使用 <code>worker_threads</code>。测试与主进程之间的通信速度虽然不如 <code>vmThreads</code> 快。但进程相关的 API（如 <code>process.chdir()</code> ）在 <code>vmForks</code> 中却可以使用。请注意，这个与 <code>vmThreads</code> 中列出的池具有相同的缺陷。</section></section><section class="level3"aria-labelledby="pooloptions-pooloptions"><h3 id="pooloptions-pooloptions">poolOptions<nonprojectoption>{#pooloptions}</nonprojectoption></h3><ul><li><strong>类型:</strong> <code>Record&#x3C;'threads' | 'forks' | 'vmThreads' | 'vmForks', {}></code><li><strong>默认值:</strong> <code>{}</code></ul><section class="level4"aria-labelledby="pooloptionsthreads"><h4 id="pooloptionsthreads">poolOptions.threads</h4><p><code>threads</code> 池的选项。<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    poolOptions<span class="token operator">:</span> <span class="token punctuation">{</span>
      threads<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token comment">// Threads related options here</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><section class="level5"aria-labelledby="pooloptionsthreadsmaxthreads"><h5 id="pooloptionsthreadsmaxthreads">poolOptions.threads.maxThreads<nonprojectoption></nonprojectoption></h5><ul><li><strong>类型:</strong> <code>number | string</code><li><strong>默认值:</strong> <em>available CPUs</em></ul><p>最大线程数或百分比。还可以使用<code>VITEST_MAX_THREADS</code>环境变量进行设置。</section><section class="level5"aria-labelledby="pooloptionsthreadsminthreads"><h5 id="pooloptionsthreadsminthreads">poolOptions.threads.minThreads<nonprojectoption></nonprojectoption></h5><ul><li><strong>类型:</strong> <code>number | string</code><li><strong>默认值:</strong> <em>available CPUs</em></ul><p>最小线程数或百分比。还可以使用<code>VITEST_MIN_THREADS</code>环境变量进行设置。</section><section class="level5"aria-labelledby="pooloptionsthreadssinglethread"><h5 id="pooloptionsthreadssinglethread">poolOptions.threads.singleThread</h5><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>在单个工作线程内使用相同的环境运行所有测试。 这将禁用内置模块隔离（我们的源代码或 <a href="#server-deps-inline">inlined</a> 代码仍将针对每个测试重新评估），但可以提高测试性能。<blockquote>尽管此选项将强制测试一个接一个地运行，但此选项与 Jest 的 `--runInBand` 不同。 Vitest 使用工作线程不仅可以并行运行测试，还可以提供隔离。 通过禁用此选项，你的测试将按顺序运行，但在相同的全局上下文中，因此你必须自己提供隔离。<p>如果你依赖全局状态（前端框架通常这样做）或者你的代码依赖于为每个测试单独定义的环境，这可能会导致各种问题。 但可以提高你的测试速度（最多快 3 倍），这不一定依赖于全局状态，也可以轻松绕过它。</blockquote></section><section class="level5"aria-labelledby="pooloptionsthreadsuseatomics"><h5 id="pooloptionsthreadsuseatomics">poolOptions.threads.useAtomics<nonprojectoption></nonprojectoption></h5><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>使用 Atomics 来同步线程。<p>这在某些情况下可以提高性能，但可能会导致旧 Node 版本中出现段错误。</section><section class="level5"aria-labelledby="pooloptionsthreadsisolate"><h5 id="pooloptionsthreadsisolate">poolOptions.threads.isolate</h5><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>true</code></ul><p>隔离每个测试文件的环境。</section><section class="level5"aria-labelledby="pooloptionsthreadsexecargv"><h5 id="pooloptionsthreadsexecargv">poolOptions.threads.execArgv<nonprojectoption></nonprojectoption></h5><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值:</strong> <code>[]</code></ul><p>在线程中向 <code>node</code> 传递附加参数。更多信息，具体可以浏览 <a href="https://nodejs.org/docs/latest/api/cli.html">Command-line API | Node.js</a> 。<blockquote>使用时要小心，因为某些选项（如--prof、--title）可能会导致 worker 崩溃。具体信息可以浏览 https://github.com/nodejs/node/issues/41103。</blockquote></section></section><section class="level4"aria-labelledby="pooloptionsforks"><h4 id="pooloptionsforks">poolOptions.forks</h4><p><code>forks</code> 池的选项。<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    poolOptions<span class="token operator">:</span> <span class="token punctuation">{</span>
      forks<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token comment">// Forks related options here</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><section class="level5"aria-labelledby="pooloptionsforksmaxforks"><h5 id="pooloptionsforksmaxforks">poolOptions.forks.maxForks<nonprojectoption></nonprojectoption></h5><ul><li><strong>类型:</strong> <code>number | string</code><li><strong>默认值:</strong> <em>available CPUs</em></ul><p>最大分支数量或百分比。</section><section class="level5"aria-labelledby="pooloptionsforksminforks"><h5 id="pooloptionsforksminforks">poolOptions.forks.minForks<nonprojectoption></nonprojectoption></h5><ul><li><strong>类型:</strong> <code>number | string</code><li><strong>默认值:</strong> <em>available CPUs</em></ul><p>最小分支数量或百分比。</section><section class="level5"aria-labelledby="pooloptionsforksisolate"><h5 id="pooloptionsforksisolate">poolOptions.forks.isolate</h5><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>true</code></ul><p>隔离每个测试文件的环境。</section><section class="level5"aria-labelledby="pooloptionsforkssinglefork"><h5 id="pooloptionsforkssinglefork">poolOptions.forks.singleFork</h5><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>在单个子进程中使用相同的环境运行所有测试。 这将禁用内置模块隔离（你的源代码或 <a href="#server-deps-inline">inlined</a> 代码仍将针对每个测试重新评估），但可以提高测试性能。<blockquote>尽管此选项将强制测试一个接一个地运行，但此选项与 Jest 的 `--runInBand` 不同。 Vitest 使用子进程不仅可以并行运行测试，还可以提供隔离。 通过禁用此选项，你的测试将按顺序运行，但在相同的全局上下文中，因此你必须自己提供隔离。<p>如果你依赖全局状态（前端框架通常这样做）或者你的代码依赖于为每个测试单独定义的环境，这可能会导致各种问题。 但可以提高你的测试速度（最多快 3 倍），这不一定依赖于全局状态，也可以轻松绕过它。</blockquote></section><section class="level5"aria-labelledby="pooloptionsforksexecargv"><h5 id="pooloptionsforksexecargv">poolOptions.forks.execArgv<nonprojectoption></nonprojectoption></h5><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值:</strong> <code>[]</code></ul><p>向子进程中的 <code>node</code> 进程传递附加参数。更多信息，详细信息可以浏览 <a href="https://nodejs.org/docs/latest/api/cli.html">Command-line API | Node.js</a> 。<blockquote>使用时要小心，因为某些选项（如 --prof、--title ）可能会导致 worker 崩溃。详细信息可以浏览 https://github.com/nodejs/node/issues/41103。</blockquote></section></section><section class="level4"aria-labelledby="pooloptionsvmthreads"><h4 id="pooloptionsvmthreads">poolOptions.vmThreads</h4><p><code>vmThreads</code> 池的选项。<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    poolOptions<span class="token operator">:</span> <span class="token punctuation">{</span>
      vmThreads<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token comment">// VM threads related options here</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><section class="level5"aria-labelledby="pooloptionsvmthreadsmaxthreads"><h5 id="pooloptionsvmthreadsmaxthreads">poolOptions.vmThreads.maxThreads<nonprojectoption></nonprojectoption></h5><ul><li><strong>类型:</strong> <code>number | string</code><li><strong>默认:</strong> <em>available CPUs</em></ul><p>最大线程数或百分比。还可以使用<code>VITEST_MAX_THREADS</code>环境变量进行设置。</section><section class="level5"aria-labelledby="pooloptionsvmthreadsminthreads"><h5 id="pooloptionsvmthreadsminthreads">poolOptions.vmThreads.minThreads<nonprojectoption></nonprojectoption></h5><ul><li><strong>类型:</strong> <code>number | string</code><li><strong>默认值:</strong> <em>available CPUs</em></ul><p>最小线程数或百分比。还可以使用<code>VITEST_MIN_THREADS</code>环境变量进行设置。</section><section class="level5"aria-labelledby="pooloptionsvmthreadsmemorylimit"><h5 id="pooloptionsvmthreadsmemorylimit">poolOptions.vmThreads.memoryLimit<nonprojectoption></nonprojectoption></h5><ul><li><strong>类型:</strong> <code>string | number</code><li><strong>命令行终端:</strong> <code>1 / CPU Cores</code></ul><p>指定工作线程被回收之前的内存限制。该值在很大程度上取决于你的运行环境，因此最好手动指定它，而不是依赖默认值。<blockquote>该实现基于 Jest 的 [`workerIdleMemoryLimit`](https://jestjs.io/docs/configuration#workeridlememorylimit-numberstring)。<p>可以通过多种不同的方式指定限制，无论结果是什么，<code>Math.floor</code> 都用于将其转换为整数值：<ul><li><code>&#x3C;= 1</code> - 该值假定为系统内存的百分比。所以 0.5 将 worker 的内存限制设置为系统总内存的一半。<li><code>\> 1</code> - 假设是固定字节值。由于之前的规则，如果你想要 1 字节的值（我不知道为什么），你可以使用 1.1。<li>有单位时<ul><li><code>50%</code> - 如上，占系统总内存的百分比<li><code>100KB</code>, <code>65MB</code>, 等 - 用单位表示固定的内存限制<ul><li><code>K</code> / <code>KB</code> - Kilobytes (x1000)<li><code>KiB</code> - Kibibytes (x1024)<li><code>M</code> / <code>MB</code> - Megabytes - <code>MiB</code> - Mebibytes<li><code>G</code> / <code>GB</code> - Gigabytes - <code>GiB</code> - Gibibytes</ul></ul></ul></blockquote><blockquote>由于系统内存报告不正确，基于百分比的内存限制[在 Linux CircleCI 上不起作用](https://github.com/jestjs/jest/issues/11956#issuecomment-1212925677)。</blockquote></section><section class="level5"aria-labelledby="pooloptionsvmthreadsuseatomics"><h5 id="pooloptionsvmthreadsuseatomics">poolOptions.vmThreads.useAtomics<nonprojectoption></nonprojectoption></h5><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>使用 Atomics 来同步线程。<p>这在某些情况下可以提高性能，但可能会在旧的 Node 版本中抛出错误。</section><section class="level5"aria-labelledby="pooloptionsvmthreadsexecargv"><h5 id="pooloptionsvmthreadsexecargv">poolOptions.vmThreads.execArgv<nonprojectoption></nonprojectoption></h5><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值:</strong> <code>[]</code></ul><p>将附加参数传递给虚拟机上下文中的 <code>node</code> 进程。更多信息，详细信息可以浏览 <a href="https://nodejs.org/docs/latest/api/cli.html">Command-line API | Node.js</a> 。<blockquote>使用时要小心，因为某些选项（如 --prof、--title ）可能会导致 worker 崩溃。详细信息可以浏览 https://github.com/nodejs/node/issues/41103。</blockquote></section></section><section class="level4"aria-labelledby="pooloptionsvmforks"><h4 id="pooloptionsvmforks">poolOptions.vmForks<nonprojectoption></nonprojectoption></h4><p><code>vmForks</code> 池的选项<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    poolOptions<span class="token operator">:</span> <span class="token punctuation">{</span>
      vmForks<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token comment">// VM forks related options here</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><section class="level5"aria-labelledby="pooloptionsvmforksmaxforks"><h5 id="pooloptionsvmforksmaxforks">poolOptions.vmForks.maxForks<nonprojectoption></nonprojectoption></h5><ul><li><strong>类型:</strong> <code>number | string</code><li><strong>默认值:</strong> <em>available CPUs</em></ul><p>最大线程数或百分比。也可以使用 <code>VITEST_MAX_FORKS</code> 环境变量。</section><section class="level5"aria-labelledby="pooloptionsvmforksminforks"><h5 id="pooloptionsvmforksminforks">poolOptions.vmForks.minForks<nonprojectoption></nonprojectoption></h5><ul><li><strong>类型:</strong> <code>number | string</code><li><strong>默认值:</strong> <em>available CPUs</em></ul><p>最小线程数或百分比。也可以使用 <code>VITEST_MIN_FORKS</code> 环境变量。</section><section class="level5"aria-labelledby="pooloptionsvmforksmemorylimit"><h5 id="pooloptionsvmforksmemorylimit">poolOptions.vmForks.memoryLimit<nonprojectoption></nonprojectoption></h5><ul><li><strong>类型:</strong> <code>string | number</code><li><strong>默认值:</strong> <code>1 / CPU Cores</code></ul><p>指定 Worker 被回收前的内存限制。该值在很大程度上取决于环境，因此最好手动指定，而不是依赖默认值。该值的计算方法查看 <a href="#pooloptions-vmthreads-memorylimit"><code>poolOptions.vmThreads.memoryLimit</code></a></section><section class="level5"aria-labelledby="pooloptionsvmforksexecargv"><h5 id="pooloptionsvmforksexecargv">poolOptions.vmForks.execArgv<nonprojectoption></nonprojectoption></h5><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值:</strong> <code>[]</code></ul><p>将附加参数传递给虚拟机上下文中的 <code>node</code> 进程。更多信息，查看 <a href="https://nodejs.org/docs/latest/api/cli.html">Command-line API | Node.js</a> 了解更多详情。。<blockquote>使用时要小心，因为某些选项（如 `--prof` 、`--title`）可能会导致 worker 崩溃。查看 https://github.com/nodejs/node/issues/41103 了解更多详情。</blockquote></section></section></section><section class="level3"aria-labelledby="fileparallelism-fileparallelism"><h3 id="fileparallelism-fileparallelism">fileParallelism<nonprojectoption>{#fileparallelism}</nonprojectoption></h3><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>true</code><li><strong>命令行终端:</strong> <code>--no-file-parallelism</code>, <code>--fileParallelism=false</code></ul><p>所有测试文件应该并行运行。将其设置为 <code>false</code> 将覆盖 <code>maxWorkers</code> 和 <code>minWorkers</code> 选项为 <code>1</code>。<blockquote>此选项不会影响在同一文件中运行的测试。如果你想并行运行这些程序，请在[description](../api.html#describe-concurrent)或通过[a config](#sequence-concurrent) 上使用 `concurrent` 选项。</blockquote></section><section class="level3"aria-labelledby="maxworkers-maxworkers"><h3 id="maxworkers-maxworkers">maxWorkers<nonprojectoption>{#maxworkers}</nonprojectoption></h3><ul><li><strong>类型:</strong> <code>number | string</code></ul><p>运行测试时设置的最大工作线程数或百分比。<code>poolOptions。｛threads，vmThreads｝.maxThreads</code>/<code>poolOptions.forks.maxForks</code> 具有更高的优先级。</section><section class="level3"aria-labelledby="minworkers-minworkers"><h3 id="minworkers-minworkers">minWorkers<nonprojectoption>{#minworkers}</nonprojectoption></h3><ul><li><strong>类型:</strong> <code>number | string</code></ul><p>运行测试时设置的最小工作线程数或百分比。<code>poolOptions.{threads,vmThreads}.minThreads</code>/<code>poolOptions.forks.minForks</code> 具有更高的优先级。</section><section class="level3"aria-labelledby="testtimeout"><h3 id="testtimeout">testTimeout</h3><ul><li><strong>类型:</strong> <code>number</code><li><strong>默认值:</strong> <code>5_000</code> in Node.js, <code>15_000</code> if <code>browser.enabled</code> is <code>true</code><li><strong>命令行终端:</strong> <code>--test-timeout=5000</code>, <code>--testTimeout=5000</code></ul><p>测试的默认超时时间（以毫秒为单位）。</section><section class="level3"aria-labelledby="hooktimeout"><h3 id="hooktimeout">hookTimeout</h3><ul><li><strong>类型:</strong> <code>number</code><li><strong>默认值:</strong> <code>10_000</code> in Node.js, <code>30_000</code> if <code>browser.enabled</code> is <code>true</code><li><strong>命令行终端:</strong> <code>--hook-timeout=10000</code>, <code>--hookTimeout=10000</code></ul><p>钩子(hook)的默认超时时间（以毫秒为单位）。</section><section class="level3"aria-labelledby="teardowntimeout"><h3 id="teardowntimeout">teardownTimeout<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型:</strong> <code>number</code><li><strong>默认值:</strong> <code>1000</code><li><strong>命令行终端:</strong> <code>--teardown-timeout=5000</code>, <code>--teardownTimeout=5000</code></ul><p>Vitest 关闭时等待关闭的默认超时时间，以毫秒为单位</section><section class="level3"aria-labelledby="silent"><h3 id="silent">silent<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code><li><strong>命令行终端:</strong> <code>--silent</code>, <code>--silent=false</code></ul><p>静默模式下启动测试。</section><section class="level3"aria-labelledby="setupfiles"><h3 id="setupfiles">setupFiles</h3><ul><li><strong>类型:</strong> <code>string | string[]</code></ul><p>setup 文件的路径。它们将运行在每个测试文件之前。</section>info 提示 更改配置文件将触发所有测试的重新运行。<p>你可以在全局设置文件中使用 <code>process.env.VITEST_POOL_ID</code>（类似整数的字符串）来区分不同的线程。<blockquote>请注意，如果运行 [`--isolate=false`](#isolate) ，这个配置文件将在全局范围内多次运行。这意味着每次测试前都要访问同一个全局对象，因此请确保不要重复做同一件事。</blockquote><p>比如，你可能依赖于一个全局变量：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> config <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@some-testing-lib'</span>

<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>globalThis<span class="token punctuation">.</span><span class="token property-access">defined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  config<span class="token punctuation">.</span><span class="token property-access">plugins</span> <span class="token operator">=</span> <span class="token punctuation">[</span>myCoolPlugin<span class="token punctuation">]</span>
  <span class="token function">computeHeavyThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  globalThis<span class="token punctuation">.</span><span class="token property-access">defined</span> <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>

<span class="token comment">// hooks are reset before each suite</span>
<span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

globalThis<span class="token punctuation">.</span><span class="token property-access">resetBeforeEachTest</span> <span class="token operator">=</span> <span class="token boolean">true</span></code></pre><section class="level3"aria-labelledby="provide-210-provide"><h3 id="provide-210-provide">provide<version>2.1.0</version>{#provide}</h3><ul><li><strong>Type:</strong> <code>Partial&#x3C;ProvidedContext></code></ul><p>使用 <code>inject</code> 方法定义可在测试中访问的值。</section>code-group ```ts [vitest.config.js] import { defineConfig } from 'vitest/config'<p>export default defineConfig({ test: { provide: { API_KEY: '123', }, }, })<pre class="language-text"><code class="language-text">```ts [my.test.js]
import { expect, inject, test } from 'vitest'

test('api key is defined', () => {
  expect(inject('API_KEY')).toBe('123')
})</code></pre><blockquote>属性必须是字符串，值必须是[可序列化](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types)，因为该对象将在不同进程之间传输。</blockquote><blockquote>如果使用的是 TypeScript，则需要增强 `ProvidedContext` 类型，以实现类型安全访问：<pre class="language-ts"><code class="language-ts"><span class="token comment">// vitest.shims.d.ts</span>

<span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'vitest'</span> <span class="token punctuation">{</span>
  <span class="token keyword module">export</span> <span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">ProvidedContext</span></span> <span class="token punctuation">{</span>
    <span class="token constant">API_KEY</span><span class="token operator">:</span> <span class="token builtin">string</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// mark this file as a module so augmentation works correctly</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span><span class="token punctuation">}</span></span></code></pre></blockquote><section class="level3"aria-labelledby="globalsetup"><h3 id="globalsetup">globalSetup</h3><ul><li><strong>类型:</strong> <code>string | string[]</code></ul><p>全局的 setup 文件的路径，相对于项目的根目录。<p>全局的 setup 文件可以导出命名函数 <code>setup</code> 和 <code>teardown</code> 或返回拆卸函数的 <code>default</code> 函数（<a href="https://github.com/vitest-dev/vitest/blob/main/test/global-setup/vitest.config.ts">示例</a>)。</section>info 提示 可以存在多个 globalSetup。setup 和 teardown 依次执行，而 teardown 则以相反的顺序执行。<blockquote>全局设置只有在至少有一个正在运行的测试时才运行。这意味着在测试文件更改后，全局安装程序可能会在监视模式下开始运行（测试文件将等待全局安装程序完成后再运行）。<p>请注意，全局设置在不同的全局范围内运行，因此你的测试无法访问此处定义的变量。悬停，从 1.0.0 开始，你可以通过 <a href="#provide"><code>provide</code></a> 方法将可序列化数据传递给测试：</blockquote>code-group<pre class="language-js"><code class="language-js"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token keyword">function</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> provide <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">provide</span><span class="token punctuation">(</span><span class="token string">'wsPort'</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">GlobalSetupContext</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">'vitest/node'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token keyword">function</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">{</span> provide <span class="token punctuation">}</span><span class="token operator">:</span> <span class="token maybe-class-name">GlobalSetupContext</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">provide</span><span class="token punctuation">(</span><span class="token string">'wsPort'</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'vitest'</span> <span class="token punctuation">{</span>
  <span class="token keyword module">export</span> <span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">ProvidedContext</span></span> <span class="token punctuation">{</span>
    wsPort<span class="token operator">:</span> <span class="token builtin">number</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> inject <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest'</span>

<span class="token function">inject</span><span class="token punctuation">(</span><span class="token string">'wsPort'</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">3000</span></code></pre><section class="level3"aria-labelledby="forcereruntriggers"><h3 id="forcereruntriggers">forceRerunTriggers<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型</strong>: <code>string[]</code><li><strong>默认值:</strong> <code>['**/package.json/**', '**/vitest.config.*/**', '**/vite.config.*/**']</code></ul><p>将触发整个套件重新运行的文件路径的全局 glob 模式。 如果在 git diff 中找到触发器，则与 --changed 参数配对时，将运行整个测试套件。<p>如果你正在测试调用 CLI 命令时很有用，因为 Vite 无法构建模块依赖树:<pre class="language-ts"><code class="language-ts"><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'execute a script'</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// Vitest cannot rerun this test, if content of `dist/index.js` changes</span>
  <span class="token keyword control-flow">await</span> <span class="token function">execa</span><span class="token punctuation">(</span><span class="token string">'node'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'dist/index.js'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><blockquote>提醒 请确保您的文件没有被 [`server.watch.ignored`](https://vitejs.dev/config/server-options.html#server-watch)排除在外。</blockquote></section><section class="level3"aria-labelledby="coverage"><h3 id="coverage">coverage<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型:</strong> <code>CoverageC8Options | CoverageIstanbulOptions</code><li><strong>默认值:</strong> <code>undefined</code></ul><p>你可以使用点符号向 CLI 提供覆盖选项：<pre class="language-sh"><code class="language-sh">npx vitest --coverage.enabled --coverage.provider=istanbul --coverage.all</code></pre><blockquote>如果你使用带点符号的覆盖选项，请不要忘记指定 `--coverage.enabled`。 在这种情况下，不要提供单个 --coverage 选项。</blockquote><section class="level4"aria-labelledby="coverageprovider"><h4 id="coverageprovider">coverage.provider</h4><ul><li><strong>类型:</strong> <code>'v8' | 'istanbul' | 'custom'</code><li><strong>默认值:</strong> <code>'v8'</code><li><strong>命令行终端:</strong> <code>--coverage.provider=&#x3C;provider></code></ul><p>使用 <code>provider</code> 选择收集测试覆盖率的工具。</section><section class="level4"aria-labelledby="coverageenabled"><h4 id="coverageenabled">coverage.enabled</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.enabled</code>, <code>--coverage.enabled=false</code></ul><p>是否启用收集测试覆盖率。可以使用 <code>--coverage</code> 覆盖 CLI 选项。</section><section class="level4"aria-labelledby="coverageinclude"><h4 id="coverageinclude">coverage.include</h4><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值:</strong> <code>['**']</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.include=&#x3C;path></code>, <code>--coverage.include=&#x3C;path1> --coverage.include=&#x3C;path2></code></ul><p>匹配包含测试覆盖率的 glob 规则</section><section class="level4"aria-labelledby="coverageextension"><h4 id="coverageextension">coverage.extension</h4><ul><li><strong>类型:</strong> <code>string | string[]</code><li><strong>默认值:</strong> <code>['.js', '.cjs', '.mjs', '.ts', '.mts', '.tsx', '.jsx', '.vue', '.svelte', '.marko', '.astro']</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.extension=&#x3C;extension></code>, <code>--coverage.extension=&#x3C;extension1> --coverage.extension=&#x3C;extension2></code></ul></section><section class="level4"aria-labelledby="coverageexclude"><h4 id="coverageexclude">coverage.exclude</h4><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值:</strong></ul><pre class="language-js"><code class="language-js"><span class="token punctuation">[</span>
  <span class="token string">'coverage/**'</span><span class="token punctuation">,</span>
  <span class="token string">'dist/**'</span><span class="token punctuation">,</span>
  <span class="token string">'**/node_modules/**'</span><span class="token punctuation">,</span>
  <span class="token string">'**/[.]**'</span><span class="token punctuation">,</span>
  <span class="token string">'packages/*/test?(s)/**'</span><span class="token punctuation">,</span>
  <span class="token string">'**/*.d.ts'</span><span class="token punctuation">,</span>
  <span class="token string">'**/virtual:*'</span><span class="token punctuation">,</span>
  <span class="token string">'**/__x00__*'</span><span class="token punctuation">,</span>
  <span class="token string">'**/\x00*'</span><span class="token punctuation">,</span>
  <span class="token string">'cypress/**'</span><span class="token punctuation">,</span>
  <span class="token string">'test?(s)/**'</span><span class="token punctuation">,</span>
  <span class="token string">'test?(-*).?(c|m)[jt]s?(x)'</span><span class="token punctuation">,</span>
  <span class="token string">'**/*{.,-}{test,spec,bench,benchmark}?(-d).?(c|m)[jt]s?(x)'</span><span class="token punctuation">,</span>
  <span class="token string">'**/__tests__/**'</span><span class="token punctuation">,</span>
  <span class="token string">'**/{karma,rollup,webpack,vite,vitest,jest,ava,babel,nyc,cypress,tsup,build,eslint,prettier}.config.*'</span><span class="token punctuation">,</span>
  <span class="token string">'**/vitest.{workspace,projects}.[jt]s?(on)'</span><span class="token punctuation">,</span>
  <span class="token string">'**/.{eslint,mocha,prettier}rc.{?(c|m)js,yml}'</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span></code></pre><ul><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.exclude=&#x3C;path></code>, <code>--coverage.exclude=&#x3C;path1> --coverage.exclude=&#x3C;path2></code></ul><p>使用全局模式排除在覆盖范围之外的文件列表。<p>该选项覆盖所有默认选项。添加新的忽略模式时，扩展默认选项：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> coverageConfigDefaults<span class="token punctuation">,</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    coverage<span class="token operator">:</span> <span class="token punctuation">{</span>
      exclude<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'**/custom-pattern/**'</span><span class="token punctuation">,</span> <span class="token spread operator">...</span>coverageConfigDefaults<span class="token punctuation">.</span><span class="token property-access">exclude</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><blockquote>NOTE Vitest 会自动将测试文件的 `include` 模式添加到 `coverage.exclude` 的默认值中。</blockquote></section><section class="level4"aria-labelledby="coverageall"><h4 id="coverageall">coverage.all</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>true</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.all</code>, <code>--coverage.all=false</code></ul><p>是否将所有文件（包括未测试的文件）包括在报告中。</section><section class="level4"aria-labelledby="coverageclean"><h4 id="coverageclean">coverage.clean</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>true</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.clean</code>, <code>--coverage.clean=false</code></ul><p>运行测试之前是否清除覆盖率结果</section><section class="level4"aria-labelledby="coveragecleanonrerun"><h4 id="coveragecleanonrerun">coverage.cleanOnRerun</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>true</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.cleanOnRerun</code>, <code>--coverage.cleanOnRerun=false</code></ul><p>监视重新运行时是否清除覆盖率报告。设置为 <code>false</code> 可保留观察模式下上次运行的覆盖结果。</section><section class="level4"aria-labelledby="coveragereportsdirectory"><h4 id="coveragereportsdirectory">coverage.reportsDirectory</h4><ul><li><strong>类型:</strong> <code>string</code><li><strong>默认值:</strong> <code>'./coverage'</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.reportsDirectory=&#x3C;path></code></ul><blockquote>如果启用了 `coverage.clean`（默认值），Vitest 会在运行测试前删除此目录。</blockquote><p>配置测试覆盖率报告写入的目录。<p>要预览覆盖范围报告，请使用 <a href="/guide/reporters.html#html-reporter">HTML reporter</a>, 该选项必须设置为 html 报告目录的子目录 (比如 <code>./html/coverage</code>).</section><section class="level4"aria-labelledby="coveragereporter"><h4 id="coveragereporter">coverage.reporter</h4><ul><li><strong>类型:</strong> <code>string | string[] | [string, {}][]</code><li><strong>默认值:</strong> <code>['text', 'html', 'clover', 'json']</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.reporter=&#x3C;reporter></code>, <code>--coverage.reporter=&#x3C;reporter1> --coverage.reporter=&#x3C;reporter2></code></ul><p>配置要使用的测试覆盖率报告器。查看 <a href="https://istanbul.js.org/docs/advanced/alternative-reporters/">istanbul 文档</a> 来了解报告详情。有关报告特定选项的详细信息，请参阅 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/276d95e4304b3670eaf6e8e5a7ea9e265a14e338/types/istanbul-reports/index.d.ts"><code>@types/istanbul-reporter</code></a>。<p>该报告器支持三种不同的类型:<ul><li>单个报告器: <code>{ reporter: 'html' }</code><li>无配置的多个报告器: <code>{ reporter: ['html', 'json'] }</code><li>有配置的单个或多个报告器:<pre class="language-ts"><code class="language-ts"><span class="token punctuation">{</span>
  reporter<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">[</span><span class="token string">"lcov"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> projectRoot<span class="token operator">:</span> <span class="token string">"./src"</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token string">"json"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> file<span class="token operator">:</span> <span class="token string">"coverage.json"</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token string">"text"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></ul><p>我们还可以传递自定义覆盖报告器。查看<a href="/guide/coverage#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A6%86%E7%9B%96%E7%8E%87%E6%8F%90%E4%BE%9B%E8%80%85">自定义覆盖报告器</a>了解更多详情。<pre class="language-ts"><code class="language-ts"><span class="token punctuation">{</span>
  reporter<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token comment">// Specify reporter using name of the NPM package</span>
    <span class="token string">"@vitest/custom-coverage-reporter"</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token string">"@vitest/custom-coverage-reporter"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> someOption<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>

    <span class="token comment">// Specify reporter using local path</span>
    <span class="token string">"/absolute/path/to/custom-reporter.cjs"</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token string">"/absolute/path/to/custom-reporter.cjs"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> someOption<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>我们可以在 Vitest UI 中查看覆盖率报告：查看 <a href="/guide/coverage#vitest-ui">Vitest UI Coverage</a> 了解更多详情。</section><section class="level4"aria-labelledby="coverage-reportonfailure"><h4 id="coverage-reportonfailure">coverage.reportOnFailure</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.reportOnFailure</code>, <code>--coverage.reportOnFailure=false</code></ul><p>即使测试失败也会生成覆盖率报告。</section><section class="level4"aria-labelledby="coverageallowexternal"><h4 id="coverageallowexternal">coverage.allowExternal</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.allowExternal</code>, <code>--coverage.allowExternal=false</code></ul><p>收集 <a href="#root">项目<code>root</code></a> 之外文件的覆盖率。</section><section class="level4"aria-labelledby="coverageexcludeafterremap-210-coverage-exclude-after-remap"><h4 id="coverageexcludeafterremap-210-coverage-exclude-after-remap">coverage.excludeAfterRemap<version>2.1.0</version>{#coverage-exclude-after-remap}</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.excludeAfterRemap</code>, <code>--coverage.excludeAfterRemap=false</code></ul><p>在覆盖范围重新映射到原始源后再次应用排除。 当你的源文件被转译并且可能包含非源文件的源映射时，这很有用。<p>当你看到报告中显示的文件与你的 <code>coverage.exclude</code> 模式匹配时，请使用此选项。</section><section class="level4"aria-labelledby="coverageskipfull"><h4 id="coverageskipfull">coverage.skipFull</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.skipFull</code>, <code>--coverage.skipFull=false</code></ul><p>是否显示具有 100% 语句、分支和函数的测试覆盖率的文件。</section><section class="level4"aria-labelledby="coveragethresholds"><h4 id="coveragethresholds">coverage.thresholds</h4><p>覆盖范围阈值选项<section class="level5"aria-labelledby="coveragethresholdslines"><h5 id="coveragethresholdslines">coverage.thresholds.lines</h5><ul><li><strong>类型:</strong> <code>number</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.thresholds.lines=&#x3C;number></code></ul><p>lines 的全局阈值。 更多信息请查看 <a href="https://github.com/istanbuljs/nyc#coverage-thresholds">istanbul documentation</a>。</section><section class="level5"aria-labelledby="coveragethresholdsfunctions"><h5 id="coveragethresholdsfunctions">coverage.thresholds.functions</h5><ul><li><strong>类型:</strong> <code>number</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.thresholds.functions=&#x3C;number></code></ul><p>functions 的全局阈值。 更多信息请查看 <a href="https://github.com/istanbuljs/nyc#coverage-thresholds">istanbul documentation</a>。</section><section class="level5"aria-labelledby="coveragethresholdsbranches"><h5 id="coveragethresholdsbranches">coverage.thresholds.branches</h5><ul><li><strong>类型:</strong> <code>number</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.thresholds.branches=&#x3C;number></code></ul><p>branches 的全局阈值。 更多信息请查看 <a href="https://github.com/istanbuljs/nyc#coverage-thresholds">istanbul documentation</a>。</section><section class="level5"aria-labelledby="coveragethresholdsstatements"><h5 id="coveragethresholdsstatements">coverage.thresholds.statements</h5><ul><li><strong>类型:</strong> <code>number</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.thresholds.statements=&#x3C;number></code></ul><p>statements 的全局阈值。 更多信息请查看 <a href="https://github.com/istanbuljs/nyc#coverage-thresholds">istanbul documentation</a>。</section><section class="level5"aria-labelledby="coveragethresholdsperfile"><h5 id="coveragethresholdsperfile">coverage.thresholds.perFile</h5><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.thresholds.perFile</code>, <code>--coverage.thresholds.perFile=false</code></ul><p>检查每个文件的阈值。</section><section class="level5"aria-labelledby="coveragethresholdsautoupdate"><h5 id="coveragethresholdsautoupdate">coverage.thresholds.autoUpdate</h5><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.thresholds.autoUpdate=&#x3C;boolean></code></ul><p>如果当前覆盖率高于配置的阈值时，将所有阈值 <code>lines</code> 、<code>functions</code> 、<code>branches</code> 和 <code>statements</code> 更新到配置文件中。 此选项有助于在覆盖率提高时保持阈值不变。</section><section class="level5"aria-labelledby="coveragethresholds100"><h5 id="coveragethresholds100">coverage.thresholds.100</h5><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.thresholds.100</code>, <code>--coverage.thresholds.100=false</code></ul><p>将全局阈值设置为 100。 这是 <code>--coverage.thresholds.lines 100 --coverage.thresholds.functions 100 --coverage.thresholds.branches 100 --coverage.thresholds.statements 100</code> 的快捷方式。</section><section class="level5"aria-labelledby="coveragethresholdsglob-pattern"><h5 id="coveragethresholdsglob-pattern">coverage.thresholds[glob-pattern]</h5><ul><li><strong>类型:</strong> <code>{ statements?: number functions?: number branches?: number lines?: number }</code><li><strong>默认值:</strong> <code>undefined</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code></ul><p>设置与 glob 模式匹配的文件的阈值。<blockquote>NOTE Vitest counts all files, including those covered by glob-patterns, into the global coverage thresholds. This is different from Jest behavior.</blockquote><pre class="language-ts"><code class="language-ts"><span class="token punctuation">{</span>
  coverage<span class="token operator">:</span> <span class="token punctuation">{</span>
    thresholds<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// Thresholds for all files</span>
      functions<span class="token operator">:</span> <span class="token number">95</span><span class="token punctuation">,</span>
      branches<span class="token operator">:</span> <span class="token number">70</span><span class="token punctuation">,</span>

      <span class="token comment">// Thresholds for matching glob pattern</span>
      <span class="token string-property property">'src/utils/**.ts'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        statements<span class="token operator">:</span> <span class="token number">95</span><span class="token punctuation">,</span>
        functions<span class="token operator">:</span> <span class="token number">90</span><span class="token punctuation">,</span>
        branches<span class="token operator">:</span> <span class="token number">85</span><span class="token punctuation">,</span>
        lines<span class="token operator">:</span> <span class="token number">80</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>

      <span class="token comment">// Files matching this pattern will only have lines thresholds set.</span>
      <span class="token comment">// Global thresholds are not inherited.</span>
      <span class="token string-property property">'**/math.ts'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        lines<span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></section><section class="level5"aria-labelledby="coveragethresholdsglob-pattern100-210-coverage-thresholds-glob-pattern-100"><h5 id="coveragethresholdsglob-pattern100-210-coverage-thresholds-glob-pattern-100">coverage.thresholds[glob-pattern].100<version>2.1.0</version>{#coverage-thresholds-glob-pattern-100}</h5><ul><li><strong>Type:</strong> <code>boolean</code><li><strong>Default:</strong> <code>false</code><li><strong>Available for providers:</strong> <code>'v8' | 'istanbul'</code></ul><p>Sets thresholds to 100 for files matching the glob pattern.<pre class="language-ts"><code class="language-ts"><span class="token punctuation">{</span>
  coverage<span class="token operator">:</span> <span class="token punctuation">{</span>
    thresholds<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// Thresholds for all files</span>
      functions<span class="token operator">:</span> <span class="token number">95</span><span class="token punctuation">,</span>
      branches<span class="token operator">:</span> <span class="token number">70</span><span class="token punctuation">,</span>

      <span class="token comment">// Thresholds for matching glob pattern</span>
      <span class="token string-property property">'src/utils/**.ts'</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token number">100</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token string-property property">'**/math.ts'</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token number">100</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></section></section><section class="level4"aria-labelledby="coverageignoreemptylines"><h4 id="coverageignoreemptylines">coverage.ignoreEmptyLines</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>true</code> (<code>false</code> in v1)<li><strong>可用的测试提供者:</strong> <code>'v8'</code><li><strong>命令行终端:</strong> <code>--coverage.ignoreEmptyLines=&#x3C;boolean></code></ul><p>忽略空行、注释和其他非运行时代码，如 Typescript 类型。<p>该选项只有在使用的编译器删除了转译代码中的注释和其他非运行时代码时才有效。 默认情况下，Vite 使用 ESBuild，它会删除 <code>.ts</code>、<code>.tsx</code> 和 <code>.jsx</code> 文件中的注释和 Typescript 类型。<p>如果还想将 ESBuild 应用于其他文件，请在 <a href="https://cn.vitejs.dev/config/shared-options.html#esbuild"><code>esbuild</code> options</a> 中定义它们：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  esbuild<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用 ESBuild 转换所有文件以删除代码覆盖率中的注释。</span>
    <span class="token comment">// `test.coverage.ignoreEmptyLines` 需要工作：</span>
    include<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'**/*.js'</span><span class="token punctuation">,</span> <span class="token string">'**/*.jsx'</span><span class="token punctuation">,</span> <span class="token string">'**/*.mjs'</span><span class="token punctuation">,</span> <span class="token string">'**/*.ts'</span><span class="token punctuation">,</span> <span class="token string">'**/*.tsx'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    coverage<span class="token operator">:</span> <span class="token punctuation">{</span>
      provider<span class="token operator">:</span> <span class="token string">'v8'</span><span class="token punctuation">,</span>
      ignoreEmptyLines<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section><section class="level4"aria-labelledby="coverageignoreclassmethods"><h4 id="coverageignoreclassmethods">coverage.ignoreClassMethods</h4><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值:</strong> <code>[]</code><li><strong>可用的测试提供者:</strong> <code>'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.ignoreClassMethods=&#x3C;method></code></ul><p>设置为要忽略覆盖率的类方法名称数组。参考 <a href="https://github.com/istanbuljs/nyc#ignoring-methods">istanbul 文档</a> 来了解详情。</section><section class="level4"aria-labelledby="coveragewatermarks"><h4 id="coveragewatermarks">coverage.watermarks</h4><ul><li><strong>类型:</strong></ul><pre class="language-ts"><code class="language-ts"><span class="token punctuation">{</span>
  statements<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  functions<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  branches<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  lines<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre><ul><li><strong>默认值:</strong></ul><pre class="language-ts"><code class="language-ts"><span class="token punctuation">{</span>
  statements<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  functions<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  branches<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  lines<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre><ul><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.watermarks.statements=50,80</code>， <code>--coverage.watermarks.branches=50,80</code></ul><p>语句、行、分支和函数的水印。有关更多信息，请参见 <a href="https://github.com/istanbuljs/nyc#high-and-low-watermarks">istanbul 文档</a>。</section><section class="level4"aria-labelledby="coverageprocessingconcurrency"><h4 id="coverageprocessingconcurrency">coverage.processingConcurrency</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>Math.min(20, os.availableParallelism?.() ?? os.cpus().length)</code><li><strong>可用的测试提供者:</strong> <code>'v8' | 'istanbul'</code><li><strong>命令行终端:</strong> <code>--coverage.processingConcurrency=&#x3C;number></code></ul><p>处理覆盖率结果时使用的并发限制。</section><section class="level4"aria-labelledby="coveragecustomprovidermodule"><h4 id="coveragecustomprovidermodule">coverage.customProviderModule</h4><ul><li><strong>类型:</strong> <code>string</code><li><strong>可用的测试提供者:</strong> <code>'custom'</code><li><strong>命令行终端:</strong> <code>--coverage.customProviderModule=&#x3C;path or module name></code></ul><p>指定自定义覆盖率提供者的模块名称或路径。有关详细信息，请参阅<a href="/guide/coverage#custom-coverage-provider">指南 - 自定义覆盖率提供者</a>。</section></section><section class="level3"aria-labelledby="testnamepattern"><h3 id="testnamepattern">testNamePattern<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型</strong> <code>string | RegExp</code><li><strong>命令行终端:</strong> <code>-t &#x3C;pattern></code>, <code>--testNamePattern=&#x3C;pattern></code>, <code>--test-name-pattern=&#x3C;pattern></code></ul><p>使用与模式匹配的全名运行测试。 如果你将 <code>OnlyRunThis</code> 添加到此属性，将跳过测试名称中不包含单词 <code>OnlyRunThis</code> 的测试。<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> expect<span class="token punctuation">,</span> test <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest'</span>

<span class="token comment">// run</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'OnlyRunThis'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">expect</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">toBe</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// skipped</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'doNotRun'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">expect</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">toBe</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section><section class="level3"aria-labelledby="open"><h3 id="open">open<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>!process.env.CI</code><li><strong>命令行终端:</strong> <code>--open</code>, <code>--open=false</code></ul><p>打开 Vitest UI (WIP: 赞助者计划可用)</section><section class="level3"aria-labelledby="api"><h3 id="api">api</h3><ul><li><strong>类型:</strong> <code>boolean | number</code><li><strong>默认值:</strong> <code>false</code><li><strong>命令行终端:</strong> <code>--api</code>, <code>--api.port</code>, <code>--api.host</code>, <code>--api.strictPort</code></ul><p>提供 API 服务的端口。当设置为 true 时，默认端口为 51204</section><section class="level3"aria-labelledby="browser"><h3 id="browser">browser</h3><ul><li><strong>类型:</strong> <code>{ enabled?, name?, provider?, headless?, api? }</code><li><strong>默认值:</strong> <code>{ enabled: false, headless: process.env.CI, api: 63315 }</code><li><strong>命令行终端:</strong> <code>--browser</code>, <code>--browser=&#x3C;name></code>, <code>--browser.name=chrome --browser.headless</code></ul><p>在浏览器中运行 Vitest 测试。我们默认使用 <a href="https://webdriver.io/">WebdriverIO</a> 来运行测试，但可以使用 <a href="#browser-provider">browser.provider</a> 选项进行配置。<blockquote>NOTE 在 [指南页面](/guide/browser/) 中阅读有关在真实浏览器中进行测试的更多信息。</blockquote><blockquote>这是一项实验性功能。重大更改可能不会遵循 semver，请在使用时锁定 Vitest 的版本。</blockquote><section class="level4"aria-labelledby="browserenabled"><h4 id="browserenabled">browser.enabled</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code><li><strong>命令行终端:</strong> <code>--browser</code>, <code>--browser.enabled=false</code></ul><p>默认情况下在浏览器中运行所有测试。可以用 <a href="#poolmatchglobs"><code>poolMatchGlobs</code></a> 选项覆盖。</section><section class="level4"aria-labelledby="browsername"><h4 id="browsername">browser.name</h4><ul><li><strong>类型:</strong> <code>string</code><li><strong>命令行终端:</strong> <code>--browser=safari</code></ul><p>在特定浏览器中运行所有测试。不同的浏览器提供商有以下选项：<ul><li><code>webdriverio</code>: <code>firefox</code>, <code>chrome</code>, <code>edge</code>, <code>safari</code><li><code>playwright</code>: <code>firefox</code>, <code>webkit</code>, <code>chromium</code><li>自定义: 将传递给提供者的任何字符串</ul></section><section class="level4"aria-labelledby="browserheadless"><h4 id="browserheadless">browser.headless</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>process.env.CI</code><li><strong>命令行终端:</strong> <code>--browser.headless</code>, <code>--browser.headless=false</code></ul><p>以 <code>headless</code> 模式运行浏览器。如果你在 CI 中运行 Vitest，它将默认启用。</section><section class="level4"aria-labelledby="browserisolate"><h4 id="browserisolate">browser.isolate</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>true</code><li><strong>命令行终端:</strong> <code>--browser.isolate</code>, <code>--browser.isolate=false</code></ul><p>在单独的 iframe 中运行每个测试。</section><section class="level4"aria-labelledby="browserapi"><h4 id="browserapi">browser.api</h4><ul><li><strong>类型:</strong> <code>number | { port?, strictPort?, host? }</code><li><strong>默认值:</strong> <code>63315</code><li><strong>命令行终端:</strong> <code>--browser.api=63315</code>, <code>--browser.api.port=1234, --browser.api.host=example.com</code></ul><p>为在浏览器中提供代码的 Vite 服务器配置选项。它不影响 <a href="#api"><code>test.api</code></a> 选项。默认情况下，Vitest 会分配端口 <code>63315</code>，以避免与开发服务器冲突，从而允许同时运行这两个端口。</section><section class="level4"aria-labelledby="browserprovider"><h4 id="browserprovider">browser.provider</h4><ul><li><strong>类型:</strong> <code>'webdriverio' | 'playwright' | 'preview' | string</code><li><strong>默认值:</strong> <code>'preview'</code><li><strong>命令行终端:</strong> <code>--browser.provider=playwright</code></ul><p>设置运行浏览器测试时浏览器的路径。Vitest 提供了三个浏览器驱动选项: <code>preview</code>（默认）、<code>webdriverio</code> 和 <code>playwright</code> 。自定义提供商应该使用 <code>default</code> 进行导出，并具有如下类型签名:<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">BrowserProvider</span></span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span>
  <span class="token function-variable function">getSupportedBrowsers</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">readonly</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token function-variable function">initialize</span><span class="token operator">:</span> <span class="token punctuation">(</span>
    ctx<span class="token operator">:</span> <span class="token maybe-class-name">Vitest</span><span class="token punctuation">,</span>
    options<span class="token operator">:</span> <span class="token punctuation">{</span> browser<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> options<span class="token operator">?</span><span class="token operator">:</span> <span class="token maybe-class-name">BrowserProviderOptions</span> <span class="token punctuation">}</span>
  <span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">Awaitable</span><span class="token operator">&#x3C;</span><span class="token keyword">void</span><span class="token operator">></span>
  <span class="token function-variable function">openPage</span><span class="token operator">:</span> <span class="token punctuation">(</span>url<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">Awaitable</span><span class="token operator">&#x3C;</span><span class="token keyword">void</span><span class="token operator">></span>
  <span class="token function-variable function">close</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">Awaitable</span><span class="token operator">&#x3C;</span><span class="token keyword">void</span><span class="token operator">></span>
<span class="token punctuation">}</span></code></pre><blockquote>这是一个对库作者友好的的高级 API。如果你只需要在浏览器中运行测试，请使用 [browser](#browser) 选项。</blockquote></section><section class="level4"aria-labelledby="browser-provideroptions"><h4 id="browser-provideroptions">browser.providerOptions</h4><ul><li><strong>类型:</strong> <code>BrowserProviderOptions</code></ul><p>调用 <code>provider.initialize</code> 时将传递给提供程序的选项。<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    browser<span class="token operator">:</span> <span class="token punctuation">{</span>
      providerOptions<span class="token operator">:</span> <span class="token punctuation">{</span>
        launch<span class="token operator">:</span> <span class="token punctuation">{</span>
          devtools<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><blockquote>为了在使用内置提供程序时获得更好的类型安全性，你可以将以下类型之一（针对正在使用的提供程序）添加到 tsconfig 的 `compilerOptions.types` 字段中：<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"types"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token string">"@vitest/browser/providers/webdriverio"</span><span class="token punctuation">,</span>
      <span class="token string">"@vitest/browser/providers/playwright"</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></blockquote></section><section class="level4"aria-labelledby="browser-ui"><h4 id="browser-ui">browser.ui</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>!isCI</code><li><strong>命令行终端:</strong> <code>--browser.ui=false</code></ul><p>是否应该将 Vitest UI 注入到页面中。默认情况下，在开发过程中注入 UI iframe。</section><section class="level4"aria-labelledby="browser-viewport"><h4 id="browser-viewport">browser.viewport</h4><ul><li><strong>Type:</strong> <code>{ width, height }</code><li><strong>Default:</strong> <code>414x896</code></ul><p>默认 iframe 的viewport。</section><section class="level4"aria-labelledby="browser-locators"><h4 id="browser-locators">browser.locators</h4><p>Options for built-in <a href="/guide/browser/locators">browser locators</a>.<section class="level5"aria-labelledby="browserlocatorstestidattribute"><h5 id="browserlocatorstestidattribute">browser.locators.testIdAttribute</h5><ul><li><strong>Type:</strong> <code>string</code><li><strong>Default:</strong> <code>data-testid</code></ul><p>Attribute used to find elements with <code>getByTestId</code> locator.</section></section><section class="level4"aria-labelledby="browser-screenshotdirectory"><h4 id="browser-screenshotdirectory">browser.screenshotDirectory</h4><ul><li><strong>Type:</strong> <code>string</code><li><strong>Default:</strong> <code>__snapshots__</code> in the test file directory</ul><p>相对于 <code>root</code> 的快照目录路径。</section><section class="level4"aria-labelledby="browser-screenshotfailures"><h4 id="browser-screenshotfailures">browser.screenshotFailures</h4><ul><li><strong>Type:</strong> <code>boolean</code><li><strong>Default:</strong> <code>!browser.ui</code></ul><p>如果测试失败，Vitest 是否应截图。</section><section class="level4"aria-labelledby="browser-orchestratorscripts"><h4 id="browser-orchestratorscripts">browser.orchestratorScripts</h4><ul><li><strong>类型:</strong> <code>BrowserScript[]</code><li><strong>默认值:</strong> <code>[]</code></ul><p>在启动测试 iframe 之前，应注入orchestrator HTML 中的自定义脚本。此 HTML 文档仅设置 iframe，并不实际导入您的代码。<p>脚本 <code>src</code> 和 <code>content</code> 将由 Vite 插件处理。脚本应以以下格式提供：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">BrowserScript</span></span> <span class="token punctuation">{</span>
  <span class="token doc-comment comment">/**
   * 如果提供了 "content"，且类型为 "module"，则这将是其标识符。
   *
   * 如果使用的是 TypeScript，可以在此处添加 `.ts` 扩展名，例如
   * <span class="token keyword">@default</span> `injected-$<span class="token punctuation">{</span>index<span class="token punctuation">}</span>.js`
   */</span>
  id<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span>
  <span class="token doc-comment comment">/**
   * 要注入的 JavaScript 内容。如果类型为 “module”，Vite 插件将处理此字符串。
   *
   * 你可以使用 `id` 给 Vite 有关文件扩展名的提示。
   */</span>
  content<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span>
  <span class="token doc-comment comment">/**
   * 脚本的路径。该值由 Vite 解析，因此可以是节点模块或文件路径。
   */</span>
  src<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span>
  <span class="token doc-comment comment">/**
   * 如果要异步加载脚本
   */</span>
  async<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span>
  <span class="token doc-comment comment">/**
   * Script type.
   * <span class="token keyword">@default</span> 'module'
   */</span>
  type<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span></code></pre></section><section class="level4"aria-labelledby="browser-testerscripts"><h4 id="browser-testerscripts">browser.testerScripts</h4><ul><li><strong>类型:</strong> <code>BrowserScript[]</code><li><strong>默认值:</strong> <code>[]</code></ul><p>应在测试环境启动前注入测试器 HTML 的自定义脚本。这对注入 Vitest 浏览器实现所需的 polyfills 非常有用。建议在几乎所有情况下使用 <a href="#setupfiles"><code>setupFiles</code></a>，而不要使用此脚本。<p>脚本 <code>src</code> 和 <code>content</code> 将由 Vite 插件处理。</section><section class="level4"aria-labelledby="browser-commands"><h4 id="browser-commands">browser.commands</h4><ul><li><strong>类型:</strong> <code>Record&#x3C;string, BrowserCommand></code><li><strong>默认值:</strong> <code>{ readFile, writeFile, ... }</code></ul><p>自定义<a href="/guide/browser/commands">命令</a>，可在浏览器测试期间从 <code>@vitest/browser/commands</code> 导入。</section></section><section class="level3"aria-labelledby="clearmocks"><h3 id="clearmocks">clearMocks</h3><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>是否在每次测试前对所有监听(Spy)调用 <a href="/api/mock#mockclear"><code>.mockClear()</code></a>。这将清除模拟历史记录，但不会将其实现重置为默认值。</section><section class="level3"aria-labelledby="mockreset"><h3 id="mockreset">mockReset</h3><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>是否在每次测试之前对所有监听(Spy)调用 <a href="/api/mock#mockreset"><code>.mockReset()</code></a>。 这将清除模拟历史并将其实现重置为空函数（将返回<code>undefined</code>）。</section><section class="level3"aria-labelledby="restoremocks"><h3 id="restoremocks">restoreMocks</h3><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>是否在每次测试之前对所有监听(Spy)调用 <a href="../api.html#mockrestore"><code>.mockRestore()</code></a>。 这将清除模拟历史并将其实现重置为原始历史。</section><section class="level3"aria-labelledby="unstubenvs"><h3 id="unstubenvs">unstubEnvs</h3><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>将在每次测试前调用 <a href="../api.html#vi-unstuballenvs"><code>vi.unstubAllEnvs</code></a>。</section><section class="level3"aria-labelledby="unstubglobals"><h3 id="unstubglobals">unstubGlobals</h3><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>将在每次测试前调用 <a href="../api.html#vi-unstuballglobals"><code>vi.unstubAllGlobals</code></a>。</section><section class="level3"aria-labelledby="testtransformmode"><h3 id="testtransformmode">testTransformMode</h3><ul><li><strong>类型:</strong> <code>{ web?, ssr? }</code></ul><p>确定与测试中的 glob 模式匹配的所有导入模块的转换方法。默认情况下，依赖于环境。例如，使用 JSDOM 环境的测试将处理所有带有 <code>ssr: false</code> 标志的文件，而使用 Node 环境的测试将处理所有带有 <code>ssr: true</code> 的模块。<section class="level4"aria-labelledby="testtransformmodessr"><h4 id="testtransformmodessr">testTransformMode.ssr</h4><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值:</strong> <code>[]</code></ul><p>对指定的文件使用 SSR 转换管道。<br>Vite 插件在处理这些文件时会收到 <code>ssr: true</code> 标志。</section><section class="level4"aria-labelledby="testtransformmodeweb"><h4 id="testtransformmodeweb">testTransformMode.web</h4><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值:</strong> <code>[]</code></ul><p>首先会进行正常的转换管道（针对浏览器），然后进行 SSR 重写以在 Node 中运行代码。<br>Vite 插件在处理这些文件时会收到 <code>ssr: false</code> 标志。<p>当你使用 JSX 作为 React 以外的组件模型（例如 Vue JSX 或 SolidJS）时，你可能需要进行如下配置以使 <code>.tsx</code> / <code>.jsx</code> 转换为客户端组件：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    transformMode<span class="token operator">:</span> <span class="token punctuation">{</span>
      web<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.[jt]sx$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section></section><section class="level3"aria-labelledby="snapshotformat"><h3 id="snapshotformat">snapshotFormat<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型:</strong> <code>PrettyFormatOptions</code></ul><p>测试快照的格式选项。这些选项被传递给 <a href="https://www.npmjs.com/package/pretty-format"><code>pretty-format</code></a>。<blockquote>请注意，此对象上的 `plugins` 字段将被忽略。<p>如果你需要通过 pretty-format 插件扩展快照序列器，请使用 <a href="/api/expect#expect-addsnapshotserializer"><code>expect.addSnapshotSerializer</code></a> 或 <a href="#snapshotserializers">snapshotSerializers</a> 选项。</blockquote></section><section class="level3"aria-labelledby="snapshotserializers-snapshotserializers"><h3 id="snapshotserializers-snapshotserializers">snapshotSerializers<nonprojectoption>{#snapshotserializers}</nonprojectoption></h3><ul><li><strong>类型:</strong> <code>string[]</code><li><strong>默认值:</strong> <code>[]</code></ul><p>快照测试的快照序列化程序模块的路径列表，如果要添加自定义快照序列化器，则非常有用。有关详细信息，请参阅<a href="/guide/snapshot#custom-serializer">自定义序列化器</a>。</section><section class="level3"aria-labelledby="resolvesnapshotpath"><h3 id="resolvesnapshotpath">resolveSnapshotPath<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型</strong>: <code>(testPath: string, snapExtension: string) => string</code><li><strong>默认值</strong>: 存储快照文件在 <code>__snapshots__</code> 目录</ul><p>覆盖快照的默认路径。例如，要在测试文件旁边存储一下快照：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">resolveSnapshotPath</span><span class="token operator">:</span> <span class="token punctuation">(</span>testPath<span class="token punctuation">,</span> snapExtension<span class="token punctuation">)</span> <span class="token arrow operator">=></span> testPath <span class="token operator">+</span> snapExtension<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section><section class="level3"aria-labelledby="allowonly"><h3 id="allowonly">allowOnly</h3><ul><li><strong>类型</strong>: <code>boolean</code><li><strong>默认值</strong>: <code>!process.env.CI</code><li><strong>命令行终端:</strong> <code>--allowOnly</code>, <code>--allowOnly=false</code></ul><p>允许标记为 only 的测试和套件。</section><section class="level3"aria-labelledby="dangerouslyignoreunhandlederrors"><h3 id="dangerouslyignoreunhandlederrors">dangerouslyIgnoreUnhandledErrors<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型</strong>: <code>boolean</code><li><strong>默认值</strong>: <code>false</code><li><strong>命令行终端:</strong> <code>--dangerouslyIgnoreUnhandledErrors</code> <code>--dangerouslyIgnoreUnhandledErrors=false</code></ul><p>忽略发生的任何未处理的错误。</section><section class="level3"aria-labelledby="passwithnotests"><h3 id="passwithnotests">passWithNoTests<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型</strong>: <code>boolean</code><li><strong>默认值</strong>: <code>false</code><li><strong>命令行终端:</strong> <code>--passWithNoTests</code>, <code>--passWithNoTests=false</code></ul><p>如果没有找到测试，Vitest 不会失败。</section><section class="level3"aria-labelledby="logheapusage"><h3 id="logheapusage">logHeapUsage</h3><ul><li><strong>类型</strong>: <code>boolean</code><li><strong>默认值</strong>: <code>false</code><li><strong>命令行终端:</strong> <code>--logHeapUsage</code>, <code>--logHeapUsage=false</code></ul><p>每次测试后显示堆的使用情况。用于调试内存是否泄漏。</section><section class="level3"aria-labelledby="css"><h3 id="css">css</h3><ul><li><strong>类型</strong>: <code>boolean | { include?, exclude?, modules? }</code></ul><p>配置是否应处理 CSS。 排除后，CSS 文件将被替换为空字符串以绕过后续处理。 CSS 模块将返回一个代理以不影响运行时。<section class="level4"aria-labelledby="cssinclude"><h4 id="cssinclude">css.include</h4><ul><li><strong>类型</strong>: <code>RegExp | RegExp[]</code><li><strong>默认值</strong>: <code>[]</code></ul><p>将返回匹配正则表达式并将由 Vite 管道处理的实际 CSS 文件。<blockquote>如果需要处理所有 CSS 文件，请使用 `/.+/`。</blockquote></section><section class="level4"aria-labelledby="cssexclude"><h4 id="cssexclude">css.exclude</h4><ul><li><strong>类型</strong>: <code>RegExp | RegExp[]</code><li><strong>默认值</strong>: <code>[]</code></ul><p>将返回匹配正则表达式的空 CSS 文件。</section><section class="level4"aria-labelledby="cssmodules"><h4 id="cssmodules">css.modules</h4><ul><li><strong>类型</strong>: <code>{ classNameStrategy? }</code><li><strong>默认值</strong>: <code>{}</code></ul></section><section class="level4"aria-labelledby="cssmodulesclassnamestrategy"><h4 id="cssmodulesclassnamestrategy">css.modules.classNameStrategy</h4><ul><li><strong>类型</strong>: <code>'stable' | 'scoped' | 'non-scoped'</code><li><strong>默认值</strong>: <code>'stable'</code></ul><p>如果你决定处理 CSS 文件，你可以配置 CSS 模块中的类名是否在限定范围内。 默认情况下，Vitest 会导出一个代理，绕过 CSS 模块处理。 你可以选择以下选项之一：<ul><li><code>stable</code>: 类名将生成为<code>_${name}_${hashedFilename}</code>，这意味着如果 CSS 内容发生变化，生成的类将保持不变，但如果文件名被修改，或者文件名将发生变化 被移动到另一个文件夹。 如果你使用快照功能，此设置很有用。<li><code>scoped</code>: 类名将照常生成，遵照 <code>css.modules.generateScopedName</code> 方法，如果你有的话。 默认情况下，文件名将生成为<code>_${name}_${hash}</code>，其中 hash 包括文件名和文件内容。<li><code>non-scoped</code>: 类名将保留 CSS 中定义的名称。</ul><blockquote>在默认的情况下，Vitest 导出代理会绕过 CSS 模块处理。 如果你依赖类的 CSS 属性，就必须使用 `include` 选项启用 CSS 处理。</blockquote></section></section><section class="level3"aria-labelledby="maxconcurrency"><h3 id="maxconcurrency">maxConcurrency</h3><ul><li><strong>类型</strong>: <code>number</code><li><strong>默认值</strong>: <code>5</code><li><strong>命令行终端</strong>: <code>--max-concurrency=10</code>, <code>--maxConcurrency=10</code></ul><p>使用 <code>test.concurrent</code> 标记允许同时运行的最大测试数量。<p>当出现可用插槽时，超过此限制的测试将排队运行。</section><section class="level3"aria-labelledby="cache"><h3 id="cache">cache<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型</strong>: <code>false</code><li><strong>命令行终端</strong>: <code>--no-cache</code>, <code>--cache=false</code></ul><p>如果要禁用缓存功能，请使用此选项。目前，Vitest 会对测试结果进行缓存，优先运行时间较长和失败的测试。<p>缓存目录由 Vite 的 <a href="https://vitejs.dev/config/shared-options.html#cachedir"><code>cacheDir</code></a> 选项控制：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  cacheDir<span class="token operator">:</span> <span class="token string">'custom-folder/.vitest'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>您可以使用 <code>process.env.VITEST</code> 来限制目录，使其仅用于 Vitest：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  cacheDir<span class="token operator">:</span> process<span class="token punctuation">.</span><span class="token property-access">env</span><span class="token punctuation">.</span><span class="token constant">VITEST</span> <span class="token operator">?</span> <span class="token string">'custom-folder/.vitest'</span> <span class="token operator">:</span> <span class="token keyword nil">undefined</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section><section class="level3"aria-labelledby="sequence"><h3 id="sequence">sequence</h3><ul><li><strong>类型</strong>: <code>{ sequencer?, shuffle?, seed?, hooks?, setupFiles? }</code></ul><p>配置测试运行顺序的选项。<p>你可以使用点符号向 CLI 提供序列选项：<pre class="language-sh"><code class="language-sh">npx vitest --sequence.shuffle --sequence.seed=1000</code></pre><section class="level4"aria-labelledby="sequencesequencer"><h4 id="sequencesequencer">sequence.sequencer<nonprojectoption></nonprojectoption></h4><ul><li><strong>类型</strong>: <code>TestSequencerConstructor</code><li><strong>默认值</strong>: <code>BaseSequencer</code></ul><p>定义分片和排序的自定义类。你可以从 <code>vitest/node</code> 扩展 <code>BaseSequencer</code>，如果你只需要重新定义 <code>sort</code> 和 <code>shard</code> 方法之一，但两者都应该存在。<p>分片是在排序之前进行的，并且只有提供了 <code>--shard</code> 选项的情况下才会生效。</section><section class="level4"aria-labelledby="sequenceshuffle"><h4 id="sequenceshuffle">sequence.shuffle</h4><ul><li><strong>类型</strong>: <code>boolean | { files?, tests? }</code><li><strong>默认值</strong>: <code>false</code><li><strong>命令行终端</strong>: <code>--sequence.shuffle</code>, <code>--sequence.shuffle=false</code></ul><p>如果你希望测试随机运行，可以使用此选项或 CLI 参数 <a href="/guide/cli"><code>--sequence.shuffle</code></a> 启用它。<p>Vitest 通常使用缓存对测试进行排序，因此长时间运行的测试会更早开始 - 这会使测试运行得更快。 如果你的测试将以随机顺序运行，你将失去这种性能改进，但跟踪意外依赖于先前运行的测试可能很有用。<ul><li><strong>类型</strong>: <code>boolean | { files?, tests? }</code><li><strong>默认值</strong>: <code>false</code><li><strong>命令行终端</strong>: <code>--sequence.shuffle</code>, <code>--sequence.shuffle=false</code></ul></section><section class="level4"aria-labelledby="sequence-shuffle-files"><h4 id="sequence-shuffle-files">sequence.shuffle.files</h4><ul><li><strong>类型</strong>: <code>boolean</code><li><strong>默认值</strong>: <code>false</code><li><strong>命令行终端</strong>: <code>--sequence.shuffle.files</code>, <code>--sequence.shuffle.files=false</code></ul><p>是否随机化文件，注意如果启用此选项，长时间运行的测试将不会提前启动。</section><section class="level4"aria-labelledby="sequence-shuffle-tests"><h4 id="sequence-shuffle-tests">sequence.shuffle.tests</h4><ul><li><strong>类型</strong>: <code>boolean</code><li><strong>默认值</strong>: <code>false</code><li><strong>命令行终端</strong>: <code>--sequence.shuffle.tests</code>, <code>--sequence.shuffle.tests=false</code></ul><p>是否随机测试。</section><section class="level4"aria-labelledby="sequence-concurrent"><h4 id="sequence-concurrent">sequence.concurrent</h4><ul><li><strong>类型</strong>: <code>boolean</code><li><strong>默认值</strong>: <code>false</code><li><strong>命令行终端</strong>: <code>--sequence.concurrent</code>, <code>--sequence.concurrent=false</code></ul><p>如果你希望测试并行运行，可以使用此选项或 CLI 参数 <a href="/guide/cli"><code>--sequence.concurrent</code></a> 启用它。</section><section class="level4"aria-labelledby="sequenceseed"><h4 id="sequenceseed">sequence.seed<nonprojectoption></nonprojectoption></h4><ul><li><strong>类型</strong>: <code>number</code><li><strong>默认值</strong>: <code>Date.now()</code><li><strong>命令行终端</strong>: <code>--sequence.seed=1000</code></ul><p>如果测试以随机顺序运行，则设置随机化种子。</section><section class="level4"aria-labelledby="sequencehooks"><h4 id="sequencehooks">sequence.hooks</h4><ul><li><strong>类型</strong>: <code>'stack' | 'list' | 'parallel'</code><li><strong>默认值</strong>: <code>'parallel'</code><li><strong>命令行终端</strong>: <code>--sequence.hooks=&#x3C;value></code></ul><p>更改钩子的执行顺序。<ul><li><code>stack</code> 将以相反的顺序排列 "after" 钩子，"before" 钩子将按照它们定义的顺序运行<li><code>list</code> 将按照定义的顺序对所有钩子进行排序<li><code>parallel</code> 将并行运行单个组中的钩子（父套件中的钩子仍将在当前套件的钩子之前运行）</ul><blockquote>该选项不会影响 [`onTestFinished`](../api.html#ontestfinished)。它总是以相反的顺序调用。</blockquote></section><section class="level4"aria-labelledby="sequence-setupfiles"><h4 id="sequence-setupfiles">sequence.setupFiles</h4><ul><li><strong>类型</strong>: <code>'list' | 'parallel'</code><li><strong>默认值</strong>: <code>'parallel'</code><li><strong>命令行终端</strong>: <code>--sequence.setupFiles=&#x3C;value></code></ul><p>更改安装文件的执行顺序。<ul><li><code>list</code> 将按照定义的顺序运行安装文件<li><code>parallel</code> 将并行运行设置文件</ul></section></section><section class="level3"aria-labelledby="typecheck"><h3 id="typecheck">typecheck</h3><p>用于配置 <a href="/guide/testing-types">typechecking</a> 测试环境的选项。<section class="level4"aria-labelledby="typecheck-enabled"><h4 id="typecheck-enabled">typecheck.enabled</h4><ul><li><strong>类型</strong>: <code>boolean</code><li><strong>默认值</strong>: <code>false</code><li><strong>命令行终端</strong>: <code>--typecheck</code>, <code>--typecheck.enabled</code></ul><p>常规测试时是否进行类型检查。</section><section class="level4"aria-labelledby="typecheck-only"><h4 id="typecheck-only">typecheck.only</h4><ul><li><strong>类型</strong>: <code>boolean</code><li><strong>默认值</strong>: <code>false</code><li><strong>命令行终端</strong>: <code>--typecheck.only</code></ul><p>启用类型检查时，仅运行类型检查测试。使用 CLI 时，此选项将自动启用类型检查。</section><section class="level4"aria-labelledby="typecheckchecker"><h4 id="typecheckchecker">typecheck.checker</h4><ul><li><strong>类型</strong>: <code>'tsc' | 'vue-tsc' | string</code><li><strong>默认值</strong>: <code>tsc</code></ul><p>设置类型检查的检测器。Vitest 将根据类型生成具有某些参数的进程，以便于解析。 Checker 应该实现与 <code>tsc</code> 相同的输出格式。<p>你需要安装一个包才能使用 typecheker:<ul><li><code>tsc</code> requires <code>typescript</code> package<li><code>vue-tsc</code> requires <code>vue-tsc</code> package</ul><p>你还可以将路径传递到自定义二进制文件或命令名称，该路径会产生与 <code>tsc --noEmit --pretty false</code> 相同的输出。</section><section class="level4"aria-labelledby="typecheckinclude"><h4 id="typecheckinclude">typecheck.include</h4><ul><li><strong>类型</strong>: <code>string[]</code><li><strong>默认值</strong>: <code>['**/*.{test,spec}-d.?(c|m)[jt]s?(x)']</code></ul><p>匹配包含测试文件的 glob 规则。</section><section class="level4"aria-labelledby="typecheckexclude"><h4 id="typecheckexclude">typecheck.exclude</h4><ul><li><strong>类型</strong>: <code>string[]</code><li><strong>默认值</strong>: <code>['**/node_modules/**', '**/dist/**', '**/cypress/**', '**/.{idea,git,cache,output,temp}/**']</code></ul><p>匹配排除测试文件的 glob 规则。</section><section class="level4"aria-labelledby="typecheckallowjs"><h4 id="typecheckallowjs">typecheck.allowJs</h4><ul><li><strong>类型</strong>: <code>boolean</code><li><strong>默认值</strong>: <code>false</code></ul><p>检查有 <code>@ts-check</code> 注释的 JS 文件。 如果你在 tsconfig 中启用它，则不会覆盖它。</section><section class="level4"aria-labelledby="typecheckignoresourceerrors"><h4 id="typecheckignoresourceerrors">typecheck.ignoreSourceErrors</h4><ul><li><strong>类型</strong>: <code>boolean</code><li><strong>默认值</strong>: <code>false</code></ul><p>如果 Vitest 在测试文件之外发现错误，不要失败。 这根本不会向你显示非测试错误。<p>默认情况下，如果 Vitest 发现源错误，它将测试套件中抛出失败。</section><section class="level4"aria-labelledby="typechecktsconfig"><h4 id="typechecktsconfig">typecheck.tsconfig</h4><ul><li><strong>类型</strong>: <code>string</code><li><strong>默认值</strong>: <em>tries to find closest tsconfig.json</em></ul><p>自定义 tsconfig 的路径，相对于项目根目录。</section></section><section class="level3"aria-labelledby="slowtestthreshold"><h3 id="slowtestthreshold">slowTestThreshold<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型</strong>: <code>number</code><li><strong>默认值</strong>: <code>300</code><li><strong>命令行终端:</strong>:<code>--slow-test-threshold=&#x3C;number></code>, <code>--slowTestThreshold=&#x3C;number></code></ul><p>如果测试被认为是缓慢的，那么会在报告结果中显示毫秒值。</section><section class="level3"aria-labelledby="chaiconfig"><h3 id="chaiconfig">chaiConfig</h3><ul><li><strong>类型:</strong> <code>{ includeStack?, showDiff?, truncateThreshold? }</code><li><strong>默认值:</strong> <code>{ includeStack: false, showDiff: true, truncateThreshold: 40 }</code></ul><p>等同于 <a href="https://github.com/chaijs/chai/blob/4.x.x/lib/chai/config.js">Chai 配置</a>。<section class="level4"aria-labelledby="chaiconfigincludestack"><h4 id="chaiconfigincludestack">chaiConfig.includeStack</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>影响断言错误消息中是否包含堆栈跟踪。默认值为 false，在错误消息中抑制堆栈跟踪。</section><section class="level4"aria-labelledby="chaiconfigshowdiff"><h4 id="chaiconfigshowdiff">chaiConfig.showDiff</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>true</code></ul><p>影响是否应在抛出的 AssertionErrors 中包含 <code>showDiff</code> 标志。<code>false</code> 始终为 <code>false</code>；<code>true</code> 将在断言请求显示差异时为 <code>true</code>。</section><section class="level4"aria-labelledby="chaiconfigtruncatethreshold"><h4 id="chaiconfigtruncatethreshold">chaiConfig.truncateThreshold</h4><ul><li><strong>类型:</strong> <code>number</code><li><strong>默认值:</strong> <code>40</code></ul><p>设置断言错误中实际值和期望值的长度阈值。如果超过此阈值，例如对于大型数据结构，该值将被替换为类似 <code>[ Array(3) ]</code> 或 <code>{ Object (prop1, prop2) }</code> 的内容。如果要完全禁用截断，请将其设置为 <code>0</code>。<p>此配置选项影响在 <code>test.each</code> 标题和断言错误消息中截断值的方式。</section></section><section class="level3"aria-labelledby="bail"><h3 id="bail">bail</h3><ul><li><strong>类型:</strong> <code>number</code><li><strong>默认值:</strong> <code>0</code><li><strong>命令行终端</strong>: <code>--bail=&#x3C;value></code></ul><p>当给定数量的测试失败时停止测试执行。<p>默认情况下，即使其中一些测试失败，Vitest 也会运行你的所有测试用例。这可能不适用于 CI 构建，你只对 100% 成功的构建感兴趣，并且希望在测试失败时尽早停止测试执行。<code>bail</code> 选项可用于通过在发生故障时防止运行更多测试来加速 CI 运行。</section><section class="level3"aria-labelledby="retry"><h3 id="retry">retry</h3><ul><li><strong>类型:</strong> <code>number</code><li><strong>默认值:</strong> <code>0</code><li><strong>命令行终端:</strong> <code>--retry=&#x3C;value></code></ul><p>如果测试失败，请重试特定次数的测试。</section><section class="level3"aria-labelledby="onconsolelog"><h3 id="onconsolelog">onConsoleLog<nonprojectoption></nonprojectoption></h3><ul><li><strong>类型</strong>: <code>(log: string, type: 'stdout' | 'stderr') => boolean | void</code></ul><p>在测试自定义 <code>console.log</code> 的处理程序。如果返回 <code>false</code>，Vitest 将不会将日志打印到控制台上。<p>这在过滤掉来自第三方库的日志时会非常有用。<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">onConsoleLog</span><span class="token punctuation">(</span>log<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> type<span class="token operator">:</span> <span class="token string">'stdout'</span> <span class="token operator">|</span> <span class="token string">'stderr'</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>log <span class="token operator">===</span> <span class="token string">'message from third party library'</span> <span class="token operator">&#x26;&#x26;</span> type <span class="token operator">===</span> <span class="token string">'stdout'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section><section class="level3"aria-labelledby="onstacktrace-onstacktrace"><h3 id="onstacktrace-onstacktrace">onStackTrace<nonprojectoption>{#onstacktrace}</nonprojectoption></h3><ul><li><strong>类型</strong>: <code>(error: Error, frame: ParsedStack) => boolean | void</code></ul><p>在处理错误时，对每个堆栈的每个帧应用过滤功能。第一个参数 <code>error</code> 是一个与标准 <code>Error</code> 具有相同属性的对象，但它不是实际实例。<p>可用于从第三方库中筛选堆栈跟踪帧。<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">ParsedStack</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">'vitest'</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">onStackTrace</span><span class="token punctuation">(</span>error<span class="token operator">:</span> <span class="token known-class-name class-name">Error</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> file <span class="token punctuation">}</span><span class="token operator">:</span> <span class="token maybe-class-name">ParsedStack</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
      <span class="token comment">// If we've encountered a ReferenceError, show the whole stack.</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">===</span> <span class="token string">'ReferenceError'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword control-flow">return</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// Reject all frames from third party libraries.</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token method function property-access">includes</span><span class="token punctuation">(</span><span class="token string">'node_modules'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword control-flow">return</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></section><section class="level3"aria-labelledby="diff"><h3 id="diff">diff</h3><ul><li><strong>类型:</strong> <code>string</code><li><strong>命令行终端:</strong> <code>--diff=&#x3C;value></code></ul><p>生成差异界面时使用的不同配置的路径。如果你想自定义差异显示，这将非常有用。</section>code-group<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">DiffOptions</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">'vitest'</span>
<span class="token keyword module">import</span> <span class="token imports">c</span> <span class="token keyword module">from</span> <span class="token string">'tinyrainbow'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>
  aIndicator<span class="token operator">:</span> c<span class="token punctuation">.</span><span class="token method function property-access">bold</span><span class="token punctuation">(</span><span class="token string">'--'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  bIndicator<span class="token operator">:</span> c<span class="token punctuation">.</span><span class="token method function property-access">bold</span><span class="token punctuation">(</span><span class="token string">'++'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  omitAnnotationLines<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span> satisfies <span class="token maybe-class-name">DiffOptions</span></code></pre><pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vitest/config'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  test<span class="token operator">:</span> <span class="token punctuation">{</span>
    diff<span class="token operator">:</span> <span class="token string">'./vitest.diff.ts'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><section class="level4"aria-labelledby="difftruncatethreshold"><h4 id="difftruncatethreshold">diff.truncateThreshold</h4><ul><li><strong>类型</strong>: <code>number</code><li><strong>默认值</strong>: <code>0</code></ul><p>要显示的差异结果的最大长度。超过此阈值的差异将被截断。 默认值为 0 时，截断不会生效。</section><section class="level4"aria-labelledby="difftruncateannotation"><h4 id="difftruncateannotation">diff.truncateAnnotation</h4><ul><li><strong>类型</strong>: <code>string</code><li><strong>默认值</strong>: <code>'... Diff result is truncated'</code></ul><p>在 diff 结果末尾输出的注释（如果被截断）。</section><section class="level4"aria-labelledby="difftruncateannotationcolor"><h4 id="difftruncateannotationcolor">diff.truncateAnnotationColor</h4><ul><li><strong>类型</strong>: <code>DiffOptionsColor = (arg: string) => string</code><li><strong>默认值</strong>: <code>noColor = (string: string): string => string</code></ul><p>截断注释的颜色，默认为无色输出。</section><section class="level3"aria-labelledby="faketimers"><h3 id="faketimers">fakeTimers</h3><ul><li><strong>类型:</strong> <code>FakeTimerInstallOpts</code></ul><p>当使用 <a href="/api/vi#vi-usefaketimers"><code>vi.useFakeTimers()</code></a>时，Vitest 将向 <a href="https://www.npmjs.com/package/@sinonjs/fake-timers"><code>@sinon/fake-timers</code></a> 传递的选项。<section class="level4"aria-labelledby="faketimersnow"><h4 id="faketimersnow">fakeTimers.now</h4><ul><li><strong>类型:</strong> <code>number | Date</code><li><strong>默认值:</strong> <code>Date.now()</code></ul><p>用指定的 unix 时间安装假计时器。</section><section class="level4"aria-labelledby="faketimerstofake"><h4 id="faketimerstofake">fakeTimers.toFake</h4><ul><li><strong>类型:</strong> <code>('setTimeout' | 'clearTimeout' | 'setImmediate' | 'clearImmediate' | 'setInterval' | 'clearInterval' | 'Date' | 'nextTick' | 'hrtime' | 'requestAnimationFrame' | 'cancelAnimationFrame' | 'requestIdleCallback' | 'cancelIdleCallback' | 'performance' | 'queueMicrotask')[]</code><li><strong>默认值:</strong> <code>['setTimeout', 'clearTimeout', 'setImmediate', 'clearImmediate', 'setInterval', 'clearInterval', 'Date']</code></ul><p>包含要伪造的全局方法和 API 名称的数组。<p>要只模拟 <code>setTimeout()</code> 和 <code>nextTick()</code> ，请将此属性指定为 <code>['setTimeout','nextTick']</code>。<p>使用 <code>--pool=forks</code> 在 <code>node:child_process</code> 内运行 Vitest 时，不支持模拟 <code>nextTick</code>。NodeJS 在 <code>node:child_process</code> 中内部使用了 <code>process.nextTick</code>，当模拟它时会挂起。使用 <code>--pool=threads</code> 运行 Vitest 时支持模拟 <code>nextTick</code>。</section><section class="level4"aria-labelledby="faketimerslooplimit"><h4 id="faketimerslooplimit">fakeTimers.loopLimit</h4><ul><li><strong>类型:</strong> <code>number</code><li><strong>默认值:</strong> <code>10_000</code></ul><p>调用 <a href="/api/vi#vi-runalltimers"><code>vi.runAllTimers()</code></a> 时将运行的计时器的最大数量。</section><section class="level4"aria-labelledby="faketimersshouldadvancetime"><h4 id="faketimersshouldadvancetime">fakeTimers.shouldAdvanceTime</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>告诉 @sinonjs/fake-timers 根据实际系统时间的变化自动递增模拟时间（例如，实际系统时间每变化 20 毫秒，模拟时间就递增 20 毫秒）。</section><section class="level4"aria-labelledby="faketimersadvancetimedelta"><h4 id="faketimersadvancetimedelta">fakeTimers.advanceTimeDelta</h4><ul><li><strong>类型:</strong> <code>number</code><li><strong>默认值:</strong> <code>20</code></ul><p>只有在和 <code>shouldAdvanceTime: true</code> 一起使用时才相关。实际系统时间每发生一次 advanceTimeDelta ms 变化，模拟时间就增加一次 advanceTimeDelta ms。</section><section class="level4"aria-labelledby="faketimersshouldclearnativetimers"><h4 id="faketimersshouldclearnativetimers">fakeTimers.shouldClearNativeTimers</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>通过委托各自的处理程序，告诉假冒计时器清除 "native"（即非假冒）计时器。这些计时器默认情况下不会被清除，如果计时器在假计时器会话启动前就已存在，则可能会导致意外行为。</section></section><section class="level3"aria-labelledby="workspace-workspace"><h3 id="workspace-workspace">workspace<nonprojectoption>{#workspace}</nonprojectoption></h3><ul><li><strong>类型:</strong> <code>string</code><li><strong>命令行终端:</strong> <code>--workspace=./file.js</code><li><strong>默认值:</strong> <code>vitest.{workspace,projects}.{js,ts,json}</code> close to the config file or root</ul><p>相对于<a href="#root">root</a> 的 <a href="/guide/workspace">workspace</a> 配置文件的路径。</section><section class="level3"aria-labelledby="isolate"><h3 id="isolate">isolate</h3><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>true</code><li><strong>命令行终端:</strong> <code>--no-isolate</code>, <code>--isolate=false</code></ul><p>在隔离的环境中运行测试。此选项对 <code>vmThreads</code> 和 <code>vmForks</code> 池没有影响。<p>如果你的代码不依赖于副作用（对于具有 <code>node</code> 环境的项目通常如此），禁用此选项可能会<a href="/guide/improving-performance">改进性能</a>。<blockquote>你可以使用 [`poolOptions`](#poolOptions) 属性禁用特定池的隔离。</blockquote></section><section class="level3"aria-labelledby="includeTaskLocation"><h3 id="includeTaskLocation">includeTaskLocation</h3><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>Vitest API 在 <a href="#reporters">reporters</a> 中接收任务时是否应包含<code>location</code>属性。如果您有大量测试，这可能会导致性能小幅下降。<p><code>location</code> 属性的 <code>列</code> 和 <code>行</code> 值与原始文件中的 <code>test</code> 或 <code>describe</code> 位置相对应。<p>如果您没有明确禁用该选项，并且在运行 Vitest 时使用了该选项，则该选项将自动启用：<ul><li><a href="/guide/ui">Vitest UI</a><li>或使用不带 <a href="../guide/browser.html#headless">headless</a> 模式的 <a href="/guide/browser/">浏览器模式</a><li>或使用<a href="/guide/reporters#html-reporter">HTML 报告器</a></ul><blockquote>如果不使用依赖于该选项的自定义代码，该选项将不起作用。</blockquote></section><section class="level3"aria-labelledby="snapshotEnvironment"><h3 id="snapshotEnvironment">snapshotEnvironment</h3><ul><li><strong>类型:</strong> <code>string</code></ul><p>自定义快照环境实现的路径。如果在不支持 Node.js API 的环境中运行测试，该选项将非常有用。此选项对浏览器运行程序没有任何影响。<p>该对象应具有 <code>SnapshotEnvironment</code> 的形状，用于解析和读/写快照文件：<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">SnapshotEnvironment</span></span> <span class="token punctuation">{</span>
  <span class="token function-variable function">getVersion</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">string</span>
  <span class="token function-variable function">getHeader</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">string</span>
  <span class="token function-variable function">resolvePath</span><span class="token operator">:</span> <span class="token punctuation">(</span>filepath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span>
  <span class="token function-variable function">resolveRawPath</span><span class="token operator">:</span> <span class="token punctuation">(</span>testPath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> rawPath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span>
  <span class="token function-variable function">saveSnapshotFile</span><span class="token operator">:</span> <span class="token punctuation">(</span>filepath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> snapshot<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token keyword">void</span><span class="token operator">></span>
  <span class="token function-variable function">readSnapshotFile</span><span class="token operator">:</span> <span class="token punctuation">(</span>filepath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span><span class="token operator">></span>
  <span class="token function-variable function">removeSnapshotFile</span><span class="token operator">:</span> <span class="token punctuation">(</span>filepath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token keyword">void</span><span class="token operator">></span>
<span class="token punctuation">}</span></code></pre><p>如果只需覆盖部分 API，可从 <code>vitest/snapshot</code> 入口扩展默认的 <code>VitestSnapshotEnvironment</code> 。<blockquote>这是一个低级选项，仅适用于无法访问默认 Node.js API 的高级情况。<p>如果只需要配置快照功能，请使用 <a href="#snapshotformat"><code>snapshotFormat</code></a>或 <a href="#resolvesnapshotpath"><code>resolveSnapshotPath</code></a>选项。</blockquote></section><section class="level3"aria-labelledby="env"><h3 id="env">env</h3><ul><li><strong>类型:</strong> <code>Partial&#x3C;NodeJS.ProcessEnv></code></ul><p>测试期间在 <code>process.env</code> 和 <code>import.meta.env</code> 中可用的环境变量。这些变量在主进程中不可用（例如在 <code>globalSetup</code> 中）。</section><section class="level3"aria-labelledby="expect"><h3 id="expect">expect</h3><ul><li><strong>类型:</strong> <code>ExpectOptions</code></ul><section class="level4"aria-labelledby="expectrequireassertions"><h4 id="expectrequireassertions">expect.requireAssertions</h4><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>与每次测试开始时调用 <a href="/api/expect#expect-hasassertions"><code>expect.hasAssertions()</code></a> 相同。这可确保不会意外通过任何测试。<blockquote>这仅适用于 Vitest 的`expect`。如果您使用`assert`或`.should`断言，它们将不计算在内，并且您的测试将因缺少 expect 断言而失败。<p>您可以通过调用 <code>vi.setConfig({ expect: { requireAssertions: false } })</code> 来更改此值。该配置将应用于每个后续 <code>expect</code> 调用，直到手动调用 <code>vi.resetConfig</code>。</blockquote></section><section class="level4"aria-labelledby="expectpoll"><h4 id="expectpoll">expect.poll</h4><p><a href="/api/expect#poll"><code>expect.poll</code></a> 的全局配置选项。这些选项与您可以传递给 <code>expect.poll(condition, options)</code> 的选项相同。<section class="level5"aria-labelledby="expectpollinterval"><h5 id="expectpollinterval">expect.poll.interval</h5><ul><li><strong>类型:</strong> <code>number</code><li><strong>默认值:</strong> <code>50</code></ul><p>轮询间隔（以毫秒为单位）</section><section class="level5"aria-labelledby="expectpolltimeout"><h5 id="expectpolltimeout">expect.poll.timeout</h5><ul><li><strong>类型:</strong> <code>number</code><li><strong>默认值:</strong> <code>1000</code></ul><p>轮询超时时间（以毫秒为单位）</section></section></section><section class="level3"aria-labelledby="printconsoletrace"><h3 id="printconsoletrace">printConsoleTrace</h3><ul><li><strong>类型:</strong> <code>boolean</code><li><strong>默认值:</strong> <code>false</code></ul><p>调用任何<code>console</code>方法时始终打印控制台跟踪。这对于调试很有用。 <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section></section>