<!doctype html><html lang="en"><meta charset="utf-8"><title>üîê Security</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"type="text/css"href="../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="-security"><h1 id="-security">üîê Security</h1><section class="level2"aria-labelledby="auth"><h2 id="auth">Auth</h2><p>NOTE: While managing authentication on the client side is crucial, it is equally vital to implement robust security measures on the server to protect resources. Client-side authentication enhances user experience and complements server-side security measures.<p>Protecting resources comprises two key components:<section class="level3"aria-labelledby="authentication"><h3 id="authentication">Authentication</h3><p>Authentication is the process of verifying the identity of a user. In single-page applications (SPAs), the prevalent method of authenticating users is through JSON Web Tokens (<a href="https://jwt.io/">JWT</a>). When a user logs in or registers, they receive a token that is stored within the application. Subsequently, for each authenticated request, the token is sent in the header or via a cookie along with the request to validate the user's identity and access permissions.<p>The most secure practice is to store the token in the application state. However, it's important to note that if the user refreshes the application, the token will be reset. That can lead to the loss of the user's authentication status.<p>That is why tokens need to be are stored in a cookie or <code>localStorage/sessionStorage</code>.<section class="level4"aria-labelledby="localstorage-vs-cookie-for-storing-tokens"><h4 id="localstorage-vs-cookie-for-storing-tokens"><code>localStorage</code> vs cookie for storing tokens</h4><p>Storing authentication tokens in localStorage can pose a security risk, especially in the context of Cross-Site Scripting (<a href="https://owasp.org/www-community/attacks/xss/">XSS</a>) vulnerabilities, potentially leading to token theft by malicious actors.<p>Opting to store tokens in cookies, configured with the <code>HttpOnly</code> attribute, can enhance security as they are inaccessible to client-side JavaScript. In our sample app, we utilize js-cookie for cookie management, assuming the real API would enforce the HttpOnly attribute for enhanced security, and the application does not have access to the cookie from the client side.<p>In addition to securely storing tokens, it's crucial to protect the entire application from Cross-Site Scripting (XSS) attacks. One key strategy is to sanitize all user inputs before displaying them in the application. By carefully sanitizing inputs, you can reduce the risk of XSS vulnerabilities, making the application more resilient to malicious attacks and enhancing overall security for users.<p><a href="../apps/react-vihttps://github.com/alan2207/bulletproof-react/tree/master/src/components/ui/md-preview/md-preview.tsx">HTML Sanitization Example Code</a><p>For a full list of security risks, check <a href="https://owasp.org/www-project-top-10-client-side-security-risks/">OWASP</a>.</section><section class="level4"aria-labelledby="handling-user-data"><h4 id="handling-user-data">Handling user data</h4><p>User info should be considered a global piece of state which should be available from anywhere in the application. If you are already using <code>react-query</code>, you can use <a href="https://github.com/alan2207/react-query-auth">react-query-auth</a> library for handling user state which will handle all the things for you after you provide it some configuration. Otherwise, you can use react context + hooks, or some 3rd party state management library.<p>User information should be treated as a central piece of data accessible throughout the application. If you are already using <code>react-query</code>, consider using it for storing user data as well. Alternatively, you can leverage React context with hooks or opt for a third-party state management library to efficiently manage user state across your application.<p><a href="../apps/react-vihttps://github.com/alan2207/bulletproof-react/tree/master/src/lib/auth.tsx">Auth Configuration Example Code</a><p>The application will assume the user is authenticated if a user object is present.</section></section><section class="level3"aria-labelledby="authorization"><h3 id="authorization">Authorization</h3><p>Authorization is the process of verifying whether a user has permission to access a specific resource within the application.<section class="level4"aria-labelledby="rbac-role-based-access-control"><h4 id="rbac-role-based-access-control">RBAC (Role based access control)</h4><p><a href="../apps/react-vihttps://github.com/alan2207/bulletproof-react/tree/master/src/lib/authorization.tsx">Authorization Configuration Example Code</a><p>In a role-based authorization model, access to resources is determined by defining specific roles and associating them with permissions. For example, roles such as <code>USER</code> and <code>ADMIN</code> can be assigned different levels of access rights within the application. Users are then granted access based on their roles; for instance, restricting certain functionalities to regular users while permitting administrators to access all features and functionalities.<p><a href="../apps/react-vihttps://github.com/alan2207/bulletproof-react/tree/master/src/features/discussions/components/create-discussion.tsx">RBAC Example Code</a></section><section class="level4"aria-labelledby="pbac-permission-based-access-control"><h4 id="pbac-permission-based-access-control">PBAC (Permission based access control)</h4><p>While Role-Based Access Control (RBAC) provides a structured methodology for authorization, there are instances where a more granular approach is necessary. Precision-Based Access Control (PBAC) offers a more flexible solution, particularly in scenarios where access permissions need to be finely tuned based on specific criteria, such as allowing only the owner of a resource to perform certain operations. For example, in the case of a user's comment, PBAC ensures that only the author of the comment has the privilege to delete it, adding a layer of precision and customization to access control mechanisms.<p>For RBAC protection, you can use the <code>RBAC</code> component by passing allowed roles to it. On the other hand, if you need more strict protection, you can pass policies check to it.<p><a href="../apps/react-vihttps://github.com/alan2207/bulletproof-react/tree/master/src/features/comments/components/comments-list.tsx">PBAC Example Code</a> <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section></section></section>