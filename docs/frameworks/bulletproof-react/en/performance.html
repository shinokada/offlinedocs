<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>ðŸš„ Performance</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="-performance" class="level1">
      <h1>ðŸš„ Performance</h1>
      <section id="code-splitting" class="level3">
        <h3>Code Splitting</h3>
        <p>Code splitting is a technique of splitting production JavaScript into smaller files, thus allowing the application to be only partially downloaded. Any unused code will not be downloaded until it is required by the application.</p>
        <p>Most of the time code splitting should be done on the routes level, but can also be used for other lazy loaded parts of application.</p>
        <p>Do not code split everything as it might even worsen your application's performance.</p>
        <p><a href="https://github.com/alan2207/bulletproof-react/tree/master/src/routes/protected.tsx">Code Splitting Example Code</a></p>
      </section>
      <section id="component-and-state-optimizations" class="level3">
        <h3>Component and state optimizations</h3>
        <ul>
          <li>
            <p>Do not put everything in a single state. That might trigger unnecessary re-renders. Instead split the global state into multiple stores according to where it is being used.</p>
          </li>
          <li>
            <p>Keep the state as close as possible to where it is being used. This will prevent re-rendering components that do not depend on the updated state.</p>
          </li>
          <li>
            <p>If you have a piece of state that is initialized by an expensive computation, use the state initializer function instead of executing it directly because the expensive function will be run only once as it is supposed to. e.g:</p>
          </li>
        </ul>
        <pre class="language-javascript"><code class="language-javascript"><span class="token comment">// instead of this which would be executed on every re-render:</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">useState</span><span class="token punctuation">(</span><span class="token function">myExpensiveFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// prefer this which is executed only once:</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">myExpensiveFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
        <ul>
          <li>
            <p>If you develop an application that requires the state to track many elements at once, you might consider state management libraries with atomic updates such as <a href="https://recoiljs.org/">recoil</a> or <a href="https://jotai.pmnd.rs/">jotai</a>.</p>
          </li>
          <li>
            <p>If your application is expected to have frequent updates that might affect performance, consider switching from runtime styling solutions (<a href="https://chakra-ui.com/">Chakra UI</a>, <a href="https://emotion.sh/docs/introduction">emotion</a>, <a href="https://styled-components.com/">styled-components</a> that generate styles during runtime) to zero runtime styling solutions (<a href="https://tailwindcss.com/">tailwind</a>, <a href="https://github.com/callstack/linaria">linaria</a>, <a href="https://github.com/seek-oss/vanilla-extract">vanilla-extract</a>, <a href="https://github.com/css-modules/css-modules">CSS modules</a> which generate styles during build time).</p>
          </li>
        </ul>
      </section>
      <section id="image-optimizations" class="level3">
        <h3>Image optimizations</h3>
        <p>Consider lazy loading images that are not in the viewport.</p>
        <p>Use modern image formats such as WEBP for faster image loading.</p>
        <p>Use <code>srcset</code> to load the most optimal image for the clients screen size.</p>
      </section>
      <section id="web-vitals" class="level3">
        <h3>Web vitals</h3>
        <p>
          Since Google started taking web vitals in account when indexing websites, you should keep an eye on web vitals scores from <a href="https://web.dev/measure/">Lighthouse</a> and <a href="https://pagespeed.web.dev/">Pagespeed Insights</a>.
          <span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span>
        </p>
      </section>
    </section>
  </body>
</html>
