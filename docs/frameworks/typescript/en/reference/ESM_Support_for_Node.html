<!doctype html><html lang="en"><meta charset="utf-8"><title>ECMAScript Modules in Node.js</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/esm-node.html"><meta name="oneline"content="Using ECMAScript Modules in Node.js"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><p>For the last few years, Node.js has been working to support running ECMAScript modules (ESM). This has been a very difficult feature to support, since the foundation of the Node.js ecosystem is built on a different module system called CommonJS (CJS).<p>Interoperating between the two module systems brings large challenges, with many new features to juggle; however, support for ESM in Node.js is now implemented in Node.js, and the dust has begun to settle.<p>That's why TypeScript brings two new <code>module</code> and <code>moduleResolution</code> settings: <code>node16</code> and <code>nodenext</code>.<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
    <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">"module"</span><span class="token operator">:</span> <span class="token string">"nodenext"</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>These new modes bring a few high-level features which we'll explore here.<section id="type-in-packagejson-and-new-extensions"class="level3"><h3><code>type</code> in <code>package.json</code> and New Extensions</h3><p>Node.js supports <a href="https://nodejs.org/api/packages.html#packages_package_json_and_file_extensions">a new setting in <code>package.json</code></a> called <code>type</code>. <code>"type"</code> can be set to either <code>"module"</code> or <code>"commonjs"</code>.<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"my-package"</span><span class="token punctuation">,</span>
    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"module"</span><span class="token punctuation">,</span>

    <span class="token property">"//"</span><span class="token operator">:</span> <span class="token string">"..."</span><span class="token punctuation">,</span>
    <span class="token property">"dependencies"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>This setting controls whether <code>.js</code> files are interpreted as ES modules or CommonJS modules, and defaults to CommonJS when not set. When a file is considered an ES module, a few different rules come into play compared to CommonJS:<ul><li><code>import</code>/<code>export</code> statements and top-level <code>await</code> can be used<li>relative import paths need full extensions (e.g we have to write <code>import "./foo.js"</code> instead of <code>import "./foo"</code>)<li>imports might resolve differently from dependencies in <code>node_modules</code><li>certain global-like values like <code>require()</code> and <code>__dirname</code> cannot be used directly<li>CommonJS modules get imported under certain special rules</ul><p>We'll come back to some of these.<p>To overlay the way TypeScript works in this system, <code>.ts</code> and <code>.tsx</code> files now work the same way. When TypeScript finds a <code>.ts</code>, <code>.tsx</code>, <code>.js</code>, or <code>.jsx</code> file, it will walk up looking for a <code>package.json</code> to see whether that file is an ES module, and use that to determine:<ul><li>how to find other modules which that file imports<li>and how to transform that file if producing outputs</ul><p>When a <code>.ts</code> file is compiled as an ES module, ECMAScript <code>import</code>/<code>export</code> syntax is left alone in the <code>.js</code> output; when it's compiled as a CommonJS module, it will produce the same output you get today under <a href="/tsconfig#module"><code>module</code></a>: <code>commonjs</code>.<p>This also means paths resolve differently between <code>.ts</code> files that are ES modules and ones that are CJS modules. For example, let's say you have the following code today:<pre class="language-ts"><code class="language-ts"><span class="token comment">// ./foo.ts</span>
<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// ./bar.ts</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> helper <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"./foo"</span><span class="token punctuation">;</span> <span class="token comment">// only works in CJS</span>

<span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This code works in CommonJS modules, but will fail in ES modules because relative import paths need to use extensions. As a result, it will have to be rewritten to use the extension of the <em>output</em> of <code>foo.ts</code> - so <code>bar.ts</code> will instead have to import from <code>./foo.js</code>.<pre class="language-ts"><code class="language-ts"><span class="token comment">// ./bar.ts</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> helper <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"./foo.js"</span><span class="token punctuation">;</span> <span class="token comment">// works in ESM &#x26; CJS</span>

<span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This might feel a bit cumbersome at first, but TypeScript tooling like auto-imports and path completion will typically just do this for you.<p>One other thing to mention is the fact that this applies to <code>.d.ts</code> files too. When TypeScript finds a <code>.d.ts</code> file in package, whether it is treated as an ESM or CommonJS file is based on the containing package.</section><section id="new-file-extensions"class="level3"><h3>New File Extensions</h3><p>The <code>type</code> field in <code>package.json</code> is nice because it allows us to continue using the <code>.ts</code> and <code>.js</code> file extensions which can be convenient; however, you will occasionally need to write a file that differs from what <code>type</code> specifies. You might also just prefer to always be explicit.<p>Node.js supports two extensions to help with this: <code>.mjs</code> and <code>.cjs</code>. <code>.mjs</code> files are always ES modules, and <code>.cjs</code> files are always CommonJS modules, and there's no way to override these.<p>In turn, TypeScript supports two new source file extensions: <code>.mts</code> and <code>.cts</code>. When TypeScript emits these to JavaScript files, it will emit them to <code>.mjs</code> and <code>.cjs</code> respectively.<p>Furthermore, TypeScript also supports two new declaration file extensions: <code>.d.mts</code> and <code>.d.cts</code>. When TypeScript generates declaration files for <code>.mts</code> and <code>.cts</code>, their corresponding extensions will be <code>.d.mts</code> and <code>.d.cts</code>.<p>Using these extensions is entirely optional, but will often be useful even if you choose not to use them as part of your primary workflow.</section><section id="commonjs-interop"class="level3"><h3>CommonJS Interop</h3><p>Node.js allows ES modules to import CommonJS modules as if they were ES modules with a default export.<pre class="language-ts"><code class="language-ts"><span class="token comment">// @module: nodenext</span>
<span class="token comment">// @filename: helper.cts</span>
<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// @filename: index.mts</span>
<span class="token keyword module">import</span> <span class="token imports">foo</span> <span class="token keyword module">from</span> <span class="token string">"./helper.cjs"</span><span class="token punctuation">;</span>

<span class="token comment">// prints "hello world!"</span>
foo<span class="token punctuation">.</span><span class="token method function property-access">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>In some cases, Node.js also synthesizes named exports from CommonJS modules, which can be more convenient. In these cases, ES modules can use a "namespace-style" import (i.e. <code>import * as foo from "..."</code>), or named imports (i.e. <code>import { helper } from "..."</code>).<pre class="language-ts"><code class="language-ts"><span class="token comment">// @module: nodenext</span>
<span class="token comment">// @filename: helper.cts</span>
<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// @filename: index.mts</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> helper <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"./helper.cjs"</span><span class="token punctuation">;</span>

<span class="token comment">// prints "hello world!"</span>
<span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>There isn't always a way for TypeScript to know whether these named imports will be synthesized, but TypeScript will err on being permissive and use some heuristics when importing from a file that is definitely a CommonJS module.<p>One TypeScript-specific note about interop is the following syntax:<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>In a CommonJS module, this just boils down to a <code>require()</code> call, and in an ES module, this imports <a href="https://nodejs.org/api/module.html#module_module_createrequire_filename"><code>createRequire</code></a> to achieve the same thing. This will make code less portable on runtimes like the browser (which don't support <code>require()</code>), but will often be useful for interoperability. In turn, you can write the above example using this syntax as follows:<pre class="language-ts"><code class="language-ts"><span class="token comment">// @module: nodenext</span>
<span class="token comment">// @filename: helper.cts</span>
<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// @filename: index.mts</span>
<span class="token keyword module">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">"./foo.cjs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

foo<span class="token punctuation">.</span><span class="token method function property-access">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>Finally, it's worth noting that the only way to import ESM files from a CJS module is using dynamic <code>import()</code> calls. This can present challenges, but is the behavior in Node.js today.<p>You can <a href="https://nodejs.org/api/esm.html#esm_interoperability_with_commonjs">read more about ESM/CommonJS interop in Node.js here</a>.</section><section id="packagejson-exports-imports-and-self-referencing"class="level3"><h3><code>package.json</code> Exports, Imports, and Self-Referencing</h3><p>Node.js supports <a href="https://nodejs.org/api/packages.html#packages_exports">a new field for defining entry points in <code>package.json</code> called <code>"exports"</code></a>. This field is a more powerful alternative to defining <code>"main"</code> in <code>package.json</code>, and can control what parts of your package are exposed to consumers.<p>Here's an <code>package.json</code> that supports separate entry-points for CommonJS and ESM:<pre class="language-json5"><code class="language-json5"><span class="token comment">// package.json</span>
<span class="token punctuation">{</span>
    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"my-package"</span><span class="token punctuation">,</span>
    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"module"</span><span class="token punctuation">,</span>
    <span class="token property">"exports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">"."</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token comment">// Entry-point for `import "my-package"` in ESM</span>
            <span class="token property">"import"</span><span class="token operator">:</span> <span class="token string">"./esm/index.js"</span><span class="token punctuation">,</span>

            <span class="token comment">// Entry-point for `require("my-package") in CJS</span>
            <span class="token property">"require"</span><span class="token operator">:</span> <span class="token string">"./commonjs/index.cjs"</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    <span class="token comment">// CJS fall-back for older versions of Node.js</span>
    <span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"./commonjs/index.cjs"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></code></pre><p>There's a lot to this feature, <a href="https://nodejs.org/api/packages.html">which you can read more about on the Node.js documentation</a>. Here we'll try to focus on how TypeScript supports it.<p>With TypeScript's original Node support, it would look for a <code>"main"</code> field, and then look for declaration files that corresponded to that entry. For example, if <code>"main"</code> pointed to <code>./lib/index.js</code>, TypeScript would look for a file called <code>./lib/index.d.ts</code>. A package author could override this by specifying a separate field called <code>"types"</code> (e.g. <code>"types": "./types/index.d.ts"</code>).<p>The new support works similarly with <a href="https://nodejs.org/api/packages.html">import conditions</a>. By default, TypeScript overlays the same rules with import conditions - if you write an <code>import</code> from an ES module, it will look up the <code>import</code> field, and from a CommonJS module, it will look at the <code>require</code> field. If it finds them, it will look for a colocated declaration file. If you need to point to a different location for your type declarations, you can add a <code>"types"</code> import condition.<pre class="language-json5"><code class="language-json5"><span class="token comment">// package.json</span>
<span class="token punctuation">{</span>
    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"my-package"</span><span class="token punctuation">,</span>
    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"module"</span><span class="token punctuation">,</span>
    <span class="token property">"exports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">"."</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token comment">// Entry-point for TypeScript resolution - must occur first!</span>
            <span class="token property">"types"</span><span class="token operator">:</span> <span class="token string">"./types/index.d.ts"</span><span class="token punctuation">,</span>

            <span class="token comment">// Entry-point for `import "my-package"` in ESM</span>
            <span class="token property">"import"</span><span class="token operator">:</span> <span class="token string">"./esm/index.js"</span><span class="token punctuation">,</span>

            <span class="token comment">// Entry-point for `require("my-package") in CJS</span>
            <span class="token property">"require"</span><span class="token operator">:</span> <span class="token string">"./commonjs/index.cjs"</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    <span class="token comment">// CJS fall-back for older versions of Node.js</span>
    <span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"./commonjs/index.cjs"</span><span class="token punctuation">,</span>

    <span class="token comment">// Fall-back for older versions of TypeScript</span>
    <span class="token property">"types"</span><span class="token operator">:</span> <span class="token string">"./types/index.d.ts"</span>
<span class="token punctuation">}</span></code></pre><p>TypeScript also supports <a href="https://nodejs.org/api/packages.html#packages_imports">the <code>"imports"</code> field of <code>package.json</code></a> in a similar manner (looking for declaration files alongside corresponding files), and supports <a href="https://nodejs.org/api/packages.html#packages_self_referencing_a_package_using_its_name">packages self-referencing themselves</a>. These features are generally not as involved, but are supported. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section>