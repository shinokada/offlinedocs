<!doctype html><html lang="en"><meta charset="utf-8"><title>Advanced Types</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/advanced-types.html"><meta name="oneline"content="Advanced concepts around types in TypeScript"><meta name="deprecated_by"content="/docs/handbook/2/types-from-types.html"><meta name="deprecation_redirects"content="type-guards-and-differentiating-types,/docs/handbook/2/narrowing.html,user-defined-type-guards,/docs/handbook/2/narrowing.html#using-type-predicates,typeof-type-guards,/docs/handbook/2/narrowing.html#typeof-type-guards,instanceof-type-guards,/docs/handbook/2/narrowing.html#instanceof-narrowing,nullable-types,/docs/handbook/2/everyday-types.html#null-and-undefined,type-aliases,/docs/handbook/2/everyday-types.html#type-aliases,interfaces-vs-type-aliases,/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces,enum-member-types,/docs/handbook/enums.html,polymorphic-this-types,/docs/handbook/2/classes.html,index-types,/docs/handbook/2/objects.html#index-signatures,index-types-and-index-signatures,/docs/handbook/2/indexed-access-types.html,mapped-types,/docs/handbook/2/mapped-types.html,inference-from-mapped-types,/docs/handbook/2/mapped-types.html,conditional-types,/docs/handbook/2/conditional-types.html,distributive-conditional-types,/docs/handbook/2/conditional-types.html#distributive-conditional-types,type-inference-in-conditional-types,/docs/handbook/2/conditional-types.html#inferring-within-conditional-types,predefined-conditional-types,/docs/handbook/utility-types.html,using-the-in-operator,/docs/handbook/2/narrowing.html#the-in-operator-narrowing,using-type-predicates,/docs/handbook/2/narrowing.html#using-type-predicates"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><p>This page lists some of the more advanced ways in which you can model types, it works in tandem with the <a href="/docs/handbook/utility-types.html">Utility Types</a> doc which includes types which are included in TypeScript and available globally.<section id="type-guards-and-differentiating-types"class="level2"><h2>Type Guards and Differentiating Types</h2><p>Union types are useful for modeling situations when values can overlap in the types they can take on. What happens when we need to know specifically whether we have a <code>Fish</code>? A common idiom in JavaScript to differentiate between two possible values is to check for the presence of a member. As we mentioned, you can only access members that are guaranteed to be in all the constituents of a union type.<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2339</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Fish</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function-variable function">swim</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Bird</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function-variable function">fly</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Fish</span> <span class="token operator">|</span> <span class="token maybe-class-name">Bird</span><span class="token punctuation">;</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">let</span> pet <span class="token operator">=</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// You can use the 'in' operator to check</span>
<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token string">"swim"</span> <span class="token keyword">in</span> pet<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  pet<span class="token punctuation">.</span><span class="token method function property-access">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// However, you cannot use property access</span>
<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>pet<span class="token punctuation">.</span><span class="token property-access">fly</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  pet<span class="token punctuation">.</span><span class="token method function property-access">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>To get the same code working via property accessors, we'll need to use a type assertion:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Fish</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function-variable function">swim</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Bird</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function-variable function">fly</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Fish</span> <span class="token operator">|</span> <span class="token maybe-class-name">Bird</span><span class="token punctuation">;</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">let</span> pet <span class="token operator">=</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> fishPet <span class="token operator">=</span> pet <span class="token keyword module">as</span> <span class="token maybe-class-name">Fish</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> birdPet <span class="token operator">=</span> pet <span class="token keyword module">as</span> <span class="token maybe-class-name">Bird</span><span class="token punctuation">;</span>

<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>fishPet<span class="token punctuation">.</span><span class="token property-access">swim</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  fishPet<span class="token punctuation">.</span><span class="token method function property-access">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>birdPet<span class="token punctuation">.</span><span class="token property-access">fly</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  birdPet<span class="token punctuation">.</span><span class="token method function property-access">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>This isn't the sort of code you would want in your codebase however.</section><section id="user-defined-type-guards"class="level2"><h2>User-Defined Type Guards</h2><p>It would be much better if once we performed the check, we could know the type of <code>pet</code> within each branch.<p>It just so happens that TypeScript has something called a <em>type guard</em>. A type guard is some expression that performs a runtime check that guarantees the type in some scope.<section id="using-type-predicates"class="level3"><h3>Using type predicates</h3><p>To define a type guard, we simply need to define a function whose return type is a <em>type predicate</em>:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Fish</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function-variable function">swim</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Bird</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function-variable function">fly</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Fish</span> <span class="token operator">|</span> <span class="token maybe-class-name">Bird</span><span class="token punctuation">;</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">function</span> <span class="token function">isFish</span><span class="token punctuation">(</span>pet<span class="token operator">:</span> <span class="token maybe-class-name">Fish</span> <span class="token operator">|</span> <span class="token maybe-class-name">Bird</span><span class="token punctuation">)</span><span class="token operator">:</span> pet <span class="token keyword">is</span> <span class="token maybe-class-name">Fish</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>pet <span class="token keyword module">as</span> <span class="token maybe-class-name">Fish</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">swim</span> <span class="token operator">!==</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><code>pet is Fish</code> is our type predicate in this example. A predicate takes the form <code>parameterName is Type</code>, where <code>parameterName</code> must be the name of a parameter from the current function signature.<p>Any time <code>isFish</code> is called with some variable, TypeScript will <em>narrow</em> that variable to that specific type if the original type is compatible.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Fish</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function-variable function">swim</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Bird</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function-variable function">fly</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Fish</span> <span class="token operator">|</span> <span class="token maybe-class-name">Bird</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">isFish</span><span class="token punctuation">(</span>pet<span class="token operator">:</span> <span class="token maybe-class-name">Fish</span> <span class="token operator">|</span> <span class="token maybe-class-name">Bird</span><span class="token punctuation">)</span><span class="token operator">:</span> pet <span class="token keyword">is</span> <span class="token maybe-class-name">Fish</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>pet <span class="token keyword module">as</span> <span class="token maybe-class-name">Fish</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">swim</span> <span class="token operator">!==</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// ---cut---</span>
<span class="token comment">// Both calls to 'swim' and 'fly' are now okay.</span>
<span class="token keyword">let</span> pet <span class="token operator">=</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isFish</span><span class="token punctuation">(</span>pet<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  pet<span class="token punctuation">.</span><span class="token method function property-access">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
  pet<span class="token punctuation">.</span><span class="token method function property-access">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Notice that TypeScript not only knows that <code>pet</code> is a <code>Fish</code> in the <code>if</code> branch; it also knows that in the <code>else</code> branch, you <em>don't</em> have a <code>Fish</code>, so you must have a <code>Bird</code>.<p>You may use the type guard <code>isFish</code> to filter an array of <code>Fish | Bird</code> and obtain an array of <code>Fish</code>:<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2345</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Fish</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function-variable function">swim</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Bird</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function-variable function">fly</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Fish</span> <span class="token operator">|</span> <span class="token maybe-class-name">Bird</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">isFish</span><span class="token punctuation">(</span>pet<span class="token operator">:</span> <span class="token maybe-class-name">Fish</span> <span class="token operator">|</span> <span class="token maybe-class-name">Bird</span><span class="token punctuation">)</span><span class="token operator">:</span> pet <span class="token keyword">is</span> <span class="token maybe-class-name">Fish</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>pet <span class="token keyword module">as</span> <span class="token maybe-class-name">Fish</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">swim</span> <span class="token operator">!==</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">const</span> zoo<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token maybe-class-name">Fish</span> <span class="token operator">|</span> <span class="token maybe-class-name">Bird</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> underWater1<span class="token operator">:</span> <span class="token maybe-class-name">Fish</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> zoo<span class="token punctuation">.</span><span class="token method function property-access">filter</span><span class="token punctuation">(</span>isFish<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// or, equivalently</span>
<span class="token keyword">const</span> underWater2<span class="token operator">:</span> <span class="token maybe-class-name">Fish</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> zoo<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">filter</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Fish</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>isFish<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> underWater3<span class="token operator">:</span> <span class="token maybe-class-name">Fish</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> zoo<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">filter</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Fish</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>pet<span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">isFish</span><span class="token punctuation">(</span>pet<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section><section id="using-the-in-operator"class="level3"><h3>Using the <code>in</code> operator</h3><p>The <code>in</code> operator also acts as a narrowing expression for types.<p>For a <code>n in x</code> expression, where <code>n</code> is a string literal or string literal type and <code>x</code> is a union type, the "true" branch narrows to types which have an optional or required property <code>n</code>, and the "false" branch narrows to types which have an optional or missing property <code>n</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Fish</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function-variable function">swim</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Bird</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function-variable function">fly</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">function</span> <span class="token function">move</span><span class="token punctuation">(</span>pet<span class="token operator">:</span> <span class="token maybe-class-name">Fish</span> <span class="token operator">|</span> <span class="token maybe-class-name">Bird</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token string">"swim"</span> <span class="token keyword">in</span> pet<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> pet<span class="token punctuation">.</span><span class="token method function property-access">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> pet<span class="token punctuation">.</span><span class="token method function property-access">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></section></section><section id="typeof-type-guards"class="level2"><h2><code>typeof</code> type guards</h2><p>Let's go back and write the code for a version of <code>padLeft</code> which uses union types. We could write it with type predicates as follows:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">isNumber</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> x <span class="token keyword">is</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">"number"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">isString</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> x <span class="token keyword">is</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">"string"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">padLeft</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> padding<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isNumber</span><span class="token punctuation">(</span>padding<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">Array</span><span class="token punctuation">(</span>padding <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">join</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>padding<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> padding <span class="token operator">+</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">throw</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Error</span></span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Expected string or number, got '</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>padding<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>However, having to define a function to figure out if a type is a primitive is kind of a pain. Luckily, you don't need to abstract <code>typeof x === "number"</code> into its own function because TypeScript will recognize it as a type guard on its own. That means we could just write these checks inline.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">padLeft</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> padding<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">"number"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">Array</span><span class="token punctuation">(</span>padding <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">join</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">"string"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> padding <span class="token operator">+</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">throw</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Error</span></span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Expected string or number, got '</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>padding<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>These <em><code>typeof</code> type guards</em> are recognized in two different forms: <code>typeof v === "typename"</code> and <code>typeof v !== "typename"</code>, where <code>"typename"</code> can be one of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#Description"><code>typeof</code> operator's return values</a> (<code>"undefined"</code>, <code>"number"</code>, <code>"string"</code>, <code>"boolean"</code>, <code>"bigint"</code>, <code>"symbol"</code>, <code>"object"</code>, or <code>"function"</code>). While TypeScript won't stop you from comparing to other strings, the language won't recognize those expressions as type guards.</section><section id="instanceof-type-guards"class="level2"><h2><code>instanceof</code> type guards</h2><p>If you've read about <code>typeof</code> type guards and are familiar with the <code>instanceof</code> operator in JavaScript, you probably have some idea of what this section is about.<p><em><code>instanceof</code> type guards</em> are a way of narrowing types using their constructor function. For instance, let's borrow our industrial strength string-padder example from earlier:<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Padder</span></span> <span class="token punctuation">{</span>
  <span class="token function">getPaddingString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">SpaceRepeatingPadder</span></span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token maybe-class-name">Padder</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> numSpaces<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">getPaddingString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">Array</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">numSpaces</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">join</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">StringPadder</span></span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token maybe-class-name">Padder</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">getPaddingString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getRandomPadder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token method function property-access">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&#x3C;</span> <span class="token number">0.5</span>
    <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">SpaceRepeatingPadder</span></span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">StringPadder</span></span><span class="token punctuation">(</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> padder<span class="token operator">:</span> <span class="token maybe-class-name">Padder</span> <span class="token operator">=</span> <span class="token function">getRandomPadder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//       ^?</span>

<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>padder <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token maybe-class-name">SpaceRepeatingPadder</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  padder<span class="token punctuation">;</span>
  <span class="token comment">//   ^?</span>
<span class="token punctuation">}</span>
<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>padder <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token maybe-class-name">StringPadder</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  padder<span class="token punctuation">;</span>
  <span class="token comment">//   ^?</span>
<span class="token punctuation">}</span></code></pre><p>The right side of the <code>instanceof</code> needs to be a constructor function, and TypeScript will narrow down to:<ol><li>the type of the function's <code>prototype</code> property if its type is not <code>any</code><li>the union of types returned by that type's construct signatures</ol><p>in that order.</section><section id="nullable-types"class="level2"><h2>Nullable types</h2><p>TypeScript has two special types, <code>null</code> and <code>undefined</code>, that have the values null and undefined respectively. We mentioned these briefly in <a href="/docs/handbook/basic-types.html">the Basic Types section</a>.<p>By default, the type checker considers <code>null</code> and <code>undefined</code> assignable to anything. Effectively, <code>null</code> and <code>undefined</code> are valid values of every type. That means it's not possible to <em>stop</em> them from being assigned to any type, even when you would like to prevent it. The inventor of <code>null</code>, Tony Hoare, calls this his <a href="https://wikipedia.org/wiki/Null_pointer#History">"billion dollar mistake"</a>.<p>The <a href="/tsconfig#strictNullChecks"><code>strictNullChecks</code></a> flag fixes this: when you declare a variable, it doesn't automatically include <code>null</code> or <code>undefined</code>. You can include them explicitly using a union type:<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2322</span>
<span class="token keyword">let</span> exampleString <span class="token operator">=</span> <span class="token string">"foo"</span><span class="token punctuation">;</span>
exampleString <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> stringOrNull<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span> <span class="token operator">=</span> <span class="token string">"bar"</span><span class="token punctuation">;</span>
stringOrNull <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>

stringOrNull <span class="token operator">=</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span></code></pre><p>Note that TypeScript treats <code>null</code> and <code>undefined</code> differently in order to match JavaScript semantics. <code>string | null</code> is a different type than <code>string | undefined</code> and <code>string | undefined | null</code>.<p>From TypeScript 3.7 and onwards, you can use <a href="/docs/handbook/release-notes/typescript-3-7.html#optional-chaining">optional chaining</a> to simplify working with nullable types.<section id="optional-parameters-and-properties"class="level3"><h3>Optional parameters and properties</h3><p>With <a href="/tsconfig#strictNullChecks"><code>strictNullChecks</code></a>, an optional parameter automatically adds <code>| undefined</code>:<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2345</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> x <span class="token operator">+</span> <span class="token punctuation">(</span>y <span class="token operator">??</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword nil">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The same is true for optional properties:<pre class="language-ts"><code class="language-ts"><span class="token comment">// @strict: false</span>
<span class="token comment">// @strictNullChecks: true</span>
<span class="token comment">// @errors: 2322</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  b<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

c<span class="token punctuation">.</span><span class="token property-access">a</span> <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span><span class="token property-access">a</span> <span class="token operator">=</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span><span class="token property-access">b</span> <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span><span class="token property-access">b</span> <span class="token operator">=</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span><span class="token property-access">b</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span></code></pre></section><section id="type-guards-and-type-assertions"class="level3"><h3>Type guards and type assertions</h3><p>Since nullable types are implemented with a union, you need to use a type guard to get rid of the <code>null</code>. Fortunately, this is the same code you'd write in JavaScript:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>stringOrNull<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>stringOrNull <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token string">"default"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> stringOrNull<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>The <code>null</code> elimination is pretty obvious here, but you can use terser operators too:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>stringOrNull<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> stringOrNull <span class="token operator">??</span> <span class="token string">"default"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>In cases where the compiler can't eliminate <code>null</code> or <code>undefined</code>, you can use the type assertion operator to manually remove them. The syntax is postfix <code>!</code>: <code>identifier!</code> removes <code>null</code> and <code>undefined</code> from the type of <code>identifier</code>:<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2532</span>
<span class="token keyword">function</span> <span class="token function">getUser</span><span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">UserAccount</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword module">as</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">UserAccount</span></span> <span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  email<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
user<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">;</span>

<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  user<span class="token punctuation">.</span><span class="token property-access">email</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Instead if you are sure that these objects or fields exist, the</span>
<span class="token comment">// postfix ! lets you short circuit the nullability</span>
user<span class="token operator">!</span><span class="token punctuation">.</span><span class="token property-access">email</span><span class="token operator">!</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span></code></pre></section></section><section id="type-aliases"class="level2"><h2>Type Aliases</h2><p>Type aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you'd otherwise have to write by hand.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Second</span></span> <span class="token operator">=</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> timeInSecond<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> time<span class="token operator">:</span> <span class="token maybe-class-name">Second</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>Aliasing doesn't actually create a new type - it creates a new <em>name</em> to refer to that type. Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.<p>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Container</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>We can also have a type alias refer to itself in a property:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Tree</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
  left<span class="token operator">?</span><span class="token operator">:</span> <span class="token maybe-class-name">Tree</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">;</span>
  right<span class="token operator">?</span><span class="token operator">:</span> <span class="token maybe-class-name">Tree</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Together with <a href="/docs/handbook/unions-and-intersections.html">intersection</a> types, we can make some pretty mind-bending types:<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">getDriversLicenseQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">LinkedList</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Person</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">LinkedList</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Type</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Type</span> <span class="token operator">&#x26;</span> <span class="token punctuation">{</span> next<span class="token operator">:</span> <span class="token maybe-class-name">LinkedList</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Type</span><span class="token operator">></span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Person</span></span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> people <span class="token operator">=</span> <span class="token function">getDriversLicenseQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
people<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">;</span>
people<span class="token punctuation">.</span><span class="token property-access">next</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">;</span>
people<span class="token punctuation">.</span><span class="token property-access">next</span><span class="token punctuation">.</span><span class="token property-access">next</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">;</span>
people<span class="token punctuation">.</span><span class="token property-access">next</span><span class="token punctuation">.</span><span class="token property-access">next</span><span class="token punctuation">.</span><span class="token property-access">next</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">;</span>
<span class="token comment">//                  ^?</span></code></pre></section><section id="interfaces-vs-type-aliases"class="level2"><h2>Interfaces vs. Type Aliases</h2><p>As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.<p>Almost all features of an <code>interface</code> are available in <code>type</code>, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.<table class="full-width-table"><tr><th><code>Interface</code><th><code>Type</code><tr><td><p>Extending an interface</p><code><pre>interface Animal {
  name: string
}<br>
interface Bear extends Animal {
  honey: boolean
}<br>
const bear = getBear() 
bear.name
bear.honey
        </pre></code><td><p>Extending a type via intersections</p><code><pre>type Animal = {
  name: string
}<br>
type Bear = Animal &#x26; { 
  honey: Boolean 
}<br>
const bear = getBear();
bear.name;
bear.honey;
        </pre></code><tr><td><p>Adding new fields to an existing interface</p><code><pre>interface Window {
  title: string
}<br>
interface Window {
  ts: import("typescript")
}<br>
const src = 'const a = "Hello World"';
window.ts.transpileModule(src, {});
        </pre></code><td><p>A type cannot be changed after being created</p><code><pre>type Window = {
  title: string
}<br>
type Window = {
  ts: import("typescript")
}<br>
// Error: Duplicate identifier 'Window'.<br>
        </pre></code></table><p>Because an interface more closely maps how JavaScript objects work <a href="https://wikipedia.org/wiki/Open/closed_principle">by being open to extension</a>, we recommend using an interface over a type alias when possible.<p>On the other hand, if you can't express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</section><section id="enum-member-types"class="level2"><h2>Enum Member Types</h2><p>As mentioned in <a href="./enums.html#union-enums-and-enum-member-types">our section on enums</a>, enum members have types when every member is literal-initialized.<p>Much of the time when we talk about "singleton types", we're referring to both enum member types as well as numeric/string literal types, though many users will use "singleton types" and "literal types" interchangeably.</section><section id="polymorphic-this-types"class="level2"><h2>Polymorphic <code>this</code> types</h2><p>A polymorphic <code>this</code> type represents a type that is the <em>subtype</em> of the containing class or interface. This is called <em>F</em>-bounded polymorphism, a lot of people know it as the <a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent API</a> pattern. This makes hierarchical fluent interfaces much easier to express, for example. Take a simple calculator that returns <code>this</code> after each operation:<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">BasicCalculator</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">protected</span> value<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token function">currentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token function">add</span><span class="token punctuation">(</span>operand<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">+=</span> operand<span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token function">multiply</span><span class="token punctuation">(</span>operand<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">*=</span> operand<span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ... other operations go here ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">BasicCalculator</span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">multiply</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">currentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Since the class uses <code>this</code> types, you can extend it and the new class can use the old methods with no changes.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">BasicCalculator</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">protected</span> value<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token function">currentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token function">add</span><span class="token punctuation">(</span>operand<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">+=</span> operand<span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token function">multiply</span><span class="token punctuation">(</span>operand<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">*=</span> operand<span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ... other operations go here ...</span>
<span class="token punctuation">}</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">ScientificCalculator</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">BasicCalculator</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token function">constructor</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token method function property-access">sin</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ... other operations go here ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">ScientificCalculator</span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">multiply</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">sin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">currentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Without <code>this</code> types, <code>ScientificCalculator</code> would not have been able to extend <code>BasicCalculator</code> and keep the fluent interface. <code>multiply</code> would have returned <code>BasicCalculator</code>, which doesn't have the <code>sin</code> method. However, with <code>this</code> types, <code>multiply</code> returns <code>this</code>, which is <code>ScientificCalculator</code> here.</section><section id="index-types"class="level2"><h2>Index types</h2><p>With index types, you can get the compiler to check code that uses dynamic property names. For example, a common JavaScript pattern is to pick a subset of properties from an object:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">pluck</span><span class="token punctuation">(</span><span class="token parameter">o<span class="token punctuation">,</span> propertyNames</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> propertyNames<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> o<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Here's how you would write and use this function in TypeScript, using the <strong>index type query</strong> and <strong>indexed access</strong> operators:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">pluck</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>o<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> propertyNames<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> propertyNames<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token arrow operator">=></span> o<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Car</span></span> <span class="token punctuation">{</span>
  manufacturer<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  model<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  year<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> taxi<span class="token operator">:</span> <span class="token maybe-class-name">Car</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  manufacturer<span class="token operator">:</span> <span class="token string">"Toyota"</span><span class="token punctuation">,</span>
  model<span class="token operator">:</span> <span class="token string">"Camry"</span><span class="token punctuation">,</span>
  year<span class="token operator">:</span> <span class="token number">2014</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Manufacturer and model are both of type string,</span>
<span class="token comment">// so we can pluck them both into a typed string array</span>
<span class="token keyword">let</span> makeAndModel<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">pluck</span><span class="token punctuation">(</span>taxi<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"manufacturer"</span><span class="token punctuation">,</span> <span class="token string">"model"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// If we try to pluck model and year, we get an</span>
<span class="token comment">// array of a union type: (string | number)[]</span>
<span class="token keyword">let</span> modelYear <span class="token operator">=</span> <span class="token function">pluck</span><span class="token punctuation">(</span>taxi<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"model"</span><span class="token punctuation">,</span> <span class="token string">"year"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The compiler checks that <code>manufacturer</code> and <code>model</code> are actually properties on <code>Car</code>. The example introduces a couple of new type operators. First is <code>keyof T</code>, the <strong>index type query operator</strong>. For any type <code>T</code>, <code>keyof T</code> is the union of known, public property names of <code>T</code>. For example:<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Car</span></span> <span class="token punctuation">{</span>
  manufacturer<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  model<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  year<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">let</span> carProps<span class="token operator">:</span> <span class="token keyword">keyof</span> <span class="token maybe-class-name">Car</span><span class="token punctuation">;</span>
<span class="token comment">//         ^?</span></code></pre><p><code>keyof Car</code> is completely interchangeable with <code>"manufacturer" | "model" | "year"</code>. The difference is that if you add another property to <code>Car</code>, say <code>ownersAddress: string</code>, then <code>keyof Car</code> will automatically update to be <code>"manufacturer" | "model" | "year" | "ownersAddress"</code>. And you can use <code>keyof</code> in generic contexts like <code>pluck</code>, where you can't possibly know the property names ahead of time. That means the compiler will check that you pass the right set of property names to <code>pluck</code>:<pre class="language-ts"><code class="language-ts"><span class="token comment">// error, Type '"unknown"' is not assignable to type '"manufacturer" | "model" | "year"'</span>
<span class="token function">pluck</span><span class="token punctuation">(</span>taxi<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"year"</span><span class="token punctuation">,</span> <span class="token string">"unknown"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The second operator is <code>T[K]</code>, the <strong>indexed access operator</strong>. Here, the type syntax reflects the expression syntax. That means that <code>taxi["manufacturer"]</code> has the type <code>Car["manufacturer"]</code> — which in our example is just <code>string</code>. However, just like index type queries, you can use <code>T[K]</code> in a generic context, which is where its real power comes to life. You just have to make sure that the type variable <code>K extends keyof T</code>. Here's another example with a function named <code>getProperty</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">getProperty</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>o<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> propertyName<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> o<span class="token punctuation">[</span>propertyName<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// o[propertyName] is of type T[K]</span>
<span class="token punctuation">}</span></code></pre><p>In <code>getProperty</code>, <code>o: T</code> and <code>propertyName: K</code>, so that means <code>o[propertyName]: T[K]</code>. Once you return the <code>T[K]</code> result, the compiler will instantiate the actual type of the key, so the return type of <code>getProperty</code> will vary according to which property you request.<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2345</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">getProperty</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>o<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> propertyName<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> o<span class="token punctuation">[</span>propertyName<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// o[propertyName] is of type T[K]</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Car</span></span> <span class="token punctuation">{</span>
  manufacturer<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  model<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  year<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> taxi<span class="token operator">:</span> <span class="token maybe-class-name">Car</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  manufacturer<span class="token operator">:</span> <span class="token string">"Toyota"</span><span class="token punctuation">,</span>
  model<span class="token operator">:</span> <span class="token string">"Camry"</span><span class="token punctuation">,</span>
  year<span class="token operator">:</span> <span class="token number">2014</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">let</span> manufacturer<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token function">getProperty</span><span class="token punctuation">(</span>taxi<span class="token punctuation">,</span> <span class="token string">"manufacturer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> year<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token function">getProperty</span><span class="token punctuation">(</span>taxi<span class="token punctuation">,</span> <span class="token string">"year"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> <span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token function">getProperty</span><span class="token punctuation">(</span>taxi<span class="token punctuation">,</span> <span class="token string">"unknown"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section><section id="index-types-and-index-signatures"class="level2"><h2>Index types and index signatures</h2><p><code>keyof</code> and <code>T[K]</code> interact with index signatures. An index signature parameter type must be 'string' or 'number'. If you have a type with a string index signature, <code>keyof T</code> will be <code>string | number</code> (and not just <code>string</code>, since in JavaScript you can access an object property either by using strings (<code>object["42"]</code>) or numbers (<code>object[42]</code>)). And <code>T[string]</code> is just the type of the index signature:<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Dictionary</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> keys<span class="token operator">:</span> <span class="token keyword">keyof</span> <span class="token maybe-class-name">Dictionary</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//     ^?</span>
<span class="token keyword">let</span> value<span class="token operator">:</span> <span class="token maybe-class-name">Dictionary</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//      ^?</span></code></pre><p>If you have a type with a number index signature, <code>keyof T</code> will just be <code>number</code>.<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2339</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Dictionary</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> keys<span class="token operator">:</span> <span class="token keyword">keyof</span> <span class="token maybe-class-name">Dictionary</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//     ^?</span>
<span class="token keyword">let</span> numberValue<span class="token operator">:</span> <span class="token maybe-class-name">Dictionary</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//     ^?</span>
<span class="token keyword">let</span> value<span class="token operator">:</span> <span class="token maybe-class-name">Dictionary</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></section><section id="mapped-types"class="level2"><h2>Mapped types</h2><p>A common task is to take an existing type and make each of its properties optional:<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">PersonSubset</span></span> <span class="token punctuation">{</span>
  name<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Or we might want a readonly version:<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">PersonReadonly</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token keyword">readonly</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types — <strong>mapped types</strong>. In a mapped type, the new type transforms each property in the old type in the same way. For example, you can make all properties optional or of a type <code>readonly</code>. Here are a couple of examples:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Partial</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// @noErrors</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Readonly</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>And to use it:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Person</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">PersonPartial</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Partial</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Person</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">ReadonlyPerson</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Readonly</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Person</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span></code></pre><p>Note that this syntax describes a type rather than a member. If you want to add members, you can use an intersection type:<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2693 1005 1128 7061</span>
<span class="token comment">// Use this:</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">PartialWithNewMember</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token operator">&#x26;</span> <span class="token punctuation">{</span> newMember<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">}</span>

<span class="token comment">// This is an error!</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">WrongPartialWithNewMember</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  newMember<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Let's take a look at the simplest mapped type and its parts:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Keys</span></span> <span class="token operator">=</span> <span class="token string">"option1"</span> <span class="token operator">|</span> <span class="token string">"option2"</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Flags</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token maybe-class-name">Keys</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>The syntax resembles the syntax for index signatures with a <code>for .. in</code> inside. There are three parts:<ol><li>The type variable <code>K</code>, which gets bound to each property in turn.<li>The string literal union <code>Keys</code>, which contains the names of properties to iterate over.<li>The resulting type of the property.</ol><p>In this simple example, <code>Keys</code> is a hard-coded list of property names and the property type is always <code>boolean</code>, so this mapped type is equivalent to writing:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Flags</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  option1<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  option2<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Real applications, however, look like <code>Readonly</code> or <code>Partial</code> above. They're based on some existing type, and they transform the properties in some way. That's where <code>keyof</code> and indexed access types come in:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Person</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">NullablePerson</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token maybe-class-name">Person</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token maybe-class-name">Person</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">PartialPerson</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token maybe-class-name">Person</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token maybe-class-name">Person</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span></code></pre><p>But it's more useful to have a general version.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Nullable</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Partial</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>In these examples, the properties list is <code>keyof T</code> and the resulting type is some variant of <code>T[P]</code>. This is a good template for any general use of mapped types. That's because this kind of transformation is <a href="https://wikipedia.org/wiki/Homomorphism">homomorphic</a>, which means that the mapping applies only to properties of <code>T</code> and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if <code>Person.name</code> was readonly, <code>Partial&#x3C;Person>.name</code> would be readonly and optional.<p>Here's one more example, in which <code>T[P]</code> is wrapped in a <code>Proxy&#x3C;T></code> class:<pre class="language-ts"><code class="language-ts"><span class="token comment">// @noErrors</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token known-class-name class-name">Proxy</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
  <span class="token function">set</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Proxify</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token known-class-name class-name">Proxy</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">proxify</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>o<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Proxify</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment">// ... wrap proxies ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> props <span class="token operator">=</span> <span class="token punctuation">{</span> rooms<span class="token operator">:</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> proxyProps <span class="token operator">=</span> <span class="token function">proxify</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//  ^?</span></code></pre><p>Note that <code>Readonly&#x3C;T></code> and <code>Partial&#x3C;T></code> are so useful, they are included in TypeScript's standard library along with <code>Pick</code> and <code>Record</code>:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Pick</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Record</span><span class="token operator">&#x3C;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><code>Readonly</code>, <code>Partial</code> and <code>Pick</code> are homomorphic whereas <code>Record</code> is not. One clue that <code>Record</code> is not homomorphic is that it doesn't take an input type to copy properties from:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">ThreeStringProps</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Record</span><span class="token operator">&#x3C;</span><span class="token string">"prop1"</span> <span class="token operator">|</span> <span class="token string">"prop2"</span> <span class="token operator">|</span> <span class="token string">"prop3"</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>Non-homomorphic types are essentially creating new properties, so they can't copy property modifiers from anywhere.<p>Note that <code>keyof any</code> represents the type of any value that can be used as an index to an object. In otherwords, <code>keyof any</code> is currently equal to <code>string | number | symbol</code>.</section><section id="inference-from-mapped-types"class="level2"><h2>Inference from mapped types</h2><p>Now that you know how to wrap the properties of a type, the next thing you'll want to do is unwrap them. Fortunately, that's pretty easy:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token known-class-name class-name">Proxy</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
  <span class="token function">set</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Proxify</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token known-class-name class-name">Proxy</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">proxify</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>o<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Proxify</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword module">as</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> props <span class="token operator">=</span> <span class="token punctuation">{</span> rooms<span class="token operator">:</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> proxyProps <span class="token operator">=</span> <span class="token function">proxify</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">unproxify</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>t<span class="token operator">:</span> <span class="token maybe-class-name">Proxify</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword module">as</span> <span class="token constant">T</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> k <span class="token keyword">in</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> originalProps <span class="token operator">=</span> <span class="token function">unproxify</span><span class="token punctuation">(</span>proxyProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//  ^?</span></code></pre><p>Note that this unwrapping inference only works on homomorphic mapped types. If the mapped type is not homomorphic you'll have to give an explicit type parameter to your unwrapping function.</section><section id="conditional-types"class="level2"><h2>Conditional Types</h2><p>A conditional type selects one of two possible types based on a condition expressed as a type relationship test:<pre class="language-ts"><code class="language-ts"><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token constant">X</span> <span class="token operator">:</span> <span class="token constant">Y</span></code></pre><p>The type above means when <code>T</code> is assignable to <code>U</code> the type is <code>X</code>, otherwise the type is <code>Y</code>.<p>A conditional type <code>T extends U ? X : Y</code> is either <em>resolved</em> to <code>X</code> or <code>Y</code>, or <em>deferred</em> because the condition depends on one or more type variables. When <code>T</code> or <code>U</code> contains type variables, whether to resolve to <code>X</code> or <code>Y</code>, or to defer, is determined by whether or not the type system has enough information to conclude that <code>T</code> is always assignable to <code>U</code>.<p>As an example of some types that are immediately resolved, we can take a look at the following example:<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">f</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">boolean</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">true</span></span> <span class="token operator">?</span> <span class="token builtin">string</span> <span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

<span class="token comment">// Type is 'string | number'</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token method function property-access">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&#x3C;</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//  ^?</span></code></pre><p>Another example would be the <code>TypeName</code> type alias, which uses nested conditional types:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span>
  <span class="token operator">?</span> <span class="token string">"string"</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span>
  <span class="token operator">?</span> <span class="token string">"number"</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span>
  <span class="token operator">?</span> <span class="token string">"boolean"</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword nil">undefined</span></span>
  <span class="token operator">?</span> <span class="token string">"undefined"</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token known-class-name class-name">Function</span></span>
  <span class="token operator">?</span> <span class="token string">"function"</span>
  <span class="token operator">:</span> <span class="token string">"object"</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T0</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token string">"a"</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token boolean">true</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T3</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T4</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span></code></pre><p>But as an example of a place where conditional types are deferred - where they stick around instead of picking a branch - would be in the following:<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span> <span class="token punctuation">{</span>
  propA<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  propB<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">f</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span> <span class="token operator">?</span> <span class="token builtin">string</span> <span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">U</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Has type 'U extends Foo ? string : number'</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// This assignment is allowed though!</span>
  <span class="token keyword">let</span> b<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>In the above, the variable <code>a</code> has a conditional type that hasn't yet chosen a branch. When another piece of code ends up calling <code>foo</code>, it will substitute in <code>U</code> with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.<p>In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target. So in our example above we were able to assign <code>U extends Foo ? string : number</code> to <code>string | number</code> since no matter what the conditional evaluates to, it's known to be either <code>string</code> or <code>number</code>.</section><section id="distributive-conditional-types"class="level2"><h2>Distributive conditional types</h2><p>Conditional types in which the checked type is a naked type parameter are called <em>distributive conditional types</em>. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of <code>T extends U ? X : Y</code> with the type argument <code>A | B | C</code> for <code>T</code> is resolved as <code>(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</code>.<section id="example"class="level4"><h4>Example</h4><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span>
  <span class="token operator">?</span> <span class="token string">"string"</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span>
  <span class="token operator">?</span> <span class="token string">"number"</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span>
  <span class="token operator">?</span> <span class="token string">"boolean"</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword nil">undefined</span></span>
  <span class="token operator">?</span> <span class="token string">"undefined"</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token known-class-name class-name">Function</span></span>
  <span class="token operator">?</span> <span class="token string">"function"</span>
  <span class="token operator">:</span> <span class="token string">"object"</span><span class="token punctuation">;</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T5</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T6</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T7</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span></code></pre><p>In instantiations of a distributive conditional type <code>T extends U ? X : Y</code>, references to <code>T</code> within the conditional type are resolved to individual constituents of the union type (i.e. <code>T</code> refers to the individual constituents <em>after</em> the conditional type is distributed over the union type). Furthermore, references to <code>T</code> within <code>X</code> have an additional type parameter constraint <code>U</code> (i.e. <code>T</code> is considered assignable to <code>U</code> within <code>X</code>).</section><section id="example-1"class="level4"><h4>Example</h4><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">BoxedValue</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">BoxedArray</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> array<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Boxed</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token maybe-class-name">BoxedArray</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">:</span> <span class="token maybe-class-name">BoxedValue</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Boxed</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Boxed</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T3</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Boxed</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span></code></pre><p>Notice that <code>T</code> has the additional constraint <code>any[]</code> within the true branch of <code>Boxed&#x3C;T></code> and it is therefore possible to refer to the element type of the array as <code>T[number]</code>. Also, notice how the conditional type is distributed over the union type in the last example.<p>The distributive property of conditional types can conveniently be used to <em>filter</em> union types:<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2300 2322</span>
<span class="token comment">// Remove types from T that are assignable to U</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Diff</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token comment">// Remove types from T that are not assignable to U</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Filter</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token constant">T</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Diff</span><span class="token operator">&#x3C;</span><span class="token string">"a"</span> <span class="token operator">|</span> <span class="token string">"b"</span> <span class="token operator">|</span> <span class="token string">"c"</span> <span class="token operator">|</span> <span class="token string">"d"</span><span class="token punctuation">,</span> <span class="token string">"a"</span> <span class="token operator">|</span> <span class="token string">"c"</span> <span class="token operator">|</span> <span class="token string">"f"</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Filter</span><span class="token operator">&#x3C;</span><span class="token string">"a"</span> <span class="token operator">|</span> <span class="token string">"b"</span> <span class="token operator">|</span> <span class="token string">"c"</span> <span class="token operator">|</span> <span class="token string">"d"</span><span class="token punctuation">,</span> <span class="token string">"a"</span> <span class="token operator">|</span> <span class="token string">"c"</span> <span class="token operator">|</span> <span class="token string">"f"</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "a" | "c"</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T3</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Diff</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token known-class-name class-name">Function</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// string | number</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T4</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Filter</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token known-class-name class-name">Function</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// () => void</span>
<span class="token comment">//   ^?</span>

<span class="token comment">// Remove null and undefined from T</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">NotNullable</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Diff</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token keyword null nil">null</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T5</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">NotNullable</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T6</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">NotNullable</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">f1</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token maybe-class-name">NotNullable</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  x <span class="token operator">=</span> y<span class="token punctuation">;</span>
  y <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">f2</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token maybe-class-name">NotNullable</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  x <span class="token operator">=</span> y<span class="token punctuation">;</span>
  y <span class="token operator">=</span> x<span class="token punctuation">;</span>
  <span class="token keyword">let</span> s1<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
  <span class="token keyword">let</span> s2<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Conditional types are particularly useful when combined with mapped types:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">FunctionPropertyNames</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token known-class-name class-name">Function</span></span> <span class="token operator">?</span> <span class="token constant">K</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">FunctionProperties</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Pick</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token maybe-class-name">FunctionPropertyNames</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">>></span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">NonFunctionPropertyNames</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token known-class-name class-name">Function</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">NonFunctionProperties</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Pick</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token maybe-class-name">NonFunctionPropertyNames</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">>></span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Part</span></span> <span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  subparts<span class="token operator">:</span> <span class="token maybe-class-name">Part</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">updatePart</span><span class="token punctuation">(</span>newName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">FunctionPropertyNames</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Part</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">NonFunctionPropertyNames</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Part</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T3</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">FunctionProperties</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Part</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T4</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">NonFunctionProperties</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Part</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span></code></pre><p>Note, conditional types are not permitted to reference themselves recursively. For example the following is an error.</section><section id="example-2"class="level4"><h4>Example</h4><pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2456 2315</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">ElementType</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token maybe-class-name">ElementType</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span> <span class="token comment">// Error</span></code></pre></section></section><section id="type-inference-in-conditional-types"class="level2"><h2>Type inference in conditional types</h2><p>Within the <code>extends</code> clause of a conditional type, it is now possible to have <code>infer</code> declarations that introduce a type variable to be inferred. Such inferred type variables may be referenced in the true branch of the conditional type. It is possible to have multiple <code>infer</code> locations for the same type variable.<p>For example, the following extracts the return type of a function type:<pre class="language-ts"><code class="language-ts"><span class="token comment">// @noErrors</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">infer</span> <span class="token constant">R</span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span></code></pre><p>Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Unpacked</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token operator">?</span> <span class="token constant">U</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">infer</span> <span class="token constant">U</span>
  <span class="token operator">?</span> <span class="token constant">U</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token keyword">infer</span> <span class="token constant">U</span><span class="token operator">></span></span>
  <span class="token operator">?</span> <span class="token constant">U</span>
  <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T0</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Unpacked</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Unpacked</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Unpacked</span><span class="token operator">&#x3C;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T3</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Unpacked</span><span class="token operator">&#x3C;</span><span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">>></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T4</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Unpacked</span><span class="token operator">&#x3C;</span><span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T5</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Unpacked</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Unpacked</span><span class="token operator">&#x3C;</span><span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span></code></pre><p>The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span> <span class="token punctuation">}</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span></code></pre><p>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Bar</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span>
  <span class="token operator">?</span> <span class="token constant">U</span>
  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Bar</span><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Bar</span><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span></code></pre><p>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the <em>last</em> signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;</span><span class="token keyword">typeof</span> foo<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">//   ^?</span></code></pre><p>It is not possible to use <code>infer</code> declarations in constraint clauses for regular type parameters:<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 1338 2304</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">ReturnedType</span><span class="token operator">&#x3C;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span></span> <span class="token keyword">infer</span> <span class="token constant">R</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">;</span></code></pre><p>However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:<pre class="language-ts"><code class="language-ts"><span class="token comment">// @noErrors</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">AnyFunction</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token maybe-class-name">AnyFunction</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">infer</span> <span class="token constant">R</span>
  <span class="token operator">?</span> <span class="token constant">R</span>
  <span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span></code></pre></section><section id="predefined-conditional-types"class="level2"><h2>Predefined conditional types</h2><p>TypeScript adds several predefined conditional types, you can find the full list and examples in <a href="/docs/handbook/utility-types.html">Utility Types</a>. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section>