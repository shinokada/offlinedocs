<!doctype html><html lang="en"><meta charset="utf-8"><title>TypeScript for Functional Programmers</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="short"content="TS for Functional Programmers"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/typescript-in-5-minutes-func.html"><meta name="oneline"content="Learn TypeScript if you have a background in functional programming"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><p>TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript's type system has evolved to model code written by native JavaScripters. The resulting system is powerful, interesting and messy.<p>This introduction is designed for working Haskell or ML programmers who want to learn TypeScript. It describes how the type system of TypeScript differs from Haskell's type system. It also describes unique features of TypeScript's type system that arise from its modelling of JavaScript code.<p>This introduction does not cover object-oriented programming. In practice, object-oriented programs in TypeScript are similar to those in other popular languages with OO features.<section id="prerequisites"class="level2"><h2>Prerequisites</h2><p>In this introduction, I assume you know the following:<ul><li>How to program in JavaScript, the good parts.<li>Type syntax of a C-descended language.</ul><p>If you need to learn the good parts of JavaScript, read <a href="https://shop.oreilly.com/product/9780596517748.do">JavaScript: The Good Parts</a>. You may be able to skip the book if you know how to write programs in a call-by-value lexically scoped language with lots of mutability and not much else. <a href="https://people.csail.mit.edu/jaffer/r4rs.pdf">R<sup>4</sup>RS Scheme</a> is a good example.<p><a href="http://www.stroustrup.com/4th.html">The C++ Programming Language</a> is a good place to learn about C-style type syntax. Unlike C++, TypeScript uses postfix types, like so: <code>x: string</code> instead of <code>string x</code>.</section><section id="concepts-not-in-haskell"class="level2"><h2>Concepts not in Haskell</h2></section><section id="built-in-types"class="level2"><h2>Built-in types</h2><p>JavaScript defines 8 built-in types:<table><thead><tr><th>Type<th>Explanation<tbody><tr><td><code>Number</code><td>a double-precision IEEE 754 floating point.<tr><td><code>String</code><td>an immutable UTF-16 string.<tr><td><code>BigInt</code><td>integers in the arbitrary precision format.<tr><td><code>Boolean</code><td><code>true</code> and <code>false</code>.<tr><td><code>Symbol</code><td>a unique value usually used as a key.<tr><td><code>Null</code><td>equivalent to the unit type.<tr><td><code>Undefined</code><td>also equivalent to the unit type.<tr><td><code>Object</code><td>similar to records.</table><p><a href="https://developer.mozilla.org/docs/Web/JavaScript/Data_structures">See the MDN page for more detail</a>.<p>TypeScript has corresponding primitive types for the built-in types:<ul><li><code>number</code><li><code>string</code><li><code>bigint</code><li><code>boolean</code><li><code>symbol</code><li><code>null</code><li><code>undefined</code><li><code>object</code></ul><section id="other-important-typescript-types"class="level3"><h3>Other important TypeScript types</h3><table><thead><tr><th>Type<th>Explanation<tbody><tr><td><code>unknown</code><td>the top type.<tr><td><code>never</code><td>the bottom type.<tr><td>object literal<td>eg <code>{ property: Type }</code><tr><td><code>void</code><td>a subtype of <code>undefined</code> intended for use as a return type.<tr><td><code>T[]</code><td>mutable arrays, also written <code>Array&#x3C;T></code><tr><td><code>[T, T]</code><td>tuples, which are fixed-length but mutable<tr><td><code>(t: T) => U</code><td>functions</table><p>Notes:<ol><li><p>Function syntax includes parameter names. This is pretty hard to get used to!<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> <span class="token function-variable function">fst</span><span class="token operator">:</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function-variable function">any</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token arrow operator">=></span> a<span class="token punctuation">;</span>

<span class="token comment">// or more precisely:</span>

<span class="token keyword">let</span> fst<span class="token operator">:</span> <span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function-variable function"><span class="token maybe-class-name">T</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token arrow operator">=></span> a<span class="token punctuation">;</span></code></pre><li><p>Object literal type syntax closely mirrors object literal value syntax:<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> o<span class="token operator">:</span> <span class="token punctuation">{</span> n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> xs<span class="token operator">:</span> object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> n<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> xs<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><li><p><code>[T, T]</code> is a subtype of <code>T[]</code>. This is different than Haskell, where tuples are not related to lists.</ol></section><section id="boxed-types"class="level3"><h3>Boxed types</h3><p>JavaScript has boxed equivalents of primitive types that contain the methods that programmers associate with those types. TypeScript reflects this with, for example, the difference between the primitive type <code>number</code> and the boxed type <code>Number</code>. The boxed types are rarely needed, since their methods return primitives.<pre class="language-ts"><code class="language-ts"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">toExponential</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// equivalent to</span>
<span class="token known-class-name class-name">Number</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method function property-access">toExponential</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Note that calling a method on a numeric literal requires it to be in parentheses to aid the parser.</section></section><section id="gradual-typing"class="level2"><h2>Gradual typing</h2><p>TypeScript uses the type <code>any</code> whenever it can't tell what the type of an expression should be. Compared to <code>Dynamic</code>, calling <code>any</code> a type is an overstatement. It just turns off the type checker wherever it appears. For example, you can push any value into an <code>any[]</code> without marking the value in any way:<pre class="language-ts"><code class="language-ts"><span class="token comment">// with "noImplicitAny": false in tsconfig.json, anys: any[]</span>
<span class="token keyword">const</span> anys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
anys<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
anys<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token string">"oh no"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
anys<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> anything<span class="token operator">:</span> <span class="token string">"goes"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>And you can use an expression of type <code>any</code> anywhere:<pre class="language-ts"><code class="language-ts">anys<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span>anys<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// oh no, "oh no" is not a function</span></code></pre><p><code>any</code> is contagious, too — if you initialize a variable with an expression of type <code>any</code>, the variable has type <code>any</code> too.<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> sepsis <span class="token operator">=</span> anys<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> anys<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// this could mean anything</span></code></pre><p>To get an error when TypeScript produces an <code>any</code>, use <code>"noImplicitAny": true</code>, or <code>"strict": true</code> in <code>tsconfig.json</code>.</section><section id="structural-typing"class="level2"><h2>Structural typing</h2><p>Structural typing is a familiar concept to most functional programmers, although Haskell and most MLs are not structurally typed. Its basic form is pretty simple:<pre class="language-ts"><code class="language-ts"><span class="token comment">// @strict: false</span>
<span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token string">"hi"</span><span class="token punctuation">,</span> extra<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token keyword">let</span> o2<span class="token operator">:</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span> <span class="token operator">=</span> o<span class="token punctuation">;</span> <span class="token comment">// ok</span></code></pre><p>Here, the object literal <code>{ x: "hi", extra: 1 }</code> has a matching literal type <code>{ x: string, extra: number }</code>. That type is assignable to <code>{ x: string }</code> since it has all the required properties and those properties have assignable types. The extra property doesn't prevent assignment, it just makes it a subtype of <code>{ x: string }</code>.<p>Named types just give a name to a type; for assignability purposes there's no difference between the type alias <code>One</code> and the interface type <code>Two</code> below. They both have a property <code>p: string</code>. (Type aliases behave differently from interfaces with respect to recursive definitions and type parameters, however.)<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2322</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">One</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> p<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Two</span></span> <span class="token punctuation">{</span>
  p<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Three</span></span> <span class="token punctuation">{</span>
  p <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> x<span class="token operator">:</span> <span class="token maybe-class-name">One</span> <span class="token operator">=</span> <span class="token punctuation">{</span> p<span class="token operator">:</span> <span class="token string">"hi"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> two<span class="token operator">:</span> <span class="token maybe-class-name">Two</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
two <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">Three</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section><section id="unions"class="level2"><h2>Unions</h2><p>In TypeScript, union types are untagged. In other words, they are not discriminated unions like <code>data</code> in Haskell. However, you can often discriminate types in a union using built-in tags or other properties.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">start</span><span class="token punctuation">(</span>
  arg<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">{</span> s<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
  <span class="token comment">// this is super common in JavaScript</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> arg <span class="token operator">===</span> <span class="token string">"string"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token function">commonCase</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> arg<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span>commonCase<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">join</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> arg <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token function">commonCase</span><span class="token punctuation">(</span><span class="token function">arg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token function">commonCase</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span><span class="token property-access">s</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">commonCase</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token comment">// finally, just convert a string to another string</span>
    <span class="token keyword control-flow">return</span> s<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p><code>string</code>, <code>Array</code> and <code>Function</code> have built-in type predicates, conveniently leaving the object type for the <code>else</code> branch. It is possible, however, to generate unions that are difficult to differentiate at runtime. For new code, it's best to build only discriminated unions.<p>The following types have built-in predicates:<table><thead><tr><th>Type<th>Predicate<tbody><tr><td>string<td><code>typeof s === "string"</code><tr><td>number<td><code>typeof n === "number"</code><tr><td>bigint<td><code>typeof m === "bigint"</code><tr><td>boolean<td><code>typeof b === "boolean"</code><tr><td>symbol<td><code>typeof g === "symbol"</code><tr><td>undefined<td><code>typeof undefined === "undefined"</code><tr><td>function<td><code>typeof f === "function"</code><tr><td>array<td><code>Array.isArray(a)</code><tr><td>object<td><code>typeof o === "object"</code></table><p>Note that functions and arrays are objects at runtime, but have their own predicates.<section id="intersections"class="level3"><h3>Intersections</h3><p>In addition to unions, TypeScript also has intersections:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Combined</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span> <span class="token operator">&#x26;</span> <span class="token punctuation">{</span> b<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Conflicting</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span> <span class="token operator">&#x26;</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><code>Combined</code> has two properties, <code>a</code> and <code>b</code>, just as if they had been written as one object literal type. Intersection and union are recursive in case of conflicts, so <code>Conflicting.a: number &#x26; string</code>.</section></section><section id="unit-types"class="level2"><h2>Unit types</h2><p>Unit types are subtypes of primitive types that contain exactly one primitive value. For example, the string <code>"foo"</code> has the type <code>"foo"</code>. Since JavaScript has no built-in enums, it is common to use a set of well-known strings instead. Unions of string literal types allow TypeScript to type this pattern:<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">pad</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> direction<span class="token operator">:</span> <span class="token string">"left"</span> <span class="token operator">|</span> <span class="token string">"right"</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token function">pad</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">"left"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>When needed, the compiler <em>widens</em> — converts to a supertype — the unit type to the primitive type, such as <code>"foo"</code> to <code>string</code>. This happens when using mutability, which can hamper some uses of mutable variables:<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2345</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">pad</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> direction<span class="token operator">:</span> <span class="token string">"left"</span> <span class="token operator">|</span> <span class="token string">"right"</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"right"</span><span class="token punctuation">;</span>
<span class="token function">pad</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: 'string' is not assignable to '"left" | "right"'</span></code></pre><p>Here's how the error happens:<ul><li><code>"right": "right"</code><li><code>s: string</code> because <code>"right"</code> widens to <code>string</code> on assignment to a mutable variable.<li><code>string</code> is not assignable to <code>"left" | "right"</code></ul><p>You can work around this with a type annotation for <code>s</code>, but that in turn prevents assignments to <code>s</code> of variables that are not of type <code>"left" | "right"</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">pad</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> direction<span class="token operator">:</span> <span class="token string">"left"</span> <span class="token operator">|</span> <span class="token string">"right"</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">let</span> s<span class="token operator">:</span> <span class="token string">"left"</span> <span class="token operator">|</span> <span class="token string">"right"</span> <span class="token operator">=</span> <span class="token string">"right"</span><span class="token punctuation">;</span>
<span class="token function">pad</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section><section id="concepts-similar-to-haskell"class="level2"><h2>Concepts similar to Haskell</h2></section><section id="contextual-typing"class="level2"><h2>Contextual typing</h2><p>TypeScript has some obvious places where it can infer types, like variable declarations:<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"I'm a string!"</span><span class="token punctuation">;</span></code></pre><p>But it also infers types in a few other places that you may not expect if you've worked with other C-syntax languages:<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">map</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function-variable function">f</span><span class="token operator">:</span> <span class="token punctuation">(</span>t<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">U</span><span class="token punctuation">,</span> ts<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> sns <span class="token operator">=</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token arrow operator">=></span> n<span class="token punctuation">.</span><span class="token method function property-access">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Here, <code>n: number</code> in this example also, despite the fact that <code>T</code> and <code>U</code> have not been inferred before the call. In fact, after <code>[1,2,3]</code> has been used to infer <code>T=number</code>, the return type of <code>n => n.toString()</code> is used to infer <code>U=string</code>, causing <code>sns</code> to have the type <code>string[]</code>.<p>Note that inference will work in any order, but intellisense will only work left-to-right, so TypeScript prefers to declare <code>map</code> with the array first:<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">map</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ts<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function-variable function">f</span><span class="token operator">:</span> <span class="token punctuation">(</span>t<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>Contextual typing also works recursively through object literals, and on unit types that would otherwise be inferred as <code>string</code> or <code>number</code>. And it can infer return types from context:<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">run</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function-variable function">thunk</span><span class="token operator">:</span> <span class="token punctuation">(</span>t<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> i<span class="token operator">:</span> <span class="token punctuation">{</span> inference<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  o<span class="token punctuation">.</span><span class="token property-access">inference</span> <span class="token operator">=</span> <span class="token string">"INSERT STATE HERE"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The type of <code>o</code> is determined to be <code>{ inference: string }</code> because<ol><li>Declaration initializers are contextually typed by the declaration's type: <code>{ inference: string }</code>.<li>The return type of a call uses the contextual type for inferences, so the compiler infers that <code>T={ inference: string }</code>.<li>Arrow functions use the contextual type to type their parameters, so the compiler gives <code>o: { inference: string }</code>.</ol><p>And it does so while you are typing, so that after typing <code>o.</code>, you get completions for the property <code>inference</code>, along with any other properties you'd have in a real program. Altogether, this feature can make TypeScript's inference look a bit like a unifying type inference engine, but it is not.</section><section id="type-aliases"class="level2"><h2>Type aliases</h2><p>Type aliases are mere aliases, just like <code>type</code> in Haskell. The compiler will attempt to use the alias name wherever it was used in the source code, but does not always succeed.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Size</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> x<span class="token operator">:</span> <span class="token maybe-class-name">Size</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">101.1</span><span class="token punctuation">,</span> <span class="token number">999.9</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>The closest equivalent to <code>newtype</code> is a <em>tagged intersection</em>:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">FString</span></span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">&#x26;</span> <span class="token punctuation">{</span> __compileTimeOnly<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>An <code>FString</code> is just like a normal string, except that the compiler thinks it has a property named <code>__compileTimeOnly</code> that doesn't actually exist. This means that <code>FString</code> can still be assigned to <code>string</code>, but not the other way round.</section><section id="discriminated-unions"class="level2"><h2>Discriminated Unions</h2><p>The closest equivalent to <code>data</code> is a union of types with discriminant properties, normally called discriminated unions in TypeScript:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Shape</span></span> <span class="token operator">=</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"circle"</span><span class="token punctuation">;</span> radius<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"square"</span><span class="token punctuation">;</span> x<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"triangle"</span><span class="token punctuation">;</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> y<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Unlike Haskell, the tag, or discriminant, is just a property in each object type. Each variant has an identical property with a different unit type. This is still a normal union type; the leading <code>|</code> is an optional part of the union type syntax. You can discriminate the members of the union using normal JavaScript code:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Shape</span></span> <span class="token operator">=</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"circle"</span><span class="token punctuation">;</span> radius<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"square"</span><span class="token punctuation">;</span> x<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"triangle"</span><span class="token punctuation">;</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> y<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token maybe-class-name">Shape</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token property-access">kind</span> <span class="token operator">===</span> <span class="token string">"circle"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> s<span class="token punctuation">.</span><span class="token property-access">radius</span> <span class="token operator">*</span> s<span class="token punctuation">.</span><span class="token property-access">radius</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token property-access">kind</span> <span class="token operator">===</span> <span class="token string">"square"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> s<span class="token punctuation">.</span><span class="token property-access">x</span> <span class="token operator">*</span> s<span class="token punctuation">.</span><span class="token property-access">x</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token property-access">x</span> <span class="token operator">*</span> s<span class="token punctuation">.</span><span class="token property-access">y</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Note that the return type of <code>area</code> is inferred to be <code>number</code> because TypeScript knows the function is total. If some variant is not covered, the return type of <code>area</code> will be <code>number | undefined</code> instead.<p>Also, unlike Haskell, common properties show up in any union, so you can usefully discriminate multiple members of the union:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Shape</span></span> <span class="token operator">=</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"circle"</span><span class="token punctuation">;</span> radius<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"square"</span><span class="token punctuation">;</span> x<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"triangle"</span><span class="token punctuation">;</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> y<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">function</span> <span class="token function">height</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token maybe-class-name">Shape</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token property-access">kind</span> <span class="token operator">===</span> <span class="token string">"circle"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token number">2</span> <span class="token operator">*</span> s<span class="token punctuation">.</span><span class="token property-access">radius</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// s.kind: "square" | "triangle"</span>
    <span class="token keyword control-flow">return</span> s<span class="token punctuation">.</span><span class="token property-access">x</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></section><section id="type-parameters"class="level2"><h2>Type Parameters</h2><p>Like most C-descended languages, TypeScript requires declaration of type parameters:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">liftArray</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>t<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Array</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>There is no case requirement, but type parameters are conventionally single uppercase letters. Type parameters can also be constrained to a type, which behaves a bit like type class constraints:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">firstish</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span> length<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>t1<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> t2<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> t1<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">></span> t2<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">?</span> t1 <span class="token operator">:</span> t2<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>TypeScript can usually infer type arguments from a call based on the type of the arguments, so type arguments are usually not needed.<p>Because TypeScript is structural, it doesn't need type parameters as much as nominal systems. Specifically, they are not needed to make a function polymorphic. Type parameters should only be used to <em>propagate</em> type information, such as constraining parameters to be the same type:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">length</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token maybe-class-name">ArrayLike</span><span class="token operator">&#x3C;</span><span class="token builtin">unknown</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span>t<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">length</span><span class="token punctuation">(</span>t<span class="token operator">:</span> <span class="token maybe-class-name">ArrayLike</span><span class="token operator">&#x3C;</span><span class="token builtin">unknown</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>In the first <code>length</code>, T is not necessary; notice that it's only referenced once, so it's not being used to constrain the type of the return value or other parameters.<section id="higher-kinded-types"class="level3"><h3>Higher-kinded types</h3><p>TypeScript does not have higher kinded types, so the following is not legal:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">length</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token maybe-class-name">ArrayLike</span><span class="token operator">&#x3C;</span><span class="token builtin">unknown</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>m<span class="token operator">:</span> <span class="token constant">T</span><span class="token operator">&#x3C;</span><span class="token constant">U</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></section><section id="point-free-programming"class="level3"><h3>Point-free programming</h3><p>Point-free programming — heavy use of currying and function composition — is possible in JavaScript, but can be verbose. In TypeScript, type inference often fails for point-free programs, so you'll end up specifying type parameters instead of value parameters. The result is so verbose that it's usually better to avoid point-free programming.</section></section><section id="module-system"class="level2"><h2>Module system</h2><p>JavaScript's modern module syntax is a bit like Haskell's, except that any file with <code>import</code> or <code>export</code> is implicitly a module:<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> value<span class="token punctuation">,</span> <span class="token maybe-class-name">Type</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"npm-package"</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> other<span class="token punctuation">,</span> <span class="token maybe-class-name">Types</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"./local-package"</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> prefix</span> <span class="token keyword module">from</span> <span class="token string">"../lib/third-package"</span><span class="token punctuation">;</span></code></pre><p>You can also import commonjs modules — modules written using node.js' module system:<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> f <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">"single-function-package"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>You can export with an export list:<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span> f <span class="token punctuation">}</span></span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// g is not exported</span></code></pre><p>Or by marking each export individually:<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token keyword">function</span> f <span class="token punctuation">{</span> <span class="token keyword control-flow">return</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><p>The latter style is more common but both are allowed, even in the same file.</section><section id="readonly-and-const"class="level2"><h2><code>readonly</code> and <code>const</code></h2><p>In JavaScript, mutability is the default, although it allows variable declarations with <code>const</code> to declare that the <em>reference</em> is immutable. The referent is still mutable:<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token number">102</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ):</span>
a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">101</span><span class="token punctuation">;</span> <span class="token comment">// D:</span></code></pre><p>TypeScript additionally has a <code>readonly</code> modifier for properties.<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Rx</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> rx<span class="token operator">:</span> <span class="token maybe-class-name">Rx</span> <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
rx<span class="token punctuation">.</span><span class="token property-access">x</span> <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span> <span class="token comment">// error</span></code></pre><p>It also ships with a mapped type <code>Readonly&#x3C;T></code> that makes all properties <code>readonly</code>:<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">X</span></span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> rx<span class="token operator">:</span> <span class="token maybe-class-name">Readonly</span><span class="token operator">&#x3C;</span><span class="token constant">X</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
rx<span class="token punctuation">.</span><span class="token property-access">x</span> <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span> <span class="token comment">// error</span></code></pre><p>And it has a specific <code>ReadonlyArray&#x3C;T></code> type that removes side-affecting methods and prevents writing to indices of the array, as well as special syntax for this type:<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> a<span class="token operator">:</span> <span class="token maybe-class-name">ReadonlyArray</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b<span class="token operator">:</span> <span class="token keyword">readonly</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token number">102</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">101</span><span class="token punctuation">;</span> <span class="token comment">// error</span></code></pre><p>You can also use a const-assertion, which operates on arrays and object literals:<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token number">102</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">101</span><span class="token punctuation">;</span> <span class="token comment">// error</span></code></pre><p>However, none of these options are the default, so they are not consistently used in TypeScript code.</section><section id="next-steps"class="level2"><h2>Next Steps</h2><p>This doc is a high level overview of the syntax and types you would use in everyday code. From here you should:<ul><li>Read the full Handbook <a href="/docs/handbook/intro.html">from start to finish</a> (30m)<li>Explore the <a href="/play#show-examples">Playground examples</a> <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></ul></section>