<!doctype html><html lang="en"><meta charset="utf-8"><title>TypeScript 2.7</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/release-notes/typescript-2-7.html"><meta name="oneline"content="TypeScript 2.7 Release Notes"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="constant-named-properties"class="level2"><h2>Constant-named properties</h2><p>TypeScript 2.7 adds support for declaring const-named properties on types including ECMAScript symbols.<section id="example"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token comment">// Lib</span>
<span class="token keyword module">export</span> <span class="token keyword">const</span> <span class="token constant">SERIALIZE</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Symbol</span><span class="token punctuation">(</span><span class="token string">"serialize-method-key"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Serializable</span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">SERIALIZE</span><span class="token punctuation">]</span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><pre class="language-ts"><code class="language-ts"><span class="token comment">// consumer</span>

<span class="token keyword module">import</span> <span class="token punctuation">{</span> <span class="token constant">SERIALIZE</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Serializable</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">"lib"</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">JSONSerializableItem</span></span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token maybe-class-name">Serializable</span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">SERIALIZE</span><span class="token punctuation">]</span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">JSON</span><span class="token punctuation">.</span><span class="token method function property-access">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>This also applies to numeric and string literals.</section><section id="example-1"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> <span class="token maybe-class-name">Foo</span> <span class="token operator">=</span> <span class="token string">"Foo"</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">Bar</span> <span class="token operator">=</span> <span class="token string">"Bar"</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token maybe-class-name">Foo</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token maybe-class-name">Bar</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token string">"hello"</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> a <span class="token operator">=</span> x<span class="token punctuation">[</span><span class="token maybe-class-name">Foo</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// has type 'number'</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> x<span class="token punctuation">[</span><span class="token maybe-class-name">Bar</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// has type 'string'</span></code></pre></section></section><section id="unique-symbol"class="level2"><h2><code>unique symbol</code></h2><p>To enable treating symbols as unique literals a new type <code>unique symbol</code> is available. <code>unique symbol</code> is a subtype of <code>symbol</code>, and are produced only from calling <code>Symbol()</code> or <code>Symbol.for()</code>, or from explicit type annotations. The new type is only allowed on <code>const</code> declarations and <code>readonly static</code> properties, and in order to reference a specific unique symbol, you'll have to use the <code>typeof</code> operator. Each reference to a <code>unique symbol</code> implies a completely unique identity that's tied to a given declaration.<section id="example-2"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token comment">// Works</span>
<span class="token keyword">declare</span> <span class="token keyword">const</span> <span class="token maybe-class-name">Foo</span><span class="token operator">:</span> unique <span class="token builtin">symbol</span><span class="token punctuation">;</span>

<span class="token comment">// Error! 'Bar' isn't a constant.</span>
<span class="token keyword">let</span> <span class="token maybe-class-name">Bar</span><span class="token operator">:</span> unique <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Works - refers to a unique symbol, but its identity is tied to 'Foo'.</span>
<span class="token keyword">let</span> <span class="token maybe-class-name">Baz</span><span class="token operator">:</span> <span class="token keyword">typeof</span> <span class="token maybe-class-name">Foo</span> <span class="token operator">=</span> <span class="token maybe-class-name">Foo</span><span class="token punctuation">;</span>

<span class="token comment">// Also works.</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token keyword">readonly</span> <span class="token maybe-class-name">StaticSymbol</span><span class="token operator">:</span> unique <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Because each <code>unique symbol</code> has a completely separate identity, no two <code>unique symbol</code> types are assignable or comparable to each other.</section><section id="example-3"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> <span class="token maybe-class-name">Foo</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">Bar</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Error: can't compare two unique symbols.</span>
<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token maybe-class-name">Foo</span> <span class="token operator">===</span> <span class="token maybe-class-name">Bar</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></section></section><section id="strict-class-initialization"class="level2"><h2>Strict Class Initialization</h2><p>TypeScript 2.7 introduces a new flag called <a href="/tsconfig#strictPropertyInitialization"><code>strictPropertyInitialization</code></a>. This flag performs checks to ensure that each instance property of a class gets initialized in the constructor body, or by a property initializer. For example<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  bar <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
  baz<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  <span class="token comment">//  ~~~</span>
  <span class="token comment">//  Error! Property 'baz' has no initializer and is not definitely assigned in the</span>
  <span class="token comment">//         constructor.</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">foo</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>In the above, if we truly meant for <code>baz</code> to potentially be <code>undefined</code>, we should have declared it with the type <code>boolean | undefined</code>.<p>There are certain scenarios where properties can be initialized indirectly (perhaps by a helper method or dependency injection library), in which case you can use the new <em>definite assignment assertion modifiers</em> for your properties (discussed below).<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  foo<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token comment">// ^</span>
  <span class="token comment">// Notice this '!' modifier.</span>
  <span class="token comment">// This is the "definite assignment assertion"</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">foo</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Keep in mind that <a href="/tsconfig#strictPropertyInitialization"><code>strictPropertyInitialization</code></a> will be turned on along with other <a href="/tsconfig#strict"><code>strict</code></a> mode flags, which can impact your project. You can set the <a href="/tsconfig#strictPropertyInitialization"><code>strictPropertyInitialization</code></a> setting to <code>false</code> in your <code>tsconfig.json</code>'s <code>compilerOptions</code>, or <code>--strictPropertyInitialization false</code> on the command line to turn off this checking.</section><section id="definite-assignment-assertions"class="level2"><h2>Definite Assignment Assertions</h2><p>The definite assignment assertion is a feature that allows a <code>!</code> to be placed after instance property and variable declarations to relay to TypeScript that a variable is indeed assigned for all intents and purposes, even if TypeScript's analyses cannot detect so.<section id="example-4"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>x <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//          ~   ~</span>
<span class="token comment">// Error! Variable 'x' is used before being assigned.</span>

<span class="token keyword">function</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>With definite assignment assertions, we can assert that <code>x</code> is really assigned by appending an <code>!</code> to its declaration:<pre class="language-ts"><code class="language-ts"><span class="token comment">// Notice the '!'</span>
<span class="token keyword">let</span> x<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// No error!</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>x <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>In a sense, the definite assignment assertion operator is the dual of the non-null assertion operator (in which <em>expressions</em> are post-fixed with a <code>!</code>), which we could also have used in the example.<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// No error!</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>x<span class="token operator">!</span> <span class="token operator">+</span> x<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><p>In our example, we knew that all uses of <code>x</code> would be initialized so it makes more sense to use definite assignment assertions than non-null assertions.</section></section><section id="fixed-length-tuples"class="level2"><h2>Fixed Length Tuples</h2><p>In TypeScript 2.6 and earlier, <code>[number, string, string]</code> was considered a subtype of <code>[number, string]</code>. This was motivated by TypeScript's structural nature; the first and second elements of a <code>[number, string, string]</code> are respectively subtypes of the first and second elements of <code>[number, string]</code>. However, after examining real world usage of tuples, we noticed that most situations in which this was permitted was typically undesirable.<p>In TypeScript 2.7, tuples of different arities are no longer assignable to each other. Thanks to a pull request from <a href="https://github.com/KiaraGrouwstra">Kiara Grouwstra</a>, tuple types now encode their arity into the type of their respective <code>length</code> property. This is accomplished by leveraging numeric literal types, which now allow tuples to be distinct from tuples of different arities.<p>Conceptually, you might consider the type <code>[number, string]</code> to be equivalent to the following declaration of <code>NumStrTuple</code>:<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">NumStrTuple</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token known-class-name class-name">Array</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  <span class="token number">0</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token number">1</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  length<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// using the numeric literal type '2'</span>
<span class="token punctuation">}</span></code></pre><p>Note that this is a breaking change for some code. If you need to resort to the original behavior in which tuples only enforce a minimum length, you can use a similar declaration that does not explicitly define a <code>length</code> property, falling back to <code>number</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">MinimumNumStrTuple</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token known-class-name class-name">Array</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  <span class="token number">0</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token number">1</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Note that this does not imply tuples represent immutable arrays, but it is an implied convention.</section><section id="improved-type-inference-for-object-literals"class="level2"><h2>Improved type inference for object literals</h2><p>TypeScript 2.7 improves type inference for multiple object literals occurring in the same context. When multiple object literal types contribute to a union type, we now <em>normalize</em> the object literal types such that all properties are present in each constituent of the union type.<p>Consider:<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> obj <span class="token operator">=</span> test <span class="token operator">?</span> <span class="token punctuation">{</span> text<span class="token operator">:</span> <span class="token string">"hello"</span> <span class="token punctuation">}</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// { text: string } | { text?: undefined }</span>
<span class="token keyword">const</span> s <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token property-access">text</span><span class="token punctuation">;</span> <span class="token comment">// string | undefined</span></code></pre><p>Previously type <code>{}</code> was inferred for <code>obj</code> and the second line subsequently caused an error because <code>obj</code> would appear to have no properties. That obviously wasn't ideal.<section id="example-5"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token comment">// let obj: { a: number, b: number } |</span>
<span class="token comment">//     { a: string, b?: undefined } |</span>
<span class="token comment">//     { a?: undefined, b?: undefined }</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token string">"abc"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token property-access">a</span><span class="token punctuation">;</span> <span class="token comment">// string | number | undefined</span>
obj<span class="token punctuation">.</span><span class="token property-access">b</span><span class="token punctuation">;</span> <span class="token comment">// number | undefined</span></code></pre><p>Multiple object literal type inferences for the same type parameter are similarly collapsed into a single normalized union type:<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">f</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token spread operator">...</span>items<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token comment">// let obj: { a: number, b: number } |</span>
<span class="token comment">//     { a: string, b?: undefined } |</span>
<span class="token comment">//     { a?: undefined, b?: undefined }</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token string">"abc"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token property-access">a</span><span class="token punctuation">;</span> <span class="token comment">// string | number | undefined</span>
obj<span class="token punctuation">.</span><span class="token property-access">b</span><span class="token punctuation">;</span> <span class="token comment">// number | undefined</span></code></pre></section></section><section id="improved-handling-of-structurally-identical-classes-and-instanceof-expressions"class="level2"><h2>Improved handling of structurally identical classes and <code>instanceof</code> expressions</h2><p>TypeScript 2.7 improves the handling of structurally identical classes in union types and <code>instanceof</code> expressions:<ul><li>Structurally identical, but distinct, class types are now preserved in union types (instead of eliminating all but one).<li>Union type subtype reduction only removes a class type if it is a subclass of <em>and</em> derives from another class type in the union.<li>Type checking of the <code>instanceof</code> operator is now based on whether the type of the left operand <em>derives from</em> the type indicated by the right operand (as opposed to a structural subtype check).</ul><p>This means that union types and <code>instanceof</code> properly distinguish between structurally identical classes.<section id="example-6"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">D</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  c<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">E</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">D</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">let</span> x1 <span class="token operator">=</span> <span class="token operator">!</span><span class="token boolean">true</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">A</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">B</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// A</span>
<span class="token keyword">let</span> x2 <span class="token operator">=</span> <span class="token operator">!</span><span class="token boolean">true</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">B</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// B | C (previously B)</span>
<span class="token keyword">let</span> x3 <span class="token operator">=</span> <span class="token operator">!</span><span class="token boolean">true</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">D</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// C | D (previously C)</span>

<span class="token keyword">let</span> a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name"><span class="token constant">A</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">B</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">D</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">E</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// A[]</span>
<span class="token keyword">let</span> a2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name"><span class="token constant">B</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">D</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">E</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// (B | C | D)[] (previously B[])</span>

<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">B</span> <span class="token operator">|</span> <span class="token constant">C</span> <span class="token operator">|</span> <span class="token constant">D</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>x <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token constant">B</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">;</span> <span class="token comment">// B (previously B | D)</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>x <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">;</span> <span class="token comment">// C</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">;</span> <span class="token comment">// D (previously never)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></section></section><section id="type-guards-inferred-from-in-operator"class="level2"><h2>Type guards inferred from <code>in</code> operator</h2><p>The <code>in</code> operator now acts as a narrowing expression for types.<p>For a <code>n in x</code> expression, where <code>n</code> is a string literal or string literal type and <code>x</code> is a union type, the "true" branch narrows to types which have an optional or required property <code>n</code>, and the "false" branch narrows to types which have an optional or missing property <code>n</code>.<section id="example-7"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token punctuation">{</span>
  b<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">A</span> <span class="token operator">|</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token string">"a"</span> <span class="token keyword">in</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> x<span class="token punctuation">.</span><span class="token property-access">a</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> x<span class="token punctuation">.</span><span class="token property-access">b</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></section></section><section id="support-for-import-d-from-cjs-from-commonjs-modules-with---esmoduleinterop"class="level2"><h2>Support for <code>import d from "cjs"</code> from CommonJS modules with <code>--esModuleInterop</code></h2><p>TypeScript 2.7 updates CommonJS/AMD/UMD module emit to synthesize namespace records based on the presence of an <code>__esModule</code> indicator under <a href="/tsconfig#esModuleInterop"><code>esModuleInterop</code></a>. The change brings the generated output from TypeScript closer to that generated by Babel.<p>Previously CommonJS/AMD/UMD modules were treated in the same way as ES6 modules, resulting in a couple of problems. Namely:<ul><li>TypeScript treats a namespace import (i.e. <code>import * as foo from "foo"</code>) for a CommonJS/AMD/UMD module as equivalent to <code>const foo = require("foo")</code>.Things are simple here, but they don't work out if the primary object being imported is a primitive or a class or a function. ECMAScript spec stipulates that a namespace record is a plain object, and that a namespace import (<code>foo</code> in the example above) is not callable, though allowed by TypeScript<li>Similarly a default import (i.e. <code>import d from "foo"</code>) for a CommonJS/AMD/UMD module as equivalent to <code>const d = require("foo").default</code>.Most of the CommonJS/AMD/UMD modules available today do not have a <code>default</code> export, making this import pattern practically unusable to import non-ES modules (i.e. CommonJS/AMD/UMD). For instance <code>import fs from "fs"</code> or <code>import express from "express"</code> are not allowed.</ul><p>Under the new <a href="/tsconfig#esModuleInterop"><code>esModuleInterop</code></a> these two issues should be addressed:<ul><li>A namespace import (i.e. <code>import * as foo from "foo"</code>) is now correctly flagged as uncallable. Calling it will result in an error.<li>Default imports to CommonJS/AMD/UMD are now allowed (e.g. <code>import fs from "fs"</code>), and should work as expected.</ul><blockquote><p>Note: The new behavior is added under a flag to avoid unwarranted breaks to existing code bases. <strong>We highly recommend applying it both to new and existing projects.</strong> For existing projects, namespace imports (<code>import * as express from "express"; express();</code>) will need to be converted to default imports (<code>import express from "express"; express();</code>).</blockquote><section id="example-8"class="level5"><h5>Example</h5><p>With <a href="/tsconfig#esModuleInterop"><code>esModuleInterop</code></a> two new helpers are generated <code>__importStar</code> and <code>__importDefault</code> for import <code>*</code> and import <code>default</code> respectively. For instance input like:<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> foo</span> <span class="token keyword module">from</span> <span class="token string">"foo"</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports">b</span> <span class="token keyword module">from</span> <span class="token string">"bar"</span><span class="token punctuation">;</span></code></pre><p>Will generate:<pre class="language-js"><code class="language-js"><span class="token string">"use strict"</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> __importStar <span class="token operator">=</span>
  <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">&#x26;&#x26;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">__importStar</span><span class="token punctuation">)</span> <span class="token operator">||</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">mod</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>mod <span class="token operator">&#x26;&#x26;</span> mod<span class="token punctuation">.</span><span class="token property-access">__esModule</span><span class="token punctuation">)</span> <span class="token keyword control-flow">return</span> mod<span class="token punctuation">;</span>
    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>mod <span class="token operator">!=</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span>
      <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token keyword">in</span> mod<span class="token punctuation">)</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">hasOwnProperty</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>mod<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> result<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> mod<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    result<span class="token punctuation">[</span><span class="token string">"default"</span><span class="token punctuation">]</span> <span class="token operator">=</span> mod<span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> __importDefault <span class="token operator">=</span>
  <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">&#x26;&#x26;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">__importDefault</span><span class="token punctuation">)</span> <span class="token operator">||</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">mod</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> mod <span class="token operator">&#x26;&#x26;</span> mod<span class="token punctuation">.</span><span class="token property-access">__esModule</span> <span class="token operator">?</span> mod <span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token keyword module">default</span><span class="token operator">:</span> mod <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
exports<span class="token punctuation">.</span><span class="token property-access">__esModule</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token function">__importStar</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar_1 <span class="token operator">=</span> <span class="token function">__importDefault</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section></section><section id="numeric-separators"class="level2"><h2>Numeric separators</h2><p>TypeScript 2.7 brings support for <a href="https://github.com/tc39/proposal-numeric-separator">ES Numeric Separators</a>. Numeric literals can now be separated into segments using <code>_</code>.<section id="example-9"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> million <span class="token operator">=</span> <span class="token number">1_000_000</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> phone <span class="token operator">=</span> <span class="token number">555_734_2231</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bytes <span class="token operator">=</span> <span class="token number">0xff_0c_00_ff</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> word <span class="token operator">=</span> <span class="token number">0b1100_0011_1101_0001</span><span class="token punctuation">;</span></code></pre></section></section><section id="cleaner-output-in---watch-mode"class="level2"><h2>Cleaner output in <code>--watch</code> mode</h2><p>TypeScript's <code>--watch</code> mode now clears the screen after a re-compilation is requested.</section><section id="prettier---pretty-output"class="level2"><h2>Prettier <code>--pretty</code> output</h2><p>TypeScript's <a href="/tsconfig#pretty"><code>pretty</code></a> flag can make error messages easier to read and manage. <a href="/tsconfig#pretty"><code>pretty</code></a> now uses colors for file names, diagnostic codes, and line numbers. File names and positions are now also formatted to allow navigation in common terminals (e.g. Visual Studio Code terminal). <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section>