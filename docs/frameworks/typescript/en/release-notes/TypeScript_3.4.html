<!doctype html><html lang="en"><meta charset="utf-8"><title>TypeScript 3.4</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/release-notes/typescript-3-4.html"><meta name="oneline"content="TypeScript 3.4 Release Notes"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="faster-subsequent-builds-with-the---incremental-flag"class="level2"><h2>Faster subsequent builds with the <code>--incremental</code> flag</h2><p>TypeScript 3.4 introduces a new flag called <a href="/tsconfig#incremental"><code>incremental</code></a> which tells TypeScript to save information about the project graph from the last compilation. The next time TypeScript is invoked with <a href="/tsconfig#incremental"><code>incremental</code></a>, it will use that information to detect the least costly way to type-check and emit changes to your project.<pre class="language-jsonc"><code class="language-jsonc">// tsconfig.json
{
  "compilerOptions": {
    "incremental": true,
    "outDir": "./lib"
  },
  "include": ["./src"]
}</code></pre><p>By default with these settings, when we run <code>tsc</code>, TypeScript will look for a file called <code>.tsbuildinfo</code> in the output directory (<code>./lib</code>). If <code>./lib/.tsbuildinfo</code> doesn't exist, it'll be generated. But if it does, <code>tsc</code> will try to use that file to incrementally type-check and update our output files.<p>These <code>.tsbuildinfo</code> files can be safely deleted and don't have any impact on our code at runtime - they're purely used to make compilations faster. We can also name them anything that we want, and place them anywhere we want using the <a href="/tsconfig#tsBuildInfoFile"><code>tsBuildInfoFile</code></a> option.<pre class="language-jsonc"><code class="language-jsonc">// front-end.tsconfig.json
{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./buildcache/front-end",
    "outDir": "./lib"
  },
  "include": ["./src"]
}</code></pre><section id="composite-projects"class="level3"><h3>Composite projects</h3><p>Part of the intent with composite projects (<code>tsconfig.json</code>s with <a href="/tsconfig#composite"><code>composite</code></a> set to <code>true</code>) is that references between different projects can be built incrementally. As such, composite projects will <strong>always</strong> produce <code>.tsbuildinfo</code> files.</section><section id="outfile"class="level3"><h3><code>outFile</code></h3><p>When <a href="/tsconfig#outFile"><code>outFile</code></a> is used, the build information file's name will be based on the output file's name. As an example, if our output JavaScript file is <code>./output/foo.js</code>, then under the <a href="/tsconfig#incremental"><code>incremental</code></a> flag, TypeScript will generate the file <code>./output/foo.tsbuildinfo</code>. As above, this can be controlled with the <a href="/tsconfig#tsBuildInfoFile"><code>tsBuildInfoFile</code></a> option.</section></section><section id="higher-order-type-inference-from-generic-functions"class="level2"><h2>Higher order type inference from generic functions</h2><p>TypeScript 3.4 can now produce generic function types when inference from other generic functions produces free type variables for inferences. This means many function composition patterns now work better in 3.4.<p>To get more specific, let's build up some motivation and consider the following <code>compose</code> function:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">compose</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function-variable function">f</span><span class="token operator">:</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token function-variable function">g</span><span class="token operator">:</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">C</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">C</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><code>compose</code> takes two other functions:<ul><li><code>f</code> which takes some argument (of type <code>A</code>) and returns a value of type <code>B</code><li><code>g</code> which takes an argument of type <code>B</code> (the type <code>f</code> returned), and returns a value of type <code>C</code></ul><p><code>compose</code> then returns a function which feeds its argument through <code>f</code> and then <code>g</code>.<p>When calling this function, TypeScript will try to figure out the types of <code>A</code>, <code>B</code>, and <code>C</code> through a process called <em>type argument inference</em>. This inference process usually works pretty well:<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Person</span></span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getDisplayName</span><span class="token punctuation">(</span>p<span class="token operator">:</span> <span class="token maybe-class-name">Person</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> p<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">.</span><span class="token method function property-access">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getLength</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> s<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// has type '(p: Person) => number'</span>
<span class="token keyword">const</span> getDisplayNameLength <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>getDisplayName<span class="token punctuation">,</span> getLength<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// works and returns the type 'number'</span>
<span class="token function">getDisplayNameLength</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">"Person McPersonface"</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The inference process is fairly straightforward here because <code>getDisplayName</code> and <code>getLength</code> use types that can easily be referenced. However, in TypeScript 3.3 and earlier, generic functions like <code>compose</code> didn't work so well when passed other generic functions.<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Box</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">makeArray</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">makeBox</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">U</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Box</span><span class="token operator">&#x3C;</span><span class="token constant">U</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> value <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// has type '(arg: {}) => Box&#x3C;{}[]>'</span>
<span class="token keyword">const</span> makeBoxedArray <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>makeArray<span class="token punctuation">,</span> makeBox<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">makeBoxedArray</span><span class="token punctuation">(</span><span class="token string">"hello!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token method function property-access">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//                                ~~~~~~~~~~~</span>
<span class="token comment">// error: Property 'toUpperCase' does not exist on type '{}'.</span></code></pre><p>In older versions, TypeScript would infer the empty object type (<code>{}</code>) when inferring from other type variables like <code>T</code> and <code>U</code>.<p>During type argument inference in TypeScript 3.4, for a call to a generic function that returns a function type, TypeScript <em>will</em>, as appropriate, propagate type parameters from generic function arguments onto the resulting function type.<p>In other words, instead of producing the type<pre class="language-ts"><code class="language-ts"><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">Box</span><span class="token operator">&#x3C;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></code></pre><p>TypeScript 3.4 produces the type<pre class="language-ts"><code class="language-ts"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">Box</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></code></pre><p>Notice that <code>T</code> has been propagated from <code>makeArray</code> into the resulting type's type parameter list. This means that genericity from <code>compose</code>'s arguments has been preserved and our <code>makeBoxedArray</code> sample will just work!<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Box</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">makeArray</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">makeBox</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">U</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Box</span><span class="token operator">&#x3C;</span><span class="token constant">U</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> value <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// has type '&#x3C;T>(arg: T) => Box&#x3C;T[]>'</span>
<span class="token keyword">const</span> makeBoxedArray <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>makeArray<span class="token punctuation">,</span> makeBox<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// works with no problem!</span>
<span class="token function">makeBoxedArray</span><span class="token punctuation">(</span><span class="token string">"hello!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token method function property-access">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>For more details, you can <a href="https://github.com/Microsoft/TypeScript/pull/30215">read more at the original change</a>.</section><section id="improvements-for-readonlyarray-and-readonly-tuples"class="level2"><h2>Improvements for <code>ReadonlyArray</code> and <code>readonly</code> tuples</h2><p>TypeScript 3.4 makes it a little bit easier to use read-only array-like types.<section id="a-new-syntax-for-readonlyarray"class="level3"><h3>A new syntax for <code>ReadonlyArray</code></h3><p>The <code>ReadonlyArray</code> type describes <code>Array</code>s that can only be read from. Any variable with a reference to a <code>ReadonlyArray</code> can't add, remove, or replace any elements of the array.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>arr<span class="token operator">:</span> <span class="token maybe-class-name">ReadonlyArray</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arr<span class="token punctuation">.</span><span class="token method function property-access">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// okay</span>
  arr<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token string">"hello!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error!</span>
<span class="token punctuation">}</span></code></pre><p>While it's good practice to use <code>ReadonlyArray</code> over <code>Array</code> when no mutation is intended, it's often been a pain given that arrays have a nicer syntax. Specifically, <code>number[]</code> is a shorthand version of <code>Array&#x3C;number></code>, just as <code>Date[]</code> is a shorthand for <code>Array&#x3C;Date></code>.<p>TypeScript 3.4 introduces a new syntax for <code>ReadonlyArray</code> using a new <code>readonly</code> modifier for array types.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>arr<span class="token operator">:</span> <span class="token keyword">readonly</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arr<span class="token punctuation">.</span><span class="token method function property-access">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// okay</span>
  arr<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token string">"hello!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error!</span>
<span class="token punctuation">}</span></code></pre></section><section id="readonly-tuples"class="level3"><h3><code>readonly</code> tuples</h3><p>TypeScript 3.4 also introduces new support for <code>readonly</code> tuples. We can prefix any tuple type with the <code>readonly</code> keyword to make it a <code>readonly</code> tuple, much like we now can with array shorthand syntax. As you might expect, unlike ordinary tuples whose slots could be written to, <code>readonly</code> tuples only permit reading from those positions.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>pair<span class="token operator">:</span> <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>pair<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// okay</span>
  pair<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello!"</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
<span class="token punctuation">}</span></code></pre><p>The same way that ordinary tuples are types that extend from <code>Array</code> - a tuple with elements of type <code>T<sub>1</sub></code>, <code>T<sub>2</sub></code>, ... <code>T<sub>n</sub></code> extends from <code>Array&#x3C; T<sub>1</sub> | T<sub>2</sub> | ... T<sub>n</sub> ></code> - <code>readonly</code> tuples are types that extend from <code>ReadonlyArray</code>. So a <code>readonly</code> tuple with elements <code>T<sub>1</sub></code>, <code>T<sub>2</sub></code>, ... <code>T<sub>n</sub></code> extends from <code>ReadonlyArray&#x3C; T<sub>1</sub> | T<sub>2</sub> | ... T<sub>n</sub></code>.</section><section id="readonly-mapped-type-modifiers-and-readonly-arrays"class="level3"><h3><code>readonly</code> mapped type modifiers and <code>readonly</code> arrays</h3><p>In earlier versions of TypeScript, we generalized mapped types to operate differently on array-like types. This meant that a mapped type like <code>Boxify</code> could work on arrays and tuples alike.<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Box</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Boxify</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token maybe-class-name">Box</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// { a: Box&#x3C;string>, b: Box&#x3C;number> }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Boxify</span><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">// Array&#x3C;Box&#x3C;number>></span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Boxify</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">// [Box&#x3C;string>, Box&#x3C;number>]</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Boxify</span><span class="token operator">&#x3C;</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>Unfortunately, mapped types like the <code>Readonly</code> utility type were effectively no-ops on array and tuple types.<pre class="language-ts"><code class="language-ts"><span class="token comment">// lib.d.ts</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Readonly</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// How code acted *before* TypeScript 3.4</span>

<span class="token comment">// { readonly a: string, readonly b: number }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Readonly</span><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">// number[]</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Readonly</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">// [string, boolean]</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Readonly</span><span class="token operator">&#x3C;</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>In TypeScript 3.4, the <code>readonly</code> modifier in a mapped type will automatically convert array-like types to their corresponding <code>readonly</code> counterparts.<pre class="language-ts"><code class="language-ts"><span class="token comment">// How code acts now *with* TypeScript 3.4</span>

<span class="token comment">// { readonly a: string, readonly b: number }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Readonly</span><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">// readonly number[]</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Readonly</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">// readonly [string, boolean]</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Readonly</span><span class="token operator">&#x3C;</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>Similarly, you could write a utility type like <code>Writable</code> mapped type that strips away <code>readonly</code>-ness, and that would convert <code>readonly</code> array containers back to their mutable equivalents.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Writable</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token operator">-</span><span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// { a: string, b: number }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Writable</span><span class="token operator">&#x3C;</span><span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token keyword">readonly</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">// number[]</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Writable</span><span class="token operator">&#x3C;</span><span class="token keyword">readonly</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">// [string, boolean]</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Writable</span><span class="token operator">&#x3C;</span><span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre></section><section id="caveats"class="level3"><h3>Caveats</h3><p>Despite its appearance, the <code>readonly</code> type modifier can only be used for syntax on array types and tuple types. It is not a general-purpose type operator.<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> err1<span class="token operator">:</span> <span class="token keyword">readonly</span> <span class="token known-class-name class-name">Set</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// error!</span>
<span class="token keyword">let</span> err2<span class="token operator">:</span> <span class="token keyword">readonly</span> <span class="token known-class-name class-name">Array</span><span class="token operator">&#x3C;</span><span class="token builtin">boolean</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// error!</span>

<span class="token keyword">let</span> okay<span class="token operator">:</span> <span class="token keyword">readonly</span> <span class="token builtin">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// works fine</span></code></pre><p>You can <a href="https://github.com/Microsoft/TypeScript/pull/29435">see more details in the pull request</a>.</section></section><section id="const-assertions"class="level2"><h2><code>const</code> assertions</h2><p>TypeScript 3.4 introduces a new construct for literal values called <em><code>const</code></em> assertions. Its syntax is a type assertion with <code>const</code> in place of the type name (e.g. <code>123 as const</code>). When we construct new literal expressions with <code>const</code> assertions, we can signal to the language that<ul><li>no literal types in that expression should be widened (e.g. no going from <code>"hello"</code> to <code>string</code>)<li>object literals get <code>readonly</code> properties<li>array literals become <code>readonly</code> tuples</ul><pre class="language-ts"><code class="language-ts"><span class="token comment">// Type '"hello"'</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token string">"hello"</span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

<span class="token comment">// Type 'readonly [10, 20]'</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

<span class="token comment">// Type '{ readonly text: "hello" }'</span>
<span class="token keyword">let</span> z <span class="token operator">=</span> <span class="token punctuation">{</span> text<span class="token operator">:</span> <span class="token string">"hello"</span> <span class="token punctuation">}</span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span></code></pre><p>Outside of <code>.tsx</code> files, the angle bracket assertion syntax can also be used.<pre class="language-ts"><code class="language-ts"><span class="token comment">// Type '"hello"'</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token operator">&#x3C;</span><span class="token keyword">const</span><span class="token operator">></span><span class="token string">"hello"</span><span class="token punctuation">;</span>

<span class="token comment">// Type 'readonly [10, 20]'</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token operator">&#x3C;</span><span class="token keyword">const</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// Type '{ readonly text: "hello" }'</span>
<span class="token keyword">let</span> z <span class="token operator">=</span> <span class="token operator">&#x3C;</span><span class="token keyword">const</span><span class="token operator">></span><span class="token punctuation">{</span> text<span class="token operator">:</span> <span class="token string">"hello"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>This feature means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.<pre class="language-ts"><code class="language-ts"><span class="token comment">// Works with no types referenced or declared.</span>
<span class="token comment">// We only needed a single const assertion.</span>
<span class="token keyword">function</span> <span class="token function">getShapes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"circle"</span><span class="token punctuation">,</span> radius<span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"square"</span><span class="token punctuation">,</span> sideLength<span class="token operator">:</span> <span class="token number">50</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> shape <span class="token keyword">of</span> <span class="token function">getShapes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Narrows perfectly!</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>shape<span class="token punctuation">.</span><span class="token property-access">kind</span> <span class="token operator">===</span> <span class="token string">"circle"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"Circle radius"</span><span class="token punctuation">,</span> shape<span class="token punctuation">.</span><span class="token property-access">radius</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"Square side length"</span><span class="token punctuation">,</span> shape<span class="token punctuation">.</span><span class="token property-access">sideLength</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Notice the above needed no type annotations. The <code>const</code> assertion allowed TypeScript to take the most specific type of the expression.<p>This can even be used to enable <code>enum</code>-like patterns in plain JavaScript code if you choose not to use TypeScript's <code>enum</code> construct.<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token keyword">const</span> <span class="token maybe-class-name">Colors</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  red<span class="token operator">:</span> <span class="token string">"RED"</span><span class="token punctuation">,</span>
  blue<span class="token operator">:</span> <span class="token string">"BLUE"</span><span class="token punctuation">,</span>
  green<span class="token operator">:</span> <span class="token string">"GREEN"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

<span class="token comment">// or use an 'export default'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>
  red<span class="token operator">:</span> <span class="token string">"RED"</span><span class="token punctuation">,</span>
  blue<span class="token operator">:</span> <span class="token string">"BLUE"</span><span class="token punctuation">,</span>
  green<span class="token operator">:</span> <span class="token string">"GREEN"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span></code></pre><section id="caveats-1"class="level3"><h3>Caveats</h3><p>One thing to note is that <code>const</code> assertions can only be applied immediately on simple literal expressions.<pre class="language-ts"><code class="language-ts"><span class="token comment">// Error! A 'const' assertion can only be applied to a</span>
<span class="token comment">// to a string, number, boolean, array, or object literal.</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token method function property-access">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&#x3C;</span> <span class="token number">0.5</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

<span class="token comment">// Works!</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token method function property-access">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&#x3C;</span> <span class="token number">0.5</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> d <span class="token operator">=</span> <span class="token number">3_600_000</span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span></code></pre><p>Another thing to keep in mind is that <code>const</code> contexts don't immediately convert an expression to be fully immutable.<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">"foo"</span><span class="token punctuation">,</span>
  contents<span class="token operator">:</span> arr<span class="token punctuation">,</span>
<span class="token punctuation">}</span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

foo<span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> <span class="token string">"bar"</span><span class="token punctuation">;</span> <span class="token comment">// error!</span>
foo<span class="token punctuation">.</span><span class="token property-access">contents</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// error!</span>

foo<span class="token punctuation">.</span><span class="token property-access">contents</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ...works!</span></code></pre><p>For more details, you can <a href="https://github.com/Microsoft/TypeScript/pull/29510">check out the respective pull request</a>.</section></section><section id="type-checking-for-globalthis"class="level2"><h2>Type-checking for <code>globalThis</code></h2><p>TypeScript 3.4 introduces support for type-checking ECMAScript's new <code>globalThis</code> - a global variable that, well, refers to the global scope. Unlike the above solutions, <code>globalThis</code> provides a standard way for accessing the global scope which can be used across different environments.<pre class="language-ts"><code class="language-ts"><span class="token comment">// in a global file:</span>

<span class="token keyword">var</span> abc <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>

<span class="token comment">// Refers to 'abc' from above.</span>
globalThis<span class="token punctuation">.</span><span class="token property-access">abc</span> <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span></code></pre><p>Note that global variables declared with <code>let</code> and <code>const</code> don't show up on <code>globalThis</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> answer <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

<span class="token comment">// error! Property 'answer' does not exist on 'typeof globalThis'.</span>
globalThis<span class="token punctuation">.</span><span class="token property-access">answer</span> <span class="token operator">=</span> <span class="token number">333333</span><span class="token punctuation">;</span></code></pre><p>It's also important to note that TypeScript doesn't transform references to <code>globalThis</code> when compiling to older versions of ECMAScript. As such, unless you're targeting evergreen browsers (which already support <code>globalThis</code>), you may want to <a href="https://github.com/ljharb/globalThis">use an appropriate polyfill</a> instead.<p>For more details on the implementation, see <a href="https://github.com/Microsoft/TypeScript/pull/29332">the feature's pull request</a>. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section>