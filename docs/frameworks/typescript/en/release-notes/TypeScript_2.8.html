<!doctype html><html lang="en"><meta charset="utf-8"><title>TypeScript 2.8</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/release-notes/typescript-2-8.html"><meta name="oneline"content="TypeScript 2.8 Release Notes"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="conditional-types"class="level2"><h2>Conditional Types</h2><p>TypeScript 2.8 introduces <em>conditional types</em> which add the ability to express non-uniform type mappings. A conditional type selects one of two possible types based on a condition expressed as a type relationship test:<pre class="language-ts"><code class="language-ts"><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token constant">X</span> <span class="token operator">:</span> <span class="token constant">Y</span></code></pre><p>The type above means when <code>T</code> is assignable to <code>U</code> the type is <code>X</code>, otherwise the type is <code>Y</code>.<p>A conditional type <code>T extends U ? X : Y</code> is either <em>resolved</em> to <code>X</code> or <code>Y</code>, or <em>deferred</em> because the condition depends on one or more type variables. Whether to resolve or defer is determined as follows:<ul><li>First, given types <code>T'</code> and <code>U'</code> that are instantiations of <code>T</code> and <code>U</code> where all occurrences of type parameters are replaced with <code>any</code>, if <code>T'</code> is not assignable to <code>U'</code>, the conditional type is resolved to <code>Y</code>. Intuitively, if the most permissive instantiation of <code>T</code> is not assignable to the most permissive instantiation of <code>U</code>, we know that no instantiation will be and we can just resolve to <code>Y</code>.<li>Next, for each type variable introduced by an <code>infer</code> (more later) declaration within <code>U</code> collect a set of candidate types by inferring from <code>T</code> to <code>U</code> (using the same inference algorithm as type inference for generic functions). For a given <code>infer</code> type variable <code>V</code>, if any candidates were inferred from co-variant positions, the type inferred for <code>V</code> is a union of those candidates. Otherwise, if any candidates were inferred from contra-variant positions, the type inferred for <code>V</code> is an intersection of those candidates. Otherwise, the type inferred for <code>V</code> is <code>never</code>.<li>Then, given a type <code>T''</code> that is an instantiation of <code>T</code> where all <code>infer</code> type variables are replaced with the types inferred in the previous step, if <code>T''</code> is <em>definitely assignable</em> to <code>U</code>, the conditional type is resolved to <code>X</code>. The definitely assignable relation is the same as the regular assignable relation, except that type variable constraints are not considered. Intuitively, when a type is definitely assignable to another type, we know that it will be assignable for <em>all instantiations</em> of those types.<li>Otherwise, the condition depends on one or more type variables and the conditional type is deferred.</ul><section id="example"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span>
  <span class="token operator">?</span> <span class="token string">"string"</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span>
  <span class="token operator">?</span> <span class="token string">"number"</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span>
  <span class="token operator">?</span> <span class="token string">"boolean"</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword nil">undefined</span></span>
  <span class="token operator">?</span> <span class="token string">"undefined"</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token known-class-name class-name">Function</span></span>
  <span class="token operator">?</span> <span class="token string">"function"</span>
  <span class="token operator">:</span> <span class="token string">"object"</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T0</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "string"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token string">"a"</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "string"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token boolean">true</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "boolean"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T3</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "function"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T4</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "object"</span></code></pre></section></section><section id="distributive-conditional-types"class="level2"><h2>Distributive conditional types</h2><p>Conditional types in which the checked type is a naked type parameter are called <em>distributive conditional types</em>. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of <code>T extends U ? X : Y</code> with the type argument <code>A | B | C</code> for <code>T</code> is resolved as <code>(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</code>.<section id="example-1"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T10</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "string" | "function"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T12</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "string" | "object" | "undefined"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T11</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">TypeName</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "object"</span></code></pre><p>In instantiations of a distributive conditional type <code>T extends U ? X : Y</code>, references to <code>T</code> within the conditional type are resolved to individual constituents of the union type (i.e. <code>T</code> refers to the individual constituents <em>after</em> the conditional type is distributed over the union type). Furthermore, references to <code>T</code> within <code>X</code> have an additional type parameter constraint <code>U</code> (i.e. <code>T</code> is considered assignable to <code>U</code> within <code>X</code>).</section><section id="example-2"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">BoxedValue</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">BoxedArray</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> array<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Boxed</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token maybe-class-name">BoxedArray</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">:</span> <span class="token maybe-class-name">BoxedValue</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T20</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Boxed</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// BoxedValue&#x3C;string>;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T21</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Boxed</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// BoxedArray&#x3C;number>;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T22</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Boxed</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// BoxedValue&#x3C;string> | BoxedArray&#x3C;number>;</span></code></pre><p>Notice that <code>T</code> has the additional constraint <code>any[]</code> within the true branch of <code>Boxed&#x3C;T></code> and it is therefore possible to refer to the element type of the array as <code>T[number]</code>. Also, notice how the conditional type is distributed over the union type in the last example.<p>The distributive property of conditional types can conveniently be used to <em>filter</em> union types:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Diff</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span> <span class="token comment">// Remove types from T that are assignable to U</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Filter</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token constant">T</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span> <span class="token comment">// Remove types from T that are not assignable to U</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T30</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Diff</span><span class="token operator">&#x3C;</span><span class="token string">"a"</span> <span class="token operator">|</span> <span class="token string">"b"</span> <span class="token operator">|</span> <span class="token string">"c"</span> <span class="token operator">|</span> <span class="token string">"d"</span><span class="token punctuation">,</span> <span class="token string">"a"</span> <span class="token operator">|</span> <span class="token string">"c"</span> <span class="token operator">|</span> <span class="token string">"f"</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "b" | "d"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T31</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Filter</span><span class="token operator">&#x3C;</span><span class="token string">"a"</span> <span class="token operator">|</span> <span class="token string">"b"</span> <span class="token operator">|</span> <span class="token string">"c"</span> <span class="token operator">|</span> <span class="token string">"d"</span><span class="token punctuation">,</span> <span class="token string">"a"</span> <span class="token operator">|</span> <span class="token string">"c"</span> <span class="token operator">|</span> <span class="token string">"f"</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "a" | "c"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T32</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Diff</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token known-class-name class-name">Function</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// string | number</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T33</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Filter</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token known-class-name class-name">Function</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// () => void</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">NonNullable</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Diff</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token keyword null nil">null</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// Remove null and undefined from T</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T34</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">NonNullable</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// string | number</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T35</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">NonNullable</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// string | string[]</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">f1</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token maybe-class-name">NonNullable</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  x <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">// Ok</span>
  y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// Error</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">f2</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token maybe-class-name">NonNullable</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  x <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">// Ok</span>
  y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// Error</span>
  <span class="token keyword">let</span> s1<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// Error</span>
  <span class="token keyword">let</span> s2<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">// Ok</span>
<span class="token punctuation">}</span></code></pre><p>Conditional types are particularly useful when combined with mapped types:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">FunctionPropertyNames</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token known-class-name class-name">Function</span></span> <span class="token operator">?</span> <span class="token constant">K</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">FunctionProperties</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Pick</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token maybe-class-name">FunctionPropertyNames</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">>></span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">NonFunctionPropertyNames</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token known-class-name class-name">Function</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">NonFunctionProperties</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Pick</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token maybe-class-name">NonFunctionPropertyNames</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">>></span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Part</span></span> <span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  subparts<span class="token operator">:</span> <span class="token maybe-class-name">Part</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">updatePart</span><span class="token punctuation">(</span>newName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T40</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">FunctionPropertyNames</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Part</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "updatePart"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T41</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">NonFunctionPropertyNames</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Part</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "id" | "name" | "subparts"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T42</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">FunctionProperties</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Part</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// { updatePart(newName: string): void }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T43</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">NonFunctionProperties</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Part</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// { id: number, name: string, subparts: Part[] }</span></code></pre><p>Similar to union and intersection types, conditional types are not permitted to reference themselves recursively. For example the following is an error.</section><section id="example-3"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">ElementType</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token maybe-class-name">ElementType</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span> <span class="token comment">// Error</span></code></pre></section></section><section id="type-inference-in-conditional-types"class="level2"><h2>Type inference in conditional types</h2><p>Within the <code>extends</code> clause of a conditional type, it is now possible to have <code>infer</code> declarations that introduce a type variable to be inferred. Such inferred type variables may be referenced in the true branch of the conditional type. It is possible to have multiple <code>infer</code> locations for the same type variable.<p>For example, the following extracts the return type of a function type:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">infer</span> <span class="token constant">R</span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span></code></pre><p>Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Unpacked</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token operator">?</span> <span class="token constant">U</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">infer</span> <span class="token constant">U</span>
  <span class="token operator">?</span> <span class="token constant">U</span>
  <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token keyword">infer</span> <span class="token constant">U</span><span class="token operator">></span></span>
  <span class="token operator">?</span> <span class="token constant">U</span>
  <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T0</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Unpacked</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Unpacked</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Unpacked</span><span class="token operator">&#x3C;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T3</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Unpacked</span><span class="token operator">&#x3C;</span><span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">>></span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T4</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Unpacked</span><span class="token operator">&#x3C;</span><span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// Promise&#x3C;string></span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T5</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Unpacked</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Unpacked</span><span class="token operator">&#x3C;</span><span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token punctuation">;</span> <span class="token comment">// string</span></code></pre><p>The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span> <span class="token punctuation">}</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T10</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T11</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// string | number</span></code></pre><p>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Bar</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span>
  <span class="token operator">?</span> <span class="token constant">U</span>
  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T20</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Bar</span><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T21</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Bar</span><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// string &#x26; number</span></code></pre><p>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the <em>last</em> signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T30</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;</span><span class="token keyword">typeof</span> foo<span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// string | number</span></code></pre><p>It is not possible to use <code>infer</code> declarations in constraint clauses for regular type parameters:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span></span> <span class="token keyword">infer</span> <span class="token constant">R</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">;</span> <span class="token comment">// Error, not supported</span></code></pre><p>However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">AnyFunction</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token maybe-class-name">AnyFunction</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">infer</span> <span class="token constant">R</span>
  <span class="token operator">?</span> <span class="token constant">R</span>
  <span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span></code></pre></section><section id="predefined-conditional-types"class="level2"><h2>Predefined conditional types</h2><p>TypeScript 2.8 adds several predefined conditional types to <code>lib.d.ts</code>:<ul><li><code>Exclude&#x3C;T, U></code> -- Exclude from <code>T</code> those types that are assignable to <code>U</code>.<li><code>Extract&#x3C;T, U></code> -- Extract from <code>T</code> those types that are assignable to <code>U</code>.<li><code>NonNullable&#x3C;T></code> -- Exclude <code>null</code> and <code>undefined</code> from <code>T</code>.<li><code>ReturnType&#x3C;T></code> -- Obtain the return type of a function type.<li><code>InstanceType&#x3C;T></code> -- Obtain the instance type of a constructor function type.</ul><section id="example-4"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T00</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Exclude</span><span class="token operator">&#x3C;</span><span class="token string">"a"</span> <span class="token operator">|</span> <span class="token string">"b"</span> <span class="token operator">|</span> <span class="token string">"c"</span> <span class="token operator">|</span> <span class="token string">"d"</span><span class="token punctuation">,</span> <span class="token string">"a"</span> <span class="token operator">|</span> <span class="token string">"c"</span> <span class="token operator">|</span> <span class="token string">"f"</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "b" | "d"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T01</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Extract</span><span class="token operator">&#x3C;</span><span class="token string">"a"</span> <span class="token operator">|</span> <span class="token string">"b"</span> <span class="token operator">|</span> <span class="token string">"c"</span> <span class="token operator">|</span> <span class="token string">"d"</span><span class="token punctuation">,</span> <span class="token string">"a"</span> <span class="token operator">|</span> <span class="token string">"c"</span> <span class="token operator">|</span> <span class="token string">"f"</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "a" | "c"</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T02</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Exclude</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token known-class-name class-name">Function</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// string | number</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T03</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Extract</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token known-class-name class-name">Function</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// () => void</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T04</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">NonNullable</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// string | number</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T05</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">NonNullable</span><span class="token operator">&#x3C;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// (() => string) | string[]</span>

<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> s <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T10</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T11</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// void</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T12</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// {}</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T13</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;&#x3C;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span><span class="token punctuation">,</span> <span class="token constant">U</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// number[]</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T14</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;</span><span class="token keyword">typeof</span> f1<span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// { a: number, b: string }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T15</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// any</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T16</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;</span><span class="token builtin">never</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// any</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T17</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T18</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">ReturnType</span><span class="token operator">&#x3C;</span><span class="token known-class-name class-name">Function</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// Error</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T20</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">InstanceType</span><span class="token operator">&#x3C;</span><span class="token keyword">typeof</span> <span class="token constant">C</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// C</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T21</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">InstanceType</span><span class="token operator">&#x3C;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// any</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T22</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">InstanceType</span><span class="token operator">&#x3C;</span><span class="token builtin">never</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// any</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T23</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">InstanceType</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T24</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">InstanceType</span><span class="token operator">&#x3C;</span><span class="token known-class-name class-name">Function</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// Error</span></code></pre><blockquote><p>Note: The <code>Exclude</code> type is a proper implementation of the <code>Diff</code> type suggested <a href="https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458">here</a>. We've used the name <code>Exclude</code> to avoid breaking existing code that defines a <code>Diff</code>, plus we feel that name better conveys the semantics of the type. We did not include the <code>Omit&#x3C;T, K></code> type because it is trivially written as <code>Pick&#x3C;T, Exclude&#x3C;keyof T, K>></code>.</blockquote></section></section><section id="improved-control-over-mapped-type-modifiers"class="level2"><h2>Improved control over mapped type modifiers</h2><p>Mapped types support adding a <code>readonly</code> or <code>?</code> modifier to a mapped property, but they did not provide support the ability to <em>remove</em> modifiers. This matters in <a href="https://github.com/Microsoft/TypeScript/pull/12563"><em>homomorphic mapped types</em></a> which by default preserve the modifiers of the underlying type.<p>TypeScript 2.8 adds the ability for a mapped type to either add or remove a particular modifier. Specifically, a <code>readonly</code> or <code>?</code> property modifier in a mapped type can now be prefixed with either <code>+</code> or <code>-</code> to indicate that the modifier should be added or removed.<section id="example-5"class="level4"><h4>Example</h4><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">MutableRequired</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">-</span><span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// Remove readonly and ?</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">ReadonlyPartial</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">+</span><span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// Add readonly and ?</span></code></pre><p>A modifier with no <code>+</code> or <code>-</code> prefix is the same as a modifier with a <code>+</code> prefix. So, the <code>ReadonlyPartial&#x3C;T></code> type above corresponds to<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">ReadonlyPartial</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// Add readonly and ?</span></code></pre><p>Using this ability, <code>lib.d.ts</code> now has a new <code>Required&#x3C;T></code> type. This type strips <code>?</code> modifiers from all properties of <code>T</code>, thus making all properties required.<section id="example-6"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Required</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Note that in <a href="/tsconfig#strictNullChecks"><code>strictNullChecks</code></a> mode, when a homomorphic mapped type removes a <code>?</code> modifier from a property in the underlying type it also removes <code>undefined</code> from the type of that property:</section><section id="example-7"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// Same as { a?: string | undefined }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Bar</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Required</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Foo</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// Same as { a: string }</span></code></pre></section></section></section><section id="improved-keyof-with-intersection-types"class="level2"><h2>Improved <code>keyof</code> with intersection types</h2><p>With TypeScript 2.8 <code>keyof</code> applied to an intersection type is transformed to a union of <code>keyof</code> applied to each intersection constituent. In other words, types of the form <code>keyof (A &#x26; B)</code> are transformed to be <code>keyof A | keyof B</code>. This change should address inconsistencies with inference from <code>keyof</code> expressions.<section id="example-8"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> b<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token punctuation">(</span><span class="token constant">A</span> <span class="token operator">&#x26;</span> <span class="token constant">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "a" | "b"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token punctuation">(</span><span class="token constant">T</span> <span class="token operator">&#x26;</span> <span class="token constant">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// keyof T | "b"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T3</span><span class="token operator">&#x3C;</span><span class="token constant">U</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token punctuation">(</span><span class="token constant">A</span> <span class="token operator">&#x26;</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "a" | keyof U</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T4</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token punctuation">(</span><span class="token constant">T</span> <span class="token operator">&#x26;</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// keyof T | keyof U</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T5</span></span> <span class="token operator">=</span> <span class="token constant">T2</span><span class="token operator">&#x3C;</span><span class="token constant">A</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "a" | "b"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T6</span></span> <span class="token operator">=</span> <span class="token constant">T3</span><span class="token operator">&#x3C;</span><span class="token constant">B</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "a" | "b"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T7</span></span> <span class="token operator">=</span> <span class="token constant">T4</span><span class="token operator">&#x3C;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// "a" | "b"</span></code></pre></section></section><section id="better-handling-for-namespace-patterns-in-js-files"class="level2"><h2>Better handling for namespace patterns in <code>.js</code> files</h2><p>TypeScript 2.8 adds support for understanding more namespace patterns in <code>.js</code> files. Empty object literals declarations on top level, just like functions and classes, are now recognized as as namespace declarations in JavaScript.<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> ns <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// recognized as a declaration for a namespace `ns`</span>
ns<span class="token punctuation">.</span><span class="token property-access">constant</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// recognized as a declaration for var `constant`</span></code></pre><p>Assignments at the top-level should behave the same way; in other words, a <code>var</code> or <code>const</code> declaration is not required.<pre class="language-js"><code class="language-js">app <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// does NOT need to be `var app = {}`</span>
app<span class="token punctuation">.</span><span class="token constant">C</span> <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
app<span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">f</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
app<span class="token punctuation">.</span><span class="token property-access">prop</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre></section><section id="iifes-as-namespace-declarations"class="level2"><h2>IIFEs as namespace declarations</h2><p>An IIFE returning a function, class or empty object literal, is also recognized as a namespace:<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token constant">C</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">C</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">p</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> <span class="token constant">C</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token constant">C</span><span class="token punctuation">.</span><span class="token property-access">staticProperty</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre></section><section id="defaulted-declarations"class="level2"><h2>Defaulted declarations</h2><p>"Defaulted declarations" allow initializers that reference the declared name in the left side of a logical or:<pre class="language-js"><code class="language-js">my <span class="token operator">=</span> <span class="token dom variable">window</span><span class="token punctuation">.</span><span class="token property-access">my</span> <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
my<span class="token punctuation">.</span><span class="token property-access">app</span> <span class="token operator">=</span> my<span class="token punctuation">.</span><span class="token property-access">app</span> <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></section><section id="prototype-assignment"class="level2"><h2>Prototype assignment</h2><p>You can assign an object literal directly to the prototype property. Individual prototype assignments still work too:<pre class="language-ts"><code class="language-ts"><span class="token keyword">var</span> <span class="token function-variable function"><span class="token maybe-class-name">C</span></span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">p</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token constant">C</span><span class="token punctuation">.</span><span class="token property-access">prototype</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">p</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token constant">C</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">q</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">p</span> <span class="token operator">===</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></section><section id="nested-and-merged-declarations"class="level2"><h2>Nested and merged declarations</h2><p>Nesting works to any level now, and merges correctly across files. Previously neither was the case.<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token dom variable">window</span><span class="token punctuation">.</span><span class="token property-access">app</span> <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
app<span class="token punctuation">.</span><span class="token constant">C</span> <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></section><section id="per-file-jsx-factories"class="level2"><h2>Per-file JSX factories</h2><p>TypeScript 2.8 adds support for a per-file configurable JSX factory name using <code>@jsx dom</code> pragma. JSX factory can be configured for a compilation using <a href="/tsconfig#jsxFactory"><code>jsxFactory</code></a> (default is <code>React.createElement</code>). With TypeScript 2.8 you can override this on a per-file-basis by adding a comment to the beginning of the file.<section id="example-9"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token doc-comment comment">/** <span class="token keyword">@jsx</span> dom */</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> dom <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"./renderer"</span><span class="token punctuation">;</span>
<span class="token operator">&#x3C;</span>h<span class="token operator">></span><span class="token operator">&#x3C;</span><span class="token operator">/</span>h<span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>Generates:<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> renderer_1 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./renderer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
renderer_1<span class="token punctuation">.</span><span class="token method function property-access">dom</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">,</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section></section><section id="locally-scoped-jsx-namespaces"class="level2"><h2>Locally scoped JSX namespaces</h2><p>JSX type checking is driven by definitions in a JSX namespace, for instance <code>JSX.Element</code> for the type of a JSX element, and <code>JSX.IntrinsicElements</code> for built-in elements. Before TypeScript 2.8 the <code>JSX</code> namespace was expected to be in the global namespace, and thus only allowing one to be defined in a project. Starting with TypeScript 2.8 the <code>JSX</code> namespace will be looked under the <code>jsxNamespace</code> (e.g. <code>React</code>) allowing for multiple jsx factories in one compilation. For backward compatibility the global <code>JSX</code> namespace is used as a fallback if none was defined on the factory function. Combined with the per-file <code>@jsx</code> pragma, each file can have a different JSX factory.</section><section id="new---emitdeclarationonly"class="level2"><h2>New <code>--emitDeclarationOnly</code></h2><p><a href="/tsconfig#emitDeclarationOnly"><code>emitDeclarationOnly</code></a> allows for <em>only</em> generating declaration files; <code>.js</code>/<code>.jsx</code> output generation will be skipped with this flag. The flag is useful when the <code>.js</code> output generation is handled by a different transpiler like Babel. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section>