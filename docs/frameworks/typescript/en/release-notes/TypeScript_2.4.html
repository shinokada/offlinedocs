<!doctype html><html lang="en"><meta charset="utf-8"><title>TypeScript 2.4</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/release-notes/typescript-2-4.html"><meta name="oneline"content="TypeScript 2.4 Release Notes"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="dynamic-import-expressions"class="level2"><h2>Dynamic Import Expressions</h2><p>Dynamic <code>import</code> expressions are a new feature and part of ECMAScript that allows users to asynchronously request a module at any arbitrary point in your program.<p>This means that you can conditionally and lazily import other modules and libraries. For example, here's an <code>async</code> function that only imports a utility library when it's needed:<pre class="language-ts"><code class="language-ts"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getZipFile</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> files<span class="token operator">:</span> <span class="token maybe-class-name">File</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">File</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> zipUtil <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">"./utils/create-zip-file"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> zipContents <span class="token operator">=</span> <span class="token keyword control-flow">await</span> zipUtil<span class="token punctuation">.</span><span class="token method function property-access">getContentAsBlob</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">File</span></span><span class="token punctuation">(</span>zipContents<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Many bundlers have support for automatically splitting output bundles based on these <code>import</code> expressions, so consider using this new feature with the <code>esnext</code> module target.</section><section id="string-enums"class="level2"><h2>String Enums</h2><p>TypeScript 2.4 now allows enum members to contain string initializers.<pre class="language-ts"><code class="language-ts"><span class="token keyword">enum</span> <span class="token maybe-class-name">Colors</span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">Red</span> <span class="token operator">=</span> <span class="token string">"RED"</span><span class="token punctuation">,</span>
  <span class="token maybe-class-name">Green</span> <span class="token operator">=</span> <span class="token string">"GREEN"</span><span class="token punctuation">,</span>
  <span class="token maybe-class-name">Blue</span> <span class="token operator">=</span> <span class="token string">"BLUE"</span>
<span class="token punctuation">}</span></code></pre><p>The caveat is that string-initialized enums can't be reverse-mapped to get the original enum member name. In other words, you can't write <code>Colors["RED"]</code> to get the string <code>"Red"</code>.</section><section id="improved-inference-for-generics"class="level2"><h2>Improved inference for generics</h2><p>TypeScript 2.4 introduces a few wonderful changes around the way generics are inferred.<section id="return-types-as-inference-targets"class="level3"><h3>Return types as inference targets</h3><p>For one, TypeScript can now make inferences for the return type of a call. This can improve your experience and catch errors. Something that now works:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">arrayMap</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function-variable function">f</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">U</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> a <span class="token arrow operator">=></span> a<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">lengths</span><span class="token operator">:</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">arrayMap</span><span class="token punctuation">(</span>s <span class="token arrow operator">=></span> s<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>As an example of new errors you might spot as a result:<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> x<span class="token operator">:</span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Promise</span></span><span class="token punctuation">(</span>resolve <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//      ~~ Error!</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section><section id="type-parameter-inference-from-contextual-types"class="level3"><h3>Type parameter inference from contextual types</h3><p>Prior to TypeScript 2.4, in the following example<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> f<span class="token operator">:</span> <span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function-variable function"><span class="token maybe-class-name">T</span></span> <span class="token operator">=</span> y <span class="token arrow operator">=></span> y<span class="token punctuation">;</span></code></pre><p><code>y</code> would have the type <code>any</code>. This meant the program would type-check, but you could technically do anything with <code>y</code>, such as the following:<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> f<span class="token operator">:</span> <span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function-variable function"><span class="token maybe-class-name">T</span></span> <span class="token operator">=</span> y <span class="token arrow operator">=></span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> y<span class="token punctuation">.</span><span class="token property-access">foo</span><span class="token punctuation">.</span><span class="token property-access">bar</span><span class="token punctuation">;</span></code></pre><p>That last example isn't actually type-safe.<p>In TypeScript 2.4, the function on the right side implicitly <em>gains</em> type parameters, and <code>y</code> is inferred to have the type of that type-parameter.<p>If you use <code>y</code> in a way that the type parameter's constraint doesn't support, you'll correctly get an error. In this case, the constraint of <code>T</code> was (implicitly) <code>{}</code>, so the last example will appropriately fail.</section><section id="stricter-checking-for-generic-functions"class="level3"><h3>Stricter checking for generic functions</h3><p>TypeScript now tries to unify type parameters when comparing two single-signature types. As a result, you'll get stricter checks when relating two generic signatures, and may catch some bugs.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token operator">&#x3C;</span><span class="token constant">S</span><span class="token operator">></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">S</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token constant">S</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">S</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// Error</span>
  b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// Ok</span>
<span class="token punctuation">}</span></code></pre></section></section><section id="strict-contravariance-for-callback-parameters"class="level2"><h2>Strict contravariance for callback parameters</h2><p>TypeScript has always compared parameters in a bivariant way. There are a number of reasons for this, but by-and-large this was not been a huge issue for our users until we saw some of the adverse effects it had with <code>Promise</code>s and <code>Observable</code>s.<p>TypeScript 2.4 introduces tightens this up when relating two callback types. For example:<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Mappable</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  <span class="token generic-function"><span class="token function">map</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">U</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function-variable function">f</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Mappable</span><span class="token operator">&#x3C;</span><span class="token constant">U</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">let</span> a<span class="token operator">:</span> <span class="token maybe-class-name">Mappable</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> b<span class="token operator">:</span> <span class="token maybe-class-name">Mappable</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">;</span>

a <span class="token operator">=</span> b<span class="token punctuation">;</span>
b <span class="token operator">=</span> a<span class="token punctuation">;</span></code></pre><p>Prior to TypeScript 2.4, this example would succeed. When relating the types of <code>map</code>, TypeScript would bidirectionally relate their parameters (i.e. the type of <code>f</code>). When relating each <code>f</code>, TypeScript would also bidirectionally relate the type of <em>those</em> parameters.<p>When relating the type of <code>map</code> in TS 2.4, the language will check whether each parameter is a callback type, and if so, it will ensure that those parameters are checked in a contravariant manner with respect to the current relation.<p>In other words, TypeScript now catches the above bug, which may be a breaking change for some users, but will largely be helpful.</section><section id="weak-type-detection"class="level2"><h2>Weak Type Detection</h2><p>TypeScript 2.4 introduces the concept of "weak types". Any type that contains nothing but a set of all-optional properties is considered to be <em>weak</em>. For example, this <code>Options</code> type is a weak type:<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Options</span></span> <span class="token punctuation">{</span>
  data<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  timeout<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  maxRetries<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>In TypeScript 2.4, it's now an error to assign anything to a weak type when there's no overlap in properties. For example:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>options<span class="token operator">:</span> <span class="token maybe-class-name">Options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> opts <span class="token operator">=</span> <span class="token punctuation">{</span>
  payload<span class="token operator">:</span> <span class="token string">"hello world!"</span><span class="token punctuation">,</span>
  retryOnFail<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Error!</span>
<span class="token function">sendMessage</span><span class="token punctuation">(</span>opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// No overlap between the type of 'opts' and 'Options' itself.</span>
<span class="token comment">// Maybe we meant to use 'data'/'maxRetries' instead of 'payload'/'retryOnFail'.</span></code></pre><p>You can think of this as TypeScript "toughening up" the weak guarantees of these types to catch what would otherwise be silent bugs.<p>Since this is a breaking change, you may need to know about the workarounds which are the same as those for strict object literal checks:<ol><li>Declare the properties if they really do exist.<li>Add an index signature to the weak type (i.e. <code>[propName: string]: {}</code>).<li>Use a type assertion (i.e. <code>opts as Options</code>). <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></ol></section>