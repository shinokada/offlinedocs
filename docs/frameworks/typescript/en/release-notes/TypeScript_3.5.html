<!doctype html><html lang="en"><meta charset="utf-8"><title>TypeScript 3.5</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/release-notes/typescript-3-5.html"><meta name="oneline"content="TypeScript 3.5 Release Notes"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="speed-improvements"class="level2"><h2>Speed improvements</h2><p>TypeScript 3.5 introduces several optimizations around type-checking and incremental builds.<section id="type-checking-speed-ups"class="level3"><h3>Type-checking speed-ups</h3><p>TypeScript 3.5 contains certain optimizations over TypeScript 3.4 for type-checking more efficiently. These improvements are significantly more pronounced in editor scenarios where type-checking drives operations like code completion lists.</section><section id="--incremental-improvements"class="level3"><h3><code>--incremental</code> improvements</h3><p>TypeScript 3.5 improves on 3.4's <a href="/tsconfig#incremental"><code>incremental</code></a> build mode, by saving information about how the state of the world was calculated - compiler settings, why files were looked up, where files were found, etc. In scenarios involving hundreds of projects using TypeScript's project references in <code>--build</code> mode, <a href="https://github.com/Microsoft/TypeScript/pull/31101">we've found that the amount of time rebuilding can be reduced by as much as 68% compared to TypeScript 3.4</a>!<p>For more details, you can see the pull requests to<ul><li><a href="https://github.com/Microsoft/TypeScript/pull/31100">cache module resolution</a><li><a href="https://github.com/Microsoft/TypeScript/pull/31101">cache settings calculated from <code>tsconfig.json</code></a></ul></section></section><section id="the-omit-helper-type"class="level2"><h2>The <code>Omit</code> helper type</h2><p>TypeScript 3.5 introduces the new <code>Omit</code> helper type, which creates a new type with some properties dropped from the original.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Person</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token dom variable">location</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">QuantumPerson</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Omit</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Person</span><span class="token punctuation">,</span> <span class="token string">"location"</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">// equivalent to</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">QuantumPerson</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Here we were able to copy over all the properties of <code>Person</code> except for <code>location</code> using the <code>Omit</code> helper.<p>For more details, <a href="https://github.com/Microsoft/TypeScript/pull/30552">see the pull request on GitHub to add <code>Omit</code></a>, as well as <a href="https://github.com/microsoft/TypeScript/pull/31134">the change to use <code>Omit</code> for object rest</a>.<section id="improved-excess-property-checks-in-union-types"class="level3"><h3>Improved excess property checks in union types</h3><p>In TypeScript 3.4 and earlier, certain excess properties were allowed in situations where they really shouldn't have been. For instance, TypeScript 3.4 permitted the incorrect <code>name</code> property in the object literal even though its types don't match between <code>Point</code> and <code>Label</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Point</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Label</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> thing<span class="token operator">:</span> <span class="token maybe-class-name">Point</span> <span class="token operator">|</span> <span class="token maybe-class-name">Label</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  y<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// uh-oh!</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Previously, a non-disciminated union wouldn't have <em>any</em> excess property checking done on its members, and as a result, the incorrectly typed <code>name</code> property slipped by.<p>In TypeScript 3.5, the type-checker at least verifies that all the provided properties belong to <em>some</em> union member and have the appropriate type, meaning that the sample above correctly issues an error.<p>Note that partial overlap is still permitted as long as the property types are valid.<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> pl<span class="token operator">:</span> <span class="token maybe-class-name">Point</span> <span class="token operator">|</span> <span class="token maybe-class-name">Label</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  y<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">"origin"</span> <span class="token comment">// okay</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></section></section><section id="the---allowumdglobalaccess-flag"class="level2"><h2>The <code>--allowUmdGlobalAccess</code> flag</h2><p>In TypeScript 3.5, you can now reference UMD global declarations like<pre class="language-text"><code class="language-text">export as namespace foo;</code></pre><p>from anywhere - even modules - using the new <a href="/tsconfig#allowUmdGlobalAccess"><code>allowUmdGlobalAccess</code></a> flag.<p>This mode adds flexibility for mixing and matching the way 3rd party libraries, where globals that libraries declare can always be consumed, even from within modules.<p>For more details, <a href="https://github.com/Microsoft/TypeScript/pull/30776/files">see the pull request on GitHub</a>.</section><section id="smarter-union-type-checking"class="level2"><h2>Smarter union type checking</h2><p>In TypeScript 3.4 and prior, the following example would fail:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">S</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> done<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span> value<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> done<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span> value<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span> <span class="token operator">|</span> <span class="token punctuation">{</span> done<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">;</span> value<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">declare</span> <span class="token keyword">let</span> source<span class="token operator">:</span> <span class="token constant">S</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> target<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

target <span class="token operator">=</span> source<span class="token punctuation">;</span></code></pre><p>That's because <code>S</code> isn't assignable to <code>{ done: false, value: number }</code> nor <code>{ done: true, value: number }</code>. Why? Because the <code>done</code> property in <code>S</code> isn't specific enough - it's <code>boolean</code> whereas each constituent of <code>T</code> has a <code>done</code> property that's specifically <code>true</code> or <code>false</code>. That's what we meant by each constituent type being checked in isolation: TypeScript doesn't just union each property together and see if <code>S</code> is assignable to that. If it did, some bad code could get through like the following:<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span> <span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">"foo"</span><span class="token punctuation">;</span>
  value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Bar</span></span> <span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">"bar"</span><span class="token punctuation">;</span>
  value<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token maybe-class-name">Foo</span> <span class="token operator">|</span> <span class="token maybe-class-name">Bar</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token property-access">kind</span> <span class="token operator">===</span> <span class="token string">"foo"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">.</span><span class="token method function property-access">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// uh-oh - luckily TypeScript errors here!</span>
<span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">"foo"</span><span class="token punctuation">,</span>
  value<span class="token operator">:</span> <span class="token number">123</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>However, this was a bit overly strict for the original example. If you figure out the precise type of any possible value of <code>S</code>, you can actually see that it matches the types in <code>T</code> exactly.<p>In TypeScript 3.5, when assigning to types with discriminant properties like in <code>T</code>, the language actually <em>will</em> go further and decompose types like <code>S</code> into a union of every possible inhabitant type. In this case, since <code>boolean</code> is a union of <code>true</code> and <code>false</code>, <code>S</code> will be viewed as a union of <code>{ done: false, value: number }</code> and <code>{ done: true, value: number }</code>.<p>For more details, you can <a href="https://github.com/microsoft/TypeScript/pull/30779">see the original pull request on GitHub</a>.</section><section id="higher-order-type-inference-from-generic-constructors"class="level2"><h2>Higher order type inference from generic constructors</h2><p>In TypeScript 3.4, we improved inference for when generic functions that return functions like so:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">compose</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function-variable function">f</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">U</span><span class="token punctuation">,</span> <span class="token function-variable function">g</span><span class="token operator">:</span> <span class="token punctuation">(</span>y<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">V</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">V</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> x <span class="token arrow operator">=></span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>took other generic functions as arguments, like so:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">arrayify</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Box</span><span class="token operator">&#x3C;</span><span class="token constant">U</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token constant">U</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">boxify</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">U</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>y<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Box</span><span class="token operator">&#x3C;</span><span class="token constant">U</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> y <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> newFn <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>arrayify<span class="token punctuation">,</span> boxify<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Instead of a relatively useless type like <code>(x: {}) => Box&#x3C;{}[]></code>, which older versions of the language would infer, TypeScript 3.4's inference allows <code>newFn</code> to be generic. Its new type is <code>&#x3C;T>(x: T) => Box&#x3C;T[]></code>.<p>TypeScript 3.5 generalizes this behavior to work on constructor functions as well.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Box</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">"box"</span><span class="token punctuation">;</span>
  value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Bag</span><span class="token operator">&#x3C;</span><span class="token constant">U</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">"bag"</span><span class="token punctuation">;</span>
  value<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">composeCtor</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
  <span class="token constant">F</span><span class="token operator">:</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">U</span><span class="token punctuation">,</span>
  <span class="token constant">G</span><span class="token operator">:</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>y<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">V</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">V</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> x <span class="token arrow operator">=></span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">G</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name"><span class="token constant">F</span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token function">composeCtor</span><span class="token punctuation">(</span><span class="token maybe-class-name">Box</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Bag</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// has type '&#x3C;T>(x: T) => Bag&#x3C;Box&#x3C;T>>'</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// has type 'Bag&#x3C;Box&#x3C;number>>'</span></code></pre><p>In addition to compositional patterns like the above, this new inference on generic constructors means that functions that operate on class components in certain UI libraries like React can more correctly operate on generic class components.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">ComponentClass</span><span class="token operator">&#x3C;</span><span class="token constant">P</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>props<span class="token operator">:</span> <span class="token constant">P</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">Component</span><span class="token operator">&#x3C;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Component</span><span class="token operator">&#x3C;</span><span class="token constant">P</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token constant">P</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token operator">:</span> <span class="token constant">P</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">myHoc</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">P</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token operator">:</span> <span class="token maybe-class-name">ComponentClass</span><span class="token operator">&#x3C;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">ComponentClass</span><span class="token operator">&#x3C;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">NestedProps</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> stuff<span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">declare</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">GenericComponent</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">Component</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">NestedProps</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">>></span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// type is 'new &#x3C;T>(props: NestedProps&#x3C;T>) => Component&#x3C;NestedProps&#x3C;T>>'</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">GenericComponent2</span> <span class="token operator">=</span> <span class="token function">myHoc</span><span class="token punctuation">(</span><span class="token maybe-class-name">GenericComponent</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>To learn more, <a href="https://github.com/microsoft/TypeScript/pull/31116">check out the original pull request on GitHub</a>. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section>