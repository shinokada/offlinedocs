<!doctype html><html lang="en"><meta charset="utf-8"><title>TypeScript 4.3</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/release-notes/typescript-4-3.html"><meta name="oneline"content="TypeScript 4.3 Release Notes"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="separate-write-types-on-properties"class="level2"><h2>Separate Write Types on Properties</h2><p>In JavaScript, it's pretty common for APIs to convert values that are passed in before storing them. This often happens with getters and setters too. For example, let's imagine we've got a class with a setter that always converts a value into a <code>number</code> before saving it in a private field.<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Thing</span> <span class="token punctuation">{</span>
  #size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">get</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#size</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">set</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token known-class-name class-name">Number</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Don't allow NaN and stuff.</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Number</span><span class="token punctuation">.</span><span class="token method function property-access">isFinite</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#size</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#size</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>How would we type this JavaScript code in TypeScript? Well, technically we don't have to do anything special here - TypeScript can look at this with no explicit types and can figure out that <code>size</code> is a number.<p>The problem is that <code>size</code> allows you to assign more than just <code>number</code>s to it. We could get around this by saying that <code>size</code> has the type <code>unknown</code> or <code>any</code> like in this snippet:<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Thing</span></span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">get</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">unknown</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#size</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>But that's no good - <code>unknown</code> forces people reading <code>size</code> to do a type assertion, and <code>any</code> won't catch any mistakes. If we really want to model APIs that convert values, previous versions of TypeScript forced us to pick between being precise (which makes reading values easier, and writing harder) and being permissive (which makes writing values easier, and reading harder).<p>That's why TypeScript 4.3 allows you to specify types for reading and writing to properties.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Thing</span></span> <span class="token punctuation">{</span>
  #size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">get</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#size</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">set</span> <span class="token function">size</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token known-class-name class-name">Number</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Don't allow NaN and stuff.</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Number</span><span class="token punctuation">.</span><span class="token method function property-access">isFinite</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#size</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#size</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>In the above example, our <code>set</code> accessor takes a broader set of types (<code>string</code>s, <code>boolean</code>s, and <code>number</code>s), but our <code>get</code> accessor always guarantees it will be a <code>number</code>. Now we can finally assign other types to these properties with no errors!<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Thing</span></span> <span class="token punctuation">{</span>
  #size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">get</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#size</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">set</span> <span class="token function">size</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token known-class-name class-name">Number</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Don't allow NaN and stuff.</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Number</span><span class="token punctuation">.</span><span class="token method function property-access">isFinite</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#size</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#size</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">let</span> thing <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">Thing</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Assigning other types to `thing.size` works!</span>
thing<span class="token punctuation">.</span><span class="token property-access">size</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
thing<span class="token punctuation">.</span><span class="token property-access">size</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
thing<span class="token punctuation">.</span><span class="token property-access">size</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

<span class="token comment">// Reading `thing.size` always produces a number!</span>
<span class="token keyword">let</span> mySize<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> thing<span class="token punctuation">.</span><span class="token property-access">size</span><span class="token punctuation">;</span></code></pre><p>When considering how two properties with the same name relate to each other, TypeScript will only use the "reading" type (e.g. the type on the <code>get</code> accessor above). "Writing" types are only considered when directly writing to a property.<p>Keep in mind, this isn't a pattern that's limited to classes. You can write getters and setters with different types in object literals.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">makeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Thing</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">return</span> size<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">set</span> <span class="token function">size</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token known-class-name class-name">Number</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// Don't allow NaN and stuff.</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Number</span><span class="token punctuation">.</span><span class="token method function property-access">isFinite</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      size <span class="token operator">=</span> num<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>In fact, we've added syntax to interfaces/object types to support different reading/writing types on properties.<pre class="language-ts"><code class="language-ts"><span class="token comment">// Now valid!</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Thing</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span>
    <span class="token keyword">set</span> <span class="token function">size</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>One limitation of using different types for reading and writing properties is that the type for reading a property has to be assignable to the type that you're writing. In other words, the getter type has to be assignable to the setter. This ensures some level of consistency, so that a property is always assignable to itself.<p>For more information on this feature, take a look at <a href="https://github.com/microsoft/TypeScript/pull/42425">the implementing pull request</a>.</section><section id="override-and-the---noimplicitoverride-flag"class="level2"><h2><code>override</code> and the <code>--noImplicitOverride</code> Flag</h2><p>When extending classes in JavaScript, the language makes it super easy (pun intended) to override methods - but unfortunately, there are some mistakes that you can run into.<p>One big one is missing renames. For example, take the following classes:<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">SomeComponent</span></span> <span class="token punctuation">{</span>
  <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
  <span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">SpecializedComponent</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">SomeComponent</span></span> <span class="token punctuation">{</span>
  <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
  <span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p><code>SpecializedComponent</code> subclasses <code>SomeComponent</code>, and overrides the <code>show</code> and <code>hide</code> methods. What happens if someone decides to rip out <code>show</code> and <code>hide</code> and replace them with a single method?<pre class="language-diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">class SomeComponent {
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    show() {
</span><span class="token prefix deleted">-</span><span class="token line">        // ...
</span><span class="token prefix deleted">-</span><span class="token line">    }
</span><span class="token prefix deleted">-</span><span class="token line">    hide() {
</span><span class="token prefix deleted">-</span><span class="token line">        // ...
</span><span class="token prefix deleted">-</span><span class="token line">    }
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    setVisible(value: boolean) {
</span><span class="token prefix inserted">+</span><span class="token line">        // ...
</span><span class="token prefix inserted">+</span><span class="token line">    }
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">}
</span><span class="token prefix unchanged"> </span><span class="token line">class SpecializedComponent extends SomeComponent {
</span><span class="token prefix unchanged"> </span><span class="token line">    show() {
</span><span class="token prefix unchanged"> </span><span class="token line">        // ...
</span><span class="token prefix unchanged"> </span><span class="token line">    }
</span><span class="token prefix unchanged"> </span><span class="token line">    hide() {
</span><span class="token prefix unchanged"> </span><span class="token line">        // ...
</span><span class="token prefix unchanged"> </span><span class="token line">    }
</span><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code></pre><p><em>Oh no!</em> Our <code>SpecializedComponent</code> didn't get updated. Now it's just adding these two useless <code>show</code> and <code>hide</code> methods that probably won't get called.<p>Part of the issue here is that a user can't make it clear whether they meant to add a new method, or to override an existing one. That's why TypeScript 4.3 adds the <code>override</code> keyword.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">SpecializedComponent</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">SomeComponent</span></span> <span class="token punctuation">{</span>
    override <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
    override <span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>When a method is marked with <code>override</code>, TypeScript will always make sure that a method with the same name exists in a the base class.<pre class="language-ts"><code class="language-ts"><span class="token comment">// @noImplicitOverride</span>
<span class="token comment">// @errors: 4113</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">SomeComponent</span></span> <span class="token punctuation">{</span>
    <span class="token function">setVisible</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">SpecializedComponent</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">SomeComponent</span></span> <span class="token punctuation">{</span>
    override <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>This is a big improvement, but it doesn't help if you <em>forget</em> to write <code>override</code> on a method - and that's a big mistake users can run into also.<p>For example, you might accidentally "trample over" a method that exists in a base class without realizing it.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Base</span></span> <span class="token punctuation">{</span>
  <span class="token function">someHelperMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Derived</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">Base</span></span> <span class="token punctuation">{</span>
  <span class="token comment">// Oops! We weren't trying to override here,</span>
  <span class="token comment">// we just needed to write a local helper method.</span>
  <span class="token function">someHelperMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>That's why TypeScript 4.3 <em>also</em> provides a new <a href="/tsconfig#noImplicitOverride"><code>noImplicitOverride</code></a> flag. When this option is turned on, it becomes an error to override any method from a superclass unless you explicitly use an <code>override</code> keyword. In that last example, TypeScript would error under <a href="/tsconfig#noImplicitOverride"><code>noImplicitOverride</code></a>, and give us a clue that we probably need to rename our method inside of <code>Derived</code>.<p>We'd like to extend our thanks to our community for the implementation here. The work for these items was implemented in <a href="https://github.com/microsoft/TypeScript/pull/39669">a pull request</a> by <a href="https://github.com/Kingwl">Wenlu Wang</a>, though an earlier pull request implementing only the <code>override</code> keyword by <a href="https://github.com/pcj">Paul Cody Johnston</a> served as a basis for direction and discussion. We extend our gratitude for putting in the time for these features.</section><section id="template-string-type-improvements"class="level2"><h2>Template String Type Improvements</h2><p>In recent versions, TypeScript introduced a new type construct: template string types. These are types that either construct new string-like types by concatenating...<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Color</span></span> <span class="token operator">=</span> <span class="token string">"red"</span> <span class="token operator">|</span> <span class="token string">"blue"</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Quantity</span></span> <span class="token operator">=</span> <span class="token string">"one"</span> <span class="token operator">|</span> <span class="token string">"two"</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">SeussFish</span></span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token maybe-class-name">Quantity</span> <span class="token operator">|</span> <span class="token maybe-class-name">Color</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> fish</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token comment">// same as</span>
<span class="token comment">//   type SeussFish = "one fish" | "two fish"</span>
<span class="token comment">//                  | "red fish" | "blue fish";</span></code></pre><p>...or match patterns of other string-like types.<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">let</span> s1<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> s2<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">1-2-3</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

<span class="token comment">// Works!</span>
s1 <span class="token operator">=</span> s2<span class="token punctuation">;</span></code></pre><p>The first change we made is just in when TypeScript will infer a template string type. When a template string is <em>contextually typed</em> by a string-literal-like type (i.e. when TypeScript sees we're passing a template string to something that takes a literal type) it will try to give that expression a template type.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">string</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// Previously an error, now works!</span>
    <span class="token keyword control-flow">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>s<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>This also kicks in when inferring types, and the type parameter <code>extends string</code><pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">let</span> s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">f</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token comment">// Previously: string</span>
<span class="token comment">// Now       : `hello ${string}`</span>
<span class="token keyword">let</span> x2 <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>s<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The second major change here is that TypeScript can now better-relate, and <em>infer between</em>, different template string types.<p>To see this, take the following example code:<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">let</span> s1<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> s2<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">1-2-3</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> s3<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-2-3</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

s1 <span class="token operator">=</span> s2<span class="token punctuation">;</span>
s1 <span class="token operator">=</span> s3<span class="token punctuation">;</span></code></pre><p>When checking against a string literal type like on <code>s2</code>, TypeScript could match against the string contents and figure out that <code>s2</code> was compatible with <code>s1</code> in the first assignment; however, as soon as it saw another template string, it just gave up. As a result, assignments like <code>s3</code> to <code>s1</code> just didn't work.<p>TypeScript now actually does the work to prove whether or not each part of a template string can successfully match. You can now mix and match template strings with different substitutions and TypeScript will do a good job to figure out whether they're really compatible.<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">let</span> s1<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> s2<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">1-2-3</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> s3<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-2-3</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> s4<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">1-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-3</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> s5<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">1-2-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> s6<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-2-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">number</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

<span class="token comment">// Now *all of these* work!</span>
s1 <span class="token operator">=</span> s2<span class="token punctuation">;</span>
s1 <span class="token operator">=</span> s3<span class="token punctuation">;</span>
s1 <span class="token operator">=</span> s4<span class="token punctuation">;</span>
s1 <span class="token operator">=</span> s5<span class="token punctuation">;</span>
s1 <span class="token operator">=</span> s6<span class="token punctuation">;</span></code></pre><p>In doing this work, we were also sure to add better inference capabilities. You can see an example of these in action:<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">V</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">*</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">V</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">*</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">V</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">test</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">,</span> t<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x1 <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">"*hello*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// "hello"</span>
    <span class="token keyword">let</span> x2 <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">"**hello**"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// "*hello*"</span>
    <span class="token keyword">let</span> x3 <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">*</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>s<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">*</span><span class="token template-punctuation string">`</span></span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// string</span>
    <span class="token keyword">let</span> x4 <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">*</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>n<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">*</span><span class="token template-punctuation string">`</span></span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// `${number}`</span>
    <span class="token keyword">let</span> x5 <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">*</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>b<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">*</span><span class="token template-punctuation string">`</span></span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// "true" | "false"</span>
    <span class="token keyword">let</span> x6 <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">*</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>t<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">*</span><span class="token template-punctuation string">`</span></span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// `${T}`</span>
    <span class="token keyword">let</span> x7 <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">**</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>s<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">**</span><span class="token template-punctuation string">`</span></span> <span class="token keyword module">as</span> <span class="token keyword">const</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// `*${string}*`</span>
<span class="token punctuation">}</span></code></pre><p>For more information, see <a href="https://github.com/microsoft/TypeScript/pull/43376">the original pull request on leveraging contextual types</a>, along with <a href="https://github.com/microsoft/TypeScript/pull/43361">the pull request that improved inference and checking between template types</a>.</section><section id="ecmascript-private-class-elements"class="level2"><h2>ECMAScript <code>#private</code> Class Elements</h2><p>TypeScript 4.3 expands which elements in a class can be given <code>#private</code> <code>#names</code> to make them truly private at run-time. In addition to properties, methods and accessors can also be given private names.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span> <span class="token punctuation">{</span>
  <span class="token function">#someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">get</span> <span class="token function">#someValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">publicMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// These work.</span>
    <span class="token comment">// We can access private-named members inside this class.</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">#someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#someValue</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">#someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//        ~~~~~~~~~~~</span>
<span class="token comment">// error!</span>
<span class="token comment">// Property '#someMethod' is not accessible</span>
<span class="token comment">// outside class 'Foo' because it has a private identifier.</span>

<span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">#someValue</span><span class="token punctuation">;</span>
<span class="token comment">//        ~~~~~~~~~~</span>
<span class="token comment">// error!</span>
<span class="token comment">// Property '#someValue' is not accessible</span>
<span class="token comment">// outside class 'Foo' because it has a private identifier.</span></code></pre><p>Even more broadly, static members can now also have private names.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">#someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token maybe-class-name">Foo</span><span class="token punctuation">.</span><span class="token method function property-access">#someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//  ~~~~~~~~~~~</span>
<span class="token comment">// error!</span>
<span class="token comment">// Property '#someMethod' is not accessible</span>
<span class="token comment">// outside class 'Foo' because it has a private identifier.</span></code></pre><p>This feature was authored <a href="https://github.com/microsoft/TypeScript/pull/42458">in a pull request</a> from our friends at Bloomberg - written by <a href="https://github.com/dragomirtitian">Titian Cernicova-Dragomir</a>and <a href="https://github.com/mkubilayk">Kubilay Kahveci</a>, with support and expertise from <a href="https://github.com/joeywatts">Joey Watts</a>, <a href="https://github.com/robpalme">Rob Palmer</a>, and <a href="https://github.com/tim-mc">Tim McClure</a>. We'd like to extend our thanks to all of them!</section><section id="constructorparameters-works-on-abstract-classes"class="level2"><h2><code>ConstructorParameters</code> Works on Abstract Classes</h2><p>In TypeScript 4.3, the <code>ConstructorParameters</code> type helper now works on <code>abstract</code> classes.<pre class="language-ts"><code class="language-ts"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Has the type '[a: string, b: number]'.</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">CParams</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">ConstructorParameters</span><span class="token operator">&#x3C;</span><span class="token keyword">typeof</span> <span class="token constant">C</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>This is thanks to work done in TypeScript 4.2, where construct signatures can be marked as abstract:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">MyConstructorOf</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword">abstract</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// or using the shorthand syntax:</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">MyConstructorOf</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token keyword">abstract</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">T</span><span class="token punctuation">;</span></code></pre><p>You can <a href="https://github.com/microsoft/TypeScript/pull/43380">see the change in more detail on GitHub</a>.</section><section id="contextual-narrowing-for-generics"class="level2"><h2>Contextual Narrowing for Generics</h2><p>TypeScript 4.3 now includes some slightly smarter type-narrowing logic on generic values. This allows TypeScript to accept more patterns, and sometimes even catch mistakes.<p>For some motivation, let's say we're trying to write a function called <code>makeUnique</code>. It'll take a <code>Set</code> or an <code>Array</code> of elements, and if it's given an <code>Array</code>, it'll sort that <code>Array</code> remove duplicates according to some comparison function. After all that, it will return the original collection.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">makeUnique</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
  collection<span class="token operator">:</span> <span class="token known-class-name class-name">Set</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function-variable function">comparer</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">number</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Set</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token comment">// Early bail-out if we have a Set.</span>
  <span class="token comment">// We assume the elements are already unique.</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>collection <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token known-class-name class-name">Set</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> collection<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Sort the array, then remove consecutive duplicates.</span>
  collection<span class="token punctuation">.</span><span class="token method function property-access">sort</span><span class="token punctuation">(</span>comparer<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> collection<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span>
      j <span class="token operator">&#x3C;</span> collection<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">&#x26;&#x26;</span>
      <span class="token function">comparer</span><span class="token punctuation">(</span>collection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> collection<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      j<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    collection<span class="token punctuation">.</span><span class="token method function property-access">splice</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> collection<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Let's leave questions about this function's implementation aside, and assume it arose from the requirements of a broader application. Something that you might notice is that the signature doesn't capture the original type of <code>collection</code>. We can do that by adding a type parameter called <code>C</code> in place of where we've written <code>Set&#x3C;T> | T[]</code>.<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> function makeUnique&#x3C;T>(collection: Set&#x3C;T> | T[], comparer: (x: T, y: T) => number): Set&#x3C;T> | T[]
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> function makeUnique&#x3C;T, C extends Set&#x3C;T> | T[]>(collection: C, comparer: (x: T, y: T) => number): C</span></span></code></pre><p>In TypeScript 4.2 and earlier, you'd end up with a bunch of errors as soon as you tried this.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">makeUnique</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">C</span> <span class="token keyword">extends</span> <span class="token known-class-name class-name">Set</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
  collection<span class="token operator">:</span> <span class="token constant">C</span><span class="token punctuation">,</span>
  <span class="token function-variable function">comparer</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">number</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">C</span> <span class="token punctuation">{</span>
  <span class="token comment">// Early bail-out if we have a Set.</span>
  <span class="token comment">// We assume the elements are already unique.</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>collection <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token known-class-name class-name">Set</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> collection<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Sort the array, then remove consecutive duplicates.</span>
  collection<span class="token punctuation">.</span><span class="token method function property-access">sort</span><span class="token punctuation">(</span>comparer<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//         ~~~~</span>
  <span class="token comment">// error: Property 'sort' does not exist on type 'C'.</span>
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> collection<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//                             ~~~~~~</span>
    <span class="token comment">// error: Property 'length' does not exist on type 'C'.</span>
    <span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span>
      j <span class="token operator">&#x3C;</span> collection<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">&#x26;&#x26;</span>
      <span class="token function">comparer</span><span class="token punctuation">(</span>collection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> collection<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//                    ~~~~~~</span>
      <span class="token comment">// error: Property 'length' does not exist on type 'C'.</span>
      <span class="token comment">//                                       ~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~~~</span>
      <span class="token comment">// error: Element implicitly has an 'any' type because expression of type 'number'</span>
      <span class="token comment">//        can't be used to index type 'Set&#x3C;T> | T[]'.</span>
      j<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    collection<span class="token punctuation">.</span><span class="token method function property-access">splice</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//         ~~~~~~</span>
    <span class="token comment">// error: Property 'splice' does not exist on type 'C'.</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> collection<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Ew, errors! Why is TypeScript being so mean to us?<p>The issue is that when we perform our <code>collection instanceof Set</code> check, we're expecting that to act as a type guard that narrows the type from <code>Set&#x3C;T> | T[]</code> to <code>Set&#x3C;T></code> and <code>T[]</code> depending on the branch we're in; however, we're not dealing with a <code>Set&#x3C;T> | T[]</code>, we're trying to narrow the generic value <code>collection</code>, whose type is <code>C</code>.<p>It's a very subtle distinction, but it makes a difference. TypeScript can't just grab the constraint of <code>C</code> (which is <code>Set&#x3C;T> | T[]</code>) and narrow that. If TypeScript <em>did</em> try to narrow from <code>Set&#x3C;T> | T[]</code>, it would forget that <code>collection</code> is also a <code>C</code> in each branch because there's no easy way to preserve that information. If hypothetically TypeScript tried that approach, it would break the above example in a different way. At the return positions, where the function expects values with the type <code>C</code>, we would instead get a <code>Set&#x3C;T></code> and a <code>T[]</code> in each branch, which TypeScript would reject.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">makeUnique</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
  collection<span class="token operator">:</span> <span class="token known-class-name class-name">Set</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function-variable function">comparer</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">number</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Set</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token comment">// Early bail-out if we have a Set.</span>
  <span class="token comment">// We assume the elements are already unique.</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>collection <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token known-class-name class-name">Set</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> collection<span class="token punctuation">;</span>
    <span class="token comment">//     ~~~~~~~~~~</span>
    <span class="token comment">// error: Type 'Set&#x3C;T>' is not assignable to type 'C'.</span>
    <span class="token comment">//          'Set&#x3C;T>' is assignable to the constraint of type 'C', but</span>
    <span class="token comment">//          'C' could be instantiated with a different subtype of constraint 'Set&#x3C;T> | T[]'.</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// ...</span>

  <span class="token keyword control-flow">return</span> collection<span class="token punctuation">;</span>
  <span class="token comment">//     ~~~~~~~~~~</span>
  <span class="token comment">// error: Type 'T[]' is not assignable to type 'C'.</span>
  <span class="token comment">//          'T[]' is assignable to the constraint of type 'C', but</span>
  <span class="token comment">//          'C' could be instantiated with a different subtype of constraint 'Set&#x3C;T> | T[]'.</span>
<span class="token punctuation">}</span></code></pre><p>So how does TypeScript 4.3 change things? Well, basically in a few key places when writing code, all the type system really cares about is the constraint of a type. For example, when we write <code>collection.length</code>, TypeScript doesn't care about the fact that <code>collection</code> has the type <code>C</code>, it only cares about the properties available, which are determined by the constraint <code>T[] | Set&#x3C;T></code>.<p>In cases like this, TypeScript will grab the narrowed type of the constraint because that will give you the data you care about; however, in any other case, we'll just try to narrow the original generic type (and often end up with the original generic type).<p>In other words, based on how you use a generic value, TypeScript will narrow it a little differently. The end result is that the entire above example compiles with no type-checking errors.<p>For more details, you can <a href="https://github.com/microsoft/TypeScript/pull/43183">look at the original pull request on GitHub</a>.</section><section id="always-truthy-promise-checks"class="level2"><h2>Always-Truthy Promise Checks</h2><p>Under <a href="/tsconfig#strictNullChecks"><code>strictNullChecks</code></a>, checking whether a <code>Promise</code> is "truthy" in a conditional will trigger an error.<pre class="language-ts"><code class="language-ts"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">boolean</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//  ~~~~~</span>
    <span class="token comment">// Error!</span>
    <span class="token comment">// This condition will always return true since</span>
    <span class="token comment">// this 'Promise&#x3C;boolean>' appears to always be defined.</span>
    <span class="token comment">// Did you forget to use 'await'?</span>
    <span class="token keyword control-flow">return</span> <span class="token string">"true"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> <span class="token string">"false"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><a href="https://github.com/microsoft/TypeScript/pull/39175">This change</a> was contributed by <a href="https://github.com/Jack-Works">Jack Works</a>, and we extend our thanks to them!</section><section id="static-index-signatures"class="level2"><h2><code>static</code> Index Signatures</h2><p>Index signatures allow us set more properties on a value than a type explicitly declares.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span> <span class="token punctuation">{</span>
  hello <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
  world <span class="token operator">=</span> <span class="token number">1234</span><span class="token punctuation">;</span>

  <span class="token comment">// This is an index signature:</span>
  <span class="token punctuation">[</span>propName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Valid assigment</span>
instance<span class="token punctuation">[</span><span class="token string">"whatever"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

<span class="token comment">// Has type 'string | number | undefined'.</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> instance<span class="token punctuation">[</span><span class="token string">"something"</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>Up until now, an index signature could only be declared on the instance side of a class. Thanks to <a href="https://github.com/microsoft/TypeScript/pull/37797">a pull request</a> from <a href="https://github.com/microsoft/TypeScript/pull/37797">Wenlu Wang</a>, index signatures can now be declared as <code>static</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> hello <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
  <span class="token keyword">static</span> world <span class="token operator">=</span> <span class="token number">1234</span><span class="token punctuation">;</span>

  <span class="token keyword">static</span> <span class="token punctuation">[</span>propName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Valid.</span>
<span class="token maybe-class-name">Foo</span><span class="token punctuation">[</span><span class="token string">"whatever"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

<span class="token comment">// Has type 'string | number | undefined'</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token maybe-class-name">Foo</span><span class="token punctuation">[</span><span class="token string">"something"</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>The same sorts of rules apply for index signatures on the static side of a class as they do for the instance side - namely, that every other static property has to be compatible with the index signature.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> prop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token comment">//     ~~~~</span>
  <span class="token comment">// Error! Property 'prop' of type 'boolean'</span>
  <span class="token comment">// is not assignable to string index type</span>
  <span class="token comment">// 'string | number | undefined'.</span>

  <span class="token keyword">static</span> <span class="token punctuation">[</span>propName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></section><section id="tsbuildinfo-size-improvements"class="level2"><h2><code>.tsbuildinfo</code> Size Improvements</h2><p>In TypeScript 4.3, <code>.tsbuildinfo</code> files that are generated as part of <a href="/tsconfig#incremental"><code>incremental</code></a> builds should be significantly smaller. This is thanks to several optimizations in the internal format, creating tables with numeric identifiers to be used throughout the file instead of repeating full paths and similar information. This work was spear-headed by <a href="https://github.com/sokra">Tobias Koppers</a> in <a href="https://github.com/microsoft/TypeScript/pull/43079">their pull request</a>, serving as inspiration for <a href="https://github.com/microsoft/TypeScript/pull/43155">the ensuing pull request</a> and <a href="https://github.com/microsoft/TypeScript/pull/43695">further optimizations</a>.<p>We have seen significant reductions of <code>.tsbuildinfo</code> file sizes including<ul><li>1MB to 411 KB<li>14.9MB to 1MB<li>1345MB to 467MB</ul><p>Needless to say, these sorts of savings in size translate to slightly faster build times as well.</section><section id="lazier-calculations-in---incremental-and---watch-compilations"class="level2"><h2>Lazier Calculations in <code>--incremental</code> and <code>--watch</code> Compilations</h2><p>One of the issues with <a href="/tsconfig#incremental"><code>incremental</code></a> and <code>--watch</code> modes are that while they make later compilations go faster, the initial compilation can be a bit slower - in some cases, significantly slower. This is because these modes have to perform a bunch of book-keeping, computing information about the current project, and sometimes saving that data in a <code>.tsbuildinfo</code> file for later builds.<p>That's why on top of <code>.tsbuildinfo</code> size improvements, TypeScript 4.3 also ships some changes to <a href="/tsconfig#incremental"><code>incremental</code></a> and <code>--watch</code> modes that make the first build of a project with these flags just as fast as an ordinary build! To do this, much of the information that would ordinarily be computed up-front is instead done on an on-demand basis for later builds. While this can add some overhead to a subsequent build, TypeScript's <a href="/tsconfig#incremental"><code>incremental</code></a> and <code>--watch</code> functionality will still typically operate on a much smaller set of files, and any needed information will be saved afterwards. In a sense, <a href="/tsconfig#incremental"><code>incremental</code></a> and <code>--watch</code> builds will "warm up" and get faster at compiling files once you've updated them a few times.<p>In a repository with 3000 files, <strong>this reduced initial build times to almost a third</strong>!<p><a href="https://github.com/microsoft/TypeScript/pull/42960">This work was started</a> by <a href="https://github.com/sokra">Tobias Koppers</a>, whose work ensued in <a href="https://github.com/microsoft/TypeScript/pull/43314">the resulting final change</a> for this functionality. We'd like to extend a great thanks to Tobias for helping us find these opportunities for improvements!</section><section id="import-statement-completions"class="level2"><h2>Import Statement Completions</h2><p>One of the biggest pain-points users run into with import and export statements in JavaScript is the order - specifically that imports are written as<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> func <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"./module.js"</span><span class="token punctuation">;</span></code></pre><p>instead of<pre class="language-ts"><code class="language-ts"><span class="token keyword module">from</span> <span class="token string">"./module.js"</span> <span class="token keyword module">import</span> <span class="token punctuation">{</span> func <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>This causes some pain when writing out a full import statement from scratch because auto-complete wasn't able to work correctly. For example, if you start writing something like <code>import {</code>, TypeScript has no idea what module you're planning on importing from, so it couldn't provide any scoped-down completions.<p>To alleviate this, we've leveraged the power of auto-imports! Auto-imports already deal with the issue of not being able to narrow down completions from a specific module - their whole point is to provide every possible export and automatically insert an import statement at the top of your file.<p>So when you now start writing an <code>import</code> statement that doesn't have a path, we'll provide you with a list of possible imports. When you commit a completion, we'll complete the full import statement, including the path that you were going to write.<figure><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/05/auto-import-statement-4-3.gif"alt="Import statement completions"><figcaption aria-hidden="true">Import statement completions</figcaption></figure><p>This work requires editors that specifically support the feature. You'll be able to try this out by using the latest <a href="https://code.visualstudio.com/insiders/">Insiders versions of Visual Studio Code</a>.<p>For more information, take a look at <a href="https://github.com/microsoft/TypeScript/pull/43149">the implementing pull request</a>!</section><section id="editor-support-for-link-tags"class="level2"><h2>Editor Support for <code>@link</code> Tags</h2><p>TypeScript can now understand <code>@link</code> tags, and will try to resolve declarations that they link to. What this means is that you'll be able to hover over names within <code>@link</code> tags and get quick information, or use commands like go-to-definition or find-all-references.<p>For example, you'll be able to go-to-definition on <code>bar</code> in <code>@link bar</code> in the example below and a TypeScript-supported editor will jump to <code>bar</code>'s function declaration.<pre class="language-ts"><code class="language-ts"><span class="token doc-comment comment">/**
 * To be called 70 to 80 days after <span class="token punctuation">{</span><span class="token keyword">@link</span> plantCarrot<span class="token punctuation">}</span>.
 */</span>
<span class="token keyword">function</span> <span class="token function">harvestCarrot</span><span class="token punctuation">(</span>carrot<span class="token operator">:</span> <span class="token maybe-class-name">Carrot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * Call early in spring for best results. Added in v2.1.0.
 * <span class="token keyword">@param</span> <span class="token parameter">seed</span> Make sure it's a carrot seed!
 */</span>
<span class="token keyword">function</span> <span class="token function">plantCarrot</span><span class="token punctuation">(</span>seed<span class="token operator">:</span> <span class="token maybe-class-name">Seed</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// TODO: some gardening</span>
<span class="token punctuation">}</span></code></pre><figure><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/05/link-tag-4-3.gif"alt="Jumping to definition and requesting quick info on a &#x60;@link&#x60; tag for "><figcaption aria-hidden="true">Jumping to definition and requesting quick info on a `@link` tag for</figcaption></figure><p>For more information, see <a href="https://github.com/microsoft/TypeScript/pull/41877">the pull request on GitHub</a>!</section><section id="go-to-definition-on-non-javascript-file-paths"class="level2"><h2>Go-to-Definition on Non-JavaScript File Paths</h2><p>Many loaders allow users to include assets in their applications using JavaScript imports. They'll typically be written as something like <code>import "./styles.css"</code> or the like.<p>Up until now, TypeScript's editor functionality wouldn't even attempt to read this file, so go-to-definition would typically fail. At best, go-to-definition would jump to a declaration like <code>declare module "*.css"</code> if it could find something along those lines.<p>TypeScript's language service now tries to jump to the correct file when you perform a go-to-definition on relative file paths, even if they're not JavaScript or TypeScript files! Try it out with imports to CSS, SVGs, PNGs, font files, Vue files, and more.<p>For more information, you can check out <a href="https://github.com/microsoft/TypeScript/pull/42539">the implementing pull request</a>.</section><section id="breaking-changes"class="level2"><h2>Breaking Changes</h2><section id="libdts-changes"class="level3"><h3><code>lib.d.ts</code> Changes</h3><p>As with every TypeScript version, declarations for <code>lib.d.ts</code> (especially the declarations generated for web contexts), have changed. In this release, we leveraged <a href="https://github.com/mdn/browser-compat-data">Mozilla's browser-compat-data</a> to remove APIs that no browser implements. While it is unlike that you are using them, APIs such as <code>Account</code>, <code>AssertionOptions</code>, <code>RTCStatsEventInit</code>, <code>MSGestureEvent</code>, <code>DeviceLightEvent</code>, <code>MSPointerEvent</code>, <code>ServiceWorkerMessageEvent</code>, and <code>WebAuthentication</code> have all been removed from <code>lib.d.ts</code>. This is discussed <a href="https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/991">in some detail here</a>.<p><a href="https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/991">https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/991</a></section><section id="usedefineforclassfields-now-defaults-to-true-on-esnext-and-eventually-on-es2022"class="level3"><h3><code>useDefineForClassFields</code> now defaults to true on <code>esnext</code> and eventually on <code>es2022</code></h3><p>In 2021 the class fields feature was added into the JavaScript specification with behavior which differed from how TypeScript had implemented it. In preparation for this, in TypeScript 3.7, a flag was added (<a href="/tsconfig#useDefineForClassFields"><code>useDefineForClassFields</code></a>) to migrate to emitted JavaScript to match the JavaScript standard behavior.<p>Now that the feature is in JavaScript we are changing the default to <code>true</code> for ES2022 and above, including ESNext.</section><section id="errors-on-always-truthy-promise-checks"class="level3"><h3>Errors on Always-Truthy Promise Checks</h3><p>Under <a href="/tsconfig#strictNullChecks"><code>strictNullChecks</code></a>, using a <code>Promise</code> that always appears to be defined within a condition check is now considered an error.<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">var</span> p<span class="token operator">:</span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//  ~</span>
  <span class="token comment">// Error!</span>
  <span class="token comment">// This condition will always return true since</span>
  <span class="token comment">// this 'Promise&#x3C;number>' appears to always be defined.</span>
  <span class="token comment">//</span>
  <span class="token comment">// Did you forget to use 'await'?</span>
<span class="token punctuation">}</span></code></pre><p>For more details, <a href="https://github.com/microsoft/TypeScript/pull/39175">see the original change</a>.</section><section id="union-enums-cannot-be-compared-to-arbitrary-numbers"class="level3"><h3>Union Enums Cannot Be Compared to Arbitrary Numbers</h3><p>Certain <code>enum</code>s are considered <em>union <code>enum</code>s</em> when their members are either automatically filled in, or trivially written. In those cases, an enum can recall each value that it potentially represents.<p>In TypeScript 4.3, if a value with a union <code>enum</code> type is compared with a numeric literal that it could never be equal to, then the type-checker will issue an error.<pre class="language-ts"><code class="language-ts"><span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span>
  <span class="token constant">A</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token constant">B</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">E</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Error! This condition will always return 'false' since the types 'E' and '-1' have no overlap.</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>As a workaround, you can re-write an annotation to include the appropriate literal type.<pre class="language-ts"><code class="language-ts"><span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span>
  <span class="token constant">A</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token constant">B</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token comment">// Include -1 in the type, if we're really certain that -1 can come through.</span>
<span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">E</span> <span class="token operator">|</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>You can also use a type-assertion on the value.<pre class="language-ts"><code class="language-ts"><span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span>
  <span class="token constant">A</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token constant">B</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">E</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Use a type asertion on 'x' because we know we're not actually just dealing with values from 'E'.</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token keyword module">as</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Alternatively, you can re-declare your enum to have a non-trivial initializer so that any number is both assignable and comparable to that enum. This may be useful if the intent is for the enum to specify a few well-known values.<pre class="language-ts"><code class="language-ts"><span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span>
  <span class="token comment">// the leading + on 0 opts TypeScript out of inferring a union enum.</span>
  <span class="token constant">A</span> <span class="token operator">=</span> <span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token constant">B</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></code></pre><p>For more details, <a href="https://github.com/microsoft/TypeScript/pull/42472">see the original change</a> <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>