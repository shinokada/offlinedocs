<!doctype html><html lang="en"><meta charset="utf-8"><title>TypeScript 4.8</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/release-notes/typescript-4-8.html"><meta name="oneline"content="TypeScript 4.8 Release Notes"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="improved-intersection-reduction-union-compatibility-and-narrowing"class="level2"><h2>Improved Intersection Reduction, Union Compatibility, and Narrowing</h2><p>TypeScript 4.8 brings a series of correctness and consistency improvements under <code>--strictNullChecks</code>. These changes affect how intersection and union types work, and are leveraged in how TypeScript narrows types.<p>For example, <code>unknown</code> is close in spirit to the union type <code>{} | null | undefined</code> because it accepts <code>null</code>, <code>undefined</code>, and any other type. TypeScript now recognizes this, and allows assignments from <code>unknown</code> to <code>{} | null | undefined</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">// always worked</span>
    y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// used to error, now works</span>
<span class="token punctuation">}</span></code></pre><p>Another change is that <code>{}</code> intersected with any other object type simplifies right down to that object type. That meant that we were able to rewrite <code>NonNullable</code> to just use an intersection with <code>{}</code>, because <code>{} &#x26; null</code> and <code>{} &#x26; undefined</code> just get tossed away.<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> type NonNullable&#x3C;T> = T extends null | undefined ? never : T;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> type NonNullable&#x3C;T> = T &#x26; {};</span></span></code></pre><p>This is an improvement because intersection types like this can be reduced and assigned to, while conditional types currently cannot. So <code>NonNullable&#x3C;NonNullable&#x3C;T>></code> now simplifies at least to <code>NonNullable&#x3C;T></code>, whereas it didn't before.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token maybe-class-name">NonNullable</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token maybe-class-name">NonNullable</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">NonNullable</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">>></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">// always worked</span>
    y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// used to error, now works</span>
<span class="token punctuation">}</span></code></pre><p>These changes also allowed us to bring in sensible improvements in control flow analysis and type narrowing. For example, <code>unknown</code> is now narrowed just like <code>{} | null | undefined</code> in truthy branches.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">narrowUnknownishUnion</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        x<span class="token punctuation">;</span>  <span class="token comment">// {}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
        x<span class="token punctuation">;</span>  <span class="token comment">// {} | null | undefined</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">narrowUnknown</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        x<span class="token punctuation">;</span>  <span class="token comment">// used to be 'unknown', now '{}'</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
        x<span class="token punctuation">;</span>  <span class="token comment">// unknown</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Generic values also get narrowed similarly. When checking that a value isn't <code>null</code> or <code>undefined</code>, TypeScript now just intersects it with <code>{}</code> - which again, is the same as saying it's <code>NonNullable</code>. Putting many of the changes here together, we can now define the following function without any type assertions.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">throwIfNullable</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">NonNullable</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>value <span class="token operator">===</span> <span class="token keyword nil">undefined</span> <span class="token operator">||</span> value <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword control-flow">throw</span> <span class="token known-class-name class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Nullable value!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Used to fail because 'T' was not assignable to 'NonNullable&#x3C;T>'.</span>
    <span class="token comment">// Now narrows to 'T &#x26; {}' and succeeds because that's just 'NonNullable&#x3C;T>'.</span>
    <span class="token keyword control-flow">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><code>value</code> now gets narrowed to <code>T &#x26; {}</code>, and is now identical with <code>NonNullable&#x3C;T></code> - so the body of the function just works with no TypeScript-specific syntax.<p>On their own, these changes may appear small - but they represent fixes for many many paper cuts that have been reported over several years.<p>For more specifics on these improvements, you can <a href="https://github.com/microsoft/TypeScript/pull/49119">read more here</a>.</section><section id="improved-inference-for-infer-types-in-template-string-types"class="level2"><h2>Improved Inference for <code>infer</code> Types in Template String Types</h2><p>TypeScript recently introduced a way to add <code>extends</code> constraints to <code>infer</code> type variables in conditional types.<pre class="language-ts"><code class="language-ts"><span class="token comment">// Grabs the first element of a tuple if it's assignable to 'number',</span>
<span class="token comment">// and returns 'never' if it can't find one.</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">TryGetNumberIfFirst</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span>
    <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token keyword">infer</span> <span class="token constant">U</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span><span class="token punctuation">,</span> <span class="token spread operator">...</span><span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span></code></pre><p>If these <code>infer</code> types appear in a template string type and are constrained to a primitive type, TypeScript will now try to parse out a literal type.<pre class="language-ts"><code class="language-ts"><span class="token comment">// SomeNum used to be 'number'; now it's '100'.</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">SomeNum</span></span> <span class="token operator">=</span> <span class="token string">"100"</span> <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">infer</span> <span class="token constant">U</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token comment">// SomeBigInt used to be 'bigint'; now it's '100n'.</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">SomeBigInt</span></span> <span class="token operator">=</span> <span class="token string">"100"</span> <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">infer</span> <span class="token constant">U</span> <span class="token keyword">extends</span> <span class="token class-name">bigint</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token comment">// SomeBool used to be 'boolean'; now it's 'true'.</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">SomeBool</span></span> <span class="token operator">=</span> <span class="token string">"true"</span> <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">infer</span> <span class="token constant">U</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span></code></pre><p>This can now better convey what a library will do at runtime, and give more precise types.<p>One note on this is that when TypeScript parses these literal types out it will greedily try to parse out as much of what looks like of the appropriate primitive type; however it then checks to see if the print-back of that primitive matches up with the string contents. In other words, TypeScript checks whether the going from the string, to the primitive, and back matches. If it doesn't see that the string can be "round-tripped", then it will fall back to the base primitive type.<pre class="language-ts"><code class="language-ts"><span class="token comment">// JustNumber is `number` here because TypeScript parses out `"1.0"`, but `String(Number("1.0"))` is `"1"` and doesn't match.</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">JustNumber</span></span> <span class="token operator">=</span> <span class="token string">"1.0"</span> <span class="token keyword">extends</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">infer</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">?</span> <span class="token constant">T</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span> </code></pre><p>You can <a href="https://github.com/microsoft/TypeScript/pull/48094">see more about this feature here</a>.</section><section id="--build---watch-and---incremental-performance-improvements"class="level2"><h2><code>--build</code>, <code>--watch</code>, and <code>--incremental</code> Performance Improvements</h2><p>TypeScript 4.8 introduces several optimizations that should speed up scenarios around <code>--watch</code> and <code>--incremental</code>, along with project references builds using <code>--build</code>. For example, TypeScript is now able to avoid spending time updating timestamps during no-op changes in <code>--watch</code> mode, which makes rebuilds faster and avoids messing with other build tools that might be watching for TypeScript's output. Many other optimizations where we're able to reuse information across <code>--build</code>, <code>--watch</code>, and <code>--incremental</code> have been introduced as well.<p>How big are these improvements? Well, on a fairly large internal codebase, we've seen time reductions on the order of 10%-25% on many simple common operations, with around 40% time reductions in no-change scenarios. We've seen similar results on the TypeScript codebase as well.<p>You can see <a href="https://github.com/microsoft/TypeScript/pull/48784">the changes, along with the performance results on GitHub</a>.</section><section id="errors-when-comparing-object-and-array-literals"class="level2"><h2>Errors When Comparing Object and Array Literals</h2><p>In many languages, operators like <code>==</code> perform what's called "value" equality on objects. For example, in Python it's valid to check whether a list is empty by checking whether a value is equal to the empty list using <code>==</code>.<pre class="language-py"><code class="language-py"><span class="token keyword">if</span> people_at_home <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"here's where I lie, broken inside. &#x3C;/3"</span><span class="token punctuation">)</span>
    adopt_animals<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>This is not the case in JavaScript, where <code>==</code> and <code>===</code> between objects (and therefore, arrays) check whether both references point to the same value. We believe that similar code in JavaScript is at best an early foot-gun for JavaScript developers, and at worst a bug in production code. That's why TypeScript now disallows code like the following.<pre class="language-ts"><code class="language-ts"><span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>peopleAtHome <span class="token operator">===</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">//  ~~~~~~~~~~~~~~~~~~~</span>
<span class="token comment">// This condition will always return 'false' since JavaScript compares objects by reference, not value.</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"here's where I lie, broken inside. &#x3C;/3"</span><span class="token punctuation">)</span>
    <span class="token function">adoptAnimals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>We'd like to extend our gratitude to <a href="https://github.com/Jack-Works">Jack Works</a> who contributed this check. You can <a href="https://github.com/microsoft/TypeScript/pull/45978">view the changes involved here</a>.</section><section id="improved-inference-from-binding-patterns"class="level2"><h2>Improved Inference from Binding Patterns</h2><p>In some cases, TypeScript will pick up a type from a binding pattern to make better inferences.<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">chooseRandomly</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">chooseRandomly</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">"hi!"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"bye!"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//   ^  ^  ^</span>
<span class="token comment">//   |  |  |</span>
<span class="token comment">//   |  |  string</span>
<span class="token comment">//   |  |</span>
<span class="token comment">//   |  boolean</span>
<span class="token comment">//   |</span>
<span class="token comment">//   number</span></code></pre><p>When <code>chooseRandomly</code> needs to figure out a type for <code>T</code>, it will primarily look at <code>[42, true, "hi!"]</code> and <code>[0, false, "bye!"]</code>; but TypeScript needs to figure out whether those two types should be <code>Array&#x3C;number | boolean | string></code> or the tuple type <code>[number, boolean, string]</code>. To do that, it will look for existing candidates as a hint to see whether there are any tuple types. When TypeScript sees the binding pattern <code>[a, b, c]</code>, it creates the type <code>[any, any, any]</code>, and that type gets picked up as a low-priority candidate for <code>T</code> which also gets used as a hint for the types of <code>[42, true, "hi!"]</code> and <code>[0, false, "bye!"]</code>.<p>You can see how this was good for <code>chooseRandomly</code>, but it fell short in other cases. For example, take the following code<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">f</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The binding pattern <code>[x, y, z]</code> hinted that <code>f</code> should produce an <code>[any, any, any]</code> tuple; but <code>f</code> really shouldn't change its type argument based on a binding pattern. It can't suddenly conjure up a new array-like value based on what it's being assigned to, so the binding pattern type has way too much influence on the produced type. On top of that, because the binding pattern type is full of <code>any</code>s, we're left with <code>x</code>, <code>y</code>, and <code>z</code> being typed as <code>any</code>.<p>In TypeScript 4.8, these binding patterns are never used as candidates for type arguments. Instead, they're just consulted in case a parameter needs a more specific type like in our <code>chooseRandomly</code> example. If you need to revert to the old behavior, you can always provide explicit type arguments.<p>You can <a href="https://github.com/microsoft/TypeScript/pull/49086">look at the change on GitHub</a> if you're curious to learn more.</section><section id="file-watching-fixes-especially-across-git-checkouts"class="level2"><h2>File-Watching Fixes (Especially Across <code>git checkout</code>s)</h2><p>We've had a long-standing bug where TypeScript has a very hard time with certain file changes in <code>--watch</code> mode and editor scenarios. Sometimes the symptoms are stale or inaccurate errors that might show up that require restarting <code>tsc</code> or VS Code. Frequently these occur on Unix systems, and you might have seen these after saving a file with vim or swapping branches in git.<p>This was caused by assumptions of how Node.js handles rename events across file systems. File systems used by Linux and macOS utilize <a href="https://en.wikipedia.org/wiki/Inode">inodes</a>, and <a href="https://nodejs.org/api/fs.html#inodes">Node.js will attach file watchers to inodes rather than file paths</a>. So when Node.js returns <a href="https://nodejs.org/api/fs.html#class-fsfswatcher">a watcher object</a>, it might be watching a path or an inode depending on the platform and file system.<p>To be a bit more efficient, TypeScript tries to reuse the same watcher objects if it detects a path still exists on disk. This is where things went wrong, because even if a file still exists at that path, a distinct file might have been created, and that file will have a different inode. So TypeScript would end up reusing the watcher object instead of installing a new watcher at the original location, and watch for changes at what might be a totally irrelevant file. So TypeScript 4.8 now handles these cases on inode systems and properly installs a new watcher and fixes this.<p>We'd like to extend our thanks to <a href="https://github.com/MarcCelani-at">Marc Celani</a> and his team at Airtable who invested lots of time in investigating the issues they were experiencing and pointing out the root cause. You can view <a href="https://github.com/microsoft/TypeScript/pull/48997">the specific fixes around file-watching here</a>.</section><section id="find-all-references-performance-improvements"class="level2"><h2>Find-All-References Performance Improvements</h2><p>When running find-all-references in your editor, TypeScript is now able to act a little smarter as it aggregates references. This reduced the amount of time TypeScript took to search a widely-used identifier in its own codebase by about 20%.<p><a href="https://github.com/microsoft/TypeScript/pull/49581">You can read up more on the improvement here</a>.</section><section id="exclude-specific-files-from-auto-imports"class="level2"><h2>Exclude Specific Files from Auto-Imports</h2><p>TypeScript 4.8 introduces an editor preference for excluding files from auto-imports. In Visual Studio Code, file names or globs can be added under "Auto Import File Exclude Patterns" in the Settings UI, or in a <code>.vscode/settings.json</code> file:<pre class="language-jsonc"><code class="language-jsonc">{
    // Note that `javascript.preferences.autoImportFileExcludePatterns` can be specified for JavaScript too.
    "typescript.preferences.autoImportFileExcludePatterns": [
      "**/node_modules/@types/node"
    ]
}</code></pre><p>This can be useful in cases where you can't avoid having certain modules or libraries in your compilation but you rarely want to import from them. These modules might have lots of exports that can pollute the auto-imports list and make it harder to navigate, and this option can help in those situations.<p>You can <a href="https://github.com/microsoft/TypeScript/pull/49578">see more specifics about the implementation here</a>.</section><section id="correctness-fixes-and-breaking-changes"class="level2"><h2>Correctness Fixes and Breaking Changes</h2><p>Due to the nature of type system changes, there are very few changes that can be made that don't affect <em>some</em> code; however, there are a few changes that are more likely to require adapting existing code.<section id="libdts-updates"class="level3"><h3><code>lib.d.ts</code> Updates</h3><p>While TypeScript strives to avoid major breaks, even small changes in the built-in libraries can cause issues. We don't expect major breaks as a result of DOM and <code>lib.d.ts</code> updates, but one notable change is that the <code>cause</code> property on <code>Error</code>s now has the type <code>unknown</code> instead of <code>Error</code>.</section><section id="unconstrained-generics-no-longer-assignable-to-"class="level3"><h3>Unconstrained Generics No Longer Assignable to <code>{}</code></h3><p>In TypeScript 4.8, for projects with <code>strictNullChecks</code> enabled, TypeScript will now correctly issue an error when an unconstrained type parameter is used in a position where <code>null</code> or <code>undefined</code> are not legal values. That will include any type that expects <code>{}</code>, <code>object</code>, or an object type with all-optional properties.<p>A simple example can be seen in the following.<pre class="language-ts"><code class="language-ts"><span class="token comment">// Accepts any non-null non-undefined value</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// This call throws on null/undefined at runtime.</span>
<span class="token punctuation">}</span>

<span class="token comment">// Unconstrained type parameter T...</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">bar</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Used to be allowed, now is an error in 4.8.</span>
    <span class="token comment">//  ~</span>
    <span class="token comment">// error: Argument of type 'T' is not assignable to parameter of type '{}'.</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword nil">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>As demonstrated above, code like this has a potential bug - the values <code>null</code> and <code>undefined</code> can be indirectly passed through these unconstrained type parameters to code that is not supposed to observe those values.<p>This behavior will also be visible in type positions. One example would be:<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token maybe-class-name">Bar</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Bar</span><span class="token operator">&#x3C;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">></span></span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><p>Existing code that didn't want to handle <code>null</code> and <code>undefined</code> can be fixed by propagating the appropriate constraints through.<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> function foo&#x3C;T>(x: T) {
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> function foo&#x3C;T extends {}>(x: T) {</span></span></code></pre><p>Another work-around would be to check for <code>null</code> and <code>undefined</code> at runtime.<pre class="language-diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function foo&#x3C;T>(x: T) {
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     if (x !== null &#x26;&#x26; x !== undefined) {
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">         bar(x);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     }
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> }</span></span></code></pre><p>And if you know that for some reason, your generic value can't be <code>null</code> or <code>undefined</code>, you can just use a non-null assertion.<pre class="language-diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function foo&#x3C;T>(x: T) {
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">     bar(x);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     bar(x!);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> }</span></span></code></pre><p>When it comes to types, you'll often either need to propagate constraints, or intersect your types with <code>{}</code>.<p>For more information, you can <a href="https://github.com/microsoft/TypeScript/pull/49119">see the change that introduced this</a> along with <a href="https://github.com/microsoft/TypeScript/issues/49489">the specific discussion issue regarding how unconstrained generics now work</a>.</section><section id="decorators-are-placed-on-modifiers-on-typescripts-syntax-trees"class="level3"><h3>Decorators are placed on <code>modifiers</code> on TypeScript's Syntax Trees</h3><p>The current direction of decorators in TC39 means that TypeScript will have to handle a break in terms of placement of decorators. Previously, TypeScript assumed decorators would always be placed prior to all keywords/modifiers. For example<pre class="language-ts"><code class="language-ts"><span class="token decorator"><span class="token at operator">@</span><span class="token function">decorator</span></span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>Decorators as currently proposed do not support this syntax. Instead, the <code>export</code> keyword must precede the decorator.<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token decorator"><span class="token at operator">@</span><span class="token function">decorator</span></span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>Unfortunately, TypeScript's trees are <em>concrete</em> rather than <em>abstract</em>, and our architecture expects syntax tree node fields to be entirely ordered before or after each other. To support both legacy decorators and decorators as proposed, TypeScript will have to gracefully parse, and intersperse, modifiers and decorators.<p>To do this, it exposes a new type alias called <code>ModifierLike</code> which is a <code>Modifier</code> or a <code>Decorator</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">ModifierLike</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Modifier</span> <span class="token operator">|</span> <span class="token maybe-class-name">Decorator</span><span class="token punctuation">;</span></code></pre><p>Decorators are now placed in the same field as <code>modifiers</code> which is now a <code>NodeArray&#x3C;ModifierLike></code> when set, and the entire field is deprecated.<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> readonly modifiers?: NodeArray&#x3C;Modifier> | undefined;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> /**
</span><span class="token prefix inserted">+</span><span class="token line">  * @deprecated ...
</span><span class="token prefix inserted">+</span><span class="token line">  * Use `ts.canHaveModifiers()` to test whether a `Node` can have modifiers.
</span><span class="token prefix inserted">+</span><span class="token line">  * Use `ts.getModifiers()` to get the modifiers of a `Node`.
</span><span class="token prefix inserted">+</span><span class="token line">  * ...
</span><span class="token prefix inserted">+</span><span class="token line">  */
</span><span class="token prefix inserted">+</span><span class="token line"> readonly modifiers?: NodeArray&#x3C;ModifierLike> | undefined;</span></span></code></pre><p>All existing <code>decorators</code> properties have been marked as deprecated and will always be <code>undefined</code> if read. The type has also been changed to <code>undefined</code> so that existing tools know to handle them correctly.<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> readonly decorators?: NodeArray&#x3C;Decorator> | undefined;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> /**
</span><span class="token prefix inserted">+</span><span class="token line">  * @deprecated ...
</span><span class="token prefix inserted">+</span><span class="token line">  * Use `ts.canHaveDecorators()` to test whether a `Node` can have decorators.
</span><span class="token prefix inserted">+</span><span class="token line">  * Use `ts.getDecorators()` to get the decorators of a `Node`.
</span><span class="token prefix inserted">+</span><span class="token line">  * ...
</span><span class="token prefix inserted">+</span><span class="token line">  */
</span><span class="token prefix inserted">+</span><span class="token line"> readonly decorators?: undefined;</span></span></code></pre><p>To avoid new deprecation warnings and other issues, TypeScript now exposes four new functions to use in place of the <code>decorators</code> and <code>modifiers</code> properties. There are individual predicates for testing whether a node has support modifiers and decorators, along with respective accessor functions for grabbing them.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">canHaveModifiers</span><span class="token punctuation">(</span>node<span class="token operator">:</span> <span class="token maybe-class-name">Node</span><span class="token punctuation">)</span><span class="token operator">:</span> node <span class="token keyword">is</span> <span class="token maybe-class-name">HasModifiers</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">getModifiers</span><span class="token punctuation">(</span>node<span class="token operator">:</span> <span class="token maybe-class-name">HasModifiers</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">readonly</span> <span class="token maybe-class-name">Modifier</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">canHaveDecorators</span><span class="token punctuation">(</span>node<span class="token operator">:</span> <span class="token maybe-class-name">Node</span><span class="token punctuation">)</span><span class="token operator">:</span> node <span class="token keyword">is</span> <span class="token maybe-class-name">HasDecorators</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">getDecorators</span><span class="token punctuation">(</span>node<span class="token operator">:</span> <span class="token maybe-class-name">HasDecorators</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">readonly</span> <span class="token maybe-class-name">Decorator</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span></code></pre><p>As an example of how to access modifiers off of a node, you can write<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> modifiers <span class="token operator">=</span> <span class="token function">canHaveModifiers</span><span class="token punctuation">(</span>myNode<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">getModifiers</span><span class="token punctuation">(</span>myNode<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span></code></pre><p>With the note that each call to <code>getModifiers</code> and <code>getDecorators</code> may allocate a new array.<p>For more information, see changes around<ul><li><a href="https://github.com/microsoft/TypeScript/pull/49089">the restructuring of our tree nodes</a><li><a href="https://github.com/microsoft/TypeScript/pull/50343">the deprecations</a><li><a href="https://github.com/microsoft/TypeScript/pull/50399">exposing the predicate functions</a></ul></section><section id="types-cannot-be-importedexported-in-javascript-files"class="level3"><h3>Types Cannot Be Imported/Exported in JavaScript Files</h3><p>TypeScript previously allowed JavaScript files to import and export entities declared with a type, but no value, in <code>import</code> and <code>export</code> statements. This behavior was incorrect, because named imports and exports for values that don't exist will cause a runtime error under ECMAScript modules. When a JavaScript file is type-checked under <code>--checkJs</code> or through a <code>// @ts-check</code> comment, TypeScript will now issue an error.<pre class="language-ts"><code class="language-ts"><span class="token comment">// @ts-check</span>

<span class="token comment">// Will fail at runtime because 'SomeType' is not a value.</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> someValue<span class="token punctuation">,</span> <span class="token maybe-class-name">SomeType</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"some-module"</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@type</span> <span class="token punctuation">{</span>SomeType<span class="token punctuation">}</span>
 */</span>
<span class="token keyword module">export</span> <span class="token keyword">const</span> myValue <span class="token operator">=</span> someValue<span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@typedef</span> <span class="token punctuation">{</span>string | number<span class="token punctuation">}</span> MyType
 */</span>

<span class="token comment">// Will fail at runtime because 'MyType' is not a value.</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span> <span class="token maybe-class-name">MyType</span> <span class="token keyword module">as</span> <span class="token maybe-class-name">MyExportedType</span> <span class="token punctuation">}</span></span><span class="token punctuation">;</span></code></pre><p>To reference a type from another module, you can instead directly qualify the import.<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> import { someValue, SomeType } from "some-module";
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> import { someValue } from "some-module";
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> 
</span><span class="token prefix unchanged"> </span><span class="token line"> /**
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  * @type {SomeType}
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  * @type {import("some-module").SomeType}
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  */
</span><span class="token prefix unchanged"> </span><span class="token line"> export const myValue = someValue;</span></span></code></pre><p>To export a type, you can just use a <code>/** @typedef */</code> comment in JSDoc. <code>@typedef</code> comments already automatically export types from their containing modules.<pre class="language-diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> /**
</span><span class="token prefix unchanged"> </span><span class="token line">  * @typedef {string | number} MyType
</span><span class="token prefix unchanged"> </span><span class="token line">  */
</span></span>
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> /**
</span><span class="token prefix inserted">+</span><span class="token line">  * @typedef {MyType} MyExportedType
</span><span class="token prefix inserted">+</span><span class="token line">  */
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> export { MyType as MyExportedType };</span></span></code></pre><p>You can <a href="https://github.com/microsoft/TypeScript/pull/49580">read more about the change here</a>.</section><section id="binding-patterns-do-not-directly-contribute-to-inference-candidates"class="level3"><h3>Binding Patterns Do Not Directly Contribute to Inference Candidates</h3><p>As mentioned above, binding patterns no longer change the type of inference results in function calls. You can <a href="https://github.com/microsoft/TypeScript/pull/49086">read more about the original change here</a>.</section><section id="unused-renames-in-binding-patterns-are-now-errors-in-type-signatures"class="level3"><h3>Unused Renames in Binding Patterns are Now Errors in Type Signatures</h3><p>TypeScript's type annotation syntax often looks like it can be used when destructuring values. For example, take the following function.<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">makePerson</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Person</span><span class="token punctuation">;</span></code></pre><p>You might read this signature and think that <code>makePerson</code> obviously takes an object with a <code>name</code> property with the type <code>string</code> and an <code>age</code> property with the type <code>number</code>; however, JavaScript's destructuring syntax is actually taking precedence here. <code>makePerson</code> does say that it's going to take an object with a <code>name</code> and an <code>age</code> property, but instead of specifying a type for them, it's just saying that it renames <code>name</code> and <code>age</code> to <code>string</code> and <code>number</code> respectively.<p>In a pure type construct, writing code like this is useless, and typically a mistake since developers usually assume they're writing a type annotation.<p>TypeScript 4.8 makes these an error unless they're referenced later in the signature. The correct way to write the above signature would be as follows:<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">makePerson</span><span class="token punctuation">(</span>options<span class="token operator">:</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Person</span><span class="token punctuation">;</span>

<span class="token comment">// or</span>

<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">makePerson</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">,</span> age <span class="token punctuation">}</span><span class="token operator">:</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Person</span><span class="token punctuation">;</span></code></pre><p>This change can catch bugs in declarations, and has been helpful for improving existing code. We'd like to extend our thanks to <a href="https://github.com/uhyo">GitHub user uhyo</a> for providing this check. <a href="https://github.com/microsoft/TypeScript/pull/41044">You can read up on the change here</a>.<span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>