<!doctype html><html lang="en"><meta charset="utf-8"><title>TypeScript 4.7</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/release-notes/typescript-4-7.html"><meta name="oneline"content="TypeScript 4.7 Release Notes"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="ecmascript-module-support-in-nodejs"class="level2"><h2>ECMAScript Module Support in Node.js</h2><p>For the last few years, Node.js has been working to support ECMAScript modules (ESM). This has been a very difficult feature, since the Node.js ecosystem is built on a different module system called CommonJS (CJS). Interoperating between the two brings large challenges, with many new features to juggle; however, support for ESM in Node.js was largely implemented in Node.js 12 and later. Around TypeScript 4.5 we rolled out nightly-only support for ESM in Node.js to get some feedback from users and let library authors ready themselves for broader support.<p>TypeScript 4.7 adds this functionality with two new <code>module</code> settings: <code>node16</code> and <code>nodenext</code>.<pre class="language-jsonc"><code class="language-jsonc">{
    "compilerOptions": {
        "module": "node16",
    }
}</code></pre><p>These new modes bring a few high-level features which we'll explore here.<section id="type-in-packagejson-and-new-extensions"class="level3"><h3><code>type</code> in <code>package.json</code> and New Extensions</h3><p>Node.js supports <a href="https://nodejs.org/api/packages.html#packages_package_json_and_file_extensions">a new setting in <code>package.json</code></a> called <code>type</code>. <code>"type"</code> can be set to either <code>"module"</code> or <code>"commonjs"</code>.<pre class="language-jsonc"><code class="language-jsonc">{
    "name": "my-package",
    "type": "module",

    "//": "...",
    "dependencies": {
    }
}</code></pre><p>This setting controls whether <code>.js</code> files are interpreted as ES modules or CommonJS modules, and defaults to CommonJS when not set. When a file is considered an ES module, a few different rules come into play compared to CommonJS:<ul><li><code>import</code>/<code>export</code> statements can be used.<li>Top-level <code>await</code> can be used<li>Relative import paths need full extensions (we have to write <code>import "./foo.js"</code> instead of <code>import "./foo"</code>).<li>Imports might resolve differently from dependencies in <code>node_modules</code>.<li>Certain global-like values like <code>require</code> and <code>module</code> cannot be used directly.<li>CommonJS modules get imported under certain special rules.</ul><p>We'll come back to some of these.<p>To overlay the way TypeScript works in this system, <code>.ts</code> and <code>.tsx</code> files now work the same way. When TypeScript finds a <code>.ts</code>, <code>.tsx</code>, <code>.js</code>, or <code>.jsx</code> file, it will walk up looking for a <code>package.json</code> to see whether that file is an ES module, and use that to determine:<ul><li>how to find other modules which that file imports<li>and how to transform that file if producing outputs</ul><p>When a <code>.ts</code> file is compiled as an ES module, ECMAScript <code>import</code>/<code>export</code> statements are left alone in the <code>.js</code> output; when it's compiled as a CommonJS module, it will produce the same output you get today under <code>--module commonjs</code>.<p>This also means paths resolve differently between <code>.ts</code> files that are ES modules and ones that are CJS modules. For example, let's say you have the following code today:<pre class="language-ts"><code class="language-ts"><span class="token comment">// ./foo.ts</span>
<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// ./bar.ts</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> helper <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"./foo"</span><span class="token punctuation">;</span> <span class="token comment">// only works in CJS</span>

<span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This code works in CommonJS modules, but will fail in ES modules because relative import paths need to use extensions. As a result, it will have to be rewritten to use the extension of the <em>output</em> of <code>foo.ts</code> - so <code>bar.ts</code> will instead have to import from <code>./foo.js</code>.<pre class="language-ts"><code class="language-ts"><span class="token comment">// ./bar.ts</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> helper <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"./foo.js"</span><span class="token punctuation">;</span> <span class="token comment">// works in ESM &#x26; CJS</span>

<span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This might feel a bit cumbersome at first, but TypeScript tooling like auto-imports and path completion will typically just do this for you.<p>One other thing to mention is the fact that this applies to <code>.d.ts</code> files too. When TypeScript finds a <code>.d.ts</code> file in package, it is interpreted based on the containing package.</section><section id="new-file-extensions"class="level3"><h3>New File Extensions</h3><p>The <code>type</code> field in <code>package.json</code> is nice because it allows us to continue using the <code>.ts</code> and <code>.js</code> file extensions which can be convenient; however, you will occasionally need to write a file that differs from what <code>type</code> specifies. You might also just prefer to always be explicit.<p>Node.js supports two extensions to help with this: <code>.mjs</code> and <code>.cjs</code>. <code>.mjs</code> files are always ES modules, and <code>.cjs</code> files are always CommonJS modules, and there's no way to override these.<p>In turn, TypeScript supports two new source file extensions: <code>.mts</code> and <code>.cts</code>. When TypeScript emits these to JavaScript files, it will emit them to <code>.mjs</code> and <code>.cjs</code> respectively.<p>Furthermore, TypeScript also supports two new declaration file extensions: <code>.d.mts</code> and <code>.d.cts</code>. When TypeScript generates declaration files for <code>.mts</code> and <code>.cts</code>, their corresponding extensions will be <code>.d.mts</code> and <code>.d.cts</code>.<p>Using these extensions is entirely optional, but will often be useful even if you choose not to use them as part of your primary workflow.</section><section id="commonjs-interoperability"class="level3"><h3>CommonJS Interoperability</h3><p>Node.js allows ES modules to import CommonJS modules as if they were ES modules with a default export.<pre class="language-ts"><code class="language-ts"><span class="token comment">// ./foo.cts</span>
<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ./bar.mts</span>
<span class="token keyword module">import</span> <span class="token imports">foo</span> <span class="token keyword module">from</span> <span class="token string">"./foo.cjs"</span><span class="token punctuation">;</span>

<span class="token comment">// prints "hello world!"</span>
foo<span class="token punctuation">.</span><span class="token method function property-access">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>In some cases, Node.js also synthesizes named exports from CommonJS modules, which can be more convenient. In these cases, ES modules can use a "namespace-style" import (i.e. <code>import * as foo from "..."</code>), or named imports (i.e. <code>import { helper } from "..."</code>).<pre class="language-ts"><code class="language-ts"><span class="token comment">// ./foo.cts</span>
<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ./bar.mts</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> helper <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"./foo.cjs"</span><span class="token punctuation">;</span>

<span class="token comment">// prints "hello world!"</span>
<span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>There isn't always a way for TypeScript to know whether these named imports will be synthesized, but TypeScript will err on being permissive and use some heuristics when importing from a file that is definitely a CommonJS module.<p>One TypeScript-specific note about interop is the following syntax:<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>In a CommonJS module, this just boils down to a <code>require()</code> call, and in an ES module, this imports <a href="https://nodejs.org/api/module.html#module_module_createrequire_filename"><code>createRequire</code></a> to achieve the same thing. This will make code less portable on runtimes like the browser (which don't support <code>require()</code>), but will often be useful for interoperability. In turn, you can write the above example using this syntax as follows:<pre class="language-ts"><code class="language-ts"><span class="token comment">// ./foo.cts</span>
<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ./bar.mts</span>
<span class="token keyword module">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">"./foo.cjs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

foo<span class="token punctuation">.</span><span class="token method function property-access">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>Finally, it's worth noting that the only way to import ESM files from a CJS module is using dynamic <code>import()</code> calls. This can present challenges, but is the behavior in Node.js today.<p>You can <a href="https://nodejs.org/api/esm.html#esm_interoperability_with_commonjs">read more about ESM/CommonJS interop in Node.js here</a>.</section><section id="packagejson-exports-imports-and-self-referencing"class="level3"><h3><code>package.json</code> Exports, Imports, and Self-Referencing</h3><p>Node.js supports <a href="https://nodejs.org/api/packages.html#packages_exports">a new field for defining entry points in <code>package.json</code> called <code>"exports"</code></a>. This field is a more powerful alternative to defining <code>"main"</code> in <code>package.json</code>, and can control what parts of your package are exposed to consumers.<p>Here's an <code>package.json</code> that supports separate entry-points for CommonJS and ESM:<pre class="language-jsonc"><code class="language-jsonc">// package.json
{
    "name": "my-package",
    "type": "module",
    "exports": {
        ".": {
            // Entry-point for `import "my-package"` in ESM
            "import": "./esm/index.js",

            // Entry-point for `require("my-package") in CJS
            "require": "./commonjs/index.cjs",
        },
    },

    // CJS fall-back for older versions of Node.js
    "main": "./commonjs/index.cjs",
}</code></pre><p>There's a lot to this feature, <a href="https://nodejs.org/api/packages.html">which you can read more about on the Node.js documentation</a>. Here we'll try to focus on how TypeScript supports it.<p>With TypeScript's original Node support, it would look for a <code>"main"</code> field, and then look for declaration files that corresponded to that entry. For example, if <code>"main"</code> pointed to <code>./lib/index.js</code>, TypeScript would look for a file called <code>./lib/index.d.ts</code>. A package author could override this by specifying a separate field called <code>"types"</code> (e.g. <code>"types": "./types/index.d.ts"</code>).<p>The new support works similarly with <a href="https://nodejs.org/api/packages.html">import conditions</a>. By default, TypeScript overlays the same rules with import conditions - if you write an <code>import</code> from an ES module, it will look up the <code>import</code> field, and from a CommonJS module, it will look at the <code>require</code> field. If it finds them, it will look for a corresponding declaration file. If you need to point to a different location for your type declarations, you can add a <code>"types"</code> import condition.<pre class="language-jsonc"><code class="language-jsonc">// package.json
{
    "name": "my-package",
    "type": "module",
    "exports": {
        ".": {
            // Entry-point for `import "my-package"` in ESM
            "import": {
                // Where TypeScript will look.
                "types": "./types/esm/index.d.ts",

                // Where Node.js will look.
                "default": "./esm/index.js"
            },
            // Entry-point for `require("my-package") in CJS
            "require": {
                // Where TypeScript will look.
                "types": "./types/commonjs/index.d.cts",

                // Where Node.js will look.
                "default": "./commonjs/index.cjs"
            },
        }
    },

    // Fall-back for older versions of TypeScript
    "types": "./types/index.d.ts",

    // CJS fall-back for older versions of Node.js
    "main": "./commonjs/index.cjs"
}</code></pre><aside><p>Note that the <code>"types"</code> condition should always come first in <code>"exports"</code>.</aside><p>TypeScript also supports <a href="https://nodejs.org/api/packages.html#packages_imports">the <code>"imports"</code> field of <code>package.json</code></a> in a similar manner by looking for declaration files alongside corresponding files, and supports <a href="https://nodejs.org/api/packages.html#packages_self_referencing_a_package_using_its_name">packages self-referencing themselves</a>. These features are generally not as involved to set up, but are supported.</section><section id="your-feedback-wanted"class="level3"><h3>Your Feedback Wanted!</h3><p>As we continue working on TypeScript 4.7, we expect to see more documentation and polish go into this functionality. Supporting these new features has been an ambitious under-taking, and that's why we're looking for early feedback on it! Please try it out and let us know how it works for you.<p>For more information, <a href="https://github.com/microsoft/TypeScript/pull/44501">you can see the implementing PR here</a>.</section></section><section id="control-over-module-detection"class="level2"><h2>Control over Module Detection</h2><p>One issue with the introduction of modules to JavaScript was the ambiguity between existing "script" code and the new module code. JavaScript code in a module runs slightly differently, and has different scoping rules, so tools have to make decisions as to how each file runs. For example, Node.js requires module entry-points to be written in a <code>.mjs</code>, or have a nearby <code>package.json</code> with <code>"type": "module"</code>. TypeScript treats a file as a module whenever it finds any <code>import</code> or <code>export</code> statement in a file, but otherwise, will assume a <code>.ts</code> or <code>.js</code> file is a script file acting on the global scope.<p>This doesn't quite match up with the behavior of Node.js where the <code>package.json</code> can change the format of a file, or the <code>--jsx</code> setting <code>react-jsx</code>, where any JSX file contains an implicit import to a JSX factory. It also doesn't match modern expectations where most new TypeScript code is written with modules in mind.<p>That's why TypeScript 4.7 introduces a new option called <code>moduleDetection</code>. <code>moduleDetection</code> can take on 3 values: <code>"auto"</code> (the default), <code>"legacy"</code> (the same behavior as 4.6 and prior), and <code>"force"</code>.<p>Under the mode <code>"auto"</code>, TypeScript will not only look for <code>import</code> and <code>export</code> statements, but it will also check whether<ul><li>the <code>"type"</code> field in <code>package.json</code> is set to <code>"module"</code> when running under <code>--module nodenext</code>/<code>--module node16</code>, and<li>check whether the current file is a JSX file when running under <code>--jsx react-jsx</code></ul><p>In cases where you want every file to be treated as a module, the <code>"force"</code> setting ensures that every non-declaration file is treated as a module. This will be true regardless of how <code>module</code>, <code>moduleResoluton</code>, and <code>jsx</code> are configured.<p>Meanwhile, the <code>"legacy"</code> option simply goes back to the old behavior of only seeking out <code>import</code> and <code>export</code> statements to determine whether a file is a module.<p>You can <a href="https://github.com/microsoft/TypeScript/pull/47495">read up more about this change on the pull request</a>.</section><section id="control-flow-analysis-for-bracketed-element-access"class="level2"><h2>Control-Flow Analysis for Bracketed Element Access</h2><p>TypeScript 4.7 now narrows the types of element accesses when the indexed keys are literal types and unique symbols. For example, take the following code:<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token known-class-name class-name">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> numberOrString <span class="token operator">=</span> <span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token method function property-access">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&#x3C;</span> <span class="token number">0.5</span> <span class="token operator">?</span> <span class="token number">42</span> <span class="token operator">:</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">:</span> numberOrString<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">"string"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> str <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token method function property-access">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Previously, TypeScript would not consider any type guards on <code>obj[key]</code>, and would have no idea that <code>obj[key]</code> was really a <code>string</code>. Instead, it would think that <code>obj[key]</code> was still a <code>string | number</code> and accessing <code>toUpperCase()</code> would trigger an error.<p>TypeScript 4.7 now knows that <code>obj[key]</code> is a string.<p>This also means that under <code>--strictPropertyInitialization</code>, TypeScript can correctly check that computed properties are initialized by the end of a constructor body.<pre class="language-ts"><code class="language-ts"><span class="token comment">// 'key' has type 'unique symbol'</span>
<span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token known-class-name class-name">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

    <span class="token function">constructor</span><span class="token punctuation">(</span>str<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// oops, forgot to set 'this[key]'</span>
    <span class="token punctuation">}</span>

    <span class="token function">screamString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token method function property-access">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Under TypeScript 4.7, <code>--strictPropertyInitialization</code> reports an error telling us that the <code>[key]</code> property wasn't definitely assigned by the end of the constructor.<p>We'd like to extend our gratitude to <a href="https://github.com/a-tarasyuk">Oleksandr Tarasiuk</a> who provided <a href="https://github.com/microsoft/TypeScript/pull/45974">this change</a>!</section><section id="improved-function-inference-in-objects-and-methods"class="level2"><h2>Improved Function Inference in Objects and Methods</h2><p>TypeScript 4.7 can now perform more granular inferences from functions within objects and arrays. This allows the types of these functions to consistently flow in a left-to-right manner just like for plain arguments.<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">f</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">produce</span><span class="token operator">:</span> <span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">T</span><span class="token punctuation">,</span>
    <span class="token function-variable function">consume</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>

<span class="token comment">// Works</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">produce</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token string">"hello"</span><span class="token punctuation">,</span>
    <span class="token function-variable function">consume</span><span class="token operator">:</span> x <span class="token arrow operator">=></span> x<span class="token punctuation">.</span><span class="token method function property-access">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Works</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">produce</span><span class="token operator">:</span> <span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> n<span class="token punctuation">,</span>
    <span class="token function-variable function">consume</span><span class="token operator">:</span> x <span class="token arrow operator">=></span> x<span class="token punctuation">.</span><span class="token method function property-access">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Was an error, now works.</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">produce</span><span class="token operator">:</span> n <span class="token arrow operator">=></span> n<span class="token punctuation">,</span>
    <span class="token function-variable function">consume</span><span class="token operator">:</span> x <span class="token arrow operator">=></span> x<span class="token punctuation">.</span><span class="token method function property-access">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Was an error, now works.</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">produce</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword control-flow">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">consume</span><span class="token operator">:</span> x <span class="token arrow operator">=></span> x<span class="token punctuation">.</span><span class="token method function property-access">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Was an error, now works.</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword control-flow">return</span> <span class="token string">"hello"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">consume</span><span class="token operator">:</span> x <span class="token arrow operator">=></span> x<span class="token punctuation">.</span><span class="token method function property-access">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Inference failed in some of these examples because knowing the type of their <code>produce</code> functions would indirectly request the type of <code>arg</code> before finding a good type for <code>T</code>. TypeScript now gathers functions that could contribute to the inferred type of <code>T</code> and infers from them lazily.<p>For more information, you can <a href="https://github.com/microsoft/TypeScript/pull/48538">take a look at the specific modifications to our inference process</a>.</section><section id="instantiation-expressions"class="level2"><h2>Instantiation Expressions</h2><p>Occasionally functions can be a bit more general than we want. For example, let's say we had a <code>makeBox</code> function.<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Box</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">makeBox</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> value <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Maybe we want to create a more specialized set of functions for making <code>Box</code>es of <code>Wrench</code>es and <code>Hammer</code>s. To do that today, we'd have to wrap <code>makeBox</code> in other functions, or use an explicit type for an alias of <code>makeBox</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">makeHammerBox</span><span class="token punctuation">(</span>hammer<span class="token operator">:</span> <span class="token maybe-class-name">Hammer</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token function">makeBox</span><span class="token punctuation">(</span>hammer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// or...</span>

<span class="token keyword">const</span> <span class="token function-variable function">makeWrenchBox</span><span class="token operator">:</span> <span class="token punctuation">(</span>wrench<span class="token operator">:</span> <span class="token maybe-class-name">Wrench</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">Box</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Wrench</span><span class="token operator">></span> <span class="token operator">=</span> makeBox<span class="token punctuation">;</span></code></pre><p>These work, but wrapping a call to <code>makeBox</code> is a bit wasteful, and writing the full signature of <code>makeWrenchBox</code> could get unwieldy. Ideally, we would be able to say that we just want to alias <code>makeBox</code> while replacing all of the generics in its signature.<p>TypeScript 4.7 allows exactly that! We can now take functions and constructors and feed them type arguments directly.<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> makeHammerBox <span class="token operator">=</span> makeBox<span class="token operator">&#x3C;</span><span class="token maybe-class-name">Hammer</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> makeWrenchBox <span class="token operator">=</span> makeBox<span class="token operator">&#x3C;</span><span class="token maybe-class-name">Wrench</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>So with this, we can specialize <code>makeBox</code> to accept more specific types and reject anything else.<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> makeStringBox <span class="token operator">=</span> makeBox<span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">// TypeScript correctly rejects this.</span>
<span class="token function">makeStringBox</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This logic also works for constructor functions such as <code>Array</code>, <code>Map</code>, and <code>Set</code>.<pre class="language-ts"><code class="language-ts"><span class="token comment">// Has type `new () => Map&#x3C;string, Error>`</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">ErrorMap</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Map</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token known-class-name class-name">Error</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">// Has type `// Map&#x3C;string, Error>`</span>
<span class="token keyword">const</span> errorMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">ErrorMap</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>When a function or constructor is given type arguments, it will produce a new type that keeps all signatures with compatible type parameter lists, and replaces the corresponding type parameters with the given type arguments. Any other signatures are dropped, as TypeScript will assume that they aren't meant to be used.<p>For more information on this feature, <a href="https://github.com/microsoft/TypeScript/pull/47607">check out the pull request</a>.</section><section id="extends-constraints-on-infer-type-variables"class="level2"><h2><code>extends</code> Constraints on <code>infer</code> Type Variables</h2><p>Conditional types are a bit of a power-user feature. They allow us to match and infer against the shape of types, and make decisions based on them. For example, we can write a conditional type that returns the first element of a tuple type if it's a <code>string</code>-like type.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">FirstIfString</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span>
    <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token keyword">infer</span> <span class="token constant">S</span><span class="token punctuation">,</span> <span class="token spread operator">...</span><span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token operator">?</span> <span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token constant">S</span> <span class="token operator">:</span> <span class="token builtin">never</span>
        <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

 <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">FirstIfString</span><span class="token operator">&#x3C;</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">// "hello"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">FirstIfString</span><span class="token operator">&#x3C;</span><span class="token punctuation">[</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">// "hello" | "world"</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">FirstIfString</span><span class="token operator">&#x3C;</span><span class="token punctuation">[</span><span class="token string">"hello"</span> <span class="token operator">|</span> <span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">// never</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">D</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">FirstIfString</span><span class="token operator">&#x3C;</span><span class="token punctuation">[</span><span class="token builtin">boolean</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><p><code>FirstIfString</code> matches against any tuple with at least one element and grabs the type of the first element as <code>S</code>. Then it checks if <code>S</code> is compatible with <code>string</code> and returns that type if it is.<p>Note that we had to use two conditional types to write this. We could have written <code>FirstIfString</code> as follows:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">FirstIfString</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span>
    <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token spread operator">...</span><span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token comment">// Grab the first type out of `T`</span>
        <span class="token operator">?</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span></code></pre><p>This works, but it's slightly more "manual" and less declarative. Instead of just pattern-matching on the type and giving the first element a name, we have to fetch out the <code>0</code>th element of <code>T</code> with <code>T[0]</code>. If we were dealing with types more complex than tuples, this could get a lot trickier, so <code>infer</code> can simplify things.<p>Using nested conditionals to infer a type and then match against that inferred type is pretty common. To avoid that second level of nesting, TypeScript 4.7 now allows you to place a constraint on any <code>infer</code> type.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">FirstIfString</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span>
    <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token keyword">infer</span> <span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span><span class="token punctuation">,</span> <span class="token spread operator">...</span><span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token operator">?</span> <span class="token constant">S</span>
        <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span></code></pre><p>This way, when TypeScript matches against <code>S</code>, it also ensures that <code>S</code> has to be a <code>string</code>. If <code>S</code> isn't a <code>string</code>, it takes the false path, which in these cases is <code>never</code>.<p>For more details, you can <a href="https://github.com/microsoft/TypeScript/pull/48112">read up on the change on GitHub</a>.</section><section id="optional-variance-annotations-for-type-parameters"class="level2"><h2>Optional Variance Annotations for Type Parameters</h2><p>Let's take the following types.<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Animal</span></span> <span class="token punctuation">{</span>
    animalStuff<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Dog</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">Animal</span></span> <span class="token punctuation">{</span>
    dogStuff<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ...</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Getter</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Setter</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span></code></pre><p>Imagine we had two different instances of <code>Getter</code>s. Figuring out whether any two different <code>Getter</code>s are substitutable for one another depends entirely on <code>T</code>. In the case of whether an assignment of <code>Getter&#x3C;Dog></code> → <code>Getter&#x3C;Animal></code> is valid, we have to check whether <code>Dog</code> → <code>Animal</code> is valid. Because each type for <code>T</code> just gets related in the same "direction", we say that the <code>Getter</code> type is <em>covariant</em> on <code>T</code>. On the other hand, checking whether <code>Setter&#x3C;Dog></code> → <code>Setter&#x3C;Animal></code> is valid involves checking whether <code>Animal</code> → <code>Dog</code> is valid. That "flip" in direction is kind of like how in math, checking whether −<em>x</em> &#x3C; <em>−y</em> is the same as checking whether <em>y</em> &#x3C; <em>x</em>. When we have to flip directions like this to compare <code>T</code>, we say that <code>Setter</code> is <em>contravariant</em> on <code>T</code>.<p>With TypeScript 4.7, we're now able to <em>explicitly</em> specify variance on type parameters.<p>So now, if we want to make it explicit that <code>Getter</code> is covariant on <code>T</code>, we can now give it an <code>out</code> modifier.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Getter</span><span class="token operator">&#x3C;</span>out <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">T</span><span class="token punctuation">;</span></code></pre><p>And similarly, if we also want to make it explicit that <code>Setter</code> is contravariant on <code>T</code>, we can give it an <code>in</code> modifier.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Setter</span><span class="token operator">&#x3C;</span><span class="token keyword">in</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span></code></pre><p><code>out</code> and <code>in</code> are used here because a type parameter's variance depends on whether it's used in an <em>output</em> or an <em>input</em>. Instead of thinking about variance, you can just think about if <code>T</code> is used in output and input positions.<p>There are also cases for using both <code>in</code> and <code>out</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">State</span><span class="token operator">&#x3C;</span><span class="token keyword">in</span> out <span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">T</span><span class="token punctuation">;</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>When a <code>T</code> is used in both an output and input position, it becomes <em>invariant</em>. Two different <code>State&#x3C;T></code>s can't be interchanged unless their <code>T</code>s are the same. In other words, <code>State&#x3C;Dog></code> and <code>State&#x3C;Animal></code> aren't substitutable for the other.<p>Now technically speaking, in a purely structural type system, type parameters and their variance don't really matter - you can just plug in types in place of each type parameter and check whether each matching member is structurally compatible. So if TypeScript uses a structural type system, why are we interested in the variance of type parameters? And why might we ever want to annotate them?<p>One reason is that it can be a useful for a reader to explicitly see how a type parameter is used at a glance. For much more complex types, it can be difficult to tell whether a type is meant to be read, written, or both. TypeScript will also help us out if we forget to mention how that type parameter is used. As an example, if we forgot to specify both <code>in</code> and <code>out</code> on <code>State</code>, we'd get an error.<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">State</span><span class="token operator">&#x3C;</span>out <span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
    <span class="token comment">//          ~~~~~</span>
    <span class="token comment">// error!</span>
    <span class="token comment">// Type 'State&#x3C;sub-T>' is not assignable to type 'State&#x3C;super-T>' as implied by variance annotation.</span>
    <span class="token comment">//   Types of property 'set' are incompatible.</span>
    <span class="token comment">//     Type '(value: sub-T) => void' is not assignable to type '(value: super-T) => void'.</span>
    <span class="token comment">//       Types of parameters 'value' and 'value' are incompatible.</span>
    <span class="token comment">//         Type 'super-T' is not assignable to type 'sub-T'.</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token constant">T</span><span class="token punctuation">;</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Another reason is precision and speed! TypeScript already tries to infer the variance of type parameters as an optimization. By doing this, it can type-check larger structural types in a reasonable amount of time. Calculating variance ahead of time allows the type-checker to skip deeper comparisons and just compare type arguments which can be <em>much</em> faster than comparing the full structure of a type over and over again. But often there are cases where this calculation is still fairly expensive, and the calculation may find circularities that can't be accurately resolved, meaning there's no clear answer for the variance of a type.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
    f<span class="token operator">:</span> <span class="token maybe-class-name">Bar</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Bar</span><span class="token operator">&#x3C;</span><span class="token constant">U</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token maybe-class-name">Baz</span><span class="token operator">&#x3C;</span><span class="token constant">U</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Baz</span><span class="token operator">&#x3C;</span><span class="token constant">V</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token constant">V</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">let</span> foo1<span class="token operator">:</span> <span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token builtin">unknown</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> foo2<span class="token operator">:</span> <span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">;</span>

foo1 <span class="token operator">=</span> foo2<span class="token punctuation">;</span>  <span class="token comment">// Should be an error but isn't ❌</span>
foo2 <span class="token operator">=</span> foo1<span class="token punctuation">;</span>  <span class="token comment">// Error - correct ✅</span></code></pre><p>Providing an explicit annotation can speed up type-checking at these circularities and provide better accuracy. For instance, marking <code>T</code> as invariant in the above example can help stop the problematic assignment.<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> type Foo&#x3C;T> = {
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> type Foo&#x3C;in out T> = {
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     x: T;
</span><span class="token prefix unchanged"> </span><span class="token line">     f: Bar&#x3C;T>;
</span><span class="token prefix unchanged"> </span><span class="token line"> }</span></span></code></pre><p>We don't necessarily recommend annotating every type parameter with its variance; For example, it's possible (but not recommended) to make variance a little stricter than is necessary, so TypeScript won't stop you from marking something as invariant if it's really just covariant, contravariant, or even independent. So if you do choose to add explicit variance markers, we would encourage thoughtful and precise use of them.<p>But if you're working with deeply recursive types, especially if you're a library author, you may be interested in using these annotations to the benefit of your users. Those annotations can provide wins in both accuracy and type-checking speed, which can even affect their code editing experience. Determining when variance calculation is a bottleneck on type-checking time can be done experimentally, and determined using tooling like our <a href="https://github.com/microsoft/typescript-analyze-trace">analyze-trace</a> utility.<p>For more details on this feature, you can <a href="https://github.com/microsoft/TypeScript/pull/48240">read up on the pull request</a>.</section><section id="resolution-customization-with-modulesuffixes"class="level2"><h2>Resolution Customization with <code>moduleSuffixes</code></h2><p>TypeScript 4.7 now supports a <code>moduleSuffixes</code> option to customize how module specifiers are looked up.<pre class="language-jsonc"><code class="language-jsonc">{
    "compilerOptions": {
        "moduleSuffixes": [".ios", ".native", ""]
    }
}</code></pre><p>Given the above configuration, an import like the following...<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> foo</span> <span class="token keyword module">from</span> <span class="token string">"./foo"</span><span class="token punctuation">;</span></code></pre><p>will try to look at the relative files <code>./foo.ios.ts</code>, <code>./foo.native.ts</code>, and finally <code>./foo.ts</code>.<aside><p>Note that the empty string <code>""</code> in <code>moduleSuffixes</code> is necessary for TypeScript to also look-up <code>./foo.ts</code>. In a sense, the default value for <code>moduleSuffixes</code> is <code>[""]</code>.</aside><p>This feature can be useful for React Native projects where each target platform can use a separate <code>tsconfig.json</code> with differing <code>moduleSuffixes</code>.<p><a href="https://github.com/microsoft/TypeScript/pull/48189">The <code>moduleSuffixes</code> option</a> was contributed thanks to <a href="https://github.com/afoxman">Adam Foxman</a>!</section><section id="resolution-mode"class="level2"><h2>resolution-mode</h2><p>With Node's ECMAScript resolution, the mode of the containing file and the syntax you use determines how imports are resolved; however it would be useful to reference the types of a CommonJS module from an ECMAScript module, or vice-versa.<p>TypeScript now allows <code>/// &#x3C;reference types="..." /></code> directives.<pre class="language-ts"><code class="language-ts"><span class="token comment">/// &#x3C;reference types="pkg" resolution-mode="require" /></span>

<span class="token comment">// or</span>

<span class="token comment">/// &#x3C;reference types="pkg" resolution-mode="import" /></span></code></pre><p>Additionally, in nightly versions of TypeScript, <code>import type</code> can specify an import assertion to achieve something similar.<pre class="language-ts"><code class="language-ts"><span class="token comment">// Resolve `pkg` as if we were importing with a `require()`</span>
<span class="token keyword module">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">TypeFromRequire</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">"pkg"</span> <span class="token keyword">assert</span> <span class="token punctuation">{</span>
    <span class="token string-property property">"resolution-mode"</span><span class="token operator">:</span> <span class="token string">"require"</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Resolve `pkg` as if we were importing with an `import`</span>
<span class="token keyword module">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">TypeFromImport</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">"pkg"</span> <span class="token keyword">assert</span> <span class="token punctuation">{</span>
    <span class="token string-property property">"resolution-mode"</span><span class="token operator">:</span> <span class="token string">"import"</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">MergedType</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">TypeFromRequire</span></span><span class="token punctuation">,</span> <span class="token maybe-class-name">TypeFromImport</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>These import assertions can also be used on <code>import()</code> types.<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">TypeFromRequire</span></span> <span class="token operator">=</span>
    <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">"pkg"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> assert<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token string-property property">"resolution-mode"</span><span class="token operator">:</span> <span class="token string">"require"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">TypeFromRequire</span></span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">TypeFromImport</span></span> <span class="token operator">=</span>
    <span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">"pkg"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> assert<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token string-property property">"resolution-mode"</span><span class="token operator">:</span> <span class="token string">"import"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access"><span class="token maybe-class-name">TypeFromImport</span></span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">MergedType</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">TypeFromRequire</span></span><span class="token punctuation">,</span> <span class="token maybe-class-name">TypeFromImport</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>The <code>import type</code> and <code>import()</code> syntaxes only support <code>resolution-mode</code> in <a href="https://www.typescriptlang.org/docs/handbook/nightly-builds.html">nightly builds of TypeScript</a>. You'll likely get an error like<pre class="language-text"><code class="language-text">Resolution mode assertions are unstable. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'.</code></pre><p>If you do find yourself using this feature in nightly versions of TypeScript, <a href="https://github.com/microsoft/TypeScript/issues/49055">consider providing feedback on this issue</a>.<p>You can see the respective changes <a href="https://github.com/microsoft/TypeScript/pull/47732">for reference directives</a> and <a href="https://github.com/microsoft/TypeScript/pull/47807">for type import assertions</a>.</section><section id="go-to-source-definition"class="level2"><h2>Go to Source Definition</h2><p>TypeScript 4.7 contains support for a new experimental editor command called <em>Go To Source Definition</em>. It's similar to <em>Go To Definition</em>, but it never returns results inside declaration files. Instead, it tries to find corresponding <em>implementation</em> files (like <code>.js</code> or <code>.ts</code> files), and find definitions there — even if those files are normally shadowed by <code>.d.ts</code> files.<p>This comes in handy most often when you need to peek at the implementation of a function you're importing from a library instead of its type declaration in a <code>.d.ts</code> file.<figure><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2022/05/go-to-source-definition-4-7-v1.gif"alt="The &#x22;Go to Source Definition&#x22; command on a use of the yargs package jumps the editor to an index.cjs file in yargs."><figcaption aria-hidden="true">The "Go to Source Definition" command on a use of the yargs package jumps the editor to an index.cjs file in yargs.</figcaption></figure><p>You can try this new command in the latest versions of Visual Studio Code. Note, though, that this functionality is still in preview, and there are some known limitations. In some cases TypeScript uses heuristics to guess which <code>.js</code> file corresponds to the given result of a definition, so these results might be inaccurate. Visual Studio Code also doesn't yet indicate whether a result was a guess, but it's something we're collaborating on.<p>You can leave feedback about the feature, read about known limitations, or learn more at <a href="https://github.com/microsoft/TypeScript/issues/49003">our dedicated feedback issue</a>.</section><section id="group-aware-organize-imports"class="level2"><h2>Group-Aware Organize Imports</h2><p>TypeScript has an <em>Organize Imports</em> editor feature for both JavaScript and TypeScript. Unfortunately, it could be a bit of a blunt instrument, and would often naively sort your import statements.<p>For instance, if you ran Organize Imports on the following file...<pre class="language-ts"><code class="language-ts"><span class="token comment">// local code</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> bbb</span> <span class="token keyword module">from</span> <span class="token string">"./bbb"</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> ccc</span> <span class="token keyword module">from</span> <span class="token string">"./ccc"</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> aaa</span> <span class="token keyword module">from</span> <span class="token string">"./aaa"</span><span class="token punctuation">;</span>

<span class="token comment">// built-ins</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> path</span> <span class="token keyword module">from</span> <span class="token string">"path"</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> child_process</span> <span class="token keyword module">from</span> <span class="token string">"child_process"</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> fs</span> <span class="token keyword module">from</span> <span class="token string">"fs"</span><span class="token punctuation">;</span>

<span class="token comment">// some code...</span></code></pre><p>You would get something like the following<pre class="language-ts"><code class="language-ts"><span class="token comment">// local code</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> child_process</span> <span class="token keyword module">from</span> <span class="token string">"child_process"</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> fs</span> <span class="token keyword module">from</span> <span class="token string">"fs"</span><span class="token punctuation">;</span>
<span class="token comment">// built-ins</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> path</span> <span class="token keyword module">from</span> <span class="token string">"path"</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> aaa</span> <span class="token keyword module">from</span> <span class="token string">"./aaa"</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> bbb</span> <span class="token keyword module">from</span> <span class="token string">"./bbb"</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> ccc</span> <span class="token keyword module">from</span> <span class="token string">"./ccc"</span><span class="token punctuation">;</span>


<span class="token comment">// some code...</span></code></pre><p>This is... not ideal. Sure, our imports are sorted by their paths, and our comments and newlines are preserved, but not in a way we expected. Much of the time, if we have our imports grouped in a specific way, then we want to keep them that way.<p>TypeScript 4.7 performs Organize Imports in a group-aware manner. Running it on the above code looks a little bit more like what you'd expect:<pre class="language-ts"><code class="language-ts"><span class="token comment">// local code</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> aaa</span> <span class="token keyword module">from</span> <span class="token string">"./aaa"</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> bbb</span> <span class="token keyword module">from</span> <span class="token string">"./bbb"</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> ccc</span> <span class="token keyword module">from</span> <span class="token string">"./ccc"</span><span class="token punctuation">;</span>

<span class="token comment">// built-ins</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> child_process</span> <span class="token keyword module">from</span> <span class="token string">"child_process"</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> fs</span> <span class="token keyword module">from</span> <span class="token string">"fs"</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> path</span> <span class="token keyword module">from</span> <span class="token string">"path"</span><span class="token punctuation">;</span>

<span class="token comment">// some code...</span></code></pre><p>We'd like to extend our thanks to <a href="https://github.com/MQuy">Minh Quy</a> who provided <a href="https://github.com/microsoft/TypeScript/pull/48330">this feature</a>.</section><section id="object-method-snippet-completions"class="level2"><h2>Object Method Snippet Completions</h2><p>TypeScript now provides snippet completions for object literal methods. When completing members in an object, TypeScript will provide a typical completion entry for just the name of a method, along with a separate completion entry for the full method definition!<figure><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2022/05/object-method-completions-4-7-v2.gif"alt="Completion a full method signature from an object"><figcaption aria-hidden="true">Completion a full method signature from an object</figcaption></figure><p>For more details, <a href="https://github.com/microsoft/TypeScript/pull/48168">see the implementing pull request</a>.</section><section id="breaking-changes"class="level2"><h2>Breaking Changes</h2><section id="libdts-updates"class="level3"><h3><code>lib.d.ts</code> Updates</h3><p>While TypeScript strives to avoid major breaks, even small changes in the built-in libraries can cause issues. We don't expect major breaks as a result of DOM and <code>lib.d.ts</code> updates, but there may be some small ones.</section><section id="stricter-spread-checks-in-jsx"class="level3"><h3>Stricter Spread Checks in JSX</h3><p>When writing a <code>...spread</code> in JSX, TypeScript now enforces stricter checks that the given type is actually an object. As a result, values with the types <code>unknown</code> and <code>never</code> (and more rarely, just bare <code>null</code> and <code>undefined</code>) can no longer be spread into JSX elements.<p>So for the following example:<pre class="language-tsx"><code class="language-tsx"><span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> <span class="token maybe-class-name">React</span></span> <span class="token keyword module">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Props</span></span> <span class="token punctuation">{</span>
    stuff<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span>props<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>div</span> <span class="token spread"><span class="token punctuation">{</span><span class="token spread operator">...</span>props<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>you'll now receive an error like the following:<pre class="language-text"><code class="language-text">Spread types may only be created from object types.</code></pre><p>This makes this behavior more consistent with spreads in object literals.<p>For more details, <a href="https://github.com/microsoft/TypeScript/pull/48570">see the change on GitHub</a>.</section><section id="stricter-checks-with-template-string-expressions"class="level3"><h3>Stricter Checks with Template String Expressions</h3><p>When a <code>symbol</code> value is used in a template string, it will trigger a runtime error in JavaScript.<pre class="language-js"><code class="language-js"><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token known-class-name class-name">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token comment">// TypeError: Cannot convert a Symbol value to a string</span></code></pre><p>As a result, TypeScript will issue an error as well; however, TypeScript now also checks if a generic value that is constrained to a symbol in some way is used in a template string.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">logKey</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token constant">S</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">S</span> <span class="token punctuation">{</span>
    <span class="token comment">// Now an error.</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is the key</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> key<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Now an error.</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Grabbing property '</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>TypeScript will now issue the following error:<pre class="language-text"><code class="language-text">Implicit conversion of a 'symbol' to a 'string' will fail at runtime. Consider wrapping this expression in 'String(...)'.</code></pre><p>In some cases, you can get around this by wrapping the expression in a call to <code>String</code>, just like the error message suggests.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">logKey</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">S</span> <span class="token keyword">extends</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token constant">S</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">S</span> <span class="token punctuation">{</span>
    <span class="token comment">// Now an error.</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token known-class-name class-name">String</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is the key</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> key<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>In others, this error is too pedantic, and you might not ever care to even allow <code>symbol</code> keys when using <code>keyof</code>. In such cases, you can switch to <code>string &#x26; keyof ...</code>:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token builtin">string</span> <span class="token operator">&#x26;</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Now an error.</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Grabbing property '</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>For more information, you can <a href="https://github.com/microsoft/TypeScript/pull/44578">see the implementing pull request</a>.</section><section id="readfile-method-is-no-longer-optional-on-languageservicehost"class="level3"><h3><code>readFile</code> Method is No Longer Optional on <code>LanguageServiceHost</code></h3><p>If you're creating <code>LanguageService</code> instances, then provided <code>LanguageServiceHost</code>s will need to provide a <code>readFile</code> method. This change was necessary to support the new <code>moduleDetection</code> compiler option.<p>You can <a href="https://github.com/microsoft/TypeScript/pull/47495">read more on the change here</a>.</section><section id="readonly-tuples-have-a-readonly-length-property"class="level3"><h3><code>readonly</code> Tuples Have a <code>readonly</code> <code>length</code> Property</h3><p>A <code>readonly</code> tuple will now treat its <code>length</code> property as <code>readonly</code>. This was almost never witnessable for fixed-length tuples, but was an oversight which could be observed for tuples with trailing optional and rest element types.<p>As a result, the following code will now fail:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">overwriteLength</span><span class="token punctuation">(</span>tuple<span class="token operator">:</span> <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Now errors.</span>
    tuple<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>You can <a href="https://github.com/microsoft/TypeScript/pull/47717">read more on this change here</a>. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>