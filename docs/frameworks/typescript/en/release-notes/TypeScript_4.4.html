<!doctype html><html lang="en"><meta charset="utf-8"><title>TypeScript 4.4</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/release-notes/typescript-4-4.html"><meta name="oneline"content="TypeScript 4.4 Release Notes"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="control-flow-analysis-of-aliased-conditions-and-discriminants"class="level2"><h2>Control Flow Analysis of Aliased Conditions and Discriminants</h2><p>In JavaScript, we often have to probe a value in different ways, and do something different once we know more about its type. TypeScript understands these checks and calls them <em>type guards</em>. Instead of having to convince TypeScript of a variable's type whenever we use it, the type-checker leverages something called <em>control flow analysis</em> to see if we've used a type guard before a given piece of code.<p>For example, we can write something like<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> arg <span class="token operator">===</span> <span class="token string">"string"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span><span class="token method function property-access">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//           ^?</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>In this example, we checked whether <code>arg</code> was a <code>string</code>. TypeScript recognized the <code>typeof arg === "string"</code> check, which it considered a type guard, and knew that <code>arg</code> was a <code>string</code> inside the body of the <code>if</code> block. That let us access <code>string</code> methods like <code>toUpperCase()</code> without getting an error.<p>However, what would happen if we moved the condition out to a constant called <code>argIsString</code>?<pre class="language-ts"><code class="language-ts"><span class="token comment">// In TS 4.3 and below</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> argIsString <span class="token operator">=</span> <span class="token keyword">typeof</span> arg <span class="token operator">===</span> <span class="token string">"string"</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>argIsString<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span><span class="token method function property-access">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//              ~~~~~~~~~~~</span>
    <span class="token comment">// Error! Property 'toUpperCase' does not exist on type 'unknown'.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>In previous versions of TypeScript, this would be an error - even though <code>argIsString</code> was assigned the value of a type guard, TypeScript simply lost that information. That's unfortunate since we might want to re-use the same check in several places. To get around that, users often have to repeat themselves or use type assertions (a.k.a. casts).<p>In TypeScript 4.4, that is no longer the case. The above example works with no errors! When TypeScript sees that we are testing a constant value, it will do a little bit of extra work to see if it contains a type guard. If that type guard operates on a <code>const</code>, a <code>readonly</code> property, or an un-modified parameter, then TypeScript is able to narrow that value appropriately.<p>Different sorts of type guard conditions are preserved - not just <code>typeof</code> checks. For example, checks on discriminated unions work like a charm.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Shape</span></span> <span class="token operator">=</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"circle"</span><span class="token punctuation">;</span> radius<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"square"</span><span class="token punctuation">;</span> sideLength<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span>shape<span class="token operator">:</span> <span class="token maybe-class-name">Shape</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> isCircle <span class="token operator">=</span> shape<span class="token punctuation">.</span><span class="token property-access">kind</span> <span class="token operator">===</span> <span class="token string">"circle"</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>isCircle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// We know we have a circle here!</span>
    <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> shape<span class="token punctuation">.</span><span class="token property-access">radius</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// We know we're left with a square here!</span>
    <span class="token keyword control-flow">return</span> shape<span class="token punctuation">.</span><span class="token property-access">sideLength</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Analysis on discriminants in 4.4 also goes a little bit deeper - we can now extract out discriminants and TypeScript can narrow the original object.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Shape</span></span> <span class="token operator">=</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"circle"</span><span class="token punctuation">;</span> radius<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"square"</span><span class="token punctuation">;</span> sideLength<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span>shape<span class="token operator">:</span> <span class="token maybe-class-name">Shape</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
  <span class="token comment">// Extract out the 'kind' field first.</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> kind <span class="token punctuation">}</span> <span class="token operator">=</span> shape<span class="token punctuation">;</span>

  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>kind <span class="token operator">===</span> <span class="token string">"circle"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// We know we have a circle here!</span>
    <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> shape<span class="token punctuation">.</span><span class="token property-access">radius</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// We know we're left with a square here!</span>
    <span class="token keyword control-flow">return</span> shape<span class="token punctuation">.</span><span class="token property-access">sideLength</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>As another example, here's a function that checks whether two of its inputs have contents.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">doSomeChecks</span><span class="token punctuation">(</span>
  inputA<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span>
  inputB<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span>
  shouldDoExtraWork<span class="token operator">:</span> <span class="token builtin">boolean</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> mustDoWork <span class="token operator">=</span> inputA <span class="token operator">&#x26;&#x26;</span> inputB <span class="token operator">&#x26;&#x26;</span> shouldDoExtraWork<span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>mustDoWork<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// We can access 'string' properties on both 'inputA' and 'inputB'!</span>
    <span class="token keyword">const</span> upperA <span class="token operator">=</span> inputA<span class="token punctuation">.</span><span class="token method function property-access">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> upperB <span class="token operator">=</span> inputB<span class="token punctuation">.</span><span class="token method function property-access">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>TypeScript can understand that both <code>inputA</code> and <code>inputB</code> are both present if <code>mustDoWork</code> is <code>true</code>. That means we don't have to write a non-null assertion like <code>inputA!</code> to convince TypeScript that <code>inputA</code> isn't <code>undefined</code>.<p>One neat feature here is that this analysis works transitively. TypeScript will hop through constants to understand what sorts of checks you've already performed.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> isString <span class="token operator">=</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">"string"</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> isNumber <span class="token operator">=</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">"number"</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> isStringOrNumber <span class="token operator">=</span> isString <span class="token operator">||</span> isNumber<span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>isStringOrNumber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">;</span>
<span class="token comment">//  ^?</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">;</span>
<span class="token comment">//  ^?</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Note that there's a cutoff - TypeScript doesn't go arbitrarily deep when checking these conditions, but its analysis is deep enough for most checks.<p>This feature should make a lot of intuitive JavaScript code "just work" in TypeScript without it getting in your way. For more details, <a href="https://github.com/microsoft/TypeScript/pull/44730">check out the implementation on GitHub</a>!</section><section id="symbol-and-template-string-pattern-index-signatures"class="level2"><h2>Symbol and Template String Pattern Index Signatures</h2><p>TypeScript lets us describe objects where every property has to have a certain type using <em>index signatures</em>. This allows us to use these objects as dictionary-like types, where we can use string keys to index into them with square brackets.<p>For example, we can write a type with an index signature that takes <code>string</code> keys and maps to <code>boolean</code> values. If we try to assign anything other than a <code>boolean</code> value, we'll get an error.<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2322 2375</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">BooleanDictionary</span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">let</span> myDict<span class="token operator">:</span> <span class="token maybe-class-name">BooleanDictionary</span><span class="token punctuation">;</span>

<span class="token comment">// Valid to assign boolean values</span>
myDict<span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
myDict<span class="token punctuation">[</span><span class="token string">"bar"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token comment">// Error, "oops" isn't a boolean</span>
myDict<span class="token punctuation">[</span><span class="token string">"baz"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"oops"</span><span class="token punctuation">;</span></code></pre><p>While <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">a <code>Map</code> might be a better data structure here</a> (specifically, a <code>Map&#x3C;string, boolean></code>), JavaScript objects are often more convenient to use or just happen to be what we're given to work with.<p>Similarly, <code>Array&#x3C;T></code> already defines a <code>number</code> index signature that lets us insert/retrieve values of type <code>T</code>.<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2322 2375</span>
<span class="token comment">// This is part of TypeScript's definition of the built-in Array type.</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token known-class-name class-name">Array</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>index<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Array</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Valid</span>
arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello!"</span><span class="token punctuation">;</span>

<span class="token comment">// Error, expecting a 'string' value here</span>
arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></code></pre><p>Index signatures are very useful to express lots of code out in the wild; however, until now they've been limited to <code>string</code> and <code>number</code> keys (and <code>string</code> index signatures have an intentional quirk where they can accept <code>number</code> keys since they'll be coerced to strings anyway). That means that TypeScript didn't allow indexing objects with <code>symbol</code> keys. TypeScript also couldn't model an index signature of some <em>subset</em> of <code>string</code> keys - for example, an index signature which describes just properties whose names start with the text <code>data-</code>.<p>TypeScript 4.4 addresses these limitations, and allows index signatures for <code>symbol</code>s and template string patterns.<p>For example, TypeScript now allows us to declare a type that can be keyed on arbitrary <code>symbol</code>s.<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2322 2375</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Colors</span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>sym<span class="token operator">:</span> <span class="token builtin">symbol</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> red <span class="token operator">=</span> <span class="token known-class-name class-name">Symbol</span><span class="token punctuation">(</span><span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> green <span class="token operator">=</span> <span class="token known-class-name class-name">Symbol</span><span class="token punctuation">(</span><span class="token string">"green"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> blue <span class="token operator">=</span> <span class="token known-class-name class-name">Symbol</span><span class="token punctuation">(</span><span class="token string">"blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> colors<span class="token operator">:</span> <span class="token maybe-class-name">Colors</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Assignment of a number is allowed</span>
colors<span class="token punctuation">[</span>red<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> redVal <span class="token operator">=</span> colors<span class="token punctuation">[</span>red<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//  ^?</span>

colors<span class="token punctuation">[</span>blue<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"da ba dee"</span><span class="token punctuation">;</span></code></pre><p>Similarly, we can write an index signature with template string pattern type. One use of this might be to exempt properties starting with <code>data-</code> from TypeScript's excess property checking. When we pass an object literal to something with an expected type, TypeScript will look for excess properties that weren't declared in the expected type.<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2322 2375</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Options</span></span> <span class="token punctuation">{</span>
    width<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    height<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> a<span class="token operator">:</span> <span class="token maybe-class-name">Options</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    width<span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
    height<span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>

    <span class="token string-property property">"data-blah"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">OptionsWithDataProps</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">Options</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// Permit any property starting with 'data-'.</span>
    <span class="token punctuation">[</span>optName<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">data-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token builtin">string</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> b<span class="token operator">:</span> <span class="token maybe-class-name">OptionsWithDataProps</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    width<span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
    height<span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
    <span class="token string-property property">"data-blah"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>

    <span class="token comment">// Fails for a property which is not known, nor</span>
    <span class="token comment">// starts with 'data-'</span>
    <span class="token string-property property">"unknown-property"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>A final note on index signatures is that they now permit union types, as long as they're a union of infinite-domain primitive types - specifically:<ul><li><code>string</code><li><code>number</code><li><code>symbol</code><li>template string patterns (e.g. <code>`hello-${string}`</code>)</ul><p>An index signature whose argument is a union of these types will de-sugar into several different index signatures.<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Data</span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>optName<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Equivalent to</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Data</span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>optName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
  <span class="token punctuation">[</span>optName<span class="token operator">:</span> <span class="token builtin">symbol</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>For more details, <a href="https://github.com/microsoft/TypeScript/pull/44512">read up on the pull request</a></section><section id="defaulting-to-the-unknown-type-in-catch-variables---useunknownincatchvariables"class="level2"><h2>Defaulting to the <code>unknown</code> Type in Catch Variables (<code>--useUnknownInCatchVariables</code>)</h2><p>In JavaScript, any type of value can be thrown with <code>throw</code> and caught in a <code>catch</code> clause. Because of this, TypeScript historically typed catch clause variables as <code>any</code>, and would not allow any other type annotation:<pre class="language-ts"><code class="language-ts"><span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>
  <span class="token comment">// Who knows what this might throw...</span>
  <span class="token function">executeSomeThirdPartyCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword control-flow">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// err: any</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">error</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token property-access">message</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Allowed, because 'any'</span>
  err<span class="token punctuation">.</span><span class="token method function property-access">thisWillProbablyFail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Allowed, because 'any' :(</span>
<span class="token punctuation">}</span></code></pre><p>Once TypeScript added the <code>unknown</code> type, it became clear that <code>unknown</code> was a better choice than <code>any</code> in <code>catch</code> clause variables for users who want the highest degree of correctness and type-safety, since it narrows better and forces us to test against arbitrary values. Eventually TypeScript 4.0 allowed users to specify an explicit type annotation of <code>unknown</code> (or <code>any</code>) on each <code>catch</code> clause variable so that we could opt into stricter types on a case-by-case basis; however, for some, manually specifying <code>: unknown</code> on every <code>catch</code> clause was a chore.<p>That's why TypeScript 4.4 introduces a new flag called <a href="/tsconfig#useUnknownInCatchVariables"><code>useUnknownInCatchVariables</code></a>. This flag changes the default type of <code>catch</code> clause variables from <code>any</code> to <code>unknown</code>.<pre class="language-ts"><code class="language-ts"><span class="token comment">// @errors: 2571</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">executeSomeThirdPartyCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>
  <span class="token function">executeSomeThirdPartyCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword control-flow">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// err: unknown</span>

  <span class="token comment">// Error! Property 'message' does not exist on type 'unknown'.</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">error</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token property-access">message</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Works! We can narrow 'err' from 'unknown' to 'Error'.</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>err <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token known-class-name class-name">Error</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">error</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token property-access">message</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>This flag is enabled under the <a href="/tsconfig#strict"><code>strict</code></a> family of options. That means that if you check your code using <a href="/tsconfig#strict"><code>strict</code></a>, this option will automatically be turned on. You may end up with errors in TypeScript 4.4 such as<pre class="language-text"><code class="language-text">Property 'message' does not exist on type 'unknown'.
Property 'name' does not exist on type 'unknown'.
Property 'stack' does not exist on type 'unknown'.</code></pre><p>In cases where we don't want to deal with an <code>unknown</code> variable in a <code>catch</code> clause, we can always add an explicit <code>: any</code> annotation so that we can opt <em>out</em> of stricter types.<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">executeSomeThirdPartyCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>
  <span class="token function">executeSomeThirdPartyCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword control-flow">catch</span> <span class="token punctuation">(</span>err<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">error</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token property-access">message</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Works again!</span>
<span class="token punctuation">}</span></code></pre><p>For more information, take a look at <a href="https://github.com/microsoft/TypeScript/pull/41013">the implementing pull request</a>.</section><section id="exact-optional-property-types---exactoptionalpropertytypes"class="level2"><h2>Exact Optional Property Types (<code>--exactOptionalPropertyTypes</code>)</h2><p>In JavaScript, reading a <em>missing</em> property on an object produces the value <code>undefined</code>. It's also possible to <em>have</em> an actual property with the value <code>undefined</code>. A lot of code in JavaScript tends to treat these situations the same way, and so initially TypeScript just interpreted every optional property as if a user had written <code>undefined</code> in the type. For example,<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Person</span></span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>was considered equivalent to<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Person</span></span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>What this meant is that a user could explicitly write <code>undefined</code> in place of <code>age</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> p<span class="token operator">:</span> <span class="token maybe-class-name">Person</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">"Daniel"</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> <span class="token comment">// This is okay by default.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>So by default, TypeScript doesn't distinguish between a present property with the value <code>undefined</code> and a missing property. While this works most of the time, not all code in JavaScript makes the same assumptions. Functions and operators like <code>Object.assign</code>, <code>Object.keys</code>, object spread (<code>{ ...obj }</code>), and <code>for</code>-<code>in</code> loops behave differently depending on whether or not a property actually exists on an object. In the case of our <code>Person</code> example, this could potentially lead to runtime errors if the <code>age</code> property was observed in a context where its presence was important.<p>In TypeScript 4.4, the new flag <a href="/tsconfig#exactOptionalPropertyTypes"><code>exactOptionalPropertyTypes</code></a> specifies that optional property types should be interpreted exactly as written, meaning that <code>| undefined</code> is not added to the type:<pre class="language-ts"><code class="language-ts"><span class="token comment">// @exactOptionalPropertyTypes</span>
<span class="token comment">// @errors: 2322 2375</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Person</span></span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// ---cut---</span>
<span class="token comment">// With 'exactOptionalPropertyTypes' on:</span>
<span class="token keyword">const</span> p<span class="token operator">:</span> <span class="token maybe-class-name">Person</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">"Daniel"</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> <span class="token comment">// Error! undefined isn't a number</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>This flag is <strong>not</strong> part of the <a href="/tsconfig#strict"><code>strict</code></a> family and needs to be turned on explicitly if you'd like this behavior. It also requires <a href="/tsconfig#strictNullChecks"><code>strictNullChecks</code></a> to be enabled as well. We've been making updates to DefinitelyTyped and other definitions to try to make the transition as straightforward as possible, but you may encounter some friction with this depending on how your code is structured.<p>For more information, you can <a href="https://github.com/microsoft/TypeScript/pull/43947">take a look at the implementing pull request here</a>.</section><section id="static-blocks-in-classes"class="level2"><h2><code>static</code> Blocks in Classes</h2><p>TypeScript 4.4 brings support for <a href="https://github.com/tc39/proposal-class-static-block#ecmascript-class-static-initialization-blocks"><code>static</code> blocks in classes</a>, an upcoming ECMAScript feature that can help you write more-complex initialization code for static members.<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">someCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// This is a static block:</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">someCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token maybe-class-name">Foo</span><span class="token punctuation">.</span><span class="token property-access">count</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>These static blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. That means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class's internals.<pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">loadLastInstances</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment">// ---cut---</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> #count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">get</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">Foo</span><span class="token punctuation">.</span><span class="token property-access">#count</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> lastInstances <span class="token operator">=</span> <span class="token function">loadLastInstances</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token maybe-class-name">Foo</span><span class="token punctuation">.</span><span class="token property-access">#count</span> <span class="token operator">+=</span> lastInstances<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword control-flow">catch</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Without <code>static</code> blocks, writing the code above was possible, but often involved several different types of hacks that had to compromise in some way.<p>Note that a class can have multiple <code>static</code> blocks, and they're run in the same order in which they're written.<pre class="language-ts"><code class="language-ts"><span class="token comment">// Prints:</span>
<span class="token comment">//    1</span>
<span class="token comment">//    2</span>
<span class="token comment">//    3</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> prop <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token maybe-class-name">Foo</span><span class="token punctuation">.</span><span class="token property-access">prop</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token maybe-class-name">Foo</span><span class="token punctuation">.</span><span class="token property-access">prop</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token maybe-class-name">Foo</span><span class="token punctuation">.</span><span class="token property-access">prop</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>We'd like to extend our thanks to <a href="https://github.com/Kingwl">Wenlu Wang</a> for TypeScript's implementation of this feature. For more details, you can <a href="https://github.com/microsoft/TypeScript/pull/43370">see that pull request here</a>.</section><section id="tsc---help-updates-and-improvements"class="level2"><h2><code>tsc --help</code> Updates and Improvements</h2><p>TypeScript's <code>--help</code> option has gotten a refresh! Thanks to work in part by <a href="https://github.com/ShuiRuTian">Song Gao</a>, we've brought in changes to <a href="https://github.com/microsoft/TypeScript/pull/44409">update the descriptions of our compiler options</a> and <a href="https://github.com/microsoft/TypeScript/pull/44157">restyle the <code>--help</code> menu</a> with colors and other visual separation.<figure><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/08/tsc-help-ps-wt-4-4.png"alt="The new TypeScript &#x60;--help&#x60; menu where the output is bucketed into several different areas"><figcaption aria-hidden="true">The new TypeScript `--help` menu where the output is bucketed into several different areas</figcaption></figure><p>You can read more on <a href="https://github.com/microsoft/TypeScript/issues/44074">the original proposal thread</a>.</section><section id="performance-improvements"class="level2"><h2>Performance Improvements</h2><section id="faster-declaration-emit"class="level3"><h3>Faster Declaration Emit</h3><p>TypeScript now caches whether internal symbols are accessible in different contexts, along with how specific types should be printed. These changes can improve TypeScript's general performance in code with fairly complex types, and is especially observed when emitting <code>.d.ts</code> files under the <a href="/tsconfig#declaration"><code>declaration</code></a> flag.<p><a href="https://github.com/microsoft/TypeScript/pull/43973">See more details here</a>.</section><section id="faster-path-normalization"class="level3"><h3>Faster Path Normalization</h3><p>TypeScript often has to do several types of "normalization" on file paths to get them into a consistent format that the compiler can use everywhere. This involves things like replacing backslashes with slashes, or removing intermediate <code>/./</code> and <code>/../</code> segments of paths. When TypeScript has to operates over millions of these paths, these operations end up being a bit slow. In TypeScript 4.4, paths first undergo quick checks to see whether they need any normalization in the first place. These improvements together reduce project load time by 5-10% on bigger projects, and significantly more in massive projects that we've tested internally.<p>For more details, you can <a href="https://github.com/microsoft/TypeScript/pull/44173">view the PR for path segment normalization</a> along with <a href="https://github.com/microsoft/TypeScript/pull/44100">the PR for slash normalization</a>.</section><section id="faster-path-mapping"class="level3"><h3>Faster Path Mapping</h3><p>TypeScript now caches the way it constructs path-mappings (using the <a href="/tsconfig#paths"><code>paths</code></a> option in <code>tsconfig.json</code>). For projects with several hundred mappings, the reduction is significant. You can see more <a href="https://github.com/microsoft/TypeScript/pull/44078">on the change itself</a>.</section><section id="faster-incremental-builds-with---strict"class="level3"><h3>Faster Incremental Builds with <code>--strict</code></h3><p>In what was effectively a bug, TypeScript would end up redoing type-checking work under <a href="/tsconfig#incremental"><code>incremental</code></a> compilations if <a href="/tsconfig#strict"><code>strict</code></a> was on. This led to many builds being just as slow as if <a href="/tsconfig#incremental"><code>incremental</code></a> was turned off. TypeScript 4.4 fixes this, though the change has also been back-ported to TypeScript 4.3.<p>See more <a href="https://github.com/microsoft/TypeScript/pull/44394">here</a>.</section><section id="faster-source-map-generation-for-big-outputs"class="level3"><h3>Faster Source Map Generation for Big Outputs</h3><p>TypeScript 4.4 adds an optimization for source map generation on extremely large output files. When building an older version of the TypeScript compiler, this results in around an 8% reduction in emit time.<p>We'd like to extend our thanks to <a href="https://github.com/dmichon-msft">David Michon</a> who provided a <a href="https://github.com/microsoft/TypeScript/pull/44031">simple and clean change</a> to enable this performance win.</section><section id="faster---force-builds"class="level3"><h3>Faster <code>--force</code> Builds</h3><p>When using <code>--build</code> mode on project references, TypeScript has to perform up-to-date checks to determine which files need to be rebuilt. When performing a <a href="/tsconfig#force"><code>--force</code></a> build, however, that information is irrelevant since every project dependency will be rebuilt from scratch. In TypeScript 4.4, <a href="/tsconfig#force"><code>--force</code></a> builds avoid those unnecessary steps and start a full build. See more about the change <a href="https://github.com/microsoft/TypeScript/pull/43666">here</a>.</section></section><section id="spelling-suggestions-for-javascript"class="level2"><h2>Spelling Suggestions for JavaScript</h2><p>TypeScript powers the JavaScript editing experience in editors like Visual Studio and Visual Studio Code. Most of the time, TypeScript tries to stay out of the way in JavaScript files; however, TypeScript often has a lot of information to make confident suggestions, and ways of surfacing suggestions that aren't <em>too</em> invasive.<p>That's why TypeScript now issues spelling suggestions in plain JavaScript files - ones without <code>// @ts-check</code> or in a project with <a href="/tsconfig#checkJs"><code>checkJs</code></a> turned off. These are the same <em>"Did you mean...?"</em> suggestions that TypeScript files already have, and now they're available in <em>all</em> JavaScript files in some form.<p>These spelling suggestions can provide a subtle clue that your code is wrong. We managed to find a few bugs in existing code while testing this feature!<p>For more details on this new feature, <a href="https://github.com/microsoft/TypeScript/pull/44271">take a look at the pull request</a>!</section><section id="inlay-hints"class="level2"><h2>Inlay Hints</h2><p>TypeScript 4.4 provides support for <em>inlay hints</em> which can help display useful information like parameter names and return types in your code. You can think of it as a sort of friendly "ghost text".<figure><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/08/inlayHints-4.4-rc-ghd.png"alt="A preview of inlay hints in Visual Studio Code"><figcaption aria-hidden="true">A preview of inlay hints in Visual Studio Code</figcaption></figure><p>This feature was built by <a href="https://github.com/Kingwl">Wenlu Wang</a> whose <a href="https://github.com/microsoft/TypeScript/pull/42089">pull request</a> has more details.<p>Wenlu also contributed <a href="https://github.com/microsoft/vscode/pull/113412">the integration for inlay hints in Visual Studio Code</a> which has shipped as <a href="https://code.visualstudio.com/updates/v1_59#_typescript-44">part of the July 2021 (1.59) release</a>. If you'd like to try inlay hints out, make sure you're using a recent <a href="https://code.visualstudio.com/updates/v1_59">stable</a> or <a href="https://code.visualstudio.com/insiders/">insiders</a> version of the editor. You can also modify when and where inlay hints get displayed in Visual Studio Code's settings.</section><section id="auto-imports-show-true-paths-in-completion-lists"class="level2"><h2>Auto-Imports Show True Paths in Completion Lists</h2><p>When editors like Visual Studio Code show a completion list, completions which include auto-imports are displayed with a path to the given module; however, this path usually isn't what TypeScript ends up placing in a module specifier. The path is usually something relative to the <em>workspace</em>, meaning that if you're importing from a package like <code>moment</code>, you'll often see a path like <code>node_modules/moment</code>.<figure><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/08/completion-import-labels-pre-4-4.png"alt="A completion list containing unwieldy paths containing &#x27;node_modules&#x27;. For example, the label for &#x27;calendarFormat&#x27; is &#x27;node_modules/moment/moment&#x27; instead of &#x27;moment&#x27;."><figcaption aria-hidden="true">A completion list containing unwieldy paths containing 'node_modules'. For example, the label for 'calendarFormat' is 'node_modules/moment/moment' instead of 'moment'.</figcaption></figure><p>These paths end up being unwieldy and often misleading, especially given that the path that actually gets inserted into your file needs to consider Node's <code>node_modules</code> resolution, path mappings, symlinks, and re-exports.<p>That's why with TypeScript 4.4, the completion item label now shows the <em>actual</em> module path that will be used for the import!<figure><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/08/completion-import-labels-4-4.png"alt="A completion list containing clean paths with no intermediate &#x27;node_modules&#x27;. For example, the label for &#x27;calendarFormat&#x27; is &#x27;moment&#x27; instead of &#x27;node_modules/moment/moment&#x27;."><figcaption aria-hidden="true">A completion list containing clean paths with no intermediate 'node_modules'. For example, the label for 'calendarFormat' is 'moment' instead of 'node_modules/moment/moment'.</figcaption></figure><p>Since this calculation can be expensive, completion lists containing many auto-imports may fill in the final module specifiers in batches as you type more characters. It's possible that you'll still sometimes see the old workspace-relative path labels; however, as your editing experience "warms up", they should get replaced with the actual path after another keystroke or two.</section><section id="breaking-changes"class="level2"><h2>Breaking Changes</h2><section id="libdts-changes-for-typescript-44"class="level3"><h3><code>lib.d.ts</code> Changes for TypeScript 4.4</h3><p>As with every TypeScript version, declarations for <code>lib.d.ts</code> (especially the declarations generated for web contexts), have changed. You can consult <a href="https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1029#issuecomment-869224737">our list of known <code>lib.dom.d.ts</code> changes</a> to understand what is impacted.</section><section id="more-compliant-indirect-calls-for-imported-functions"class="level3"><h3>More-Compliant Indirect Calls for Imported Functions</h3><p>In earlier versions of TypeScript, calling an import from CommonJS, AMD, and other non-ES module systems would set the <code>this</code> value of the called function. Specifically, in the following example, when calling <code>fooModule.foo()</code>, the <code>foo()</code> method will have <code>fooModule</code> set as the value of <code>this</code>.<pre class="language-ts"><code class="language-ts"><span class="token comment">// Imagine this is our imported module, and it has an export named 'foo'.</span>
<span class="token keyword">let</span> fooModule <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

fooModule<span class="token punctuation">.</span><span class="token method function property-access">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This is not the way exported functions in ECMAScript are supposed to work when we call them. That's why TypeScript 4.4 intentionally discards the <code>this</code> value when calling imported functions, by using the following emit.<pre class="language-ts"><code class="language-ts"><span class="token comment">// Imagine this is our imported module, and it has an export named 'foo'.</span>
<span class="token keyword">let</span> fooModule <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Notice we're actually calling '(0, fooModule.foo)' now, which is subtly different.</span>
<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> fooModule<span class="token punctuation">.</span><span class="token property-access">foo</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>You can <a href="https://github.com/microsoft/TypeScript/pull/44624">read up more about the changes here</a>.</section><section id="using-unknown-in-catch-variables"class="level3"><h3>Using <code>unknown</code> in Catch Variables</h3><p>Users running with the <a href="/tsconfig#strict"><code>strict</code></a> flag may see new errors around <code>catch</code> variables being <code>unknown</code>, especially if the existing code assumes only <code>Error</code> values have been caught. This often results in error messages such as:<pre class="language-text"><code class="language-text">Property 'message' does not exist on type 'unknown'.
Property 'name' does not exist on type 'unknown'.
Property 'stack' does not exist on type 'unknown'.</code></pre><p>To get around this, you can specifically add runtime checks to ensure that the thrown type matches your expected type. Otherwise, you can just use a type assertion, add an explicit <code>: any</code> to your catch variable, or turn off <a href="/tsconfig#useUnknownInCatchVariables"><code>useUnknownInCatchVariables</code></a>.</section><section id="broader-always-truthy-promise-checks"class="level3"><h3>Broader Always-Truthy Promise Checks</h3><p>In prior versions, TypeScript introduced "Always Truthy Promise checks" to catch code where an <code>await</code> may have been forgotten; however, the checks only applied to named declarations. That meant that while this code would correctly receive an error...<pre class="language-ts"><code class="language-ts"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">boolean</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> fooResult <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>fooResult<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// &#x3C;- error! :D</span>
    <span class="token keyword control-flow">return</span> <span class="token string">"true"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> <span class="token string">"false"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>...the following code would not.<pre class="language-ts"><code class="language-ts"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">boolean</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Promise</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// &#x3C;- no error :(</span>
    <span class="token keyword control-flow">return</span> <span class="token string">"true"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> <span class="token string">"false"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>TypeScript 4.4 now flags both. For more information, <a href="https://github.com/microsoft/TypeScript/pull/44491">read up on the original change</a>.</section><section id="abstract-properties-do-not-allow-initializers"class="level3"><h3>Abstract Properties Do Not Allow Initializers</h3><p>The following code is now an error because abstract properties may not have initializers:<pre class="language-ts"><code class="language-ts"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">abstract</span> prop <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token comment">//       ~~~~</span>
  <span class="token comment">// Property 'prop' cannot have an initializer because it is marked abstract.</span>
<span class="token punctuation">}</span></code></pre><p>Instead, you may only specify a type for the property:<pre class="language-ts"><code class="language-ts"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">abstract</span> prop<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>