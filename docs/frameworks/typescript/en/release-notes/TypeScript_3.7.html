<!doctype html><html lang="en"><meta charset="utf-8"><title>TypeScript 3.7</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/release-notes/typescript-3-7.html"><meta name="oneline"content="TypeScript 3.7 Release Notes"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="optional-chaining"class="level2"><h2>Optional Chaining</h2><p><a href="/play/#example/optional-chaining">Playground</a><p>Optional chaining is <a href="https://github.com/microsoft/TypeScript/issues/16">issue #16</a> on our issue tracker. For context, there have been over 23,000 issues on the TypeScript issue tracker since then.<p>At its core, optional chaining lets us write code where TypeScript can immediately stop running some expressions if we run into a <code>null</code> or <code>undefined</code>. The star of the show in optional chaining is the new <code>?.</code> operator for <em>optional property accesses</em>. When we write code like<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> x <span class="token operator">=</span> foo<span class="token operator">?.</span>bar<span class="token punctuation">.</span><span class="token method function property-access">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>this is a way of saying that when <code>foo</code> is defined, <code>foo.bar.baz()</code> will be computed; but when <code>foo</code> is <code>null</code> or <code>undefined</code>, stop what we're doing and just return <code>undefined</code>."<p>More plainly, that code snippet is the same as writing the following.<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> x <span class="token operator">=</span> foo <span class="token operator">===</span> <span class="token keyword null nil">null</span> <span class="token operator">||</span> foo <span class="token operator">===</span> <span class="token keyword nil">undefined</span> <span class="token operator">?</span> <span class="token keyword nil">undefined</span> <span class="token operator">:</span> foo<span class="token punctuation">.</span><span class="token property-access">bar</span><span class="token punctuation">.</span><span class="token method function property-access">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Note that if <code>bar</code> is <code>null</code> or <code>undefined</code>, our code will still hit an error accessing <code>baz</code>. Likewise, if <code>baz</code> is <code>null</code> or <code>undefined</code>, we'll hit an error at the call site. <code>?.</code> only checks for whether the value on the <em>left</em> of it is <code>null</code> or <code>undefined</code> - not any of the subsequent properties.<p>You might find yourself using <code>?.</code> to replace a lot of code that performs repetitive nullish checks using the <code>&#x26;&#x26;</code> operator.<pre class="language-ts"><code class="language-ts"><span class="token comment">// Before</span>
<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>foo <span class="token operator">&#x26;&#x26;</span> foo<span class="token punctuation">.</span><span class="token property-access">bar</span> <span class="token operator">&#x26;&#x26;</span> foo<span class="token punctuation">.</span><span class="token property-access">bar</span><span class="token punctuation">.</span><span class="token property-access">baz</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// After-ish</span>
<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>foo<span class="token operator">?.</span>bar<span class="token operator">?.</span>baz<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>Keep in mind that <code>?.</code> acts differently than those <code>&#x26;&#x26;</code> operations since <code>&#x26;&#x26;</code> will act specially on "falsy" values (e.g. the empty string, <code>0</code>, <code>NaN</code>, and, well, <code>false</code>), but this is an intentional feature of the construct. It doesn't short-circuit on valid data like <code>0</code> or empty strings.<p>Optional chaining also includes two other operations. First there's the <em>optional element access</em> which acts similarly to optional property accesses, but allows us to access non-identifier properties (e.g. arbitrary strings, numbers, and symbols):<pre class="language-ts"><code class="language-ts"><span class="token doc-comment comment">/**
 * Get the first element of the array if we have an array.
 * Otherwise return undefined.
 */</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">tryGetFirstElement</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>arr<span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> arr<span class="token operator">?.</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// equivalent to</span>
  <span class="token comment">//   return (arr === null || arr === undefined) ?</span>
  <span class="token comment">//       undefined :</span>
  <span class="token comment">//       arr[0];</span>
<span class="token punctuation">}</span></code></pre><p>There's also <em>optional call</em>, which allows us to conditionally call expressions if they're not <code>null</code> or <code>undefined</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">makeRequest</span><span class="token punctuation">(</span>url<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> log<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span>msg<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  log<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Request started at </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Date</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">toISOString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// roughly equivalent to</span>
  <span class="token comment">//   if (log != null) {</span>
  <span class="token comment">//       log(`Request started at ${new Date().toISOString()}`);</span>
  <span class="token comment">//   }</span>

  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword control-flow">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  log<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Request finished at </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Date</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">toISOString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>The "short-circuiting" behavior that optional chains have is limited property accesses, calls, element accesses - it doesn't expand any further out from these expressions. In other words,<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> result <span class="token operator">=</span> foo<span class="token operator">?.</span>bar <span class="token operator">/</span> <span class="token function">someComputation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>doesn't stop the division or <code>someComputation()</code> call from occurring. It's equivalent to<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> temp <span class="token operator">=</span> foo <span class="token operator">===</span> <span class="token keyword null nil">null</span> <span class="token operator">||</span> foo <span class="token operator">===</span> <span class="token keyword nil">undefined</span> <span class="token operator">?</span> <span class="token keyword nil">undefined</span> <span class="token operator">:</span> foo<span class="token punctuation">.</span><span class="token property-access">bar</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> result <span class="token operator">=</span> temp <span class="token operator">/</span> <span class="token function">someComputation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>That might result in dividing <code>undefined</code>, which is why in <a href="/tsconfig#strictNullChecks"><code>strictNullChecks</code></a>, the following is an error.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">barPercentage</span><span class="token punctuation">(</span>foo<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">{</span> bar<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> foo<span class="token operator">?.</span>bar <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token comment">//     ~~~~~~~~</span>
  <span class="token comment">// Error: Object is possibly undefined.</span>
<span class="token punctuation">}</span></code></pre><p>More more details, you can <a href="https://github.com/tc39/proposal-optional-chaining/">read up on the proposal</a> and <a href="https://github.com/microsoft/TypeScript/pull/33294">view the original pull request</a>.</section><section id="nullish-coalescing"class="level2"><h2>Nullish Coalescing</h2><p><a href="/play/#example/nullish-coalescing">Playground</a><p>The <em>nullish coalescing operator</em> is another upcoming ECMAScript feature that goes hand-in-hand with optional chaining, and which our team has been involved with championing in TC39.<p>You can think of this feature - the <code>??</code> operator - as a way to "fall back" to a default value when dealing with <code>null</code> or <code>undefined</code>. When we write code like<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> x <span class="token operator">=</span> foo <span class="token operator">??</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>this is a new way to say that the value <code>foo</code> will be used when it's "present"; but when it's <code>null</code> or <code>undefined</code>, calculate <code>bar()</code> in its place.<p>Again, the above code is equivalent to the following.<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> x <span class="token operator">=</span> foo <span class="token operator">!==</span> <span class="token keyword null nil">null</span> <span class="token operator">&#x26;&#x26;</span> foo <span class="token operator">!==</span> <span class="token keyword nil">undefined</span> <span class="token operator">?</span> foo <span class="token operator">:</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The <code>??</code> operator can replace uses of <code>||</code> when trying to use a default value. For example, the following code snippet tries to fetch the volume that was last saved in <a href="https://developer.mozilla.org/docs/Web/API/Window/localStorage"><code>localStorage</code></a> (if it ever was); however, it has a bug because it uses <code>||</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">initializeAudio</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> volume <span class="token operator">=</span> <span class="token dom variable">localStorage</span><span class="token punctuation">.</span><span class="token property-access">volume</span> <span class="token operator">||</span> <span class="token number">0.5</span><span class="token punctuation">;</span>

  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>When <code>localStorage.volume</code> is set to <code>0</code>, the page will set the volume to <code>0.5</code> which is unintended. <code>??</code> avoids some unintended behavior from <code>0</code>, <code>NaN</code> and <code>""</code> being treated as falsy values.<p>We owe a large thanks to community members <a href="https://github.com/Kingwl">Wenlu Wang</a> and <a href="https://github.com/dragomirtitian">Titian Cernicova Dragomir</a> for implementing this feature! For more details, <a href="https://github.com/microsoft/TypeScript/pull/32883">check out their pull request</a> and <a href="https://github.com/tc39/proposal-nullish-coalescing/">the nullish coalescing proposal repository</a>.</section><section id="assertion-functions"class="level2"><h2>Assertion Functions</h2><p><a href="/play/#example/assertion-functions">Playground</a><p>There's a specific set of functions that <code>throw</code> an error if something unexpected happened. They're called "assertion" functions. As an example, Node.js has a dedicated function for this called <code>assert</code>.<pre class="language-js"><code class="language-js"><span class="token function">assert</span><span class="token punctuation">(</span>someValue <span class="token operator">===</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>In this example if <code>someValue</code> isn't equal to <code>42</code>, then <code>assert</code> will throw an <code>AssertionError</code>.<p>Assertions in JavaScript are often used to guard against improper types being passed in. For example,<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">"number"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> y <span class="token operator">===</span> <span class="token string">"number"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Unfortunately in TypeScript these checks could never be properly encoded. For loosely-typed code this meant TypeScript was checking less, and for slightly conservative code it often forced users to use type assertions.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">yell</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> str <span class="token operator">===</span> <span class="token string">"string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> str<span class="token punctuation">.</span><span class="token method function property-access">toUppercase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Oops! We misspelled 'toUpperCase'.</span>
  <span class="token comment">// Would be great if TypeScript still caught this!</span>
<span class="token punctuation">}</span></code></pre><p>The alternative was to instead rewrite the code so that the language could analyze it, but this isn't convenient.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">yell</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> str <span class="token operator">!==</span> <span class="token string">"string"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">throw</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">TypeError</span></span><span class="token punctuation">(</span><span class="token string">"str should have been a string."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// Error caught!</span>
  <span class="token keyword control-flow">return</span> str<span class="token punctuation">.</span><span class="token method function property-access">toUppercase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Ultimately the goal of TypeScript is to type existing JavaScript constructs in the least disruptive way. For that reason, TypeScript 3.7 introduces a new concept called "assertion signatures" which model these assertion functions.<p>The first type of assertion signature models the way that Node's <code>assert</code> function works. It ensures that whatever condition is being checked must be true for the remainder of the containing scope.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">assert</span><span class="token punctuation">(</span>condition<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> msg<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">asserts</span> condition <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">throw</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">AssertionError</span></span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p><code>asserts condition</code> says that whatever gets passed into the <code>condition</code> parameter must be true if the <code>assert</code> returns (because otherwise it would throw an error). That means that for the rest of the scope, that condition must be truthy. As an example, using this assertion function means we <em>do</em> catch our original <code>yell</code> example.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">yell</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> str <span class="token operator">===</span> <span class="token string">"string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> str<span class="token punctuation">.</span><span class="token method function property-access">toUppercase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//         ~~~~~~~~~~~</span>
  <span class="token comment">// error: Property 'toUppercase' does not exist on type 'string'.</span>
  <span class="token comment">//        Did you mean 'toUpperCase'?</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">assert</span><span class="token punctuation">(</span>condition<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> msg<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">asserts</span> condition <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">throw</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">AssertionError</span></span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>The other type of assertion signature doesn't check for a condition, but instead tells TypeScript that a specific variable or property has a different type.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">assertIsString</span><span class="token punctuation">(</span>val<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">asserts</span> val <span class="token keyword">is</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> val <span class="token operator">!==</span> <span class="token string">"string"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">throw</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">AssertionError</span></span><span class="token punctuation">(</span><span class="token string">"Not a string!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Here <code>asserts val is string</code> ensures that after any call to <code>assertIsString</code>, any variable passed in will be known to be a <code>string</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">yell</span><span class="token punctuation">(</span>str<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">assertIsString</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Now TypeScript knows that 'str' is a 'string'.</span>

  <span class="token keyword control-flow">return</span> str<span class="token punctuation">.</span><span class="token method function property-access">toUppercase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//         ~~~~~~~~~~~</span>
  <span class="token comment">// error: Property 'toUppercase' does not exist on type 'string'.</span>
  <span class="token comment">//        Did you mean 'toUpperCase'?</span>
<span class="token punctuation">}</span></code></pre><p>These assertion signatures are very similar to writing type predicate signatures:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">isString</span><span class="token punctuation">(</span>val<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> val <span class="token keyword">is</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">"string"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">yell</span><span class="token punctuation">(</span>str<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> str<span class="token punctuation">.</span><span class="token method function property-access">toUppercase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">throw</span> <span class="token string">"Oops!"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>And just like type predicate signatures, these assertion signatures are incredibly expressive. We can express some fairly sophisticated ideas with these.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">assertIsDefined</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>val<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">asserts</span> val <span class="token keyword">is</span> <span class="token maybe-class-name">NonNullable</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> <span class="token keyword nil">undefined</span> <span class="token operator">||</span> val <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">throw</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">AssertionError</span></span><span class="token punctuation">(</span>
      <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Expected 'val' to be defined, but received </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>val<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>To read up more about assertion signatures, <a href="https://github.com/microsoft/TypeScript/pull/32695">check out the original pull request</a>.</section><section id="better-support-for-never-returning-functions"class="level2"><h2>Better Support for <code>never</code>-Returning Functions</h2><p>As part of the work for assertion signatures, TypeScript needed to encode more about where and which functions were being called. This gave us the opportunity to expand support for another class of functions: functions that return <code>never</code>.<p>The intent of any function that returns <code>never</code> is that it never returns. It indicates that an exception was thrown, a halting error condition occurred, or that the program exited. For example, <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874"><code>process.exit(...)</code> in <code>@types/node</code></a> is specified to return <code>never</code>.<p>In order to ensure that a function never potentially returned <code>undefined</code> or effectively returned from all code paths, TypeScript needed some syntactic signal - either a <code>return</code> or <code>throw</code> at the end of a function. So users found themselves <code>return</code>-ing their failure functions.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">dispatch</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">SomeType</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">"string"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token function">doThingWithString</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">"number"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token function">doThingWithNumber</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> process<span class="token punctuation">.</span><span class="token method function property-access">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Now when these <code>never</code>-returning functions are called, TypeScript recognizes that they affect the control flow graph and accounts for them.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">dispatch</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">SomeType</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">"string"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token function">doThingWithString</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">"number"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token function">doThingWithNumber</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  process<span class="token punctuation">.</span><span class="token method function property-access">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>As with assertion functions, you can <a href="https://github.com/microsoft/TypeScript/pull/32695">read up more at the same pull request</a>.</section><section id="more-recursive-type-aliases"class="level2"><h2>(More) Recursive Type Aliases</h2><p><a href="/play/#example/recursive-type-references">Playground</a><p>Type aliases have always had a limitation in how they could be "recursively" referenced. The reason is that any use of a type alias needs to be able to substitute itself with whatever it aliases. In some cases, that's not possible, so the compiler rejects certain recursive aliases like the following:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Foo</span><span class="token punctuation">;</span></code></pre><p>This is a reasonable restriction because any use of <code>Foo</code> would need to be replaced with <code>Foo</code> which would need to be replaced with <code>Foo</code> which would need to be replaced with <code>Foo</code> which... well, hopefully you get the idea! In the end, there isn't a type that makes sense in place of <code>Foo</code>.<p>This is fairly <a href="https://wikipedia.org/w/index.php?title=Recursive_data_type&#x26;oldid=913091335#in_type_synonyms">consistent with how other languages treat type aliases</a>, but it does give rise to some slightly surprising scenarios for how users leverage the feature. For example, in TypeScript 3.6 and prior, the following causes an error.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">ValueOrArray</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token known-class-name class-name">Array</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">ValueOrArray</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">>></span><span class="token punctuation">;</span>
<span class="token comment">//   ~~~~~~~~~~~~</span>
<span class="token comment">// error: Type alias 'ValueOrArray' circularly references itself.</span></code></pre><p>This is strange because there is technically nothing wrong with any use users could always write what was effectively the same code by introducing an interface.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">ValueOrArray</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token maybe-class-name">ArrayOfValueOrArray</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">ArrayOfValueOrArray</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token known-class-name class-name">Array</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">ValueOrArray</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">>></span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>Because interfaces (and other object types) introduce a level of indirection and their full structure doesn't need to be eagerly built out, TypeScript has no problem working with this structure.<p>But workaround of introducing the interface wasn't intuitive for users. And in principle there really wasn't anything wrong with the original version of <code>ValueOrArray</code> that used <code>Array</code> directly. If the compiler was a little bit "lazier" and only calculated the type arguments to <code>Array</code> when necessary, then TypeScript could express these correctly.<p>That's exactly what TypeScript 3.7 introduces. At the "top level" of a type alias, TypeScript will defer resolving type arguments to permit these patterns.<p>This means that code like the following that was trying to represent JSON...<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Json</span></span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span> <span class="token operator">|</span> <span class="token maybe-class-name">JsonObject</span> <span class="token operator">|</span> <span class="token maybe-class-name">JsonArray</span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">JsonObject</span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>property<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token maybe-class-name">Json</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">JsonArray</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token known-class-name class-name">Array</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Json</span><span class="token operator">></span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>can finally be rewritten without helper interfaces.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Json</span></span> <span class="token operator">=</span>
  <span class="token operator">|</span> <span class="token builtin">string</span>
  <span class="token operator">|</span> <span class="token builtin">number</span>
  <span class="token operator">|</span> <span class="token builtin">boolean</span>
  <span class="token operator">|</span> <span class="token keyword null nil">null</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>property<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token maybe-class-name">Json</span> <span class="token punctuation">}</span>
  <span class="token operator">|</span> <span class="token maybe-class-name">Json</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>This new relaxation also lets us recursively reference type aliases in tuples as well. The following code which used to error is now valid TypeScript code.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">VirtualNode</span></span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token spread operator">...</span><span class="token maybe-class-name">VirtualNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> myNode<span class="token operator">:</span> <span class="token maybe-class-name">VirtualNode</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">"div"</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">"parent"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">"first-child"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"I'm the first child"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">"second-child"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"I'm the second child"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>For more information, you can <a href="https://github.com/microsoft/TypeScript/pull/33050">read up on the original pull request</a>.</section><section id="--declaration-and---allowjs"class="level2"><h2><code>--declaration</code> and <code>--allowJs</code></h2><p>The <a href="/tsconfig#declaration"><code>declaration</code></a> flag in TypeScript allows us to generate <code>.d.ts</code> files (declaration files) from TypeScript source files (i.e. <code>.ts</code> and <code>.tsx</code> files). These <code>.d.ts</code> files are important for a couple of reasons.<p>First of all, they're important because they allow TypeScript to type-check against other projects without re-checking the original source code. They're also important because they allow TypeScript to interoperate with existing JavaScript libraries that weren't built with TypeScript in mind. Finally, a benefit that is often underappreciated: both TypeScript <em>and</em> JavaScript users can benefit from these files when using editors powered by TypeScript to get things like better auto-completion.<p>Unfortunately, <a href="/tsconfig#declaration"><code>declaration</code></a> didn't work with the <a href="/tsconfig#allowJs"><code>allowJs</code></a> flag which allows mixing TypeScript and JavaScript input files. This was a frustrating limitation because it meant users couldn't use the <a href="/tsconfig#declaration"><code>declaration</code></a> flag when migrating codebases, even if they were JSDoc-annotated. TypeScript 3.7 changes that, and allows the two options to be used together!<p>The most impactful outcome of this feature might a bit subtle: with TypeScript 3.7, users can write libraries in JSDoc annotated JavaScript and support TypeScript users.<p>The way that this works is that when using <a href="/tsconfig#allowJs"><code>allowJs</code></a>, TypeScript has some best-effort analyses to understand common JavaScript patterns; however, the way that some patterns are expressed in JavaScript don't necessarily look like their equivalents in TypeScript. When <a href="/tsconfig#declaration"><code>declaration</code></a> emit is turned on, TypeScript figures out the best way to transform JSDoc comments and CommonJS exports into valid type declarations and the like in the output <code>.d.ts</code> files.<p>As an example, the following code snippet<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> assert <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"assert"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span><span class="token property-access">exports</span><span class="token punctuation">.</span><span class="token property-access">blurImage</span> <span class="token operator">=</span> blurImage<span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * Produces a blurred image from an input buffer.
 *
 * <span class="token keyword">@param</span> <span class="token parameter">input</span> <span class="token punctuation">{</span>Uint8Array<span class="token punctuation">}</span>
 * <span class="token keyword">@param</span> <span class="token parameter">width</span> <span class="token punctuation">{</span>number<span class="token punctuation">}</span>
 * <span class="token keyword">@param</span> <span class="token parameter">height</span> <span class="token punctuation">{</span>number<span class="token punctuation">}</span>
 */</span>
<span class="token keyword">function</span> <span class="token function">blurImage</span><span class="token punctuation">(</span><span class="token parameter">input<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> numPixels <span class="token operator">=</span> width <span class="token operator">*</span> height <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span>
  <span class="token function">assert</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">===</span> numPixels<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span>numPixels<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// TODO</span>

  <span class="token keyword control-flow">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Will produce a <code>.d.ts</code> file like<pre class="language-ts"><code class="language-ts"><span class="token doc-comment comment">/**
 * Produces a blurred image from an input buffer.
 *
 * <span class="token keyword">@param</span> <span class="token parameter">input</span> <span class="token punctuation">{</span>Uint8Array<span class="token punctuation">}</span>
 * <span class="token keyword">@param</span> <span class="token parameter">width</span> <span class="token punctuation">{</span>number<span class="token punctuation">}</span>
 * <span class="token keyword">@param</span> <span class="token parameter">height</span> <span class="token punctuation">{</span>number<span class="token punctuation">}</span>
 */</span>
<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">blurImage</span><span class="token punctuation">(</span>
  input<span class="token operator">:</span> <span class="token known-class-name class-name">Uint8Array</span><span class="token punctuation">,</span>
  width<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
  height<span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">Uint8Array</span><span class="token punctuation">;</span></code></pre><p>This can go beyond basic functions with <code>@param</code> tags too, where the following example:<pre class="language-js"><code class="language-js"><span class="token doc-comment comment">/**
 * <span class="token keyword">@callback</span> Job
 * <span class="token keyword">@returns</span> <span class="token class-name"><span class="token punctuation">{</span><span class="token keyword">void</span><span class="token punctuation">}</span></span>
 */</span>

<span class="token doc-comment comment">/** Queues work */</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">maxDepth <span class="token operator">=</span> <span class="token number">10</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">started</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">depthLimit</span> <span class="token operator">=</span> maxDepth<span class="token punctuation">;</span>
    <span class="token doc-comment comment">/**
     * NOTE: queued jobs may add more items to queue
     * <span class="token keyword">@type</span> <span class="token class-name"><span class="token punctuation">{</span>Job<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span>
     */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">queue</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token doc-comment comment">/**
   * Adds a work item to the queue
   * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>Job<span class="token punctuation">}</span></span> <span class="token parameter">work</span>
   */</span>
  <span class="token function">push</span><span class="token punctuation">(</span><span class="token parameter">work</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">queue</span><span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">depthLimit</span><span class="token punctuation">)</span> <span class="token keyword control-flow">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Queue full!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">queue</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>work<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token doc-comment comment">/**
   * Starts the queue if it has not yet started
   */</span>
  <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">started</span><span class="token punctuation">)</span> <span class="token keyword control-flow">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">started</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">queue</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token doc-comment comment">/** <span class="token keyword">@type</span> <span class="token class-name"><span class="token punctuation">{</span>Job<span class="token punctuation">}</span></span> */</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">queue</span><span class="token punctuation">.</span><span class="token method function property-access">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>will be transformed into the following <code>.d.ts</code> file:<pre class="language-ts"><code class="language-ts"><span class="token doc-comment comment">/**
 * <span class="token keyword">@callback</span> Job
 * <span class="token keyword">@returns</span> <span class="token punctuation">{</span>void<span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/** Queues work */</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Worker</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>maxDepth<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  started<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  depthLimit<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token doc-comment comment">/**
   * NOTE: queued jobs may add more items to queue
   * <span class="token keyword">@type</span> <span class="token punctuation">{</span>Job[]<span class="token punctuation">}</span>
   */</span>
  queue<span class="token operator">:</span> <span class="token maybe-class-name">Job</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token doc-comment comment">/**
   * Adds a work item to the queue
   * <span class="token keyword">@param</span> <span class="token punctuation">{</span>Job<span class="token punctuation">}</span> work
   */</span>
  <span class="token function">push</span><span class="token punctuation">(</span>work<span class="token operator">:</span> <span class="token maybe-class-name">Job</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token doc-comment comment">/**
   * Starts the queue if it has not yet started
   */</span>
  <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword module">export</span> <span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Job</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span></code></pre><p>Note that when using these flags together, TypeScript doesn't necessarily have to downlevel <code>.js</code> files. If you simply want TypeScript to create <code>.d.ts</code> files, you can use the <a href="/tsconfig#emitDeclarationOnly"><code>emitDeclarationOnly</code></a> compiler option.<p>For more details, you can <a href="https://github.com/microsoft/TypeScript/pull/32372">check out the original pull request</a>.</section><section id="the-usedefineforclassfields-flag-and-the-declare-property-modifier"class="level2"><h2>The <code>useDefineForClassFields</code> Flag and The <code>declare</code> Property Modifier</h2><p>Back when TypeScript implemented public class fields, we assumed to the best of our abilities that the following code<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  foo <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  bar<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>would be equivalent to a similar assignment within a constructor body.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">foo</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Unfortunately, while this seemed to be the direction that the proposal moved towards in its earlier days, there is an extremely strong chance that public class fields will be standardized differently. Instead, the original code sample might need to de-sugar to something closer to the following:<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      value<span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      value<span class="token operator">:</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>While TypeScript 3.7 isn't changing any existing emit by default, we've been rolling out changes incrementally to help users mitigate potential future breakage. We've provided a new flag called <a href="/tsconfig#useDefineForClassFields"><code>useDefineForClassFields</code></a> to enable this emit mode with some new checking logic.<p>The two biggest changes are the following:<ul><li>Declarations are initialized with <code>Object.defineProperty</code>.<li>Declarations are <em>always</em> initialized to <code>undefined</code>, even if they have no initializer.</ul><p>This can cause quite a bit of fallout for existing code that use inheritance. First of all, <code>set</code> accessors from base classes won't get triggered - they'll be completely overwritten.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Base</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">set</span> <span class="token function">data</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"data changed to "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Derived</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">Base</span></span> <span class="token punctuation">{</span>
  <span class="token comment">// No longer triggers a 'console.log'</span>
  <span class="token comment">// when using 'useDefineForClassFields'.</span>
  data <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Secondly, using class fields to specialize properties from base classes also won't work.<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Animal</span></span> <span class="token punctuation">{</span>
  animalStuff<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Dog</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">Animal</span></span> <span class="token punctuation">{</span>
  dogStuff<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">AnimalHouse</span></span> <span class="token punctuation">{</span>
  resident<span class="token operator">:</span> <span class="token maybe-class-name">Animal</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>animal<span class="token operator">:</span> <span class="token maybe-class-name">Animal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">resident</span> <span class="token operator">=</span> animal<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">DogHouse</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">AnimalHouse</span></span> <span class="token punctuation">{</span>
  <span class="token comment">// Initializes 'resident' to 'undefined'</span>
  <span class="token comment">// after the call to 'super()' when</span>
  <span class="token comment">// using 'useDefineForClassFields'!</span>
  resident<span class="token operator">:</span> <span class="token maybe-class-name">Dog</span><span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span>dog<span class="token operator">:</span> <span class="token maybe-class-name">Dog</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>What these two boil down to is that mixing properties with accessors is going to cause issues, and so will re-declaring properties with no initializers.<p>To detect the issue around accessors, TypeScript 3.7 will now emit <code>get</code>/<code>set</code> accessors in <code>.d.ts</code> files so that in TypeScript can check for overridden accessors.<p>Code that's impacted by the class fields change can get around the issue by converting field initializers to assignments in constructor bodies.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Base</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">set</span> <span class="token function">data</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"data changed to "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Derived</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">Base</span></span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">data</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>To help mitigate the second issue, you can either add an explicit initializer or add a <code>declare</code> modifier to indicate that a property should have no emit.<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Animal</span></span> <span class="token punctuation">{</span>
  animalStuff<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Dog</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">Animal</span></span> <span class="token punctuation">{</span>
  dogStuff<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">AnimalHouse</span></span> <span class="token punctuation">{</span>
  resident<span class="token operator">:</span> <span class="token maybe-class-name">Animal</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>animal<span class="token operator">:</span> <span class="token maybe-class-name">Animal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">resident</span> <span class="token operator">=</span> animal<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">DogHouse</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">AnimalHouse</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">declare</span> resident<span class="token operator">:</span> <span class="token maybe-class-name">Dog</span><span class="token punctuation">;</span>
  <span class="token comment">//  ^^^^^^^</span>
  <span class="token comment">// 'resident' now has a 'declare' modifier,</span>
  <span class="token comment">// and won't produce any output code.</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span>dog<span class="token operator">:</span> <span class="token maybe-class-name">Dog</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Currently <a href="/tsconfig#useDefineForClassFields"><code>useDefineForClassFields</code></a> is only available when targeting ES5 and upwards, since <code>Object.defineProperty</code> doesn't exist in ES3. To achieve similar checking for issues, you can create a separate project that targets ES5 and uses <a href="/tsconfig#noEmit"><code>noEmit</code></a> to avoid a full build.<p>For more information, you can <a href="https://github.com/microsoft/TypeScript/pull/33509">take a look at the original pull request for these changes</a>.<p>We strongly encourage users to try the <a href="/tsconfig#useDefineForClassFields"><code>useDefineForClassFields</code></a> flag and report back on our issue tracker or in the comments below. This includes feedback on difficulty of adopting the flag so we can understand how we can make migration easier.</section><section id="build-free-editing-with-project-references"class="level2"><h2>Build-Free Editing with Project References</h2><p>TypeScript's project references provide us with an easy way to break codebases up to give us faster compiles. Unfortunately, editing a project whose dependencies hadn't been built (or whose output was out of date) meant that the editing experience wouldn't work well.<p>In TypeScript 3.7, when opening a project with dependencies, TypeScript will automatically use the source <code>.ts</code>/<code>.tsx</code> files instead. This means projects using project references will now see an improved editing experience where semantic operations are up-to-date and "just work". You can disable this behavior with the compiler option <a href="/tsconfig#disableSourceOfProjectReferenceRedirect"><code>disableSourceOfProjectReferenceRedirect</code></a> which may be appropriate when working in very large projects where this change may impact editing performance.<p>You can <a href="https://github.com/microsoft/TypeScript/pull/32028">read up more about this change by reading up on its pull request</a>.</section><section id="uncalled-function-checks"class="level2"><h2>Uncalled Function Checks</h2><p>A common and dangerous error is to forget to invoke a function, especially if the function has zero arguments or is named in a way that implies it might be a property rather than a function.<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">User</span></span> <span class="token punctuation">{</span>
  <span class="token function">isAdministrator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  doNotDisturb<span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// later...</span>

<span class="token comment">// Broken code, do not use!</span>
<span class="token keyword">function</span> <span class="token function">doAdminThing</span><span class="token punctuation">(</span>user<span class="token operator">:</span> <span class="token maybe-class-name">User</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// oops!</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token property-access">isAdministrator</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">sudo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">editTheConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">throw</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">AccessDeniedError</span></span><span class="token punctuation">(</span><span class="token string">"User is not an admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Here, we forgot to call <code>isAdministrator</code>, and the code incorrectly allows non-adminstrator users to edit the configuration!<p>In TypeScript 3.7, this is identified as a likely error:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">doAdminThing</span><span class="token punctuation">(</span>user<span class="token operator">:</span> <span class="token maybe-class-name">User</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token property-access">isAdministrator</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//  ~~~~~~~~~~~~~~~~~~~~</span>
    <span class="token comment">// error! This condition will always return true since the function is always defined.</span>
    <span class="token comment">//        Did you mean to call it instead?</span></code></pre><p>This check is a breaking change, but for that reason the checks are very conservative. This error is only issued in <code>if</code> conditions, and it is not issued on optional properties, if <a href="/tsconfig#strictNullChecks"><code>strictNullChecks</code></a> is off, or if the function is later called within the body of the <code>if</code>:<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">User</span></span> <span class="token punctuation">{</span>
  <span class="token function">isAdministrator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  doNotDisturb<span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">issueNotification</span><span class="token punctuation">(</span>user<span class="token operator">:</span> <span class="token maybe-class-name">User</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token property-access">doNotDisturb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// OK, property is optional</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token property-access">notify</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// OK, called the function</span>
    user<span class="token punctuation">.</span><span class="token method function property-access">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>If you intended to test the function without calling it, you can correct the definition of it to include <code>undefined</code>/<code>null</code>, or use <code>!!</code> to write something like <code>if (!!user.isAdministrator)</code> to indicate that the coercion is intentional.<p>We owe a big thanks to GitHub user <a href="https://github.com/jwbay">@jwbay</a> who took the initiative to create a <a href="https://github.com/microsoft/TypeScript/pull/32802">proof-of-concept</a> and iterated to provide us with <a href="https://github.com/microsoft/TypeScript/pull/33178">the current version</a>.</section><section id="-ts-nocheck-in-typescript-files"class="level2"><h2><code>// @ts-nocheck</code> in TypeScript Files</h2><p>TypeScript 3.7 allows us to add <code>// @ts-nocheck</code> comments to the top of TypeScript files to disable semantic checks. Historically this comment was only respected in JavaScript source files in the presence of <a href="/tsconfig#checkJs"><code>checkJs</code></a>, but we've expanded support to TypeScript files to make migrations easier for all users.</section><section id="semicolon-formatter-option"class="level2"><h2>Semicolon Formatter Option</h2><p>TypeScript's built-in formatter now supports semicolon insertion and removal at locations where a trailing semicolon is optional due to JavaScript's automatic semicolon insertion (ASI) rules. The setting is available now in <a href="https://code.visualstudio.com/insiders/">Visual Studio Code Insiders</a>, and will be available in Visual Studio 16.4 Preview 2 in the Tools Options menu.</p><img width="833"alt="New semicolon formatter option in VS Code"src="https://user-images.githubusercontent.com/3277153/65913194-10066e80-e395-11e9-8a3a-4f7305c397d5.png"><p>Choosing a value of "insert" or "remove" also affects the format of auto-imports, extracted types, and other generated code provided by TypeScript services. Leaving the setting on its default value of "ignore" makes generated code match the semicolon preference detected in the current file.</section><section id="37-breaking-changes"class="level2"><h2>3.7 Breaking Changes</h2><section id="dom-changes"class="level3"><h3>DOM Changes</h3><p><a href="https://github.com/microsoft/TypeScript/pull/33627">Types in <code>lib.dom.d.ts</code> have been updated</a>. These changes are largely correctness changes related to nullability, but impact will ultimately depend on your codebase.</section><section id="class-field-mitigations"class="level3"><h3>Class Field Mitigations</h3><p><a href="#the-usedefineforclassfields-flag-and-the-declare-property-modifier">As mentioned above</a>, TypeScript 3.7 emits <code>get</code>/<code>set</code> accessors in <code>.d.ts</code> files which can cause breaking changes for consumers on older versions of TypeScript like 3.5 and prior. TypeScript 3.6 users will not be impacted, since that version was future-proofed for this feature.<p>While not a breakage per se, opting in to the <a href="/tsconfig#useDefineForClassFields"><code>useDefineForClassFields</code></a> flag can cause breakage when:<ul><li>overriding an accessor in a derived class with a property declaration<li>re-declaring a property declaration with no initializer</ul><p>To understand the full impact, read <a href="#the-usedefineforclassfields-flag-and-the-declare-property-modifier">the section above on the <code>useDefineForClassFields</code> flag</a>.</section><section id="function-truthy-checks"class="level3"><h3>Function Truthy Checks</h3><p>As mentioned above, TypeScript now errors when functions appear to be uncalled within <code>if</code> statement conditions. An error is issued when a function type is checked in <code>if</code> conditions unless any of the following apply:<ul><li>the checked value comes from an optional property<li><a href="/tsconfig#strictNullChecks"><code>strictNullChecks</code></a> is disabled<li>the function is later called within the body of the <code>if</code></ul></section><section id="local-and-imported-type-declarations-now-conflict"class="level3"><h3>Local and Imported Type Declarations Now Conflict</h3><p>Due to a bug, the following construct was previously allowed in TypeScript:<pre class="language-ts"><code class="language-ts"><span class="token comment">// ./someOtherModule.ts</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">SomeType</span></span> <span class="token punctuation">{</span>
  y<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ./myModule.ts</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">SomeType</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"./someOtherModule"</span><span class="token punctuation">;</span>
<span class="token keyword module">export</span> <span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">SomeType</span></span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token maybe-class-name">SomeType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span><span class="token property-access">x</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error! 'x' doesn't exist on 'SomeType'</span>
<span class="token punctuation">}</span></code></pre><p>Here, <code>SomeType</code> appears to originate in both the <code>import</code> declaration and the local <code>interface</code> declaration. Perhaps surprisingly, inside the module, <code>SomeType</code> refers exclusively to the <code>import</code>ed definition, and the local declaration <code>SomeType</code> is only usable when imported from another file. This is very confusing and our review of the very small number of cases of code like this in the wild showed that developers usually thought something different was happening.<p>In TypeScript 3.7, <a href="https://github.com/microsoft/TypeScript/pull/31231">this is now correctly identified as a duplicate identifier error</a>. The correct fix depends on the original intent of the author and should be addressed on a case-by-case basis. Usually, the naming conflict is unintentional and the best fix is to rename the imported type. If the intent was to augment the imported type, a proper module augmentation should be written instead.</section><section id="37-api-changes"class="level3"><h3>3.7 API Changes</h3><p>To enable the recursive type alias patterns described above, the <code>typeArguments</code> property has been removed from the <code>TypeReference</code> interface. Users should instead use the <code>getTypeArguments</code> function on <code>TypeChecker</code> instances. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>