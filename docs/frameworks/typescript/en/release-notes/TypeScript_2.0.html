<!doctype html><html lang="en"><meta charset="utf-8"><title>TypeScript 2.0</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/release-notes/typescript-2-0.html"><meta name="oneline"content="TypeScript 2.0 Release Notes"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="null--and-undefined-aware-types"class="level2"><h2>Null- and undefined-aware types</h2><p>TypeScript has two special types, Null and Undefined, that have the values <code>null</code> and <code>undefined</code> respectively. Previously it was not possible to explicitly name these types, but <code>null</code> and <code>undefined</code> may now be used as type names regardless of type checking mode.<p>The type checker previously considered <code>null</code> and <code>undefined</code> assignable to anything. Effectively, <code>null</code> and <code>undefined</code> were valid values of <em>every</em> type and it wasn't possible to specifically exclude them (and therefore not possible to detect erroneous use of them).</section><section id="--strictnullchecks"class="level2"><h2><code>--strictNullChecks</code></h2><p><a href="/tsconfig#strictNullChecks"><code>strictNullChecks</code></a> switches to a new strict null checking mode.<p>In strict null checking mode, the <code>null</code> and <code>undefined</code> values are <em>not</em> in the domain of every type and are only assignable to themselves and <code>any</code> (the one exception being that <code>undefined</code> is also assignable to <code>void</code>). So, whereas <code>T</code> and <code>T | undefined</code> are considered synonymous in regular type checking mode (because <code>undefined</code> is considered a subtype of any <code>T</code>), they are different types in strict type checking mode, and only <code>T | undefined</code> permits <code>undefined</code> values. The same is true for the relationship of <code>T</code> to <code>T | null</code>.<section id="example"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token comment">// Compiled with --strictNullChecks</span>
<span class="token keyword">let</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> z<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span>
x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Ok</span>
y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Ok</span>
z <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Ok</span>
x <span class="token operator">=</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
y <span class="token operator">=</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span> <span class="token comment">// Ok</span>
z <span class="token operator">=</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span> <span class="token comment">// Ok</span>
x <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
y <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
z <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span> <span class="token comment">// Ok</span>
x <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">// Error</span>
x <span class="token operator">=</span> z<span class="token punctuation">;</span> <span class="token comment">// Error</span>
y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// Ok</span>
y <span class="token operator">=</span> z<span class="token punctuation">;</span> <span class="token comment">// Error</span>
z <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// Ok</span>
z <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">// Ok</span></code></pre></section></section><section id="assigned-before-use-checking"class="level2"><h2>Assigned-before-use checking</h2><p>In strict null checking mode the compiler requires every reference to a local variable of a type that doesn't include <code>undefined</code> to be preceded by an assignment to that variable in every possible preceding code path.<section id="example-1"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token comment">// Compiled with --strictNullChecks</span>
<span class="token keyword">let</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> z<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span>
x<span class="token punctuation">;</span> <span class="token comment">// Error, reference not preceded by assignment</span>
y<span class="token punctuation">;</span> <span class="token comment">// Error, reference not preceded by assignment</span>
z<span class="token punctuation">;</span> <span class="token comment">// Ok</span>
x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
y <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
x<span class="token punctuation">;</span> <span class="token comment">// Ok</span>
y<span class="token punctuation">;</span> <span class="token comment">// Ok</span></code></pre><p>The compiler checks that variables are definitely assigned by performing <em>control flow based type analysis</em>. See later for further details on this topic.</section></section><section id="optional-parameters-and-properties"class="level2"><h2>Optional parameters and properties</h2><p>Optional parameters and properties automatically have <code>undefined</code> added to their types, even when their type annotations don't specifically include <code>undefined</code>. For example, the following two types are identical:<pre class="language-ts"><code class="language-ts"><span class="token comment">// Compiled with --strictNullChecks</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// x has type number | undefined</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// x has type number | undefined</span></code></pre></section><section id="non-null-and-non-undefined-type-guards"class="level2"><h2>Non-null and non-undefined type guards</h2><p>A property access or a function call produces a compile-time error if the object or function is of a type that includes <code>null</code> or <code>undefined</code>. However, type guards are extended to support non-null and non-undefined checks.<section id="example-2"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token comment">// Compiled with --strictNullChecks</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> x<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token punctuation">;</span>
<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Ok, type of x is number here</span>
<span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
  <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error, type of x is number? here</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> x <span class="token operator">!=</span> <span class="token keyword null nil">null</span> <span class="token operator">?</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">;</span> <span class="token comment">// Type of a is string</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> x <span class="token operator">&#x26;&#x26;</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Type of b is string | 0 | null | undefined</span></code></pre><p>Non-null and non-undefined type guards may use the <code>==</code>, <code>!=</code>, <code>===</code>, or <code>!==</code> operator to compare to <code>null</code> or <code>undefined</code>, as in <code>x != null</code> or <code>x === undefined</code>. The effects on subject variable types accurately reflect JavaScript semantics (e.g. double-equals operators check for both values no matter which one is specified whereas triple-equals only checks for the specified value).</section></section><section id="dotted-names-in-type-guards"class="level2"><h2>Dotted names in type guards</h2><p>Type guards previously only supported checking local variables and parameters. Type guards now support checking "dotted names" consisting of a variable or parameter name followed one or more property accesses.<section id="example-3"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Options</span></span> <span class="token punctuation">{</span>
  <span class="token dom variable">location</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    x<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    y<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>options<span class="token operator">?</span><span class="token operator">:</span> <span class="token maybe-class-name">Options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>options <span class="token operator">&#x26;&#x26;</span> options<span class="token punctuation">.</span><span class="token property-access">location</span> <span class="token operator">&#x26;&#x26;</span> options<span class="token punctuation">.</span><span class="token property-access">location</span><span class="token punctuation">.</span><span class="token property-access">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> x <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token property-access">location</span><span class="token punctuation">.</span><span class="token property-access">x</span><span class="token punctuation">;</span> <span class="token comment">// Type of x is number</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Type guards for dotted names also work with user defined type guard functions and the <code>typeof</code> and <code>instanceof</code> operators and do not depend on the <a href="/tsconfig#strictNullChecks"><code>strictNullChecks</code></a> compiler option.<p>A type guard for a dotted name has no effect following an assignment to any part of the dotted name. For example, a type guard for <code>x.y.z</code> will have no effect following an assignment to <code>x</code>, <code>x.y</code>, or <code>x.y.z</code>.</section></section><section id="expression-operators"class="level2"><h2>Expression operators</h2><p>Expression operators permit operand types to include <code>null</code> and/or <code>undefined</code> but always produce values of non-null and non-undefined types.<pre class="language-ts"><code class="language-ts"><span class="token comment">// Compiled with --strictNullChecks</span>
<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment">// Produces value of type number</span>
<span class="token punctuation">}</span></code></pre><p>The <code>&#x26;&#x26;</code> operator adds <code>null</code> and/or <code>undefined</code> to the type of the right operand depending on which are present in the type of the left operand, and the <code>||</code> operator removes both <code>null</code> and <code>undefined</code> from the type of the left operand in the resulting union type.<pre class="language-ts"><code class="language-ts"><span class="token comment">// Compiled with --strictNullChecks</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Entity</span></span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> x<span class="token operator">:</span> <span class="token maybe-class-name">Entity</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s <span class="token operator">=</span> x <span class="token operator">&#x26;&#x26;</span> x<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">;</span> <span class="token comment">// s is of type string | null</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> x <span class="token operator">||</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">"test"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// y is of type Entity</span></code></pre></section><section id="type-widening"class="level2"><h2>Type widening</h2><p>The <code>null</code> and <code>undefined</code> types are <em>not</em> widened to <code>any</code> in strict null checking mode.<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> z <span class="token operator">=</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span> <span class="token comment">// Type of z is null</span></code></pre><p>In regular type checking mode the inferred type of <code>z</code> is <code>any</code> because of widening, but in strict null checking mode the inferred type of <code>z</code> is <code>null</code> (and therefore, absent a type annotation, <code>null</code> is the only possible value for <code>z</code>).</section><section id="non-null-assertion-operator"class="level2"><h2>Non-null assertion operator</h2><p>A new <code>!</code> post-fix expression operator may be used to assert that its operand is non-null and non-undefined in contexts where the type checker is unable to conclude that fact. Specifically, the operation <code>x!</code> produces a value of the type of <code>x</code> with <code>null</code> and <code>undefined</code> excluded. Similar to type assertions of the forms <code>&#x3C;T>x</code> and <code>x as T</code>, the <code>!</code> non-null assertion operator is simply removed in the emitted JavaScript code.<pre class="language-ts"><code class="language-ts"><span class="token comment">// Compiled with --strictNullChecks</span>
<span class="token keyword">function</span> <span class="token function">validateEntity</span><span class="token punctuation">(</span>e<span class="token operator">?</span><span class="token operator">:</span> <span class="token maybe-class-name">Entity</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Throw exception if e is null or invalid entity</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">processEntity</span><span class="token punctuation">(</span>e<span class="token operator">?</span><span class="token operator">:</span> <span class="token maybe-class-name">Entity</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">validateEntity</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> s <span class="token operator">=</span> e<span class="token operator">!</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">;</span> <span class="token comment">// Assert that e is non-null and access name</span>
<span class="token punctuation">}</span></code></pre></section><section id="compatibility"class="level2"><h2>Compatibility</h2><p>The new features are designed such that they can be used in both strict null checking mode and regular type checking mode. In particular, the <code>null</code> and <code>undefined</code> types are automatically erased from union types in regular type checking mode (because they are subtypes of all other types), and the <code>!</code> non-null assertion expression operator is permitted but has no effect in regular type checking mode. Thus, declaration files that are updated to use null- and undefined-aware types can still be used in regular type checking mode for backwards compatibility.<p>In practical terms, strict null checking mode requires that all files in a compilation are null- and undefined-aware.</section><section id="control-flow-based-type-analysis"class="level2"><h2>Control flow based type analysis</h2><p>TypeScript 2.0 implements a control flow-based type analysis for local variables and parameters. Previously, the type analysis performed for type guards was limited to <code>if</code> statements and <code>?:</code> conditional expressions and didn't include effects of assignments and control flow constructs such as <code>return</code> and <code>break</code> statements. With TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the <em>narrowed type</em>) at any given location for a local variable or parameter that is declared to have a union type.<section id="example-4"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">"string"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">;</span> <span class="token comment">// type of x is string here</span>
    x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    x<span class="token punctuation">;</span> <span class="token comment">// type of x is number here</span>
  <span class="token punctuation">}</span>
  x<span class="token punctuation">;</span> <span class="token comment">// type of x is number | boolean here</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">"number"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  x<span class="token punctuation">;</span> <span class="token comment">// type of x is string here</span>
<span class="token punctuation">}</span></code></pre><p>Control flow based type analysis is particularly relevant in <a href="/tsconfig#strictNullChecks"><code>strictNullChecks</code></a> mode because nullable types are represented using union types:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  x<span class="token punctuation">;</span> <span class="token comment">// type of x is string in remainder of function</span>
<span class="token punctuation">}</span></code></pre><p>Furthermore, in <a href="/tsconfig#strictNullChecks"><code>strictNullChecks</code></a> mode, control flow based type analysis includes <em>definite assignment analysis</em> for local variables of types that don't permit the value <code>undefined</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">mumble</span><span class="token punctuation">(</span>check<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// Type doesn't permit undefined</span>
  x<span class="token punctuation">;</span> <span class="token comment">// Error, x is undefined</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>check<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    x<span class="token punctuation">;</span> <span class="token comment">// Ok</span>
  <span class="token punctuation">}</span>
  x<span class="token punctuation">;</span> <span class="token comment">// Error, x is possibly undefined</span>
  x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  x<span class="token punctuation">;</span> <span class="token comment">// Ok</span>
<span class="token punctuation">}</span></code></pre></section></section><section id="tagged-union-types"class="level2"><h2>Tagged union types</h2><p>TypeScript 2.0 implements support for tagged (or discriminated) union types. Specifically, the TS compiler now support type guards that narrow union types based on tests of a discriminant property and furthermore extend that capability to <code>switch</code> statements.<section id="example-5"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Square</span></span> <span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">"square"</span><span class="token punctuation">;</span>
  size<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Rectangle</span></span> <span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">"rectangle"</span><span class="token punctuation">;</span>
  width<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  height<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Circle</span></span> <span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">"circle"</span><span class="token punctuation">;</span>
  radius<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Shape</span></span> <span class="token operator">=</span> <span class="token maybe-class-name">Square</span> <span class="token operator">|</span> <span class="token maybe-class-name">Rectangle</span> <span class="token operator">|</span> <span class="token maybe-class-name">Circle</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token maybe-class-name">Shape</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// In the following switch statement, the type of s is narrowed in each case clause</span>
  <span class="token comment">// according to the value of the discriminant property, thus allowing the other properties</span>
  <span class="token comment">// of that variant to be accessed without a type assertion.</span>
  <span class="token keyword control-flow">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token property-access">kind</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">"square"</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> s<span class="token punctuation">.</span><span class="token property-access">size</span> <span class="token operator">*</span> s<span class="token punctuation">.</span><span class="token property-access">size</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">"rectangle"</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> s<span class="token punctuation">.</span><span class="token property-access">width</span> <span class="token operator">*</span> s<span class="token punctuation">.</span><span class="token property-access">height</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">"circle"</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> s<span class="token punctuation">.</span><span class="token property-access">radius</span> <span class="token operator">*</span> s<span class="token punctuation">.</span><span class="token property-access">radius</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">test1</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token maybe-class-name">Shape</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token property-access">kind</span> <span class="token operator">===</span> <span class="token string">"square"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    s<span class="token punctuation">;</span> <span class="token comment">// Square</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    s<span class="token punctuation">;</span> <span class="token comment">// Rectangle | Circle</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">test2</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token maybe-class-name">Shape</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token property-access">kind</span> <span class="token operator">===</span> <span class="token string">"square"</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token property-access">kind</span> <span class="token operator">===</span> <span class="token string">"rectangle"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  s<span class="token punctuation">;</span> <span class="token comment">// Circle</span>
<span class="token punctuation">}</span></code></pre><p>A <em>discriminant property type guard</em> is an expression of the form <code>x.p == v</code>, <code>x.p === v</code>, <code>x.p != v</code>, or <code>x.p !== v</code>, where <code>p</code> and <code>v</code> are a property and an expression of a string literal type or a union of string literal types. The discriminant property type guard narrows the type of <code>x</code> to those constituent types of <code>x</code> that have a discriminant property <code>p</code> with one of the possible values of <code>v</code>.<p>Note that we currently only support discriminant properties of string literal types. We intend to later add support for boolean and numeric literal types.</section></section><section id="the-never-type"class="level2"><h2>The <code>never</code> type</h2><p>TypeScript 2.0 introduces a new primitive type <code>never</code>. The <code>never</code> type represents the type of values that never occur. Specifically, <code>never</code> is the return type for functions that never return and <code>never</code> is the type of variables under type guards that are never true.<p>The <code>never</code> type has the following characteristics:<ul><li><code>never</code> is a subtype of and assignable to every type.<li>No type is a subtype of or assignable to <code>never</code> (except <code>never</code> itself).<li>In a function expression or arrow function with no return type annotation, if the function has no <code>return</code> statements, or only <code>return</code> statements with expressions of type <code>never</code>, and if the end point of the function is not reachable (as determined by control flow analysis), the inferred return type for the function is <code>never</code>.<li>In a function with an explicit <code>never</code> return type annotation, all <code>return</code> statements (if any) must have expressions of type <code>never</code> and the end point of the function must not be reachable.</ul><p>Because <code>never</code> is a subtype of every type, it is always omitted from union types and it is ignored in function return type inference as long as there are other types being returned.<p>Some examples of functions returning <code>never</code>:<pre class="language-ts"><code class="language-ts"><span class="token comment">// Function returning never must have unreachable end point</span>
<span class="token keyword">function</span> <span class="token function">error</span><span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">never</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">throw</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Error</span></span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Inferred return type is never</span>
<span class="token keyword">function</span> <span class="token function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Something failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Function returning never must have unreachable end point</span>
<span class="token keyword">function</span> <span class="token function">infiniteLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">never</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Some examples of use of functions returning <code>never</code>:<pre class="language-ts"><code class="language-ts"><span class="token comment">// Inferred return type is number</span>
<span class="token keyword">function</span> <span class="token function">move1</span><span class="token punctuation">(</span>direction<span class="token operator">:</span> <span class="token string">"up"</span> <span class="token operator">|</span> <span class="token string">"down"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">switch</span> <span class="token punctuation">(</span>direction<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">"up"</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">"down"</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Should never get here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Inferred return type is number</span>
<span class="token keyword">function</span> <span class="token function">move2</span><span class="token punctuation">(</span>direction<span class="token operator">:</span> <span class="token string">"up"</span> <span class="token operator">|</span> <span class="token string">"down"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> direction <span class="token operator">===</span> <span class="token string">"up"</span>
    <span class="token operator">?</span> <span class="token number">1</span>
    <span class="token operator">:</span> direction <span class="token operator">===</span> <span class="token string">"down"</span>
    <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span>
    <span class="token operator">:</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Should never get here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Inferred return type is T</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">check</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword nil">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> x <span class="token operator">||</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Undefined value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Because <code>never</code> is assignable to every type, a function returning <code>never</code> can be used when a callback returning a more specific type is required:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token function-variable function">cb</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">throw</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Error</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section><section id="read-only-properties-and-index-signatures"class="level2"><h2>Read-only properties and index signatures</h2><p>A property or index signature can now be declared with the <code>readonly</code> modifier is considered read-only.<p>Read-only properties may have initializers and may be assigned to in constructors within the same class declaration, but otherwise assignments to read-only properties are disallowed.<p>In addition, entities are <em>implicitly</em> read-only in several situations:<ul><li>A property declared with a <code>get</code> accessor and no <code>set</code> accessor is considered read-only.<li>In the type of an enum object, enum members are considered read-only properties.<li>In the type of a module object, exported <code>const</code> variables are considered read-only properties.<li>An entity declared in an <code>import</code> statement is considered read-only.<li>An entity accessed through an ES2015 namespace import is considered read-only (e.g. <code>foo.x</code> is read-only when <code>foo</code> is declared as <code>import * as foo from "foo"</code>).</ul><section id="example-6"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Point</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token keyword">readonly</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> p1<span class="token operator">:</span> <span class="token maybe-class-name">Point</span> <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span><span class="token property-access">x</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Error, p1.x is read-only</span>

<span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p3<span class="token operator">:</span> <span class="token maybe-class-name">Point</span> <span class="token operator">=</span> p2<span class="token punctuation">;</span> <span class="token comment">// Ok, read-only alias for p2</span>
p3<span class="token punctuation">.</span><span class="token property-access">x</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Error, p3.x is read-only</span>
p2<span class="token punctuation">.</span><span class="token property-access">x</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Ok, but also changes p3.x because of aliasing</span></code></pre><pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">readonly</span> b<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">b</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token comment">// Assignment permitted in constructor</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> a<span class="token operator">:</span> <span class="token known-class-name class-name">Array</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b<span class="token operator">:</span> <span class="token maybe-class-name">ReadonlyArray</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token operator">></span> <span class="token operator">=</span> a<span class="token punctuation">;</span>
b<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Error, elements are read-only</span>
b<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error, no push method (because it mutates array)</span>
b<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// Error, length is read-only</span>
a <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// Error, mutating methods are missing</span></code></pre></section></section><section id="specifying-the-type-of-this-for-functions"class="level2"><h2>Specifying the type of <code>this</code> for functions</h2><p>Following up on specifying the type of <code>this</code> in a class or an interface, functions and methods can now declare the type of <code>this</code> they expect.<p>By default the type of <code>this</code> inside a function is <code>any</code>. Starting with TypeScript 2.0, you can provide an explicit <code>this</code> parameter. <code>this</code> parameters are fake parameters that come first in the parameter list of a function:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// make sure `this` is unusable in this standalone function</span>
<span class="token punctuation">}</span></code></pre></section><section id="this-parameters-in-callbacks"class="level2"><h2><code>this</code> parameters in callbacks</h2><p>Libraries can also use <code>this</code> parameters to declare how callbacks will be invoked.<section id="example-7"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">UIElement</span></span> <span class="token punctuation">{</span>
  <span class="token function">addClickListener</span><span class="token punctuation">(</span><span class="token function-variable function">onclick</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">,</span> e<span class="token operator">:</span> <span class="token maybe-class-name">Event</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><code>this: void</code> means that <code>addClickListener</code> expects <code>onclick</code> to be a function that does not require a <code>this</code> type.<p>Now if you annotate calling code with <code>this</code>:<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Handler</span></span> <span class="token punctuation">{</span>
  info<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token function">onClickBad</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">:</span> <span class="token maybe-class-name">Handler</span><span class="token punctuation">,</span> e<span class="token operator">:</span> <span class="token maybe-class-name">Event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// oops, used this here. using this callback would crash at runtime</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">info</span> <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token property-access">message</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">Handler</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
uiElement<span class="token punctuation">.</span><span class="token method function property-access">addClickListener</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span><span class="token property-access">onClickBad</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error!</span></code></pre></section></section><section id="--noimplicitthis"class="level2"><h2><code>--noImplicitThis</code></h2><p>A new flag is also added in TypeScript 2.0 to flag all uses of <code>this</code> in functions without an explicit type annotation.</section><section id="glob-support-in-tsconfigjson"class="level2"><h2>Glob support in <code>tsconfig.json</code></h2><p>Glob support is here!! Glob support has been <a href="https://github.com/Microsoft/TypeScript/issues/1927">one of the most requested features</a>.<p>Glob-like file patterns are supported two properties <a href="/tsconfig#include"><code>include</code></a> and <code>exclude</code>.<section id="example-8"class="level5"><h5>Example</h5><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"module"</span><span class="token operator">:</span> <span class="token string">"commonjs"</span><span class="token punctuation">,</span>
    <span class="token property">"noImplicitAny"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token property">"removeComments"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token property">"preserveConstEnums"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token property">"outFile"</span><span class="token operator">:</span> <span class="token string">"../../built/local/tsc.js"</span><span class="token punctuation">,</span>
    <span class="token property">"sourceMap"</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"include"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/**/*"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">"exclude"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"node_modules"</span><span class="token punctuation">,</span> <span class="token string">"**/*.spec.ts"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre><p>The supported glob wildcards are:<ul><li><code>*</code> matches zero or more characters (excluding directory separators)<li><code>?</code> matches any one character (excluding directory separators)<li><code>**/</code> recursively matches any subdirectory</ul><p>If a segment of a glob pattern includes only <code>*</code> or <code>.*</code>, then only files with supported extensions are included (e.g. <code>.ts</code>, <code>.tsx</code>, and <code>.d.ts</code> by default with <code>.js</code> and <code>.jsx</code> if <a href="/tsconfig#allowJs"><code>allowJs</code></a> is set to true).<p>If the <a href="/tsconfig#files"><code>files</code></a> and <a href="/tsconfig#include"><code>include</code></a> are both left unspecified, the compiler defaults to including all TypeScript (<code>.ts</code>, <code>.d.ts</code> and <code>.tsx</code>) files in the containing directory and subdirectories except those excluded using the <code>exclude</code> property. JS files (<code>.js</code> and <code>.jsx</code>) are also included if <a href="/tsconfig#allowJs"><code>allowJs</code></a> is set to true.<p>If the <a href="/tsconfig#files"><code>files</code></a> or <a href="/tsconfig#include"><code>include</code></a> properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the <a href="/tsconfig#outDir"><code>outDir</code></a> compiler option are always excluded unless explicitly included via the <a href="/tsconfig#files"><code>files</code></a> property (even when the <code>exclude</code> property is specified).<p>Files included using <a href="/tsconfig#include"><code>include</code></a> can be filtered using the <code>exclude</code> property. However, files included explicitly using the <a href="/tsconfig#files"><code>files</code></a> property are always included regardless of <code>exclude</code>. The <code>exclude</code> property defaults to excluding the <code>node_modules</code>, <code>bower_components</code>, and <code>jspm_packages</code> directories when not specified.</section></section><section id="module-resolution-enhancements-baseurl-path-mapping-rootdirs-and-tracing"class="level2"><h2>Module resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing</h2><p>TypeScript 2.0 provides a set of additional module resolution knops to <em>inform</em> the compiler where to find declarations for a given module.<p>See <a href="http://www.typescriptlang.org/docs/handbook/module-resolution.html">Module Resolution</a> documentation for more details.</section><section id="base-url"class="level2"><h2>Base URL</h2><p>Using a <a href="/tsconfig#baseUrl"><code>baseUrl</code></a> is a common practice in applications using AMD module loaders where modules are "deployed" to a single folder at run-time. All module imports with non-relative names are assumed to be relative to the <a href="/tsconfig#baseUrl"><code>baseUrl</code></a>.<section id="example-9"class="level5"><h5>Example</h5><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"baseUrl"</span><span class="token operator">:</span> <span class="token string">"./modules"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Now imports to <code>"moduleA"</code> would be looked up in <code>./modules/moduleA</code><pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token constant">A</span> <span class="token keyword module">from</span> <span class="token string">"moduleA"</span><span class="token punctuation">;</span></code></pre></section></section><section id="path-mapping"class="level2"><h2>Path mapping</h2><p>Sometimes modules are not directly located under <em>baseUrl</em>. Loaders use a mapping configuration to map module names to files at run-time, see <a href="http://requirejs.org/docs/api.html#config-paths">RequireJs documentation</a> and <a href="https://github.com/systemjs/systemjs/blob/main/docs/import-maps.md">SystemJS documentation</a>.<p>The TypeScript compiler supports the declaration of such mappings using <a href="/tsconfig#paths"><code>paths</code></a> property in <code>tsconfig.json</code> files.<section id="example-10"class="level5"><h5>Example</h5><p>For instance, an import to a module <code>"jquery"</code> would be translated at runtime to <code>"node_modules/jquery/dist/jquery.slim.min.js"</code>.<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"baseUrl"</span><span class="token operator">:</span> <span class="token string">"./node_modules"</span><span class="token punctuation">,</span>
    <span class="token property">"paths"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">"jquery"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"jquery/dist/jquery.slim.min"</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Using <a href="/tsconfig#paths"><code>paths</code></a> also allow for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another.</section></section><section id="virtual-directories-with-rootdirs"class="level2"><h2>Virtual Directories with <code>rootDirs</code></h2><p>Using 'rootDirs', you can inform the compiler of the <em>roots</em> making up this "virtual" directory; and thus the compiler can resolve relative modules imports within these "virtual" directories <em>as if</em> they were merged together in one directory.<section id="example-11"class="level5"><h5>Example</h5><p>Given this project structure:<pre class="language-tree"><code class="language-tree"> src
 └── views
     └── view1.ts (imports './template1')
     └── view2.ts

 generated
 └── templates
         └── views
             └── template1.ts (imports './view2')</code></pre><p>A build step will copy the files in <code>/src/views</code> and <code>/generated/templates/views</code> to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as <code>"./template"</code>.<p><a href="/tsconfig#rootDirs"><code>rootDirs</code></a> specify a list of <em>roots</em> whose contents are expected to merge at run-time. So following our example, the <code>tsconfig.json</code> file should look like:<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"rootDirs"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/views"</span><span class="token punctuation">,</span> <span class="token string">"generated/templates/views"</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></section></section><section id="tracing-module-resolution"class="level2"><h2>Tracing module resolution</h2><p><a href="/tsconfig#traceResolution"><code>traceResolution</code></a> offers a handy way to understand how modules have been resolved by the compiler.<pre class="language-shell"><code class="language-shell">tsc --traceResolution</code></pre></section><section id="shorthand-ambient-module-declarations"class="level2"><h2>Shorthand ambient module declarations</h2><p>If you don't want to take the time to write out declarations before using a new module, you can now just use a shorthand declaration to get started quickly.<section id="declarationsdts"class="level5"><h5>declarations.d.ts</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">"hot-new-module"</span><span class="token punctuation">;</span></code></pre><p>All imports from a shorthand module will have the any type.<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports">x<span class="token punctuation">,</span> <span class="token punctuation">{</span> y <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"hot-new-module"</span><span class="token punctuation">;</span>
<span class="token function">x</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section></section><section id="wildcard-character-in-module-names"class="level2"><h2>Wildcard character in module names</h2><p>Importing none-code resources using module loaders extension (e.g. <a href="https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md">AMD</a> or <a href="https://github.com/systemjs/systemjs/blob/main/docs/module-types.md">SystemJS</a>) has not been easy before; previously an ambient module declaration had to be defined for each resource.<p>TypeScript 2.0 supports the use of the wildcard character (<code>*</code>) to declare a "family" of module names; this way, a declaration is only required once for an extension, and not for every resource.<section id="example-12"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">"*!text"</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> content<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token keyword module">export</span> <span class="token keyword module">default</span> content<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Some do it the other way around.</span>
<span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">"json!*"</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> value<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
  <span class="token keyword module">export</span> <span class="token keyword module">default</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Now you can import things that match <code>"*!text"</code> or <code>"json!*"</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports">fileContent</span> <span class="token keyword module">from</span> <span class="token string">"./xyz.txt!text"</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports">data</span> <span class="token keyword module">from</span> <span class="token string">"json!http://example.com/data.json"</span><span class="token punctuation">;</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> fileContent<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Wildcard module names can be even more useful when migrating from an un-typed code base. Combined with Shorthand ambient module declarations, a set of modules can be easily declared as <code>any</code>.</section><section id="example-13"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">"myLibrary/*"</span><span class="token punctuation">;</span></code></pre><p>All imports to any module under <code>myLibrary</code> would be considered to have the type <code>any</code> by the compiler; thus, shutting down any checking on the shapes or types of these modules.<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> readFile <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> "myLibrary<span class="token operator">/</span>fileSystem<span class="token operator">/</span>readFile`<span class="token punctuation">;</span>

<span class="token function">readFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// readFile is 'any'</span></code></pre></section></section><section id="support-for-umd-module-definitions"class="level2"><h2>Support for UMD module definitions</h2><p>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as <a href="https://github.com/umdjs/umd">UMD</a> or <a href="http://isomorphic.net">Isomorphic</a> modules. These libraries can be accessed through either an import or a global variable.<p>For example:<section id="math-libdts"class="level5"><h5>math-lib.d.ts</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token keyword">const</span> <span class="token function">isPrime</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token keyword module">export</span> <span class="token keyword module">as</span> <span class="token keyword">namespace</span> mathLib<span class="token punctuation">;</span></code></pre><p>The library can then be used as an import within modules:<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> isPrime <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"math-lib"</span><span class="token punctuation">;</span>
<span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mathLib<span class="token punctuation">.</span><span class="token method function property-access">isPrime</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ERROR: can't use the global definition from inside a module</span></code></pre><p>It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports.)<pre class="language-ts"><code class="language-ts">mathLib<span class="token punctuation">.</span><span class="token method function property-access">isPrime</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section></section><section id="optional-class-properties"class="level2"><h2>Optional class properties</h2><p>Optional properties and methods can now be declared in classes, similar to what is already permitted in interfaces.<section id="example-14"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Bar</span></span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  b<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  g<span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// Body of optional method can be omitted</span>
  h<span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>When compiled in <a href="/tsconfig#strictNullChecks"><code>strictNullChecks</code></a> mode, optional properties and methods automatically have <code>undefined</code> included in their type. Thus, the <code>b</code> property above is of type <code>number | undefined</code> and the <code>g</code> method above is of type <code>(() => number) | undefined</code>. Type guards can be used to strip away the <code>undefined</code> part of the type:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token maybe-class-name">Bar</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  x<span class="token punctuation">.</span><span class="token property-access">a</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
  x<span class="token punctuation">.</span><span class="token property-access">b</span><span class="token punctuation">;</span> <span class="token comment">// number | undefined</span>
  x<span class="token punctuation">.</span><span class="token property-access">f</span><span class="token punctuation">;</span> <span class="token comment">// () => number</span>
  x<span class="token punctuation">.</span><span class="token property-access">g</span><span class="token punctuation">;</span> <span class="token comment">// (() => number) | undefined</span>
  <span class="token keyword">let</span> f1 <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token method function property-access">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
  <span class="token keyword">let</span> g1 <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token property-access">g</span> <span class="token operator">&#x26;&#x26;</span> x<span class="token punctuation">.</span><span class="token method function property-access">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// number | undefined</span>
  <span class="token keyword">let</span> g2 <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token property-access">g</span> <span class="token operator">?</span> x<span class="token punctuation">.</span><span class="token method function property-access">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
<span class="token punctuation">}</span></code></pre></section></section><section id="private-and-protected-constructors"class="level2"><h2>Private and Protected Constructors</h2><p>A class constructor may be marked <code>private</code> or <code>protected</code>. A class with private constructor cannot be instantiated outside the class body, and cannot be extended. A class with protected constructor cannot be instantiated outside the class body, but can be extended.<section id="example-15"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Singleton</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> instance<span class="token operator">:</span> <span class="token maybe-class-name">Singleton</span><span class="token punctuation">;</span>

  <span class="token keyword">private</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">static</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token maybe-class-name">Singleton</span><span class="token punctuation">.</span><span class="token property-access">instance</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token maybe-class-name">Singleton</span><span class="token punctuation">.</span><span class="token property-access">instance</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">Singleton</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> <span class="token maybe-class-name">Singleton</span><span class="token punctuation">.</span><span class="token property-access">instance</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">Singleton</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: constructor of 'Singleton' is private.</span>
<span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token maybe-class-name">Singleton</span><span class="token punctuation">.</span><span class="token method function property-access">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section></section><section id="abstract-properties-and-accessors"class="level2"><h2>Abstract properties and accessors</h2><p>An abstract class can declare abstract properties and/or accessors. Any sub class will need to declare the abstract properties or be marked as abstract. Abstract properties cannot have an initializer. Abstract accessors cannot have bodies.<section id="example-16"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Base</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">abstract</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token keyword">abstract</span> <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">abstract</span> <span class="token keyword">set</span> <span class="token function">value</span><span class="token punctuation">(</span>v<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Derived</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">Base</span></span> <span class="token punctuation">{</span>
  name <span class="token operator">=</span> <span class="token string">"derived"</span><span class="token punctuation">;</span>

  value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></section></section><section id="implicit-index-signatures"class="level2"><h2>Implicit index signatures</h2><p>An object literal type is now assignable to a type with an index signature if all known properties in the object literal are assignable to that index signature. This makes it possible to pass a variable that was initialized with an object literal as parameter to a function that expects a map or dictionary:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">httpService</span><span class="token punctuation">(</span>path<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> headers<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">const</span> headers <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token string-property property">"Content-Type"</span><span class="token operator">:</span> <span class="token string">"application/x-www-form-urlencoded"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">httpService</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string-property property">"Content-Type"</span><span class="token operator">:</span> <span class="token string">"application/x-www-form-urlencoded"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Ok</span>
<span class="token function">httpService</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> headers<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Now ok, previously wasn't</span></code></pre></section><section id="including-built-in-type-declarations-with---lib"class="level2"><h2>Including built-in type declarations with <code>--lib</code></h2><p>Getting to ES6/ES2015 built-in API declarations were only limited to <code>target: ES6</code>. Enter <a href="/tsconfig#lib"><code>lib</code></a>; with <a href="/tsconfig#lib"><code>lib</code></a> you can specify a list of built-in API declaration groups that you can chose to include in your project. For instance, if you expect your runtime to have support for <code>Map</code>, <code>Set</code> and <code>Promise</code> (e.g. most evergreen browsers today), just include <code>--lib es2015.collection,es2015.promise</code>. Similarly you can exclude declarations you do not want to include in your project, e.g. DOM if you are working on a node project using <code>--lib es5,es6</code>.<p>Here is a list of available API groups:<ul><li>dom<li>webworker<li>es5<li>es6 / es2015<li>es2015.core<li>es2015.collection<li>es2015.iterable<li>es2015.promise<li>es2015.proxy<li>es2015.reflect<li>es2015.generator<li>es2015.symbol<li>es2015.symbol.wellknown<li>es2016<li>es2016.array.include<li>es2017<li>es2017.object<li>es2017.sharedmemory<li>scripthost</ul><section id="example-17"class="level5"><h5>Example</h5><pre class="language-bash"><code class="language-bash">tsc --target es5 --lib es5,es2015.promise</code></pre><pre class="language-json"><code class="language-json"><span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"lib"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"es5"</span><span class="token punctuation">,</span> <span class="token string">"es2015.promise"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre></section></section><section id="flag-unused-declarations-with---nounusedparameters-and---nounusedlocals"class="level2"><h2>Flag unused declarations with <code>--noUnusedParameters</code> and <code>--noUnusedLocals</code></h2><p>TypeScript 2.0 has two new flags to help you maintain a clean code base. <a href="/tsconfig#noUnusedParameters"><code>noUnusedParameters</code></a> flags any unused function or method parameters errors. <a href="/tsconfig#noUnusedLocals"><code>noUnusedLocals</code></a> flags any unused local (un-exported) declaration like variables, functions, classes, imports, etc... Also, unused private members of a class would be flagged as errors under <a href="/tsconfig#noUnusedLocals"><code>noUnusedLocals</code></a>.<section id="example-18"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> readFile <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">"./b"</span><span class="token punctuation">;</span>
<span class="token comment">//     ^ Error: `B` declared but never used</span>
<span class="token function">readFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">write</span><span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> args<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//                                 ^^^^  Error: 'arg' declared but never used.</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Parameters declaration with names starting with <code>_</code> are exempt from the unused parameter checking. e.g.:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">returnNull</span><span class="token punctuation">(</span>_a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// OK</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></section></section><section id="module-identifiers-allow-for-js-extension"class="level2"><h2>Module identifiers allow for <code>.js</code> extension</h2><p>Before TypeScript 2.0, a module identifier was always assumed to be extension-less; for instance, given an import as <code>import d from "./moduleA.js"</code>, the compiler looked up the definition of <code>"moduleA.js"</code> in <code>./moduleA.js.ts</code> or <code>./moduleA.js.d.ts</code>. This made it hard to use bundling/loading tools like <a href="https://github.com/systemjs/systemjs">SystemJS</a> that expect URI's in their module identifier.<p>With TypeScript 2.0, the compiler will look up definition of <code>"moduleA.js"</code> in <code>./moduleA.ts</code> or <code>./moduleA.d.t</code>.</section><section id="support-target--es5-with-module-es6"class="level2"><h2>Support 'target : es5' with 'module: es6'</h2><p>Previously flagged as an invalid flag combination, <code>target: es5</code> and 'module: es6' is now supported. This should facilitate using ES2015-based tree shakers like <a href="https://github.com/rollup/rollup">rollup</a>.</section><section id="trailing-commas-in-function-parameter-and-argument-lists"class="level2"><h2>Trailing commas in function parameter and argument lists</h2><p>Trailing comma in function parameter and argument lists are now allowed. This is an implementation for a <a href="https://jeffmo.github.io/es-trailing-function-commas/">Stage-3 ECMAScript proposal</a> that emits down to valid ES3/ES5/ES6.<section id="example-19"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>
  bar<span class="token operator">:</span> <span class="token maybe-class-name">Bar</span><span class="token punctuation">,</span>
  baz<span class="token operator">:</span> <span class="token maybe-class-name">Baz</span> <span class="token comment">// trailing commas are OK in parameter lists</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Implementation...</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span>
  bar<span class="token punctuation">,</span>
  baz <span class="token comment">// and in argument lists</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section></section><section id="new---skiplibcheck"class="level2"><h2>New <code>--skipLibCheck</code></h2><p>TypeScript 2.0 adds a new <a href="/tsconfig#skipLibCheck"><code>skipLibCheck</code></a> compiler option that causes type checking of declaration files (files with extension <code>.d.ts</code>) to be skipped. When a program includes large declaration files, the compiler spends a lot of time type checking declarations that are already known to not contain errors, and compile times may be significantly shortened by skipping declaration file type checks.<p>Since declarations in one file can affect type checking in other files, some errors may not be detected when <a href="/tsconfig#skipLibCheck"><code>skipLibCheck</code></a> is specified. For example, if a non-declaration file augments a type declared in a declaration file, errors may result that are only reported when the declaration file is checked. However, in practice such situations are rare.</section><section id="allow-duplicate-identifiers-across-declarations"class="level2"><h2>Allow duplicate identifiers across declarations</h2><p>This has been one common source of duplicate definition errors. Multiple declaration files defining the same members on interfaces.<p>TypeScript 2.0 relaxes this constraint and allows duplicate identifiers across blocks, as long as they have <em>identical</em> types.<p>Within the same block duplicate definitions are still disallowed.<section id="example-20"class="level5"><h5>Example</h5><pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token known-class-name class-name">Error</span></span> <span class="token punctuation">{</span>
  stack<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token known-class-name class-name">Error</span></span> <span class="token punctuation">{</span>
  code<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  path<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  stack<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
<span class="token punctuation">}</span></code></pre></section></section><section id="new---declarationdir"class="level2"><h2>New <code>--declarationDir</code></h2><p><a href="/tsconfig#declarationDir"><code>declarationDir</code></a> allows for generating declaration files in a different location than JavaScript files. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section>