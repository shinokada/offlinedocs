<!doctype html><html lang="en"><meta charset="utf-8"><title>TypeScript 4.6</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/release-notes/typescript-4-6.html"><meta name="oneline"content="TypeScript 4.6 Release Notes"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="allowing-code-in-constructors-before-super"class="level2"><h2>Allowing Code in Constructors Before <code>super()</code></h2><p>In JavaScript classes it's mandatory to call <code>super()</code> before referring to <code>this</code>. TypeScript enforces this as well, though it was a bit too strict in <em>how</em> it ensured this. In TypeScript, it was previously an error to contain <em>any</em> code at the beginning of a constructor if its containing class had any property initializers.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Base</span></span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Derived</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">Base</span></span> <span class="token punctuation">{</span>
  someProperty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// error!</span>
    <span class="token comment">// have to call 'super()' first because it needs to initialize 'someProperty'.</span>
    <span class="token function">doSomeStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>This made it cheap to check that <code>super()</code> gets called before <code>this</code> is referenced, but it ended up rejecting a lot of valid code. TypeScript 4.6 is now much more lenient in that check and permits other code to run before <code>super()</code>., all while still ensuring that <code>super()</code> occurs at the top-level before any references to <code>this</code>.<p>We'd like to extend our thanks to <a href="https://github.com/JoshuaKGoldberg">Joshua Goldberg</a> for <a href="https://github.com/microsoft/TypeScript/pull/29374">patiently working with us to land this change</a>!</section><section id="control-flow-analysis-for-destructured-discriminated-unions"class="level2"><h2>Control Flow Analysis for Destructured Discriminated Unions</h2><p>TypeScript is able to narrow types based on what's called a discriminant property. For example, in the following code snippet, TypeScript is able to narrow the type of <code>action</code> based on every time we check against the value of <code>kind</code>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Action</span></span> <span class="token operator">=</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"NumberContents"</span><span class="token punctuation">;</span> payload<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"StringContents"</span><span class="token punctuation">;</span> payload<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">processAction</span><span class="token punctuation">(</span>action<span class="token operator">:</span> <span class="token maybe-class-name">Action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span><span class="token property-access">kind</span> <span class="token operator">===</span> <span class="token string">"NumberContents"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// `action.payload` is a number here.</span>
    <span class="token keyword">let</span> num <span class="token operator">=</span> action<span class="token punctuation">.</span><span class="token property-access">payload</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span><span class="token property-access">kind</span> <span class="token operator">===</span> <span class="token string">"StringContents"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// `action.payload` is a string here.</span>
    <span class="token keyword">const</span> str <span class="token operator">=</span> action<span class="token punctuation">.</span><span class="token property-access">payload</span><span class="token punctuation">.</span><span class="token method function property-access">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>This lets us work with objects that can hold different data, but a common field tells us <em>which</em> data those objects have.<p>This is very common in TypeScript; however, depending on your preferences, you might have wanted to destructure <code>kind</code> and <code>payload</code> in the the example above. Perhaps something like the following:<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Action</span></span> <span class="token operator">=</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"NumberContents"</span><span class="token punctuation">;</span> payload<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">"StringContents"</span><span class="token punctuation">;</span> payload<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">processAction</span><span class="token punctuation">(</span>action<span class="token operator">:</span> <span class="token maybe-class-name">Action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> kind<span class="token punctuation">,</span> payload <span class="token punctuation">}</span> <span class="token operator">=</span> action<span class="token punctuation">;</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>kind <span class="token operator">===</span> <span class="token string">"NumberContents"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> num <span class="token operator">=</span> payload <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>kind <span class="token operator">===</span> <span class="token string">"StringContents"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> str <span class="token operator">=</span> payload<span class="token punctuation">.</span><span class="token method function property-access">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Previously TypeScript would error on these - once <code>kind</code> and <code>payload</code> were extracted from the same object into variables, they were considered totally independent.<p>In TypeScript 4.6, this just works!<p>When destructuring individual properties into a <code>const</code> declaration, or when destructuring a parameter into variables that are never assigned to, TypeScript will check for if the destructured type is a discriminated union. If it is, TypeScript can now narrow the types of variables depending on checks of other variables So in our example, a check on <code>kind</code> narrows the type of <code>payload</code>.<p>For more information, <a href="https://github.com/microsoft/TypeScript/pull/46266">see the pull request that implemented this analysis</a>.</section><section id="improved-recursion-depth-checks"class="level2"><h2>Improved Recursion Depth Checks</h2><p>TypeScript has some interesting challenges due to the fact that it's built on a structural type system that also provides generics.<p>In a structural type system, object types are compatible based on the members they have.<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Source</span></span> <span class="token punctuation">{</span>
  prop<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Target</span></span> <span class="token punctuation">{</span>
  prop<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">check</span><span class="token punctuation">(</span>source<span class="token operator">:</span> <span class="token maybe-class-name">Source</span><span class="token punctuation">,</span> target<span class="token operator">:</span> <span class="token maybe-class-name">Target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  target <span class="token operator">=</span> source<span class="token punctuation">;</span>
  <span class="token comment">// error!</span>
  <span class="token comment">// Type 'Source' is not assignable to type 'Target'.</span>
  <span class="token comment">//   Types of property 'prop' are incompatible.</span>
  <span class="token comment">//     Type 'string' is not assignable to type 'number'.</span>
<span class="token punctuation">}</span></code></pre><p>Notice that whether or not <code>Source</code> is compatible with <code>Target</code> has to do with whether their <em>properties</em> are assignable. In this case, that's just <code>prop</code>.<p>When you introduce generics into this, there are some harder questions to answer. For instance, is a <code>Source&#x3C;string></code> assignable to a <code>Target&#x3C;number></code> in the following case?<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Source</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  prop<span class="token operator">:</span> <span class="token maybe-class-name">Source</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Source</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">>></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Target</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  prop<span class="token operator">:</span> <span class="token maybe-class-name">Target</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Target</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">>></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">check</span><span class="token punctuation">(</span>source<span class="token operator">:</span> <span class="token maybe-class-name">Source</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">,</span> target<span class="token operator">:</span> <span class="token maybe-class-name">Target</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  target <span class="token operator">=</span> source<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>In order to answer that, TypeScript needs to check whether the types of <code>prop</code> are compatible. That leads to the another question: is a <code>Source&#x3C;Source&#x3C;string>></code> assignable to a <code>Target&#x3C;Target&#x3C;number>></code>? To answer that, TypeScript checks whether <code>prop</code> is compatible for <em>those</em> types, and ends up checking whether <code>Source&#x3C;Source&#x3C;Source&#x3C;string>>></code> is assignable to <code>Target&#x3C;Target&#x3C;Target&#x3C;number>>></code>. Keep going for a bit, and you might notice that the type infinitely expands the more you dig in.<p>TypeScript has a few heuristics here - if a type <em>appears</em> to be infinitely expanding after encountering a certain depth check, then it considers that the types <em>could</em> be compatible. This is usually enough, but embarrassingly there were some false-negatives that this wouldn't catch.<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  prop<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">let</span> x<span class="token operator">:</span> <span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">>>></span><span class="token operator">>>></span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> y<span class="token operator">:</span> <span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">Foo</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">>>></span><span class="token operator">>></span><span class="token punctuation">;</span>

x <span class="token operator">=</span> y<span class="token punctuation">;</span></code></pre><p>A human reader can see that <code>x</code> and <code>y</code> should be incompatible in the above example. While the types are deeply nested, that's just a consequence of how they were declared. The heuristic was meant to capture cases where deeply-nested types were generated through exploring the types, not from when a developer wrote that type out themselves.<p>TypeScript 4.6 is now able to distinguish these cases, and correctly errors on the last example. Additionally, because the language is no longer concerned with false-positives from explicitly-written types, TypeScript can conclude that a type is infinitely expanding much earlier, and save a bunch of work in checking for type compatibility. As a result, libraries on DefinitelyTyped like <code>redux-immutable</code>, <code>react-lazylog</code>, and <code>yup</code> saw a 50% reduction in check-time.<p>You may already have this change because it was cherry-picked into TypeScript 4.5.3, but it is a notable feature of TypeScript 4.6 which you can read up more about <a href="https://github.com/microsoft/TypeScript/pull/46599">here</a>.</section><section id="indexed-access-inference-improvements"class="level2"><h2>Indexed Access Inference Improvements</h2><p>TypeScript now can correctly infer to indexed access types which immediately index into a mapped object type.<pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">TypeMap</span></span> <span class="token punctuation">{</span>
  <span class="token builtin">number</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token builtin">string</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token builtin">boolean</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">UnionRecord</span><span class="token operator">&#x3C;</span><span class="token constant">P</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token maybe-class-name">TypeMap</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    kind<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">;</span>
    v<span class="token operator">:</span> <span class="token maybe-class-name">TypeMap</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function-variable function">f</span><span class="token operator">:</span> <span class="token punctuation">(</span>p<span class="token operator">:</span> <span class="token maybe-class-name">TypeMap</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">processRecord</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token maybe-class-name">TypeMap</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>record<span class="token operator">:</span> <span class="token maybe-class-name">UnionRecord</span><span class="token operator">&#x3C;</span><span class="token constant">K</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  record<span class="token punctuation">.</span><span class="token method function property-access">f</span><span class="token punctuation">(</span>record<span class="token punctuation">.</span><span class="token property-access">v</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// This call used to have issues - now works!</span>
<span class="token function">processRecord</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">"string"</span><span class="token punctuation">,</span>
  v<span class="token operator">:</span> <span class="token string">"hello!"</span><span class="token punctuation">,</span>

  <span class="token comment">// 'val' used to implicitly have the type 'string | number | boolean',</span>
  <span class="token comment">// but now is correctly inferred to just 'string'.</span>
  <span class="token function-variable function">f</span><span class="token operator">:</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>val<span class="token punctuation">.</span><span class="token method function property-access">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This pattern was already supported and allowed TypeScript to understand that the call to <code>record.f(record.v)</code> is valid, but previously the call to <code>processRecord</code> would give poor inference results for <code>val</code><p>TypeScript 4.6 improves this so that no type assertions are necessary within the call to <code>processRecord</code>.<p>For more information, you can <a href="https://github.com/microsoft/TypeScript/pull/47109">read up on the pull request</a>.</section><section id="control-flow-analysis-for-dependent-parameters"class="level2"><h2>Control Flow Analysis for Dependent Parameters</h2><p>A signature can be declared with a rest parameter whose type is a discriminated union of tuples.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"str"</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token string">"num"</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>What this says is that the arguments to <code>func</code> depends entirely on the first argument. When the first argument is the string <code>"str"</code>, then its second argument has to be a <code>string</code>. When its first argument is the string <code>"num"</code>, its second argument has to be a <code>number</code>.<p>In cases where TypeScript infers the type of a function from a signature like this, TypeScript can now narrow parameters that depend on each other.<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Func</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> f1<span class="token operator">:</span> <span class="token function-variable function"><span class="token maybe-class-name">Func</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>kind<span class="token punctuation">,</span> payload<span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>kind <span class="token operator">===</span> <span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    payload<span class="token punctuation">.</span><span class="token method function property-access">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'payload' narrowed to 'number'</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>kind <span class="token operator">===</span> <span class="token string">"b"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    payload<span class="token punctuation">.</span><span class="token method function property-access">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'payload' narrowed to 'string'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">f1</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>For more information, <a href="https://github.com/microsoft/TypeScript/pull/47190">see the change on GitHub</a>.</section><section id="--target-es2022"class="level2"><h2><code>--target es2022</code></h2><p>TypeScript's <code>--target</code> option now supports <code>es2022</code>. This means features like class fields now have a stable output target where they can be preserved. It also means that new built-in functionality like the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at"><code>at()</code> method on <code>Array</code>s</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn"><code>Object.hasOwn</code></a>, or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Error#rethrowing_an_error_with_a_cause">the <code>cause</code> option on <code>new Error</code></a> can be used either with this new <code>--target</code> setting, or with <code>--lib es2022</code>.<p>This functionality was <a href="https://github.com/microsoft/TypeScript/pull/46291">implemented</a> by <a href="https://github.com/saschanaz">Kagami Sascha Rosylight (saschanaz)</a> over several PRs, and we're grateful for that contribution!</section><section id="removed-unnecessary-arguments-in-react-jsx"class="level2"><h2>Removed Unnecessary Arguments in <code>react-jsx</code></h2><p>Previously, when compiling code like the following in <code>--jsx react-jsx</code><pre class="language-tsx"><code class="language-tsx"><span class="token keyword module">export</span> <span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">foo</span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span></code></pre><p>TypeScript would produce the following JavaScript code:<pre class="language-jsx"><code class="language-jsx"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> jsx <span class="token keyword module">as</span> _jsx <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"react/jsx-runtime"</span><span class="token punctuation">;</span>
<span class="token keyword module">export</span> <span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token function">_jsx</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">"foo"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>That last <code>void 0</code> argument is unnecessary in this emit mode, and removing it can improve bundle sizes.<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> export const el = _jsx("div", { children: "foo" }, void 0);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> export const el = _jsx("div", { children: "foo" });</span></span></code></pre><p>Thanks to <a href="https://github.com/microsoft/TypeScript/pull/47467">a pull request</a> from <a href="https://github.com/a-tarasyuk">Alexander Tarasyuk</a>, TypeScript 4.6 now drops the <code>void 0</code> argument.</section><section id="jsdoc-name-suggestions"class="level2"><h2>JSDoc Name Suggestions</h2><p>In JSDoc, you can document parameters using an <code>@param</code> tag.<pre class="language-js"><code class="language-js"><span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token parameter">x</span> The first operand
 * <span class="token keyword">@param</span> <span class="token parameter">y</span> The second operand
 */</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>But what happens when these comments fall out of date? What if we rename <code>x</code> and <code>y</code> to <code>a</code> and <code>b</code>?<pre class="language-js"><code class="language-js"><span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token parameter">x</span> <span class="token punctuation">{</span>number<span class="token punctuation">}</span> The first operand
 * <span class="token keyword">@param</span> <span class="token parameter">y</span> <span class="token punctuation">{</span>number<span class="token punctuation">}</span> The second operand
 */</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Previously TypeScript would only tell you about this when performing type-checking on JavaScript files - when using either the <code>checkJs</code> option, or adding a <code>// @ts-check</code> comment to the top of your file.<p>You can now get similar information for TypeScript files in your editor! TypeScript now provides suggestions for when parameter names don't match between your function and its JSDoc comment.<figure><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2022/02/jsdoc-comment-suggestions-4-6.png"alt="Suggestion diagnostics being shown in the editor for parameter names in JSDoc comments that don&#x27;t match an actual parameter name."><figcaption aria-hidden="true">Suggestion diagnostics being shown in the editor for parameter names in JSDoc comments that don't match an actual parameter name.</figcaption></figure><p><a href="https://github.com/microsoft/TypeScript/pull/47257">This change</a> was provided courtesy of <a href="https://github.com/a-tarasyuk">Alexander Tarasyuk</a>!</section><section id="more-syntax-and-binding-errors-in-javascript"class="level2"><h2>More Syntax and Binding Errors in JavaScript</h2><p>TypeScript has expanded its set of syntax and binding errors in JavaScript files. You'll see these new errors if you open JavaScript files in an editor like Visual Studio or Visual Studio Code, or if you run JavaScript code through the TypeScript compiler - even if you don't turn on <code>checkJs</code> or add a <code>// @ts-check</code> comment to the top of your files.<p>As one example, if you have two declarations of a <code>const</code> in the same scope of a JavaScript file, TypeScript will now issue an error on those declarations.<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token number">1234</span><span class="token punctuation">;</span>
<span class="token comment">//    ~~~</span>
<span class="token comment">// error: Cannot redeclare block-scoped variable 'foo'.</span>

<span class="token comment">// ...</span>

<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token number">5678</span><span class="token punctuation">;</span>
<span class="token comment">//    ~~~</span>
<span class="token comment">// error: Cannot redeclare block-scoped variable 'foo'.</span></code></pre><p>As another example, TypeScript will let you know if a modifier is being incorrectly used.<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">container</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">//  ~~~~~~</span>
<span class="token comment">// error: Modifiers cannot appear here.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>These errors can be disabled by adding a <code>// @ts-nocheck</code> at the top of your file, but we're interested in hearing some early feedback about how it works for your JavaScript workflow. You can easily try it out for Visual Studio Code by installing the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next">TypeScript and JavaScript Nightly Extension</a>, and read up more on the <a href="https://github.com/microsoft/TypeScript/pull/47067">first</a> and <a href="https://github.com/microsoft/TypeScript/pull/47075">second</a> pull requests.</section><section id="typescript-trace-analyzer"class="level2"><h2>TypeScript Trace Analyzer</h2><p>Occasionally, teams may encounter types that are computationally expensive to create and compare against other types. <a href="https://github.com/microsoft/TypeScript/wiki/Performance#performance-tracing">TypeScript has a <code>--generateTrace</code> flag</a> to help identify some of those expensive types, or sometimes help diagnose issues in the TypeScript compiler. While the information generated by <code>--generateTrace</code> can be useful (especially with some information added in TypeScript 4.6), it can often be hard to read in existing trace visualizers.<p>We recently published a tool called <a href="https://www.npmjs.com/package/@typescript/analyze-trace">@typescript/analyze-trace</a> to get a more digestible view of this information. While we don't expect everyone to need <code>analyze-trace</code>, we think it can come in handy for any team that is running into <a href="https://github.com/microsoft/TypeScript/wiki/Performance">build performance issues with TypeScript</a>.<p>For more information, <a href="https://github.com/microsoft/typescript-analyze-trace">see the <code>analyze-trace</code> tool's repo</a>.</section><section id="breaking-changes"class="level2"><h2>Breaking Changes</h2><section id="object-rests-drop-unspreadable-members-from-generic-objects"class="level3"><h3>Object Rests Drop Unspreadable Members from Generic Objects</h3><p>Object rest expressions now drop members that appear to be unspreadable on generic objects. In the following example...<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Thing</span></span> <span class="token punctuation">{</span>
  someProperty <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

  <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token maybe-class-name">Thing</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">{</span> someProperty<span class="token punctuation">,</span> <span class="token spread operator">...</span>rest <span class="token punctuation">}</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>

  <span class="token comment">// Used to work, is now an error!</span>
  <span class="token comment">// Property 'someMethod' does not exist on type 'Omit&#x3C;T, "someProperty" | "someMethod">'.</span>
  rest<span class="token punctuation">.</span><span class="token method function property-access">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>the variable <code>rest</code> used to have the type <code>Omit&#x3C;T, "someProperty"></code> because TypeScript would strictly analyze which other properties were destructured. This doesn't model how <code>...rest</code> would work in a destructuring from a non-generic type because <code>someMethod</code> would typically be dropped as well. In TypeScript 4.6, the type of <code>rest</code> is <code>Omit&#x3C;T, "someProperty" | "someMethod"></code>.<p>This can also come up in cases when destructuring from <code>this</code>. When destructuring <code>this</code> using a <code>...rest</code> element, unspreadable and non-public members are now dropped, which is consistent with destructuring instances of a class in other places.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Thing</span></span> <span class="token punctuation">{</span>
  someProperty <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

  <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>

  <span class="token function">someOtherMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token punctuation">{</span> someProperty<span class="token punctuation">,</span> <span class="token spread operator">...</span>rest <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

    <span class="token comment">// Used to work, is now an error!</span>
    <span class="token comment">// Property 'someMethod' does not exist on type 'Omit&#x3C;T, "someProperty" | "someMethod">'.</span>
    rest<span class="token punctuation">.</span><span class="token method function property-access">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>For more details, <a href="https://github.com/microsoft/TypeScript/pull/47078">see the corresponding change here</a>.</section><section id="javascript-files-always-receive-grammar-and-binding-errors"class="level3"><h3>JavaScript Files Always Receive Grammar and Binding Errors</h3><p>Previously, TypeScript would ignore most grammar errors in JavaScript apart from accidentally using TypeScript syntax in a JavaScript file. TypeScript now shows JavaScript syntax and binding errors in your file, such as using incorrect modifiers, duplicate declarations, and more. These will typically be most apparent in Visual Studio Code or Visual Studio, but can also occur when running JavaScript code through the TypeScript compiler.<p>You can explicitly turn these errors off by inserting a <code>// @ts-nocheck</code> comment at the top of your file.<p>For more information, see the <a href="https://github.com/microsoft/TypeScript/pull/47067">first</a> and <a href="https://github.com/microsoft/TypeScript/pull/47075">second</a> implementing pull requests for these features. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>