<!doctype html><html lang="en"><meta charset="utf-8"><title>TypeScript 3.8</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/release-notes/typescript-3-8.html"><meta name="oneline"content="TypeScript 3.8 Release Notes"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="type-only-imports-and-export"class="level2"><h2>Type-Only Imports and Export</h2><p>This feature is something most users may never have to think about; however, if you've hit issues under <a href="/tsconfig#isolatedModules"><code>isolatedModules</code></a>, TypeScript's <code>transpileModule</code> API, or Babel, this feature might be relevant.<p>TypeScript 3.8 adds a new syntax for type-only imports and exports.<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">SomeThing</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">"./some-module.js"</span><span class="token punctuation">;</span>

<span class="token keyword module">export</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">SomeThing</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><code>import type</code> only imports declarations to be used for type annotations and declarations. It <em>always</em> gets fully erased, so there's no remnant of it at runtime. Similarly, <code>export type</code> only provides an export that can be used for type contexts, and is also erased from TypeScript's output.<p>It's important to note that classes have a value at runtime and a type at design-time, and the use is context-sensitive. When using <code>import type</code> to import a class, you can't do things like extend from it.<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">Component</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">ButtonProps</span></span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Button</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token maybe-class-name">Component</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">ButtonProps</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  <span class="token comment">//               ~~~~~~~~~</span>
  <span class="token comment">// error! 'Component' only refers to a type, but is being used as a value here.</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>If you've used Flow before, the syntax is fairly similar. One difference is that we've added a few restrictions to avoid code that might appear ambiguous.<pre class="language-ts"><code class="language-ts"><span class="token comment">// Is only 'Foo' a type? Or every declaration in the import?</span>
<span class="token comment">// We just give an error because it's not clear.</span>

<span class="token keyword module">import</span> <span class="token keyword">type</span> <span class="token class-name"><span class="token maybe-class-name">Foo</span></span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">Bar</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Baz</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">"some-module"</span><span class="token punctuation">;</span>
<span class="token comment">//     ~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="token comment">// error! A type-only import can specify a default import or named bindings, but not both.</span></code></pre><p>In conjunction with <code>import type</code>, TypeScript 3.8 also adds a new compiler flag to control what happens with imports that won't be utilized at runtime: <a href="/tsconfig#importsNotUsedAsValues"><code>importsNotUsedAsValues</code></a>. This flag takes 3 different values:<ul><li><code>remove</code>: this is today's behavior of dropping these imports. It's going to continue to be the default, and is a non-breaking change.<li><code>preserve</code>: this <em>preserves</em> all imports whose values are never used. This can cause imports/side-effects to be preserved.<li><code>error</code>: this preserves all imports (the same as the <code>preserve</code> option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.</ul><p>For more information about the feature, you can <a href="https://github.com/microsoft/TypeScript/pull/35200">take a look at the pull request</a>, and <a href="https://github.com/microsoft/TypeScript/pull/36092/">relevant changes</a> around broadening where imports from an <code>import type</code> declaration can be used.</section><section id="ecmascript-private-fields"class="level2"><h2>ECMAScript Private Fields</h2><p>TypeScript 3.8 brings support for ECMAScript's private fields, part of the <a href="https://github.com/tc39/proposal-class-fields/">stage-3 class fields proposal</a>.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Person</span></span> <span class="token punctuation">{</span>
  #name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#name</span> <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#name</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> jeremy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">Person</span></span><span class="token punctuation">(</span><span class="token string">"Jeremy Bearimy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

jeremy<span class="token punctuation">.</span><span class="token property-access">#name</span><span class="token punctuation">;</span>
<span class="token comment">//     ~~~~~</span>
<span class="token comment">// Property '#name' is not accessible outside class 'Person'</span>
<span class="token comment">// because it has a private identifier.</span></code></pre><p>Unlike regular properties (even ones declared with the <code>private</code> modifier), private fields have a few rules to keep in mind. Some of them are:<ul><li>Private fields start with a <code>#</code> character. Sometimes we call these <em>private names</em>.<li>Every private field name is uniquely scoped to its containing class.<li>TypeScript accessibility modifiers like <code>public</code> or <code>private</code> can't be used on private fields.<li>Private fields can't be accessed or even detected outside of the containing class - even by JS users! Sometimes we call this <em>hard privacy</em>.</ul><p>Apart from "hard" privacy, another benefit of private fields is that uniqueness we just mentioned. For example, regular property declarations are prone to being overwritten in subclasses.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  foo <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

  <span class="token function">cHelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">foo</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">D</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  foo <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

  <span class="token function">dHelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">foo</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">D</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 'this.foo' refers to the same property on each instance.</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token method function property-access">cHelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints '20'</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token method function property-access">dHelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints '20'</span></code></pre><p>With private fields, you'll never have to worry about this, since each field name is unique to the containing class.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  #foo <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

  <span class="token function">cHelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#foo</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">D</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  #foo <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

  <span class="token function">dHelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#foo</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">D</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 'this.#foo' refers to a different field within each class.</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token method function property-access">cHelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints '10'</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token method function property-access">dHelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints '20'</span></code></pre><p>Another thing worth noting is that accessing a private field on any other type will result in a <code>TypeError</code>!<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">Square</span></span> <span class="token punctuation">{</span>
  #sideLength<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span>sideLength<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#sideLength</span> <span class="token operator">=</span> sideLength<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">equals</span><span class="token punctuation">(</span>other<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#sideLength</span> <span class="token operator">===</span> other<span class="token punctuation">.</span><span class="token property-access">#sideLength</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">Square</span></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> sideLength<span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Boom!</span>
<span class="token comment">// TypeError: attempted to get private field on non-instance</span>
<span class="token comment">// This fails because 'b' is not an instance of 'Square'.</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token method function property-access">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Finally, for any plain <code>.js</code> file users, private fields <em>always</em> have to be declared before they're assigned to.<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
  <span class="token comment">// No declaration for '#foo'</span>
  <span class="token comment">// :(</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">foo</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// SyntaxError!</span>
    <span class="token comment">// '#foo' needs to be declared before writing to it.</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#foo</span> <span class="token operator">=</span> foo<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>JavaScript has always allowed users to access undeclared properties, whereas TypeScript has always required declarations for class properties. With private fields, declarations are always needed regardless of whether we're working in <code>.js</code> or <code>.ts</code> files.<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
  <span class="token doc-comment comment">/** <span class="token keyword">@type</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span> */</span>
  #foo<span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">foo</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// This works.</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">#foo</span> <span class="token operator">=</span> foo<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>For more information about the implementation, you can <a href="https://github.com/Microsoft/TypeScript/pull/30829">check out the original pull request</a><section id="which-should-i-use"class="level3"><h3>Which should I use?</h3><p>We've already received many questions on which type of privates you should use as a TypeScript user: most commonly, "should I use the <code>private</code> keyword, or ECMAScript's hash/pound (<code>#</code>) private fields?" It depends!<p>When it comes to properties, TypeScript's <code>private</code> modifiers are fully erased - that means that at runtime, it acts entirely like a normal property and there's no way to tell that it was declared with a <code>private</code> modifier. When using the <code>private</code> keyword, privacy is only enforced at compile-time/design-time, and for JavaScript consumers it's entirely intent-based.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> foo <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// This is an error at compile time,</span>
<span class="token comment">// but when TypeScript outputs .js files,</span>
<span class="token comment">// it'll run fine and print '10'.</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">foo</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints '10'</span>
<span class="token comment">//                  ~~~</span>
<span class="token comment">// error! Property 'foo' is private and only accessible within class 'C'.</span>

<span class="token comment">// TypeScript allows this at compile-time</span>
<span class="token comment">// as a "work-around" to avoid the error.</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints '10'</span></code></pre><p>The upside is that this sort of "soft privacy" can help your consumers temporarily work around not having access to some API, and also works in any runtime.<p>On the other hand, ECMAScript's <code>#</code> privates are completely inaccessible outside of the class.<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  #foo <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">#foo</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// SyntaxError</span>
<span class="token comment">//                  ~~~~</span>
<span class="token comment">// TypeScript reports an error *and*</span>
<span class="token comment">// this won't work at runtime!</span>

<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">"#foo"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints undefined</span>
<span class="token comment">//          ~~~~~~~~~~~~~~~</span>
<span class="token comment">// TypeScript reports an error under 'noImplicitAny',</span>
<span class="token comment">// and this prints 'undefined'.</span></code></pre><p>This hard privacy is really useful for strictly ensuring that nobody can take use of any of your internals. If you're a library author, removing or renaming a private field should never cause a breaking change.<p>As we mentioned, another benefit is that subclassing can be easier with ECMAScript's <code>#</code> privates because they <em>really</em> are private. When using ECMAScript <code>#</code> private fields, no subclass ever has to worry about collisions in field naming. When it comes to TypeScript's <code>private</code> property declarations, users still have to be careful not to trample over properties declared in superclasses.<p>One more thing to think about is where you intend for your code to run. TypeScript currently can't support this feature unless targeting ECMAScript 2015 (ES6) targets or higher. This is because our downleveled implementation uses <code>WeakMap</code>s to enforce privacy, and <code>WeakMap</code>s can't be polyfilled in a way that doesn't cause memory leaks. In contrast, TypeScript's <code>private</code>-declared properties work with all targets - even ECMAScript 3!<p>A final consideration might be speed: <code>private</code> properties are no different from any other property, so accessing them is as fast as any other property access no matter which runtime you target. In contrast, because <code>#</code> private fields are downleveled using <code>WeakMap</code>s, they may be slower to use. While some runtimes might optimize their actual implementations of <code>#</code> private fields, and even have speedy <code>WeakMap</code> implementations, that might not be the case in all runtimes.</section></section><section id="export--as-ns-syntax"class="level2"><h2><code>export * as ns</code> Syntax</h2><p>It's often common to have a single entry-point that exposes all the members of another module as a single member.<pre class="language-ts"><code class="language-ts"><span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> utilities</span> <span class="token keyword module">from</span> <span class="token string">"./utilities.js"</span><span class="token punctuation">;</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span> utilities <span class="token punctuation">}</span></span><span class="token punctuation">;</span></code></pre><p>This is so common that ECMAScript 2020 recently added a new syntax to support this pattern!<pre class="language-ts"><code class="language-ts"><span class="token keyword module">export</span> <span class="token exports"><span class="token operator">*</span> <span class="token keyword module">as</span> utilities</span> <span class="token keyword module">from</span> <span class="token string">"./utilities.js"</span><span class="token punctuation">;</span></code></pre><p>This is a nice quality-of-life improvement to JavaScript, and TypeScript 3.8 implements this syntax. When your module target is earlier than <code>es2020</code>, TypeScript will output something along the lines of the first code snippet.</section><section id="top-level-await"class="level2"><h2>Top-Level <code>await</code></h2><p>TypeScript 3.8 provides support for a handy upcoming ECMAScript feature called "top-level <code>await</code>".<p>JavaScript users often introduce an <code>async</code> function in order to use <code>await</code>, and then immediately called the function after defining it.<pre class="language-js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> greeting <span class="token operator">=</span> <span class="token keyword control-flow">await</span> response<span class="token punctuation">.</span><span class="token method function property-access">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword control-flow">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This is because previously in JavaScript (along with most other languages with a similar feature), <code>await</code> was only allowed within the body of an <code>async</code> function. However, with top-level <code>await</code>, we can use <code>await</code> at the top level of a module.<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> greeting <span class="token operator">=</span> <span class="token keyword control-flow">await</span> response<span class="token punctuation">.</span><span class="token method function property-access">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Make sure we're a module</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">;</span></code></pre><p>Note there's a subtlety: top-level <code>await</code> only works at the top level of a <em>module</em>, and files are only considered modules when TypeScript finds an <code>import</code> or an <code>export</code>. In some basic cases, you might need to write out <code>export {}</code> as some boilerplate to make sure of this.<p>Top level <code>await</code> may not work in all environments where you might expect at this point. Currently, you can only use top level <code>await</code> when the <a href="/tsconfig#target"><code>target</code></a> compiler option is <code>es2017</code> or above, and <code>module</code> is <code>esnext</code> or <code>system</code>. Support within several environments and bundlers may be limited or may require enabling experimental support.<p>For more information on our implementation, you can <a href="https://github.com/microsoft/TypeScript/pull/35813">check out the original pull request</a>.</section><section id="es2020-for-target-and-module"class="level2"><h2><code>es2020</code> for <code>target</code> and <code>module</code></h2><p>TypeScript 3.8 supports <code>es2020</code> as an option for <code>module</code> and <a href="/tsconfig#target"><code>target</code></a>. This will preserve newer ECMAScript 2020 features like optional chaining, nullish coalescing, <code>export * as ns</code>, and dynamic <code>import(...)</code> syntax. It also means <code>bigint</code> literals now have a stable <a href="/tsconfig#target"><code>target</code></a> below <code>esnext</code>.</section><section id="jsdoc-property-modifiers"class="level2"><h2>JSDoc Property Modifiers</h2><p>TypeScript 3.8 supports JavaScript files by turning on the <a href="/tsconfig#allowJs"><code>allowJs</code></a> flag, and also supports <em>type-checking</em> those JavaScript files via the <a href="/tsconfig#checkJs"><code>checkJs</code></a> option or by adding a <code>// @ts-check</code> comment to the top of your <code>.js</code> files.<p>Because JavaScript files don't have dedicated syntax for type-checking, TypeScript leverages JSDoc. TypeScript 3.8 understands a few new JSDoc tags for properties.<p>First are the accessibility modifiers: <code>@public</code>, <code>@private</code>, and <code>@protected</code>. These tags work exactly like <code>public</code>, <code>private</code>, and <code>protected</code> respectively work in TypeScript.<pre class="language-js"><code class="language-js"><span class="token comment">// @ts-check</span>

<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/** <span class="token keyword">@private</span> */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">stuff</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">printStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">stuff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">stuff</span><span class="token punctuation">;</span>
<span class="token comment">//        ~~~~~</span>
<span class="token comment">// error! Property 'stuff' is private and only accessible within class 'Foo'.</span></code></pre><ul><li><code>@public</code> is always implied and can be left off, but means that a property can be reached from anywhere.<li><code>@private</code> means that a property can only be used within the containing class.<li><code>@protected</code> means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class.</ul><p>Next, we've also added the <code>@readonly</code> modifier to ensure that a property is only ever written to during initialization.<pre class="language-js"><code class="language-js"><span class="token comment">// @ts-check</span>

<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/** <span class="token keyword">@readonly</span> */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">stuff</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">writeToStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">stuff</span> <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
    <span class="token comment">//   ~~~~~</span>
    <span class="token comment">// Cannot assign to 'stuff' because it is a read-only property.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">stuff</span><span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token comment">//        ~~~~~</span>
<span class="token comment">// Cannot assign to 'stuff' because it is a read-only property.</span></code></pre></section><section id="better-directory-watching-on-linux-and-watchoptions"class="level2"><h2>Better Directory Watching on Linux and <code>watchOptions</code></h2><p>TypeScript 3.8 ships a new strategy for watching directories, which is crucial for efficiently picking up changes to <code>node_modules</code>.<p>For some context, on operating systems like Linux, TypeScript installs directory watchers (as opposed to file watchers) on <code>node_modules</code> and many of its subdirectories to detect changes in dependencies. This is because the number of available file watchers is often eclipsed by the of files in <code>node_modules</code>, whereas there are way fewer directories to track.<p>Older versions of TypeScript would <em>immediately</em> install directory watchers on folders, and at startup that would be fine; however, during an npm install, a lot of activity will take place within <code>node_modules</code> and that can overwhelm TypeScript, often slowing editor sessions to a crawl. To prevent this, TypeScript 3.8 waits slightly before installing directory watchers to give these highly volatile directories some time to stabilize.<p>Because every project might work better under different strategies, and this new approach might not work well for your workflows, TypeScript 3.8 introduces a new <code>watchOptions</code> field in <code>tsconfig.json</code> and <code>jsconfig.json</code> which allows users to tell the compiler/language service which watching strategies should be used to keep track of files and directories.<pre class="language-jsonc"><code class="language-jsonc">{
  // Some typical compiler options
  "compilerOptions": {
    "target": "es2020",
    "moduleResolution": "node"
    // ...
  },

  // NEW: Options for file/directory watching
  "watchOptions": {
    // Use native file system events for files and directories
    "watchFile": "useFsEvents",
    "watchDirectory": "useFsEvents",

    // Poll files for updates more frequently
    // when they're updated a lot.
    "fallbackPolling": "dynamicPriority"
  }
}</code></pre><p><code>watchOptions</code> contains 4 new options that can be configured:<ul><li><p><a href="/tsconfig#watchFile"><code>watchFile</code></a>: the strategy for how individual files are watched. This can be set to<ul><li><code>fixedPollingInterval</code>: Check every file for changes several times a second at a fixed interval.<li><code>priorityPollingInterval</code>: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.<li><code>dynamicPriorityPolling</code>: Use a dynamic queue where less-frequently modified files will be checked less often.<li><code>useFsEvents</code> (the default): Attempt to use the operating system/file system's native events for file changes.<li><code>useFsEventsOnParentDirectory</code>: Attempt to use the operating system/file system's native events to listen for changes on a file's containing directories. This can use fewer file watchers, but might be less accurate.</ul><li><p><a href="/tsconfig#watchDirectory"><code>watchDirectory</code></a>: the strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality. This can be set to:<ul><li><code>fixedPollingInterval</code>: Check every directory for changes several times a second at a fixed interval.<li><code>dynamicPriorityPolling</code>: Use a dynamic queue where less-frequently modified directories will be checked less often.<li><code>useFsEvents</code> (the default): Attempt to use the operating system/file system's native events for directory changes.</ul><li><p><a href="/tsconfig#fallbackPolling"><code>fallbackPolling</code></a>: when using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn't support native file watchers. This can be set to<ul><li><code>fixedPollingInterval</code>: <em>(See above.)</em><li><code>priorityPollingInterval</code>: <em>(See above.)</em><li><code>dynamicPriorityPolling</code>: <em>(See above.)</em><li><code>synchronousWatchDirectory</code>: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in <code>node_modules</code> from running <code>npm install</code>), but you might want to disable it with this flag for some less-common setups.</ul></ul><p>For more information on these changes, <a href="https://github.com/microsoft/TypeScript/pull/35615">head over to GitHub to see the pull request</a> to read more.</section><section id="fast-and-loose-incremental-checking"class="level2"><h2>"Fast and Loose" Incremental Checking</h2><p>TypeScript 3.8 introduces a new compiler option called <a href="/tsconfig#assumeChangesOnlyAffectDirectDependencies"><code>assumeChangesOnlyAffectDirectDependencies</code></a>. When this option is enabled, TypeScript will avoid rechecking/rebuilding all truly possibly-affected files, and only recheck/rebuild files that have changed as well as files that directly import them.<p>For example, consider a file <code>fileD.ts</code> that imports <code>fileC.ts</code> that imports <code>fileB.ts</code> that imports <code>fileA.ts</code> as follows:<pre class="language-text"><code class="language-text">fileA.ts &#x3C;- fileB.ts &#x3C;- fileC.ts &#x3C;- fileD.ts</code></pre><p>In <code>--watch</code> mode, a change in <code>fileA.ts</code> would typically mean that TypeScript would need to at least re-check <code>fileB.ts</code>, <code>fileC.ts</code>, and <code>fileD.ts</code>. Under <a href="/tsconfig#assumeChangesOnlyAffectDirectDependencies"><code>assumeChangesOnlyAffectDirectDependencies</code></a>, a change in <code>fileA.ts</code> means that only <code>fileA.ts</code> and <code>fileB.ts</code> need to be re-checked.<p>In a codebase like Visual Studio Code, this reduced rebuild times for changes in certain files from about 14 seconds to about 1 second. While we don't necessarily recommend this option for all codebases, you might be interested if you have an extremely large codebase and are willing to defer full project errors until later (e.g. a dedicated build via a <code>tsconfig.fullbuild.json</code> or in CI).<p>For more details, you can <a href="https://github.com/microsoft/TypeScript/pull/35711">see the original pull request</a>. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section>