<!doctype html><html lang="en"><meta charset="utf-8"><title>Do's and Don'ts</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="layout"content="docs"><meta name="permalink"content="/docs/handbook/declaration-files/do-s-and-don-ts.html"><meta name="oneline"content="Recommendations for writing d.ts files"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="general-types"class="level2"><h2>General Types</h2></section><section id="number-string-boolean-symbol-and-object"class="level2"><h2><code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>Symbol</code> and <code>Object</code></h2><p>❌ <strong>Don't</strong> ever use the types <code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>Symbol</code>, or <code>Object</code> These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code.<pre class="language-ts"><code class="language-ts"><span class="token comment">/* WRONG */</span>
<span class="token keyword">function</span> <span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token known-class-name class-name">String</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token known-class-name class-name">String</span><span class="token punctuation">;</span></code></pre><p>✅ <strong>Do</strong> use the types <code>number</code>, <code>string</code>, <code>boolean</code>, and <code>symbol</code>.<pre class="language-ts"><code class="language-ts"><span class="token comment">/* OK */</span>
<span class="token keyword">function</span> <span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span></code></pre><p>Instead of <code>Object</code>, use the non-primitive <code>object</code> type (<a href="../release-notes/typescript-2-2.html#object-type">added in TypeScript 2.2</a>).</section><section id="generics"class="level2"><h2>Generics</h2><p>❌ <strong>Don't</strong> ever have a generic type which doesn't use its type parameter. See more details in <a href="https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot--">TypeScript FAQ page</a>.</section><section id="any"class="level2"><h2>any</h2><p>❌ <strong>Don't</strong> use <code>any</code> as a type unless you are in the process of migrating a JavaScript project to TypeScript. The compiler <em>effectively</em> treats <code>any</code> as "please turn off type checking for this thing". It is similar to putting an <code>@ts-ignore</code> comment around every usage of the variable. This can be very helpful when you are first migrating a JavaScript project to TypeScript as you can set the type for stuff you haven't migrated yet as <code>any</code>, but in a full TypeScript project you are disabling type checking for any parts of your program that use it.<p>In cases where you don't know what type you want to accept, or when you want to accept anything because you will be blindly passing it through without interacting with it, you can use <a href="/play/#example/unknown-and-never"><code>unknown</code></a>.</section><section id="callback-types"class="level2"><h2>Callback Types</h2></section><section id="return-types-of-callbacks"class="level2"><h2>Return Types of Callbacks</h2><p>❌ <strong>Don't</strong> use the return type <code>any</code> for callbacks whose value will be ignored:<pre class="language-ts"><code class="language-ts"><span class="token comment">/* WRONG */</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token function-variable function">x</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>✅ <strong>Do</strong> use the return type <code>void</code> for callbacks whose value will be ignored:<pre class="language-ts"><code class="language-ts"><span class="token comment">/* OK */</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token function-variable function">x</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>❔ <strong>Why:</strong> Using <code>void</code> is safer because it prevents you from accidentally using the return value of <code>x</code> in an unchecked way:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token function-variable function">x</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// oops! meant to do something else</span>
  k<span class="token punctuation">.</span><span class="token method function property-access">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error, but would be OK if the return type had been 'any'</span>
<span class="token punctuation">}</span></code></pre></section><section id="optional-parameters-in-callbacks"class="level2"><h2>Optional Parameters in Callbacks</h2><p>❌ <strong>Don't</strong> use optional parameters in callbacks unless you really mean it:<pre class="language-ts"><code class="language-ts"><span class="token comment">/* WRONG */</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Fetcher</span></span> <span class="token punctuation">{</span>
  <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token function-variable function">done</span><span class="token operator">:</span> <span class="token punctuation">(</span>data<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">,</span> elapsedTime<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>This has a very specific meaning: the <code>done</code> callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the <code>elapsedTime</code> parameter, but there's no need to make the parameter optional to accomplish this -- it's always legal to provide a callback that accepts fewer arguments.<p>✅ <strong>Do</strong> write callback parameters as non-optional:<pre class="language-ts"><code class="language-ts"><span class="token comment">/* OK */</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Fetcher</span></span> <span class="token punctuation">{</span>
  <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token function-variable function">done</span><span class="token operator">:</span> <span class="token punctuation">(</span>data<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">,</span> elapsedTime<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></section><section id="overloads-and-callbacks"class="level2"><h2>Overloads and Callbacks</h2><p>❌ <strong>Don't</strong> write separate overloads that differ only on callback arity:<pre class="language-ts"><code class="language-ts"><span class="token comment">/* WRONG */</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">beforeAll</span><span class="token punctuation">(</span><span class="token function-variable function">action</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">,</span> timeout<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">beforeAll</span><span class="token punctuation">(</span>
  <span class="token function-variable function">action</span><span class="token operator">:</span> <span class="token punctuation">(</span>done<span class="token operator">:</span> <span class="token maybe-class-name">DoneFn</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">,</span>
  timeout<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span></code></pre><p>✅ <strong>Do</strong> write a single overload using the maximum arity:<pre class="language-ts"><code class="language-ts"><span class="token comment">/* OK */</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">beforeAll</span><span class="token punctuation">(</span>
  <span class="token function-variable function">action</span><span class="token operator">:</span> <span class="token punctuation">(</span>done<span class="token operator">:</span> <span class="token maybe-class-name">DoneFn</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">,</span>
  timeout<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span></code></pre><p>❔ <strong>Why:</strong> It's always legal for a callback to disregard a parameter, so there's no need for the shorter overload. Providing a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload.</section><section id="function-overloads"class="level2"><h2>Function Overloads</h2></section><section id="ordering"class="level2"><h2>Ordering</h2><p>❌ <strong>Don't</strong> put more general overloads before more specific overloads:<pre class="language-ts"><code class="language-ts"><span class="token comment">/* WRONG */</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token maybe-class-name">HTMLElement</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token maybe-class-name">HTMLDivElement</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> myElem<span class="token operator">:</span> <span class="token maybe-class-name">HTMLDivElement</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span>myElem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// x: unknown, wat?</span></code></pre><p>✅ <strong>Do</strong> sort overloads by putting the more general signatures after more specific signatures:<pre class="language-ts"><code class="language-ts"><span class="token comment">/* OK */</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token maybe-class-name">HTMLDivElement</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token maybe-class-name">HTMLElement</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> myElem<span class="token operator">:</span> <span class="token maybe-class-name">HTMLDivElement</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span>myElem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// x: string, :)</span></code></pre><p>❔ <strong>Why:</strong> TypeScript chooses the <em>first matching overload</em> when resolving function calls. When an earlier overload is "more general" than a later one, the later one is effectively hidden and cannot be called.</section><section id="use-optional-parameters"class="level2"><h2>Use Optional Parameters</h2><p>❌ <strong>Don't</strong> write several overloads that differ only in trailing parameters:<pre class="language-ts"><code class="language-ts"><span class="token comment">/* WRONG */</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Example</span></span> <span class="token punctuation">{</span>
  <span class="token function">diff</span><span class="token punctuation">(</span>one<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token function">diff</span><span class="token punctuation">(</span>one<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> two<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token function">diff</span><span class="token punctuation">(</span>one<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> two<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> three<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>✅ <strong>Do</strong> use optional parameters whenever possible:<pre class="language-ts"><code class="language-ts"><span class="token comment">/* OK */</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Example</span></span> <span class="token punctuation">{</span>
  <span class="token function">diff</span><span class="token punctuation">(</span>one<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> two<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> three<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Note that this collapsing should only occur when all overloads have the same return type.<p>❔ <strong>Why:</strong> This is important for two reasons.<p>TypeScript resolves signature compatibility by seeing if any signature of the target can be invoked with the arguments of the source, <em>and extraneous arguments are allowed</em>. This code, for example, exposes a bug only when the signature is correctly written using optional parameters:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token function-variable function">x</span><span class="token operator">:</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> c<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> x<span class="token operator">:</span> <span class="token maybe-class-name">Example</span><span class="token punctuation">;</span>
<span class="token comment">// When written with overloads, OK -- used first overload</span>
<span class="token comment">// When written with optionals, correctly an error</span>
<span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token property-access">diff</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The second reason is when a consumer uses the "strict null checking" feature of TypeScript. Because unspecified parameters appear as <code>undefined</code> in JavaScript, it's usually fine to pass an explicit <code>undefined</code> to a function with optional arguments. This code, for example, should be OK under strict nulls:<pre class="language-ts"><code class="language-ts"><span class="token keyword">var</span> x<span class="token operator">:</span> <span class="token maybe-class-name">Example</span><span class="token punctuation">;</span>
<span class="token comment">// When written with overloads, incorrectly an error because of passing 'undefined' to 'string'</span>
<span class="token comment">// When written with optionals, correctly OK</span>
x<span class="token punctuation">.</span><span class="token method function property-access">diff</span><span class="token punctuation">(</span><span class="token string">"something"</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token operator">?</span> <span class="token keyword nil">undefined</span> <span class="token operator">:</span> <span class="token string">"hour"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section><section id="use-union-types"class="level2"><h2>Use Union Types</h2><p>❌ <strong>Don't</strong> write overloads that differ by type in only one argument position:<pre class="language-ts"><code class="language-ts"><span class="token comment">/* WRONG */</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Moment</span></span> <span class="token punctuation">{</span>
  <span class="token function">utcOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token function">utcOffset</span><span class="token punctuation">(</span>b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Moment</span><span class="token punctuation">;</span>
  <span class="token function">utcOffset</span><span class="token punctuation">(</span>b<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Moment</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>✅ <strong>Do</strong> use union types whenever possible:<pre class="language-ts"><code class="language-ts"><span class="token comment">/* OK */</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token maybe-class-name">Moment</span></span> <span class="token punctuation">{</span>
  <span class="token function">utcOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token function">utcOffset</span><span class="token punctuation">(</span>b<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Moment</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Note that we didn't make <code>b</code> optional here because the return types of the signatures differ.<p>❔ <strong>Why:</strong> This is important for people who are "passing through" a value to your function:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// When written with separate overloads, incorrectly an error</span>
  <span class="token comment">// When written with union types, correctly OK</span>
  <span class="token keyword control-flow">return</span> <span class="token function">moment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">utcOffset</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section>