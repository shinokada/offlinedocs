<!doctype html><html lang="en"><meta charset="utf-8"><title>Security</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="sidebar_position"content="2"><link rel="stylesheet"href="../../../../../../../Vivliostyle/read-html-download-pdf/docs/themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="security"><h1 id="security">Security</h1><p>This guide seeks to explain the high-level concepts and security features at the core of Tauri's design that make you, your apps, and your users safer by default.<blockquote>Note<p>While we take every opportunity to help you harden your application - there are always underlying threats like BIOS attacks, memory rowhammering and other operating system vulnerabilities that are constantly being discovered and (in the best cases) responsibly disclosed.<p>Furthermore, there are many ways that development teams can cut corners and either leak sensitive information or leave doors wide open to any of a range of attacks. Security is a never-ending quest, and your users count on you to keep them safe.<p>Therefore, we highly recommend that you take some time to consider the security ramifications of everything that your application does, especially in the context of running on the semi-hostile platform of end-user devices.<p>If you need help or want a review, you are welcome to contact the Tauri team for security consultation.</blockquote><section class="level2"aria-labelledby="security-researchers"><h2 id="security-researchers">Security Researchers</h2><p>If you feel that there is a security concern or issue with anything in Tauri, please do not publicly comment on your findings. Instead, reach out directly to our security team: <a href="mailto:security@tauri.app">security@tauri.app</a><p>Although we do not currently have a budget for Security Bounties, in some cases, we will consider rewarding responsible disclosure with our limited resources.</section><section class="level2"aria-labelledby="no-server-required"><h2 id="no-server-required">No Server Required</h2><p>Tauri enables you to construct an application that uses web technology for the user interface without requiring you to use a server to communicate with the backend. Even if you used advanced techniques of dynamic imports and offload work to the backend, no traffic can be sniffed on TCP ports or external processes - because they aren't there. This reduces not only the physical and virtual footprint of your final binary by a good deal, but it also reduces the surface area of potential attack vectors by removing them from the equation.</section><section class="level2"aria-labelledby="language-features-of-rust"><h2 id="language-features-of-rust">Language Features of Rust</h2><p>By turning to the programming language renowned for its memory safety and speed, Tauri simply erases whole classes of conventional attacks. Use after free just isn't something that can happen with Tauri.</section><section class="level2"aria-labelledby="dynamic-ahead-of-time-compilation-aot"><h2 id="dynamic-ahead-of-time-compilation-aot">Dynamic Ahead of Time Compilation (AOT)</h2><p>This compilation process happens several times during the bootstrapping phase of a Tauri app. Using our default dynamic Ahead of Time compiler, you can generate code references that are unique for every session and are still technically static code units.</section><section class="level2"aria-labelledby="function-hardening"><h2 id="function-hardening">Function Hardening</h2><section class="level3"aria-labelledby="functional-aslr"><h3 id="functional-aslr">Functional ASLR</h3><p>Functional address Space Layout Randomization techniques randomize function names at runtime and can implement OTP hashing, so no two sessions are ever the same. We propose a novel type of function naming at boot time and optionally after every execution. Using a UID for each function pointer prevents static attacks.</section><section class="level3"aria-labelledby="kamikaze-function-injection"><h3 id="kamikaze-function-injection">Kamikaze Function Injection</h3><p>This advanced type of fASLR using the <code>EVENT</code> API endpoint is a promise wrapped in a closure (with randomized handle) that Rust inserts at runtime into the WebView, where its interface is locked within the promise resolution handler and is nulled after execution.</section><section class="level3"aria-labelledby="bridge-dont-serve"><h3 id="bridge-dont-serve">Bridge, don't serve</h3><p>Instead of passing potentially unsafe functions, an event bridge can be used to pass messages and commands to named brokers at each respective side of the application.</section><section class="level3"aria-labelledby="one-time-pad-tokenization-and-hashing"><h3 id="one-time-pad-tokenization-and-hashing">One Time Pad Tokenization and Hashing</h3><p>Hashing important messages with an OTP salt, you are able to encrypt messages between the user interface and the Rust backend. We are currently investigating the use of additional sources of entropy, such as the amazing <a href="https://13-37.org/en/shop/infinite-noise-trng/">Infinite Noise TRNG</a>.</section></section><section class="level2"aria-labelledby="system-features"><h2 id="system-features">System Features</h2><section class="level3"aria-labelledby="allowing-api"><h3 id="allowing-api">Allowing API</h3><p>You have the ability to pick and choose which API functions are available to the UI and to Rust. If they are not enabled, the code will not be shipped with your app, which reduces binary size and attack surface. They are opt-in, so you have to consciously choose to progressively enhance your application.</section><section class="level3"aria-labelledby="content-security-policy-management"><h3 id="content-security-policy-management">Content Security Policy Management</h3><p>Preventing unauthorized code execution for websites has long since been resolved by using CSPs. Tauri can inject CSPs into the <code>index.html</code> of the user interface, and when using a localhost server, it will also send these headers to the UI or any other clients that connect with it.</section><section class="level3"aria-labelledby="decompilation-is-difficult"><h3 id="decompilation-is-difficult">Decompilation is Difficult</h3><p>This means that your apps cannot be easily decompiled, as is the case with Electron ASAR files, which makes the process of reverse engineering your project much more time-intensive and requires specialist training.</section></section><section class="level2"aria-labelledby="ecosystem"><h2 id="ecosystem">Ecosystem</h2><section class="level3"aria-labelledby="build-pipelines-and-artifact-authenticity"><h3 id="build-pipelines-and-artifact-authenticity">Build Pipelines and Artifact Authenticity</h3><p>The process of releasing our source-code artifacts is highly automated yet mandates kickoff and review from real humans. Our current release strategy uses a combination of GitHub Actions and IOTA Tangle publication</section><section class="level3"aria-labelledby="resilient-pr-and-approval-processes"><h3 id="resilient-pr-and-approval-processes">Resilient PR and Approval Processes</h3><p>Our WG-TECH reviews code changes, tags PRs with scope, and makes sure that everything stays up to date. And when its time to publish a new version, one of the maintainers tags a new release on dev, which:<ul><li>Validates core<li>Runs smoke tests<li>Audits security for crates and npm<li>Generates changelogs<li>Creates artifacts<li>Publishes checksums to IOTA<li>Creates a draft release</ul><p>Then the maintainer reviews the release notes, edits if necessary, and a new release is forged.</section></section><section class="level2"aria-labelledby="future-work"><h2 id="future-work">Future Work</h2><section class="level3"aria-labelledby="signed-binaries"><h3 id="signed-binaries">Signed Binaries</h3><p>Because the entire project is shipped within a monolithic binary, code can be signed for all distributables. (Currently using external tooling, but we are actively working on making the bundler a one-stop-shop.) This makes it virtually impossible for hackers to change an installed Application without the operating system noticing. <a href="https://github.com/electron/asar/issues/123">Reference</a></section><section class="level3"aria-labelledby="post-binary-analysis"><h3 id="post-binary-analysis">Post-Binary Analysis</h3><p>Use industrial-grade pentester-tooling (via our forthcoming Tauri-Frida GUI) to discover and fix security weaknesses in your final binaries.</section><section class="level3"aria-labelledby="post-binary-enhancement"><h3 id="post-binary-enhancement">Post-Binary Enhancement</h3><p>After the build is before the delivery and Tauri will provide you with tools never seen before. Stay tuned!</section><section class="level3"aria-labelledby="audits"><h3 id="audits">Audits</h3><p>We are currently in the process of our first external audit. When complete, we will publish the results here. <span style="float:footnote"><a href="../../index.html#toc">Go to TOC</a></span></section></section></section>