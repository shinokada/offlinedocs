<!doctypehtml><html lang="en"><meta charset="utf-8"><title>Page options</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="page-options"class="level1"><h1>Page options</h1><p>By default, SvelteKit will render (or <a href="../60-appendix/30-glossary.html#prerendering">prerender</a>) any component first on the server and send it to the client as HTML. It will then render the component again in the browser to make it interactive in a process called <strong>hydration</strong>. For this reason, you need to ensure that components can run in both places. SvelteKit will then initialize a <a href="../20-core-concepts/10-routing.html"><strong>router</strong></a> that takes over subsequent navigations.<p>You can control each of these on a page-by-page basis by exporting options from <a href="../20-core-concepts/10-routing.html#page-page-js"><code>+page.js</code></a> or <a href="../20-core-concepts/10-routing.html#page-page-server-js"><code>+page.server.js</code></a>, or for groups of pages using a shared <a href="../20-core-concepts/10-routing.html#layout-layout-js"><code>+layout.js</code></a> or <a href="../20-core-concepts/10-routing.html#layout-layout-server-js"><code>+layout.server.js</code></a>. To define an option for the whole app, export it from the root layout. Child layouts and pages override values set in parent layouts, so — for example — you can enable prerendering for your entire app then disable it for pages that need to be dynamically rendered.<p>You can mix and match these options in different areas of your app. For example you could prerender your marketing page for maximum speed, server-render your dynamic pages for SEO and accessibility and turn your admin section into an SPA by rendering it on the client only. This makes SvelteKit very versatile.<section id="prerender"class="level2"><h2>prerender</h2><p>It's likely that at least some routes of your app can be represented as a simple HTML file generated at build time. These routes can be <a href="../60-appendix/30-glossary.html#prerendering"><em>prerendered</em></a>.<pre class="language-js"><code class="language-js"><span class="token comment">/// file: +page.js/+page.server.js/+server.js</span>
<span class="token keyword module">export</span> <span class="token keyword">const</span> prerender <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre><p>Alternatively, you can set <code>export const prerender = true</code> in your root <code>+layout.js</code> or <code>+layout.server.js</code> and prerender everything except pages that are explicitly marked as <em>not</em> prerenderable:<pre class="language-js"><code class="language-js"><span class="token comment">/// file: +page.js/+page.server.js/+server.js</span>
<span class="token keyword module">export</span> <span class="token keyword">const</span> prerender <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></code></pre><p>Routes with <code>prerender = true</code> will be excluded from manifests used for dynamic SSR, making your server (or serverless/edge functions) smaller. In some cases you might want to prerender a route but also include it in the manifest (for example, with a route like <code>/blog/[slug]</code> where you want to prerender your most recent/popular content but server-render the long tail) — for these cases, there's a third option, 'auto':<pre class="language-js"><code class="language-js"><span class="token comment">/// file: +page.js/+page.server.js/+server.js</span>
<span class="token keyword module">export</span> <span class="token keyword">const</span> prerender <span class="token operator">=</span> <span class="token string">'auto'</span><span class="token punctuation">;</span></code></pre><blockquote><p>If your entire app is suitable for prerendering, you can use <a href="https://github.com/sveltejs/kit/tree/master/packages/adapter-static"><code>adapter-static</code></a>, which will output files suitable for use with any static webserver.</blockquote><p>The prerenderer will start at the root of your app and generate files for any prerenderable pages or <code>+server.js</code> routes it finds. Each page is scanned for <code>&#x3C;a></code> elements that point to other pages that are candidates for prerendering — because of this, you generally don't need to specify which pages should be accessed. If you <em>do</em> need to specify which pages should be accessed by the prerenderer, you can do so with the <code>entries</code> option in the <a href="../50-api-reference/10-configuration.html#prerender">prerender configuration</a>.<p>While prerendering, the value of <code>building</code> imported from <a href="../50-api-reference/30-modules.html#$app-environment"><code>$app/environment</code></a> will be <code>true</code>.<section id="prerendering-server-routes"class="level3"><h3>Prerendering server routes</h3><p>Unlike the other page options, <code>prerender</code> also applies to <code>+server.js</code> files. These files are <em>not</em> affected from layouts, but will inherit default values from the pages that fetch data from them, if any. For example if a <code>+page.js</code> contains this <code>load</code> function...<pre class="language-js"><code class="language-js"><span class="token comment">/// file: +page.js</span>
<span class="token keyword module">export</span> <span class="token keyword">const</span> prerender <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/** <span class="token keyword">@type</span> <span class="token class-name"><span class="token punctuation">{</span><span class="token keyword module">import</span><span class="token punctuation">(</span><span class="token string">'./$types'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>PageLoad<span class="token punctuation">}</span></span> */</span>
<span class="token keyword module">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> fetch <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/my-server-route.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword control-flow">return</span> <span class="token keyword control-flow">await</span> res<span class="token punctuation">.</span><span class="token method function property-access">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>...then <code>src/routes/my-server-route.json/+server.js</code> will be treated as prerenderable if it doesn't contain its own <code>export const prerender = false</code>.</section><section id="when-not-to-prerender"class="level3"><h3>When not to prerender</h3><p>The basic rule is this: for a page to be prerenderable, any two users hitting it directly must get the same content from the server.<blockquote><p>Not all pages are suitable for prerendering. Any content that is prerendered will be seen by all users. You can of course fetch personalized data in <code>onMount</code> in a prerendered page, but this may result in a poorer user experience since it will involve blank initial content or loading indicators.</blockquote><p>Note that you can still prerender pages that load data based on the page's parameters, such as a <code>src/routes/blog/[slug]/+page.svelte</code> route.<p>Accessing <a href="../20-core-concepts/20-load.html#using-url-data-url"><code>url.searchParams</code></a> during prerendering is forbidden. If you need to use it, ensure you are only doing so in the browser (for example in <code>onMount</code>).<p>Pages with <a href="../20-core-concepts/30-form-actions.html">actions</a> cannot be prerendered, because a server must be able to handle the action <code>POST</code> requests.</section><section id="route-conflicts"class="level3"><h3>Route conflicts</h3><p>Because prerendering writes to the filesystem, it isn't possible to have two endpoints that would cause a directory and a file to have the same name. For example, <code>src/routes/foo/+server.js</code> and <code>src/routes/foo/bar/+server.js</code> would try to create <code>foo</code> and <code>foo/bar</code>, which is impossible.<p>For that reason among others, it's recommended that you always include a file extension — <code>src/routes/foo.json/+server.js</code> and <code>src/routes/foo/bar.json/+server.js</code> would result in <code>foo.json</code> and <code>foo/bar.json</code> files living harmoniously side-by-side.<p>For <em>pages</em>, we skirt around this problem by writing <code>foo/index.html</code> instead of <code>foo</code>.<p>Note that this will disable client-side routing for any navigation from this page, regardless of whether the router is already active.</section><section id="troubleshooting"class="level3"><h3>Troubleshooting</h3><p>If you encounter an error like 'The following routes were marked as prerenderable, but were not prerendered' it's because the route in question (or a parent layout, if it's a page) has <code>export const prerender = true</code> but the page wasn't actually prerendered, because it wasn't reached by the prerendering crawler.<p>Since these routes cannot be dynamically server-rendered, this will cause errors when people try to access the route in question. There are two ways to fix it:<ul><li>Ensure that SvelteKit can find the route by following links from <a href="../50-api-reference/10-configuration.html#prerender"><code>config.kit.prerender.entries</code></a>. Add links to dynamic routes (i.e. pages with <code>[parameters]</code> ) to this option if they are not found through crawling the other entry points, else they are not prerendered because SvelteKit doesn't know what value the parameters should have. Pages not marked as prerenderable will be ignored and their links to other pages will not be crawled, even if some of them would be prerenderable.<li>Change <code>export const prerender = true</code> to <code>export const prerender = 'auto'</code>. Routes with <code>'auto'</code> can be dynamically server rendered</ul></section></section><section id="ssr"class="level2"><h2>ssr</h2><p>Normally, SvelteKit renders your page on the server first and sends that HTML to the client where it's hydrated. If you set <code>ssr</code> to <code>false</code>, it renders an empty 'shell' page instead. This is useful if your page is unable to be rendered on the server (because you use browser-only globals like <code>document</code> for example), but in most situations it's not recommended (<a href="../60-appendix/30-glossary.html#ssr">see appendix</a>).<pre class="language-js"><code class="language-js"><span class="token comment">/// file: +page.js</span>
<span class="token keyword module">export</span> <span class="token keyword">const</span> ssr <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></code></pre><p>If you add <code>export const ssr = false</code> to your root <code>+layout.js</code>, your entire app will only be rendered on the client — which essentially means you turn your app into an SPA.</section><section id="csr"class="level2"><h2>csr</h2><p>Ordinarily, SvelteKit <a href="../60-appendix/30-glossary.html#hydration">hydrates</a> your server-rendered HTML into an interactive client-side-rendered (CSR) page. Some pages don't require JavaScript at all — many blog posts and 'about' pages fall into this category. In these cases you can disable CSR:<pre class="language-js"><code class="language-js"><span class="token comment">/// file: +page.js</span>
<span class="token keyword module">export</span> <span class="token keyword">const</span> csr <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></code></pre><blockquote><p>If both <code>ssr</code> and <code>csr</code> are <code>false</code>, nothing will be rendered!</blockquote></section><section id="trailingslash"class="level2"><h2>trailingSlash</h2><p>By default, SvelteKit will remove trailing slashes from URLs — if you visit <code>/about/</code>, it will respond with a redirect to <code>/about</code>. You can change this behaviour with the <code>trailingSlash</code> option, which can be one of <code>'never'</code> (the default), <code>'always'</code>, or <code>'ignore'</code>.<p>As with other page options, you can export this value from a <code>+layout.js</code> or a <code>+layout.server.js</code> and it will apply to all child pages. You can also export the configuration from <code>+server.js</code> files.<pre class="language-js"><code class="language-js"><span class="token comment">/// file: src/routes/+layout.js</span>
<span class="token keyword module">export</span> <span class="token keyword">const</span> trailingSlash <span class="token operator">=</span> <span class="token string">'always'</span><span class="token punctuation">;</span></code></pre><p>This option also affects <a href="#prerender">prerendering</a>. If <code>trailingSlash</code> is <code>always</code>, a route like <code>/about</code> will result in an <code>about/index.html</code> file, otherwise it will create <code>about.html</code>, mirroring static webserver conventions.<blockquote><p>Ignoring trailing slashes is not recommended — the semantics of relative paths differ between the two cases (<code>./y</code> from <code>/x</code> is <code>/y</code>, but from <code>/x/</code> is <code>/x/y</code>), and <code>/x</code> and <code>/x/</code> are treated as separate URLs which is harmful to SEO.<span style="float:footnote"><a href="../../index.html#toc">Go to TOC</a></span></blockquote></section></section>