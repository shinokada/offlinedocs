<!doctype html><html lang="en"><meta charset="utf-8"><title>Performance</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="performance"><h1 id="performance">Performance</h1><p>While Vite is fast by default, performance issues can creep in as the project's requirements grow. This guide aims to help you identify and fix common performance issues, such as:<ul><li>Slow server starts<li>Slow page loads<li>Slow builds</ul><section class="level2"aria-labelledby="audit-configured-vite-plugins"><h2 id="audit-configured-vite-plugins">Audit Configured Vite Plugins</h2><p>Vite's internal and official plugins are optimized to do the least amount of work possible while providing compatibility with the broader ecosystem. For example, code transformations use regex in dev, but do a complete parse in build to ensure correctness.<p>However, the performance of community plugins is out of Vite's control, which may affect the developer experience. Here are a few things you can look out for when using additional Vite plugins:<ol><li><p>Large dependencies that are only used in certain cases should be dynamically imported to reduce the Node.js startup time. Example refactors: <a href="https://github.com/vitejs/vite-plugin-react/pull/212">vite-plugin-react#212</a> and <a href="https://github.com/vite-pwa/vite-plugin-pwa/pull/244">vite-plugin-pwa#224</a>.<li><p>The <code>buildStart</code>, <code>config</code>, and <code>configResolved</code> hooks should not run long and extensive operations. These hooks are awaited during dev server startup, which delays when you can access the site in the browser.<li><p>The <code>resolveId</code>, <code>load</code>, and <code>transform</code> hooks may cause some files to load slower than others. While sometimes unavoidable, it's still worth checking for possible areas to optimize. For example, checking if the <code>code</code> contains a specific keyword, or the <code>id</code> matches a specific extension, before doing the full transformation.<p>The longer it takes to transform a file, the more significant the request waterfall will be when loading the site in the browser.<p>You can inspect the duration it takes to transform a file using <code>DEBUG="vite:plugin-transform" vite</code> or <a href="https://github.com/antfu/vite-plugin-inspect">vite-plugin-inspect</a>. Note that as asynchronous operations tend to provide inaccurate timings, you should treat the numbers as a rough estimate, but it should still reveal the more expensive operations.</ol>tip Profiling You can run `vite --profile`, visit the site, and press `p + enter` in your terminal to record a `.cpuprofile`. A tool like [speedscope](https://www.speedscope.app) can then be used to inspect the profile and identify the bottlenecks. You can also [share the profiles](https://chat.vitejs.dev) with the Vite team to help us identify performance issues.</section><section class="level2"aria-labelledby="reduce-resolve-operations"><h2 id="reduce-resolve-operations">Reduce Resolve Operations</h2><p>Resolving import paths can be an expensive operation when hitting its worst case often. For example, Vite supports "guessing" import paths with the <a href="/config/shared-options.md#resolve-extensions"><code>resolve.extensions</code></a> option, which defaults to <code>['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']</code>.<p>When you try to import <code>./Component.jsx</code> with <code>import './Component'</code>, Vite will run these steps to resolve it:<ol><li>Check if <code>./Component</code> exists, no.<li>Check if <code>./Component.mjs</code> exists, no.<li>Check if <code>./Component.js</code> exists, no.<li>Check if <code>./Component.mts</code> exists, no.<li>Check if <code>./Component.ts</code> exists, no.<li>Check if <code>./Component.jsx</code> exists, yes!</ol><p>As shown, a total of 6 filesystem checks is required to resolve an import path. The more implicit imports you have, the more time it adds up to resolve the paths.<p>Hence, it's usually better to be explicit with your import paths, e.g. <code>import './Component.jsx'</code>. You can also narrow down the list for <code>resolve.extensions</code> to reduce the general filesystem checks, but you have to make sure it works for files in <code>node_modules</code> too.<p>If you're a plugin author, make sure to only call <a href="https://rollupjs.org/plugin-development/#this-resolve"><code>this.resolve</code></a> when needed to reduce the number of checks above.</p>tip TypeScript If you are using TypeScript, enable `"moduleResolution": "bundler"` and `"allowImportingTsExtensions": true` in your `tsconfig.json`'s `compilerOptions` to use `.ts` and `.tsx` extensions directly in your code.</section><section class="level2"aria-labelledby="avoid-barrel-files"><h2 id="avoid-barrel-files">Avoid Barrel Files</h2><p>Barrel files are files that re-export the APIs of other files in the same directory. For example:<pre class="language-js"><code class="language-js"><span class="token comment">// src/utils/index.js</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token operator">*</span></span> <span class="token keyword module">from</span> <span class="token string">'./color.js'</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token operator">*</span></span> <span class="token keyword module">from</span> <span class="token string">'./dom.js'</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token operator">*</span></span> <span class="token keyword module">from</span> <span class="token string">'./slash.js'</span></code></pre><p>When you only import an individual API, e.g. <code>import { slash } from './utils'</code>, all the files in that barrel file need to be fetched and transformed as they may contain the <code>slash</code> API and may also contain side-effects that run on initialization. This means you're loading more files than required on the initial page load, resulting in a slower page load.<p>If possible, you should avoid barrel files and import the individual APIs directly, e.g. <code>import { slash } from './utils/slash.js'</code>. You can read <a href="https://github.com/vitejs/vite/issues/8237">issue #8237</a> for more information.</section><section class="level2"aria-labelledby="warm-up-frequently-used-files"><h2 id="warm-up-frequently-used-files">Warm Up Frequently Used Files</h2><p>The Vite dev server only transforms files as requested by the browser, which allows it to start up quickly and only apply transformations for used files. It can also pre-transform files if it anticipates certain files will be requested shortly. However, request waterfalls may still happen if some files take longer to transform than others. For example:<p>Given an import graph where the left file imports the right file:<pre class="language-text"><code class="language-text">main.js -> BigComponent.vue -> big-utils.js -> large-data.json</code></pre><p>The import relationship can only be known after the file is transformed. If <code>BigComponent.vue</code> takes some time to transform, <code>big-utils.js</code> has to wait for its turn, and so on. This causes an internal waterfall even with pre-transformation built-in.<p>Vite allows you to warm up files that you know are frequently used, e.g. <code>big-utils.js</code>, using the <a href="/config/server-options.md#server-warmup"><code>server.warmup</code></a> option. This way <code>big-utils.js</code> will be ready and cached to be served immediately when requested.<p>You can find files that are frequently used by running <code>DEBUG="vite:transform" vite</code> and inspect the logs:<pre class="language-bash"><code class="language-bash">vite:transform <span class="token number">28</span>.72ms /@vite/client +1ms
vite:transform <span class="token number">62</span>.95ms /src/components/BigComponent.vue +1ms
vite:transform <span class="token number">102</span>.54ms /src/utils/big-utils.js +1ms</code></pre><pre class="language-js"><code class="language-js"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">server</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">warmup</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">clientFiles</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token string">'./src/components/BigComponent.vue'</span><span class="token punctuation">,</span>
        <span class="token string">'./src/utils/big-utils.js'</span><span class="token punctuation">,</span>
      <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>Note that you should only warm up files that are frequently used to not overload the Vite dev server on startup. Check the <a href="/config/server-options.md#server-warmup"><code>server.warmup</code></a> option for more information.<p>Using <a href="/config/server-options.html#server-open"><code>--open</code> or <code>server.open</code></a> also provides a performance boost, as Vite will automatically warm up the entry point of your app or the provided URL to open.</section><section class="level2"aria-labelledby="use-lesser-or-native-tooling"><h2 id="use-lesser-or-native-tooling">Use Lesser or Native Tooling</h2><p>Keeping Vite fast with a growing codebase is about reducing the amount of work for the source files (JS/TS/CSS).<p>Examples of doing less work:<ul><li>Use CSS instead of Sass/Less/Stylus when possible (nesting can be handled by PostCSS)<li>Don't transform SVGs into UI framework components (React, Vue, etc). Import them as strings or URLs instead.<li>When using <code>@vitejs/plugin-react</code>, avoid configuring the Babel options, so it skips the transformation during build (only esbuild will be used).</ul><p>Examples of using native tooling:<p>Using native tooling often brings larger installation size and as so is not the default when starting a new Vite project. But it may be worth the cost for larger applications.<ul><li>Try out the experimental support for <a href="https://github.com/vitejs/vite/discussions/13835">LightningCSS</a><li>Use <a href="https://github.com/vitejs/vite-plugin-react-swc"><code>@vitejs/plugin-react-swc</code></a> in place of <code>@vitejs/plugin-react</code>. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></ul></section></section>