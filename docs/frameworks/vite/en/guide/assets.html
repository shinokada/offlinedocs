<!doctype html><html lang="en"><meta charset="utf-8"><title>Static Asset Handling</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="static-asset-handling"><h1 id="static-asset-handling">Static Asset Handling</h1><ul><li>Related: <a href="./build.html#public-base-path">Public Base Path</a><li>Related: <a href="/config/shared-options.md#assetsinclude"><code>assetsInclude</code> config option</a></ul><section class="level2"aria-labelledby="importing-asset-as-url"><h2 id="importing-asset-as-url">Importing Asset as URL</h2><p>Importing a static asset will return the resolved public URL when it is served:<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports">imgUrl</span> <span class="token keyword module">from</span> <span class="token string">'./img.png'</span>
<span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'hero-img'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">src</span> <span class="token operator">=</span> imgUrl</code></pre><p>For example, <code>imgUrl</code> will be <code>/img.png</code> during development, and become <code>/assets/img.2d8efhg.png</code> in the production build.<p>The behavior is similar to webpack's <code>file-loader</code>. The difference is that the import can be either using absolute public paths (based on project root during dev) or relative paths.<ul><li><p><code>url()</code> references in CSS are handled the same way.<li><p>If using the Vue plugin, asset references in Vue SFC templates are automatically converted into imports.<li><p>Common image, media, and font filetypes are detected as assets automatically. You can extend the internal list using the <a href="/config/shared-options.md#assetsinclude"><code>assetsInclude</code> option</a>.<li><p>Referenced assets are included as part of the build assets graph, will get hashed file names, and can be processed by plugins for optimization.<li><p>Assets smaller in bytes than the <a href="/config/build-options.md#build-assetsinlinelimit"><code>assetsInlineLimit</code> option</a> will be inlined as base64 data URLs.<li><p>Git LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent. To get inlining, make sure to download the file contents via Git LFS before building.<li><p>TypeScript, by default, does not recognize static asset imports as valid modules. To fix this, include <a href="./features.html#client-types"><code>vite/client</code></a>.</ul><section class="level3"aria-labelledby="explicit-url-imports"><h3 id="explicit-url-imports">Explicit URL Imports</h3><p>Assets that are not included in the internal list or in <code>assetsInclude</code>, can be explicitly imported as a URL using the <code>?url</code> suffix. This is useful, for example, to import <a href="https://houdini.how/usage">Houdini Paint Worklets</a>.<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports">workletURL</span> <span class="token keyword module">from</span> <span class="token string">'extra-scalloped-border/worklet.js?url'</span>
<span class="token constant">CSS</span><span class="token punctuation">.</span><span class="token property-access">paintWorklet</span><span class="token punctuation">.</span><span class="token method function property-access">addModule</span><span class="token punctuation">(</span>workletURL<span class="token punctuation">)</span></code></pre></section><section class="level3"aria-labelledby="importing-asset-as-string"><h3 id="importing-asset-as-string">Importing Asset as String</h3><p>Assets can be imported as strings using the <code>?raw</code> suffix.<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports">shaderString</span> <span class="token keyword module">from</span> <span class="token string">'./shader.glsl?raw'</span></code></pre></section><section class="level3"aria-labelledby="importing-script-as-a-worker"><h3 id="importing-script-as-a-worker">Importing Script as a Worker</h3><p>Scripts can be imported as web workers with the <code>?worker</code> or <code>?sharedworker</code> suffix.<pre class="language-js"><code class="language-js"><span class="token comment">// Separate chunk in the production build</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Worker</span></span> <span class="token keyword module">from</span> <span class="token string">'./shader.js?worker'</span>
<span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre class="language-js"><code class="language-js"><span class="token comment">// sharedworker</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">SharedWorker</span></span> <span class="token keyword module">from</span> <span class="token string">'./shader.js?sharedworker'</span>
<span class="token keyword">const</span> sharedWorker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SharedWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre class="language-js"><code class="language-js"><span class="token comment">// Inlined as base64 strings</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">InlineWorker</span></span> <span class="token keyword module">from</span> <span class="token string">'./shader.js?worker&#x26;inline'</span></code></pre><p>Check out the <a href="./features.md.html#web-workers">Web Worker section</a> for more details.</section></section><section class="level2"aria-labelledby="the-public-directory"><h2 id="the-public-directory">The <code>public</code> Directory</h2><p>If you have assets that are:<ul><li>Never referenced in source code (e.g. <code>robots.txt</code>)<li>Must retain the exact same file name (without hashing)<li>...or you simply don't want to have to import an asset first just to get its URL</ul><p>Then you can place the asset in a special <code>public</code> directory under your project root. Assets in this directory will be served at root path <code>/</code> during dev, and copied to the root of the dist directory as-is.<p>The directory defaults to <code>&#x3C;root>/public</code>, but can be configured via the <a href="/config/shared-options.md#publicdir"><code>publicDir</code> option</a>.<p>Note that:<ul><li>You should always reference <code>public</code> assets using root absolute path - for example, <code>public/icon.png</code> should be referenced in source code as <code>/icon.png</code>.<li>Assets in <code>public</code> cannot be imported from JavaScript.</ul></section><section class="level2"aria-labelledby="new-urlurl-importmetaurl"><h2 id="new-urlurl-importmetaurl">new URL(url, import.meta.url)</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta">import.meta.url</a> is a native ESM feature that exposes the current module's URL. Combining it with the native <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL">URL constructor</a>, we can obtain the full, resolved URL of a static asset using relative path from a JavaScript module:<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> imgUrl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">'./img.png'</span><span class="token punctuation">,</span> <span class="token keyword module">import</span><span class="token punctuation">.</span><span class="token property-access">meta</span><span class="token punctuation">.</span><span class="token property-access">url</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">href</span>

<span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'hero-img'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">src</span> <span class="token operator">=</span> imgUrl</code></pre><p>This works natively in modern browsers - in fact, Vite doesn't need to process this code at all during development!<p>This pattern also supports dynamic URLs via template literals:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getImageUrl</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">./dir/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.png</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token keyword module">import</span><span class="token punctuation">.</span><span class="token property-access">meta</span><span class="token punctuation">.</span><span class="token property-access">url</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">href</span>
<span class="token punctuation">}</span></code></pre><p>During the production build, Vite will perform necessary transforms so that the URLs still point to the correct location even after bundling and asset hashing. However, the URL string must be static so it can be analyzed, otherwise the code will be left as is, which can cause runtime errors if <code>build.target</code> does not support <code>import.meta.url</code><pre class="language-js"><code class="language-js"><span class="token comment">// Vite will not transform this</span>
<span class="token keyword">const</span> imgUrl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span>imagePath<span class="token punctuation">,</span> <span class="token keyword module">import</span><span class="token punctuation">.</span><span class="token property-access">meta</span><span class="token punctuation">.</span><span class="token property-access">url</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">href</span></code></pre>warning Does not work with SSR This pattern does not work if you are using Vite for Server-Side Rendering, because `import.meta.url` have different semantics in browsers vs. Node.js. The server bundle also cannot determine the client host URL ahead of time. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>