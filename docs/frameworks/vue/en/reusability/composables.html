<!doctypehtml><html lang="en"><meta charset="utf-8"><title>Composables</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="composables"class="level1"><h1>Composables</h1><script setup="">import{useMouse}from"./mouse";const{x,y}=useMouse()</script><p>:::tip This section assumes basic knowledge of Composition API. If you have been learning Vue with Options API only, you can set the API Preference to Composition API (using the toggle at the top of the left sidebar) and re-read the <a href="/guide/essentials/reactivity-fundamentals.html">Reactivity Fundamentals</a> and <a href="/guide/essentials/lifecycle.html">Lifecycle Hooks</a> chapters. :::<section id="what-is-a-composable"class="level2"><h2>What is a "Composable"?</h2><p>In the context of Vue applications, a "composable" is a function that leverages Vue's Composition API to encapsulate and reuse <strong>stateful logic</strong>.<p>When building frontend applications, we often need to reuse logic for common tasks. For example, we may need to format dates in many places, so we extract a reusable function for that. This formatter function encapsulates <strong>stateless logic</strong>: it takes some input and immediately returns expected output. There are many libraries out there for reusing stateless logic - for example <a href="https://lodash.com/">lodash</a> and <a href="https://date-fns.org/">date-fns</a>, which you may have heard of.<p>By contrast, stateful logic involves managing state that changes over time. A simple example would be tracking the current position of the mouse on a page. In real world scenarios, it could also be more complex logic such as touch gestures or connection status to a database.</section><section id="mouse-tracker-example"class="level2"><h2>Mouse Tracker Example</h2><p>If we were to implement the mouse tracking functionality using the Composition API directly inside a component, it would look like this:<pre class="language-vue"><code class="language-vue">&#x3C;script setup>
import { ref, onMounted, onUnmounted } from 'vue'

const x = ref(0)
const y = ref(0)

function update(event) {
  x.value = event.pageX
  y.value = event.pageY
}

onMounted(() => window.addEventListener('mousemove', update))
onUnmounted(() => window.removeEventListener('mousemove', update))
&#x3C;/script>

&#x3C;template>Mouse position is at: {{ x }}, {{ y }}&#x3C;/template></code></pre><p>But what if we want to reuse the same logic in multiple components? We can extract the logic into an external file, as a composable function:<pre class="language-js"><code class="language-js"><span class="token comment">// mouse.js</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> ref<span class="token punctuation">,</span> onMounted<span class="token punctuation">,</span> onUnmounted <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vue'</span>

<span class="token comment">// by convention, composable function names start with "use"</span>
<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">useMouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// state encapsulated and managed by the composable</span>
  <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

  <span class="token comment">// a composable can update its managed state over time.</span>
  <span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token property-access">pageX</span>
    y<span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token property-access">pageY</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// a composable can also hook into its owner component's</span>
  <span class="token comment">// lifecycle to setup and teardown side effects.</span>
  <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token dom variable">window</span><span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token function">onUnmounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token dom variable">window</span><span class="token punctuation">.</span><span class="token method function property-access">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token comment">// expose managed state as return value</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>And this is how it can be used in components:<pre class="language-vue"><code class="language-vue">&#x3C;script setup>
import { useMouse } from './mouse.js'

const { x, y } = useMouse()
&#x3C;/script>

&#x3C;template>Mouse position is at: {{ x }}, {{ y }}&#x3C;/template></code></pre><div class="demo">Mouse position is at: {{ x }}, {{ y }}</div><p><a href="https://sfc.vuejs.org/#eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IHVzZU1vdXNlIH0gZnJvbSAnLi9tb3VzZS5qcydcblxuY29uc3QgeyB4LCB5IH0gPSB1c2VNb3VzZSgpXG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICBNb3VzZSBwb3NpdGlvbiBpcyBhdDoge3sgeCB9fSwge3sgeSB9fVxuPC90ZW1wbGF0ZT4iLCJpbXBvcnQtbWFwLmpzb24iOiJ7XG4gIFwiaW1wb3J0c1wiOiB7XG4gICAgXCJ2dWVcIjogXCJodHRwczovL3NmYy52dWVqcy5vcmcvdnVlLnJ1bnRpbWUuZXNtLWJyb3dzZXIuanNcIlxuICB9XG59IiwibW91c2UuanMiOiJpbXBvcnQgeyByZWYsIG9uTW91bnRlZCwgb25Vbm1vdW50ZWQgfSBmcm9tICd2dWUnXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNb3VzZSgpIHtcbiAgY29uc3QgeCA9IHJlZigwKVxuICBjb25zdCB5ID0gcmVmKDApXG5cbiAgZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XG4gICAgeC52YWx1ZSA9IGV2ZW50LnBhZ2VYXG4gICAgeS52YWx1ZSA9IGV2ZW50LnBhZ2VZXG4gIH1cblxuICBvbk1vdW50ZWQoKCkgPT4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHVwZGF0ZSkpXG4gIG9uVW5tb3VudGVkKCgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB1cGRhdGUpKVxuXG4gIHJldHVybiB7IHgsIHkgfVxufSJ9">Try it in the Playground</a><p>As we can see, the core logic remains identical - all we had to do was move it into an external function and return the state that should be exposed. Just like inside a component, you can use the full range of <a href="/api/#composition-api">Composition API functions</a> in composables. The same <code>useMouse()</code> functionality can now be used in any component.<p>The cooler part about composables though, is that you can also nest them: one composable function can call one or more other composable functions. This enables us to compose complex logic using small, isolated units, similar to how we compose an entire application using components. In fact, this is why we decided to call the collection of APIs that make this pattern possible Composition API.<p>For example, we can extract the logic of adding and removing a DOM event listener into its own composable:<pre class="language-js"><code class="language-js"><span class="token comment">// event.js</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> onMounted<span class="token punctuation">,</span> onUnmounted <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vue'</span>

<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">useEventListener</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> event<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// if you want, you can also make this</span>
  <span class="token comment">// support selector strings as target</span>
  <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> target<span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token function">onUnmounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> target<span class="token punctuation">.</span><span class="token method function property-access">removeEventListener</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>And now our <code>useMouse()</code> composable can be simplified to:<pre class="language-js{3,9-12}"><code class="language-js{3,9-12}">// mouse.js
import { ref } from 'vue'
import { useEventListener } from './event'

export function useMouse() {
  const x = ref(0)
  const y = ref(0)

  useEventListener(window, 'mousemove', (event) => {
    x.value = event.pageX
    y.value = event.pageY
  })

  return { x, y }
}</code></pre><p>:::tip Each component instance calling <code>useMouse()</code> will create its own copies of <code>x</code> and <code>y</code> state so they won't interfere with one another. If you want to manage shared state between components, read the <a href="/guide/scaling-up/state-management.html">State Management</a> chapter. :::</section><section id="async-state-example"class="level2"><h2>Async State Example</h2><p>The <code>useMouse()</code> composable doesn't take any arguments, so let's take a look at another example that makes use of one. When doing async data fetching, we often need to handle different states: loading, success, and error:<pre class="language-vue"><code class="language-vue">&#x3C;script setup>
import { ref } from 'vue'

const data = ref(null)
const error = ref(null)

fetch('...')
  .then((res) => res.json())
  .then((json) => (data.value = json))
  .catch((err) => (error.value = err))
&#x3C;/script>

&#x3C;template>
  &#x3C;div v-if="error">Oops! Error encountered: {{ error.message }}&#x3C;/div>
  &#x3C;div v-else-if="data">
    Data loaded:
    &#x3C;pre>{{ data }}&#x3C;/pre>
  &#x3C;/div>
  &#x3C;div v-else>Loading...&#x3C;/div>
&#x3C;/template></code></pre><p>It would be tedious to have to repeat this pattern in every component that needs to fetch data. Let's extract it into a composable:<pre class="language-js"><code class="language-js"><span class="token comment">// fetch.js</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> ref <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vue'</span>

<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">useFetch</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> error <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span>

  <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> res<span class="token punctuation">.</span><span class="token method function property-access">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">json</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> json<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token keyword control-flow">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span>error<span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> data<span class="token punctuation">,</span> error <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Now in our component we can just do:<pre class="language-vue"><code class="language-vue">&#x3C;script setup>
import { useFetch } from './fetch.js'

const { data, error } = useFetch('...')
&#x3C;/script></code></pre><p><code>useFetch()</code> takes a static URL string as input - so it performs the fetch only once and is then done. What if we want it to re-fetch whenever the URL changes? We can achieve that by also accepting refs as an argument:<pre class="language-js"><code class="language-js"><span class="token comment">// fetch.js</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> ref<span class="token punctuation">,</span> isRef<span class="token punctuation">,</span> unref<span class="token punctuation">,</span> watchEffect <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vue'</span>

<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">useFetch</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> error <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span>

  <span class="token keyword">function</span> <span class="token function">doFetch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// reset state before fetching..</span>
    data<span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span>
    error<span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> <span class="token keyword null nil">null</span>
    <span class="token comment">// unref() unwraps potential refs</span>
    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token function">unref</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> res<span class="token punctuation">.</span><span class="token method function property-access">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">json</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> json<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token keyword control-flow">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span>error<span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isRef</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// setup reactive re-fetch if input URL is a ref</span>
    <span class="token function">watchEffect</span><span class="token punctuation">(</span>doFetch<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// otherwise, just fetch once</span>
    <span class="token comment">// and avoid the overhead of a watcher</span>
    <span class="token function">doFetch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> data<span class="token punctuation">,</span> error <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>This version of <code>useFetch()</code> now accepts both static URL strings and refs of URL strings. When it detects that the URL is a dynamic ref using <a href="/api/reactivity-utilities.html#isref"><code>isRef()</code></a>, it sets up a reactive effect using <a href="/api/reactivity-core.html#watcheffect"><code>watchEffect()</code></a>. The effect will run immediately and will also track the URL ref as a dependency. Whenever the URL ref changes, the data will be reset and fetched again.<p>Here's <a href="https://sfc.vuejs.org/#eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IHJlZiwgY29tcHV0ZWQgfSBmcm9tICd2dWUnXG5pbXBvcnQgeyB1c2VGZXRjaCB9IGZyb20gJy4vdXNlRmV0Y2guanMnXG5cbmNvbnN0IGJhc2VVcmwgPSAnaHR0cHM6Ly9qc29ucGxhY2Vob2xkZXIudHlwaWNvZGUuY29tL3RvZG9zLydcbmNvbnN0IGlkID0gcmVmKCcxJylcbmNvbnN0IHVybCA9IGNvbXB1dGVkKCgpID0+IGJhc2VVcmwgKyBpZC52YWx1ZSlcblxuY29uc3QgeyBkYXRhLCBlcnJvciwgcmV0cnkgfSA9IHVzZUZldGNoKHVybClcbjwvc2NyaXB0PlxuXG48dGVtcGxhdGU+XG4gIExvYWQgcG9zdCBpZDpcbiAgPGJ1dHRvbiB2LWZvcj1cImkgaW4gNVwiIEBjbGljaz1cImlkID0gaVwiPnt7IGkgfX08L2J1dHRvbj5cblxuXHQ8ZGl2IHYtaWY9XCJlcnJvclwiPlxuICAgIDxwPk9vcHMhIEVycm9yIGVuY291bnRlcmVkOiB7eyBlcnJvci5tZXNzYWdlIH19PC9wPlxuICAgIDxidXR0b24gQGNsaWNrPVwicmV0cnlcIj5SZXRyeTwvYnV0dG9uPlxuICA8L2Rpdj5cbiAgPGRpdiB2LWVsc2UtaWY9XCJkYXRhXCI+RGF0YSBsb2FkZWQ6IDxwcmU+e3sgZGF0YSB9fTwvcHJlPjwvZGl2PlxuICA8ZGl2IHYtZWxzZT5Mb2FkaW5nLi4uPC9kaXY+XG48L3RlbXBsYXRlPiIsImltcG9ydC1tYXAuanNvbiI6IntcbiAgXCJpbXBvcnRzXCI6IHtcbiAgICBcInZ1ZVwiOiBcImh0dHBzOi8vc2ZjLnZ1ZWpzLm9yZy92dWUucnVudGltZS5lc20tYnJvd3Nlci5qc1wiXG4gIH1cbn0iLCJ1c2VGZXRjaC5qcyI6ImltcG9ydCB7IHJlZiwgaXNSZWYsIHVucmVmLCB3YXRjaEVmZmVjdCB9IGZyb20gJ3Z1ZSdcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZldGNoKHVybCkge1xuICBjb25zdCBkYXRhID0gcmVmKG51bGwpXG4gIGNvbnN0IGVycm9yID0gcmVmKG51bGwpXG5cbiAgYXN5bmMgZnVuY3Rpb24gZG9GZXRjaCgpIHtcbiAgICAvLyByZXNldCBzdGF0ZSBiZWZvcmUgZmV0Y2hpbmcuLlxuICAgIGRhdGEudmFsdWUgPSBudWxsXG4gICAgZXJyb3IudmFsdWUgPSBudWxsXG4gICAgXG4gICAgLy8gcmVzb2x2ZSB0aGUgdXJsIHZhbHVlIHN5bmNocm9ub3VzbHkgc28gaXQncyB0cmFja2VkIGFzIGFcbiAgICAvLyBkZXBlbmRlbmN5IGJ5IHdhdGNoRWZmZWN0KClcbiAgICBjb25zdCB1cmxWYWx1ZSA9IHVucmVmKHVybClcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gYXJ0aWZpY2lhbCBkZWxheSAvIHJhbmRvbSBlcnJvclxuICBcdCAgYXdhaXQgdGltZW91dCgpXG4gIFx0ICAvLyB1bnJlZigpIHdpbGwgcmV0dXJuIHRoZSByZWYgdmFsdWUgaWYgaXQncyBhIHJlZlxuXHQgICAgLy8gb3RoZXJ3aXNlIHRoZSB2YWx1ZSB3aWxsIGJlIHJldHVybmVkIGFzLWlzXG4gICAgXHRjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmxWYWx1ZSlcblx0ICAgIGRhdGEudmFsdWUgPSBhd2FpdCByZXMuanNvbigpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IudmFsdWUgPSBlXG4gICAgfVxuICB9XG5cbiAgaWYgKGlzUmVmKHVybCkpIHtcbiAgICAvLyBzZXR1cCByZWFjdGl2ZSByZS1mZXRjaCBpZiBpbnB1dCBVUkwgaXMgYSByZWZcbiAgICB3YXRjaEVmZmVjdChkb0ZldGNoKVxuICB9IGVsc2Uge1xuICAgIC8vIG90aGVyd2lzZSwganVzdCBmZXRjaCBvbmNlXG4gICAgZG9GZXRjaCgpXG4gIH1cblxuICByZXR1cm4geyBkYXRhLCBlcnJvciwgcmV0cnk6IGRvRmV0Y2ggfVxufVxuXG4vLyBhcnRpZmljaWFsIGRlbGF5XG5mdW5jdGlvbiB0aW1lb3V0KCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjMpIHtcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdSYW5kb20gRXJyb3InKSlcbiAgICAgIH1cbiAgICB9LCAzMDApXG4gIH0pXG59In0=">the updated version of <code>useFetch()</code></a>, with an artificial delay and randomized error for demo purposes.</section><section id="conventions-and-best-practices"class="level2"><h2>Conventions and Best Practices</h2><section id="naming"class="level3"><h3>Naming</h3><p>It is a convention to name composable functions with camelCase names that start with "use".</section><section id="input-arguments"class="level3"><h3>Input Arguments</h3><p>A composable can accept ref arguments even if it doesn't rely on them for reactivity. If you are writing a composable that may be used by other developers, it's a good idea to handle the case of input arguments being refs instead of raw values. The <a href="/api/reactivity-utilities.html#unref"><code>unref()</code></a> utility function will come in handy for this purpose:<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> unref <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vue'</span>

<span class="token keyword">function</span> <span class="token function">useFeature</span><span class="token punctuation">(</span><span class="token parameter">maybeRef</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// if maybeRef is indeed a ref, its .value will be returned</span>
  <span class="token comment">// otherwise, maybeRef is returned as-is</span>
  <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">unref</span><span class="token punctuation">(</span>maybeRef<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>If your composable creates reactive effects when the input is a ref, make sure to either explicitly watch the ref with <code>watch()</code>, or call <code>unref()</code> inside a <code>watchEffect()</code> so that it is properly tracked.</section><section id="return-values"class="level3"><h3>Return Values</h3><p>You have probably noticed that we have been exclusively using <code>ref()</code> instead of <code>reactive()</code> in composables. The recommended convention is for composables to always return a plain, non-reactive object containing multiple refs. This allows it to be destructured in components while retaining reactivity:<pre class="language-js"><code class="language-js"><span class="token comment">// x and y are refs</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useMouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>Returning a reactive object from a composable will cause such destructures to lose the reactivity connection to the state inside the composable, while the refs will retain that connection.<p>If you prefer to use returned state from composables as object properties, you can wrap the returned object with <code>reactive()</code> so that the refs are unwrapped. For example:<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> mouse <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token function">useMouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// mouse.x is linked to original ref</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>mouse<span class="token punctuation">.</span><span class="token property-access">x</span><span class="token punctuation">)</span></code></pre><pre class="language-vue-html"><code class="language-vue-html">Mouse position is at: {{ mouse.x }}, {{ mouse.y }}</code></pre></section><section id="side-effects"class="level3"><h3>Side Effects</h3><p>It is OK to perform side effects (e.g. adding DOM event listeners or fetching data) in composables, but pay attention to the following rules:<ul><li><p>If you are working on an application that uses <a href="/guide/scaling-up/ssr.html">Server-Side Rendering</a> (SSR), make sure to perform DOM-specific side effects in post-mount lifecycle hooks, e.g. <code>onMounted()</code>. These hooks are only called in the browser, so you can be sure that code inside them has access to the DOM.<li><p>Remember to clean up side effects in <code>onUnmounted()</code>. For example, if a composable sets up a DOM event listener, it should remove that listener in <code>onUnmounted()</code> as we have seen in the <code>useMouse()</code> example. It can be a good idea to use a composable that automatically does this for you, like the <code>useEventListener()</code> example.</ul></section><section id="usage-restrictions"class="level3"><h3>Usage Restrictions</h3><p>Composables should only be called <strong>synchronously</strong> in <code>&#x3C;script setup></code> or the <code>setup()</code> hook. In some cases, you can also call them in lifecycle hooks like <code>onMounted()</code>.<p>These are the contexts where Vue is able to determine the current active component instance. Access to an active component instance is necessary so that:<ol><li><p>Lifecycle hooks can be registered to it.<li><p>Computed properties and watchers can be linked to it, so that they can be disposed when the instance is unmounted to prevent memory leaks.</ol><p>:::tip <code>&#x3C;script setup></code> is the only place where you can call composables <strong>after</strong> using <code>await</code>. The compiler automatically restores the active instance context for you after the async operation. :::</section></section><section id="extracting-composables-for-code-organization"class="level2"><h2>Extracting Composables for Code Organization</h2><p>Composables can be extracted not only for reuse, but also for code organization. As the complexity of your components grow, you may end up with components that are too large to navigate and reason about. Composition API gives you the full flexibility to organize your component code into smaller functions based on logical concerns:<pre class="language-vue"><code class="language-vue">&#x3C;script setup>
import { useFeatureA } from './featureA.js'
import { useFeatureB } from './featureB.js'
import { useFeatureC } from './featureC.js'

const { foo, bar } = useFeatureA()
const { baz } = useFeatureB(foo)
const { qux } = useFeatureC(baz)
&#x3C;/script></code></pre><p>To some extent, you can think of these extracted composables as component-scoped services that can talk to one another.</section><section id="using-composables-in-options-api"class="level2"><h2>Using Composables in Options API</h2><p>If you are using Options API, composables must be called inside <code>setup()</code>, and the returned bindings must be returned from <code>setup()</code> so that they are exposed to <code>this</code> and the template:<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> useMouse <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./mouse.js'</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> useFetch <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./fetch.js'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useMouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> data<span class="token punctuation">,</span> error <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useFetch</span><span class="token punctuation">(</span><span class="token string">'...'</span><span class="token punctuation">)</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> data<span class="token punctuation">,</span> error <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// setup() exposed properties can be accessed on `this`</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">x</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...other options</span>
<span class="token punctuation">}</span></code></pre></section><section id="comparisons-with-other-techniques"class="level2"><h2>Comparisons with Other Techniques</h2><section id="vs-mixins"class="level3"><h3>vs. Mixins</h3><p>Users coming from Vue 2 may be familiar with the <a href="/api/options-composition.html#mixins">mixins</a> option, which also allows us to extract component logic into reusable units. There are three primary drawbacks to mixins:<ol><li><p><strong>Unclear source of properties</strong>: when using many mixins, it becomes unclear which instance property is injected by which mixin, making it difficult to trace the implementation and understand the component's behavior. This is also why we recommend using the refs + destructure pattern for composables: it makes the property source clear in consuming components.<li><p><strong>Namespace collisions</strong>: multiple mixins from different authors can potentially register the same property keys, causing namespace collisions. With composables, you can rename the destructured variables if there are conflicting keys from different composables.<li><p><strong>Implicit cross-mixin communication</strong>: multiple mixins that need to interact with one another have to rely on shared property keys, making them implicitly coupled. With composables, values returned from one composable can be passed into another as arguments, just like normal functions.</ol><p>For the above reasons, we no longer recommend using mixins in Vue 3. The feature is kept only for migration and familiarity reasons.</section><section id="vs-renderless-components"class="level3"><h3>vs. Renderless Components</h3><p>In the component slots chapter, we discussed the <a href="/guide/components/slots.html#renderless-components">Renderless Component</a> pattern based on scoped slots. We even implemented the same mouse tracking demo using renderless components.<p>The main advantage of composables over renderless components is that composables do not incur the extra component instance overhead. When used across an entire application, the amount of extra component instances created by the renderless component pattern can become a noticeable performance overhead.<p>The recommendation is to use composables when reusing pure logic, and use components when reusing both logic and visual layout.</section><section id="vs-react-hooks"class="level3"><h3>vs. React Hooks</h3><p>If you have experience with React, you may notice that this looks very similar to custom React hooks. Composition API was in part inspired by React hooks, and Vue composables are indeed similar to React hooks in terms of logic composition capabilities. However, Vue composables are based on Vue's fine-grained reactivity system, which is fundamentally different from React hooks' execution model. This is discussed in more detail in the <a href="/guide/extras/composition-api-faq#comparison-with-react-hooks">Composition API FAQ</a>.</section></section><section id="further-reading"class="level2"><h2>Further Reading</h2><ul><li><a href="/guide/extras/reactivity-in-depth.html">Reactivity In Depth</a>: for a low-level understanding of how Vue's reactivity system works.<li><a href="/guide/scaling-up/state-management.html">State Management</a>: for patterns of managing state shared by multiple components.<li><a href="/guide/scaling-up/testing.html#testing-composables">Testing Composables</a>: tips on unit testing composables.<li><a href="https://vueuse.org/">VueUse</a>: an ever-growing collection of Vue composables. The source code is also a great learning resource. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></ul></section></section>