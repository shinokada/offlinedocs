<!doctypehtml><html lang="en"><meta charset="utf-8"><title>Reactivity Transform</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="reactivity-transform"class="level1"><h1>Reactivity Transform</h1><p>:::warning Experimental Feature Reactivity Transform is currently an experimental feature. It is disabled by default and requires <a href="#explicit-opt-in">explicit opt-in</a>. It may also change before being finalized. To stay up-to-date, keep an eye on its <a href="https://github.com/vuejs/rfcs/discussions/369">proposal and discussion on GitHub</a>. :::<p>:::tip Composition-API-specific Reactivity Transform is a Composition-API-specific feature and requires a build step. :::<section id="refs-vs-reactive-variables"class="level2"><h2>Refs vs. Reactive Variables</h2><p>Ever since the introduction of the Composition API, one of the primary unresolved questions is the use of refs vs. reactive objects. It's easy to lose reactivity when destructuring reactive objects, while it can be cumbersome to use <code>.value</code> everywhere when using refs. Also, <code>.value</code> is easy to miss if not using a type system.<p><a href="https://github.com/vuejs/core/tree/main/packages/reactivity-transform">Vue Reactivity Transform</a> is a compile-time transform that allows us to write code like this:<pre class="language-vue"><code class="language-vue">&#x3C;script setup>
let count = $ref(0)

console.log(count)

function increment() {
  count++
}
&#x3C;/script>

&#x3C;template>
  &#x3C;button @click="increment">{{ count }}&#x3C;/button>
&#x3C;/template></code></pre><p>The <code>$ref()</code> method here is a <strong>compile-time macro</strong>: it is not an actual method that will be called at runtime. Instead, the Vue compiler uses it as a hint to treat the resulting <code>count</code> variable as a <strong>reactive variable.</strong><p>Reactive variables can be accessed and re-assigned just like normal variables, but these operations are compiled into refs with <code>.value</code>. For example, the <code>&#x3C;script></code> part of the above component is compiled into:<pre class="language-js{5,8}"><code class="language-js{5,8}">import { ref } from 'vue'

let count = ref(0)

console.log(count.value)

function increment() {
  count.value++
}</code></pre><p>Every reactivity API that returns refs will have a <code>$</code>-prefixed macro equivalent. These APIs include:<ul><li><a href="/api/reactivity-core.html#ref"><code>ref</code></a> -> <code>$ref</code><li><a href="/api/reactivity-core.html#computed"><code>computed</code></a> -> <code>$computed</code><li><a href="/api/reactivity-advanced.html#shallowref"><code>shallowRef</code></a> -> <code>$shallowRef</code><li><a href="/api/reactivity-advanced.html#customref"><code>customRef</code></a> -> <code>$customRef</code><li><a href="/api/reactivity-utilities.html#toref"><code>toRef</code></a> -> <code>$toRef</code></ul><p>These macros are globally available and do not need to be imported when Reactivity Transform is enabled, but you can optionally import them from <code>vue/macros</code> if you want to be more explicit:<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> $ref <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vue/macros'</span>

<span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token function">$ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></code></pre></section><section id="destructuring-with--destructuring-with"class="level2"><h2>Destructuring with <code>$()</code> {#destructuring-with}</h2><p>It is common for a composition function to return an object of refs, and use destructuring to retrieve these refs. For this purpose, reactivity transform provides the <strong><code>$()</code></strong> macro:<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> useMouse <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@vueuse/core'</span>

<span class="token keyword">const</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token function">useMouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span></code></pre><p>Compiled output:<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> toRef <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vue'</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> useMouse <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'@vueuse/core'</span>

<span class="token keyword">const</span> __temp <span class="token operator">=</span> <span class="token function">useMouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  x <span class="token operator">=</span> <span class="token function">toRef</span><span class="token punctuation">(</span>__temp<span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  y <span class="token operator">=</span> <span class="token function">toRef</span><span class="token punctuation">(</span>__temp<span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">)</span>

<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span></code></pre><p>Note that if <code>x</code> is already a ref, <code>toRef(__temp, 'x')</code> will simply return it as-is and no additional ref will be created. If a destructured value is not a ref (e.g. a function), it will still work - the value will be wrapped in a ref so the rest of the code works as expected.<p><code>$()</code> destructure works on both reactive objects <strong>and</strong> plain objects containing refs.</section><section id="convert-existing-refs-to-reactive-variables-with--convert-existing-refs-to-reactive-variables-with"class="level2"><h2>Convert Existing Refs to Reactive Variables with <code>$()</code> {#convert-existing-refs-to-reactive-variables-with}</h2><p>In some cases we may have wrapped functions that also return refs. However, the Vue compiler won't be able to know ahead of time that a function is going to return a ref. In such cases, the <code>$()</code> macro can also be used to convert any existing refs into reactive variables:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">myCreateRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token function">myCreateRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></section><section id="reactive-props-destructure"class="level2"><h2>Reactive Props Destructure</h2><p>There are two pain points with the current <code>defineProps()</code> usage in <code>&#x3C;script setup></code>:<ol><li><p>Similar to <code>.value</code>, you need to always access props as <code>props.x</code> in order to retain reactivity. This means you cannot destructure <code>defineProps</code> because the resulting destructured variables are not reactive and will not update.<li><p>When using the <a href="/api/sfc-script-setup.html#typescript-only-features">type-only props declaration</a>, there is no easy way to declare default values for the props. We introduced the <code>withDefaults()</code> API for this exact purpose, but it's still clunky to use.</ol><p>We can address these issues by applying a compile-time transform when <code>defineProps</code> is used with destructuring, similar to what we saw earlier with <code>$()</code>:<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>script</span> <span class="token attr-name">setup</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ts<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">interface</span> <span class="token class-name">Props</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">msg</span><span class="token operator">:</span> string
    count<span class="token operator">?</span><span class="token operator">:</span> number
    foo<span class="token operator">?</span><span class="token operator">:</span> string
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> <span class="token punctuation">{</span>
    msg<span class="token punctuation">,</span>
    <span class="token comment">// default value just works</span>
    count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token comment">// local aliasing also just works</span>
    <span class="token comment">// here we are aliasing `props.foo` to `bar`</span>
    <span class="token literal-property property">foo</span><span class="token operator">:</span> bar
  <span class="token punctuation">}</span> <span class="token operator">=</span> defineProps<span class="token operator">&#x3C;</span><span class="token maybe-class-name">Props</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// will log whenever the props change</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> count<span class="token punctuation">,</span> bar<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>The above will be compiled into the following runtime declaration equivalent:<pre class="language-js"><code class="language-js"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token known-class-name class-name">String</span><span class="token punctuation">,</span> <span class="token literal-property property">required</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token known-class-name class-name">Number</span><span class="token punctuation">,</span> <span class="token keyword module">default</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token known-class-name class-name">String</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">msg</span><span class="token punctuation">,</span> props<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">,</span> props<span class="token punctuation">.</span><span class="token property-access">foo</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></section><section id="retaining-reactivity-across-function-boundaries"class="level2"><h2>Retaining Reactivity Across Function Boundaries</h2><p>While reactive variables relieve us from having to use <code>.value</code> everywhere, it creates an issue of "reactivity loss" when we pass reactive variables across function boundaries. This can happen in two cases:<section id="passing-into-function-as-argument"class="level3"><h3>Passing into function as argument</h3><p>Given a function that expects a ref as an argument, e.g.:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">trackChange</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token maybe-class-name">Ref</span><span class="token operator">&#x3C;</span><span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">watch</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'x changed!'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token function">$ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">trackChange</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token comment">// doesn't work!</span></code></pre><p>The above case will not work as expected because it compiles to:<pre class="language-ts"><code class="language-ts"><span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">trackChange</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span></code></pre><p>Here <code>count.value</code> is passed as a number, whereas <code>trackChange</code> expects an actual ref. This can be fixed by wrapping <code>count</code> with <code>$$()</code> before passing it:<pre class="language-diff"><code class="language-diff">let count = $ref(0)
<span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> trackChange(count)
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> trackChange($$(count))</span></span></code></pre><p>The above compiles to:<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> ref <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vue'</span>

<span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">trackChange</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span></code></pre><p>As we can see, <code>$$()</code> is a macro that serves as an <strong>escape hint</strong>: reactive variables inside <code>$$()</code> will not get <code>.value</code> appended.</section><section id="returning-inside-function-scope"class="level3"><h3>Returning inside function scope</h3><p>Reactivity can also be lost if reactive variables are used directly in a returned expression:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">useMouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">$ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token function">$ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

  <span class="token comment">// listen to mousemove...</span>

  <span class="token comment">// doesn't work!</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    y
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>The above return statement compiles to:<pre class="language-ts"><code class="language-ts"><span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> x<span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">,</span>
  y<span class="token operator">:</span> y<span class="token punctuation">.</span><span class="token property-access">value</span>
<span class="token punctuation">}</span></code></pre><p>In order to retain reactivity, we should be returning the actual refs, not the current value at return time.<p>Again, we can use <code>$$()</code> to fix this. In this case, <code>$$()</code> can be used directly on the returned object - any reference to reactive variables inside the <code>$$()</code> call will retain the reference to their underlying refs:<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">useMouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">$ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token function">$ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

  <span class="token comment">// listen to mousemove...</span>

  <span class="token comment">// fixed</span>
  <span class="token keyword control-flow">return</span> <span class="token function">$$</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    y
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></section><section id="using-on-destructured-props"class="level3"><h3>Using <code>$()</code> on destructured props</h3><p><code>$$()</code> works on destructured props since they are reactive variables as well. The compiler will convert it with <code>toRef</code> for efficiency:<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> <span class="token punctuation">{</span> count <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">defineProps</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">passAsRef</span><span class="token punctuation">(</span><span class="token function">$$</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>compiles to:<pre class="language-js"><code class="language-js"><span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> __props_count <span class="token operator">=</span> <span class="token function">toRef</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> <span class="token string">'count'</span><span class="token punctuation">)</span>
  <span class="token function">passAsRef</span><span class="token punctuation">(</span>__props_count<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></section></section><section id="typescript-integration-sup-classvt-badge-ts--typescript-integration"class="level2"><h2>TypeScript Integration <sup class="vt-badge ts">{#typescript-integration}</sup></h2><p>Vue provides typings for these macros (available globally) and all types will work as expected. There are no incompatibilities with standard TypeScript semantics, so the syntax will work with all existing tooling.<p>This also means the macros can work in any files where valid JS / TS are allowed - not just inside Vue SFCs.<p>Since the macros are available globally, their types need to be explicitly referenced (e.g. in a <code>env.d.ts</code> file):<pre class="language-ts"><code class="language-ts"><span class="token comment">/// &#x3C;reference types="vue/macros-global" /></span></code></pre><p>When explicitly importing the macros from <code>vue/macros</code>, the type will work without declaring the globals.</section><section id="explicit-opt-in"class="level2"><h2>Explicit Opt-in</h2><p>Reactivity Transform is currently disabled by default and requires explicit opt-in. In addition, all of the following setups require <code>vue@^3.2.25</code>.<section id="vite"class="level3"><h3>Vite</h3><ul><li>Requires <code>@vitejs/plugin-vue@>=2.0.0</code><li>Applies to SFCs and js(x)/ts(x) files. A fast usage check is performed on files before applying the transform so there should be no performance cost for files not using the macros.<li>Note <code>reactivityTransform</code> is now a plugin root-level option instead of nested as <code>script.refSugar</code>, since it affects not just SFCs.</ul><pre class="language-js"><code class="language-js"><span class="token comment">// vite.config.js</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token function">vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">reactivityTransform</span><span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre></section><section id="vue-cli-vue-cli"class="level3"><h3><code>vue-cli</code> {#vue-cli}</h3><ul><li>Currently only affects SFCs<li>Requires <code>vue-loader@>=17.0.0</code></ul><pre class="language-js"><code class="language-js"><span class="token comment">// vue.config.js</span>
module<span class="token punctuation">.</span><span class="token property-access">exports</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">chainWebpack</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">config</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    config<span class="token punctuation">.</span><span class="token property-access">module</span>
      <span class="token punctuation">.</span><span class="token method function property-access">rule</span><span class="token punctuation">(</span><span class="token string">'vue'</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token method function property-access">use</span><span class="token punctuation">(</span><span class="token string">'vue-loader'</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token method function property-access">tap</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
        <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
          <span class="token spread operator">...</span>options<span class="token punctuation">,</span>
          <span class="token literal-property property">reactivityTransform</span><span class="token operator">:</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></section><section id="plain-webpack--vue-loader-plain-webpack-vue-loader"class="level3"><h3>Plain <code>webpack</code> + <code>vue-loader</code> {#plain-webpack-vue-loader}</h3><ul><li>Currently only affects SFCs<li>Requires <code>vue-loader@>=17.0.0</code></ul><pre class="language-js"><code class="language-js"><span class="token comment">// webpack.config.js</span>
module<span class="token punctuation">.</span><span class="token property-access">exports</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">module</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.vue$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">'vue-loader'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">options</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token literal-property property">reactivityTransform</span><span class="token operator">:</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p><span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section></section>