<!doctypehtml><html lang="en"><meta charset="utf-8"><title>Vue and Web Components</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="vue-and-web-components"class="level1"><h1>Vue and Web Components</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components">Web Components</a> is an umbrella term for a set of web native APIs that allows developers to create reusable custom elements.<p>We consider Vue and Web Components to be primarily complementary technologies. Vue has excellent support for both consuming and creating custom elements. Whether you are integrating custom elements into an existing Vue application, or using Vue to build and distribute custom elements, you are in good company.<section id="using-custom-elements-in-vue"class="level2"><h2>Using Custom Elements in Vue</h2><p>Vue <a href="https://custom-elements-everywhere.com/libraries/vue/results/results.html">scores a perfect 100% in the Custom Elements Everywhere tests</a>. Consuming custom elements inside a Vue application largely works the same as using native HTML elements, with a few things to keep in mind:<section id="skipping-component-resolution"class="level3"><h3>Skipping Component Resolution</h3><p>By default, Vue will attempt to resolve a non-native HTML tag as a registered Vue component before falling back to rendering it as a custom element. This will cause Vue to emit a "failed to resolve component" warning during development. To let Vue know that certain elements should be treated as custom elements and skip component resolution, we can specify the <a href="/api/application.html#app-config-compileroptions"><code>compilerOptions.isCustomElement</code> option</a>.<p>If you are using Vue with a build setup, the option should be passed via build configs since it is a compile-time option.<section id="example-in-browser-config"class="level4"><h4>Example In-Browser Config</h4><pre class="language-js"><code class="language-js"><span class="token comment">// Only works if using in-browser compilation.</span>
<span class="token comment">// If using build tools, see config examples below.</span>
app<span class="token punctuation">.</span><span class="token property-access">config</span><span class="token punctuation">.</span><span class="token property-access">compilerOptions</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">isCustomElement</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> tag<span class="token punctuation">.</span><span class="token method function property-access">includes</span><span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span></code></pre></section><section id="example-vite-config"class="level4"><h4>Example Vite Config</h4><pre class="language-js"><code class="language-js"><span class="token comment">// vite.config.js</span>
<span class="token keyword module">import</span> <span class="token imports">vue</span> <span class="token keyword module">from</span> <span class="token string">'@vitejs/plugin-vue'</span>

<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token function">vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">compilerOptions</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token comment">// treat all tags with a dash as custom elements</span>
          <span class="token function-variable function">isCustomElement</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">tag</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> tag<span class="token punctuation">.</span><span class="token method function property-access">includes</span><span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre></section><section id="example-vue-cli-config"class="level4"><h4>Example Vue CLI Config</h4><pre class="language-js"><code class="language-js"><span class="token comment">// vue.config.js</span>
module<span class="token punctuation">.</span><span class="token property-access">exports</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">chainWebpack</span><span class="token operator">:</span> <span class="token parameter">config</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    config<span class="token punctuation">.</span><span class="token property-access">module</span>
      <span class="token punctuation">.</span><span class="token method function property-access">rule</span><span class="token punctuation">(</span><span class="token string">'vue'</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token method function property-access">use</span><span class="token punctuation">(</span><span class="token string">'vue-loader'</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token method function property-access">tap</span><span class="token punctuation">(</span><span class="token parameter">options</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token spread operator">...</span>options<span class="token punctuation">,</span>
        <span class="token literal-property property">compilerOptions</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token comment">// treat any tag that starts with ion- as custom elements</span>
          <span class="token function-variable function">isCustomElement</span><span class="token operator">:</span> <span class="token parameter">tag</span> <span class="token arrow operator">=></span> tag<span class="token punctuation">.</span><span class="token method function property-access">startsWith</span><span class="token punctuation">(</span><span class="token string">'ion-'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></section></section><section id="passing-dom-properties"class="level3"><h3>Passing DOM Properties</h3><p>Since DOM attributes can only be strings, we need to pass complex data to custom elements as DOM properties. When setting props on a custom element, Vue 3 automatically checks DOM-property presence using the <code>in</code> operator and will prefer setting the value as a DOM property if the key is present. This means that, in most cases, you won't need to think about this if the custom element follows the <a href="https://web.dev/custom-elements-best-practices/">recommended best practices</a>.<p>However, there could be rare cases where the data must be passed as a DOM property, but the custom element does not properly define/reflect the property (causing the <code>in</code> check to fail). In this case, you can force a <code>v-bind</code> binding to be set as a DOM property using the <code>.prop</code> modifier:<pre class="language-vue-html"><code class="language-vue-html">&#x3C;my-element :user.prop="{ name: 'jack' }">&#x3C;/my-element>

&#x3C;!-- shorthand equivalent -->
&#x3C;my-element .user="{ name: 'jack' }">&#x3C;/my-element></code></pre></section></section><section id="building-custom-elements-with-vue"class="level2"><h2>Building Custom Elements with Vue</h2><p>The primary benefit of custom elements is that they can be used with any framework, or even without a framework. This makes them ideal for distributing components where the end consumer may not be using the same frontend stack, or when you want to insulate the end application from the implementation details of the components it uses.<section id="definecustomelement"class="level3"><h3>defineCustomElement</h3><p>Vue supports creating custom elements using exactly the same Vue component APIs via the <a href="/api/general.html#definecustomelement"><code>defineCustomElement</code></a> method. The method accepts the same argument as <a href="/api/general.html#definecomponent"><code>defineComponent</code></a>, but instead returns a custom element constructor that extends <code>HTMLElement</code>:<pre class="language-vue-html"><code class="language-vue-html">&#x3C;my-vue-element>&#x3C;/my-vue-element></code></pre><pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineCustomElement <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> <span class="token maybe-class-name">MyVueElement</span> <span class="token operator">=</span> <span class="token function">defineCustomElement</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// normal Vue component options here</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">emits</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">...</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>

  <span class="token comment">// defineCustomElement only: CSS to be injected into shadow root</span>
  <span class="token literal-property property">styles</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/* inlined css */</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// Register the custom element.</span>
<span class="token comment">// After registration, all `&#x3C;my-vue-element>` tags</span>
<span class="token comment">// on the page will be upgraded.</span>
customElements<span class="token punctuation">.</span><span class="token method function property-access">define</span><span class="token punctuation">(</span><span class="token string">'my-vue-element'</span><span class="token punctuation">,</span> <span class="token maybe-class-name">MyVueElement</span><span class="token punctuation">)</span>

<span class="token comment">// You can also programmatically instantiate the element:</span>
<span class="token comment">// (can only be done after registration)</span>
<span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">body</span><span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span>
  <span class="token keyword">new</span> <span class="token class-name">MyVueElement</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token comment">// initial props (optional)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span></code></pre><section id="lifecycle"class="level4"><h4>Lifecycle</h4><ul><li><p>A Vue custom element will mount an internal Vue component instance inside its shadow root when the element's <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks"><code>connectedCallback</code></a> is called for the first time.<li><p>When the element's <code>disconnectedCallback</code> is invoked, Vue will check whether the element is detached from the document after a microtask tick.<ul><li><p>If the element is still in the document, it's a move and the component instance will be preserved;<li><p>If the element is detached from the document, it's a removal and the component instance will be unmounted.</ul></ul></section><section id="props"class="level4"><h4>Props</h4><ul><li><p>All props declared using the <code>props</code> option will be defined on the custom element as properties. Vue will automatically handle the reflection between attributes / properties where appropriate.<ul><li><p>Attributes are always reflected to corresponding properties.<li><p>Properties with primitive values (<code>string</code>, <code>boolean</code> or <code>number</code>) are reflected as attributes.</ul><li><p>Vue also automatically casts props declared with <code>Boolean</code> or <code>Number</code> types into the desired type when they are set as attributes (which are always strings). For example, given the following props declaration:<pre class="language-js"><code class="language-js"><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">selected</span><span class="token operator">:</span> <span class="token known-class-name class-name">Boolean</span><span class="token punctuation">,</span>
  <span class="token literal-property property">index</span><span class="token operator">:</span> <span class="token known-class-name class-name">Number</span>
<span class="token punctuation">}</span></code></pre><p>And the custom element usage:<pre class="language-vue-html"><code class="language-vue-html">&#x3C;my-element selected index="1">&#x3C;/my-element></code></pre><p>In the component, <code>selected</code> will be cast to <code>true</code> (boolean) and <code>index</code> will be cast to <code>1</code> (number).</ul></section><section id="events"class="level4"><h4>Events</h4><p>Events emitted via <code>this.$emit</code> or setup <code>emit</code> are dispatched as native <a href="https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events#adding_custom_data_%E2%80%93_customevent">CustomEvents</a> on the custom element. Additional event arguments (payload) will be exposed as an array on the CustomEvent object as its <code>detail</code> property.</section><section id="slots"class="level4"><h4>Slots</h4><p>Inside the component, slots can be rendered using the <code>&#x3C;slot/></code> element as usual. However, when consuming the resulting element, it only accepts <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots">native slots syntax</a>:<ul><li><p><a href="/guide/components/slots.html#scoped-slots">Scoped slots</a> are not supported.<li><p>When passing named slots, use the <code>slot</code> attribute instead of the <code>v-slot</code> directive:<pre class="language-vue-html"><code class="language-vue-html">&#x3C;my-element>
  &#x3C;div slot="named">hello&#x3C;/div>
&#x3C;/my-element></code></pre></ul></section><section id="provide-inject"class="level4"><h4>Provide / Inject</h4><p>The <a href="/guide/components/provide-inject.html#provide-inject">Provide / Inject API</a> and its <a href="/api/composition-api-dependency-injection.html#provide">Composition API equivalent</a> also work between Vue-defined custom elements. However, note that this works <strong>only between custom elements</strong>. i.e. a Vue-defined custom element won't be able to inject properties provided by a non-custom-element Vue component.</section></section><section id="sfc-as-custom-element"class="level3"><h3>SFC as Custom Element</h3><p><code>defineCustomElement</code> also works with Vue Single-File Components (SFCs). However, with the default tooling setup, the <code>&#x3C;style></code> inside the SFCs will still be extracted and merged into a single CSS file during production build. When using an SFC as a custom element, it is often desirable to inject the <code>&#x3C;style></code> tags into the custom element's shadow root instead.<p>The official SFC toolings support importing SFCs in "custom element mode" (requires <code>@vitejs/plugin-vue@^1.4.0</code> or <code>vue-loader@^16.5.0</code>). An SFC loaded in custom element mode inlines its <code>&#x3C;style></code> tags as strings of CSS and exposes them under the component's <code>styles</code> option. This will be picked up by <code>defineCustomElement</code> and injected into the element's shadow root when instantiated.<p>To opt-in to this mode, simply end your component file name with <code>.ce.vue</code>:<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineCustomElement <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vue'</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Example</span></span> <span class="token keyword module">from</span> <span class="token string">'./Example.ce.vue'</span>

<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token maybe-class-name">Example</span><span class="token punctuation">.</span><span class="token property-access">styles</span><span class="token punctuation">)</span> <span class="token comment">// ["/* inlined css */"]</span>

<span class="token comment">// convert into custom element constructor</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">ExampleElement</span> <span class="token operator">=</span> <span class="token function">defineCustomElement</span><span class="token punctuation">(</span><span class="token maybe-class-name">Example</span><span class="token punctuation">)</span>

<span class="token comment">// register</span>
customElements<span class="token punctuation">.</span><span class="token method function property-access">define</span><span class="token punctuation">(</span><span class="token string">'my-example'</span><span class="token punctuation">,</span> <span class="token maybe-class-name">ExampleElement</span><span class="token punctuation">)</span></code></pre><p>If you wish to customize what files should be imported in custom element mode (for example, treating <em>all</em> SFCs as custom elements), you can pass the <code>customElement</code> option to the respective build plugins:<ul><li><a href="https://github.com/vitejs/vite/tree/main/packages/plugin-vue#using-vue-sfcs-as-custom-elements">@vitejs/plugin-vue</a><li><a href="https://github.com/vuejs/vue-loader/tree/next#v16-only-options">vue-loader</a></ul></section><section id="tips-for-a-vue-custom-elements-library"class="level3"><h3>Tips for a Vue Custom Elements Library</h3><p>When building custom elements with Vue, the elements will rely on Vue's runtime. There is a ~16kb baseline size cost depending on how many features are being used. This means it is not ideal to use Vue if you are shipping a single custom element - you may want to use vanilla JavaScript, <a href="https://github.com/vuejs/petite-vue">petite-vue</a>, or frameworks that specialize in small runtime size. However, the base size is more than justifiable if you are shipping a collection of custom elements with complex logic, as Vue will allow each component to be authored with much less code. The more elements you are shipping together, the better the trade-off.<p>If the custom elements will be used in an application that is also using Vue, you can choose to externalize Vue from the built bundle so that the elements will be using the same copy of Vue from the host application.<p>It is recommended to export the individual element constructors to give your users the flexibility to import them on-demand and register them with desired tag names. You can also export a convenience function to automatically register all elements. Here's an example entry point of a Vue custom element library:<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> defineCustomElement <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'vue'</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Foo</span></span> <span class="token keyword module">from</span> <span class="token string">'./MyFoo.ce.vue'</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Bar</span></span> <span class="token keyword module">from</span> <span class="token string">'./MyBar.ce.vue'</span>

<span class="token keyword">const</span> <span class="token maybe-class-name">MyFoo</span> <span class="token operator">=</span> <span class="token function">defineCustomElement</span><span class="token punctuation">(</span><span class="token maybe-class-name">Foo</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token maybe-class-name">MyBar</span> <span class="token operator">=</span> <span class="token function">defineCustomElement</span><span class="token punctuation">(</span><span class="token maybe-class-name">Bar</span><span class="token punctuation">)</span>

<span class="token comment">// export individual elements</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span> <span class="token maybe-class-name">MyFoo</span><span class="token punctuation">,</span> <span class="token maybe-class-name">MyBar</span> <span class="token punctuation">}</span></span>

<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  customElements<span class="token punctuation">.</span><span class="token method function property-access">define</span><span class="token punctuation">(</span><span class="token string">'my-foo'</span><span class="token punctuation">,</span> <span class="token maybe-class-name">MyFoo</span><span class="token punctuation">)</span>
  customElements<span class="token punctuation">.</span><span class="token method function property-access">define</span><span class="token punctuation">(</span><span class="token string">'my-bar'</span><span class="token punctuation">,</span> <span class="token maybe-class-name">MyBar</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>If you have many components, you can also leverage build tool features such as Vite's <a href="https://vitejs.dev/guide/features.html#glob-import">glob import</a> or webpack's <a href="https://webpack.js.org/guides/dependency-management/#requirecontext"><code>require.context</code></a> to load all components from a directory.</section></section><section id="web-components-vs-vue-components"class="level2"><h2>Web Components vs. Vue Components</h2><p>Some developers believe that framework-proprietary component models should be avoided, and that exclusively using Custom Elements makes an application "future-proof". Here we will try to explain why we believe that this is an overly simplistic take on the problem.<p>There is indeed a certain level of feature overlap between Custom Elements and Vue Components: they both allow us to define reusable components with data passing, event emitting, and lifecycle management. However, Web Components APIs are relatively low-level and bare-bones. To build an actual application, we need quite a few additional capabilities which the platform does not cover:<ul><li><p>A declarative and efficient templating system;<li><p>A reactive state management system that facilitates cross-component logic extraction and reuse;<li><p>A performant way to render the components on the server and hydrate them on the client (SSR), which is important for SEO and <a href="https://web.dev/vitals/">Web Vitals metrics such as LCP</a>. Native custom elements SSR typically involves simulating the DOM in Node.js and then serializing the mutated DOM, while Vue SSR compiles into string concatenation whenever possible, which is much more efficient.</ul><p>Vue's component model is designed with these needs in mind as a coherent system.<p>With a competent engineering team, you could probably build the equivalent on top of native Custom Elements - but this also means you are taking on the long-term maintenance burden of an in-house framework, while losing out on the ecosystem and community benefits of a mature framework like Vue.<p>There are also frameworks built using Custom Elements as the basis of their component model, but they all inevitably have to introduce their proprietary solutions to the problems listed above. Using these frameworks entails buying into their technical decisions on how to solve these problems - which, despite what may be advertised, doesn't automatically insulate you from potential future churns.<p>There are also some areas where we find custom elements to be limiting:<ul><li><p>Eager slot evaluation hinders component composition. Vue's <a href="/guide/components/slots.html#scoped-slots">scoped slots</a> are a powerful mechanism for component composition, which can't be supported by custom elements due to native slots' eager nature. Eager slots also mean the receiving component cannot control when or whether to render a piece of slot content.<li><p>Shipping custom elements with shadow DOM scoped CSS today requires embedding the CSS inside JavaScript so that they can be injected into shadow roots at runtime. They also result in duplicated styles in markup in SSR scenarios. There are <a href="https://github.com/whatwg/html/pull/4898/">platform features</a> being worked on in this area - but as of now they are not yet universally supported, and there are still production performance / SSR concerns to be addressed. In the meanwhile, Vue SFCs provide <a href="/api/sfc-css-features.html">CSS scoping mechanisms</a> that support extracting the styles into plain CSS files.</ul><p>Vue will always stay up to date with the latest standards in the web platform, and we will happily leverage whatever the platform provides if it makes our job easier. However, our goal is to provide solutions that work well and work today. That means we have to incorporate new platform features with a critical mindset - and that involves filling the gaps where the standards fall short while that is still the case. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>