<!doctypehtml><html lang="en"><meta charset="utf-8"><title>Rendering Mechanism</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="outline"content="deep"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="rendering-mechanism"class="level1"><h1>Rendering Mechanism</h1><p>How does Vue take a template and turn it into actual DOM nodes? How does Vue update those DOM nodes efficiently? We will attempt to shed some light on these questions here by diving into Vue's internal rendering mechanism.<section id="virtual-dom"class="level2"><h2>Virtual DOM</h2><p>You have probably heard about the term "virtual DOM", which Vue's rendering system is based upon.<p>The virtual DOM (VDOM) is a programming concept where an ideal, or “virtual”, representation of a UI is kept in memory and synced with the “real” DOM. The concept was pioneered by <a href="https://reactjs.org/">React</a>, and has been adapted in many other frameworks with different implementations, including Vue.<p>Virtual DOM is more of a pattern than a specific technology, so there is no one canonical implementation. We can illustrate the idea using a simple example:<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'hello'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token comment">/* more vnodes */</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre><p>Here, <code>vnode</code> is a plain JavaScript object (a "virtual node") representing a <code>&#x3C;div></code> element. It contains all the information that we need to create the actual element. It also contains more children vnodes, which makes it the root of a virtual DOM tree.<p>A runtime renderer can walk a virtual DOM tree and construct a real DOM tree from it. This process is called <strong>mount</strong>.<p>If we have two copies of virtual DOM trees, the renderer can also walk and compare the two trees, figuring out the differences, and apply those changes to the actual DOM. This process is called <strong>patch</strong>, also known as "diffing" or "reconciliation".<p>The main benefit of virtual DOM is that it gives the developer the ability to programmatically create, inspect and compose desired UI structures in a declarative way, while leaving the direct DOM manipulation to the renderer.</section><section id="render-pipeline"class="level2"><h2>Render Pipeline</h2><p>At the high level, this is what happens when a Vue component is mounted:<ol><li><p><strong>Compile</strong>: Vue templates are compiled into <strong>render functions</strong>: functions that return virtual DOM trees. This step can be done either ahead-of-time via a build step, or on-the-fly by using the runtime compiler.<li><p><strong>Mount</strong>: The runtime renderer invokes the render functions, walks the returned virtual DOM tree, and creates actual DOM nodes based on it. This step is performed as a <a href="./reactivity-in-depth">reactive effect</a>, so it keeps track of all reactive dependencies that were used.<li><p><strong>Patch</strong>: When a dependency used during mount changes, the effect re-runs. This time, a new, updated Virtual DOM tree is created. The runtime renderer walks the new tree, compares it with the old one, and applies necessary updates to the actual DOM.</ol><figure><img src="./images/render-pipeline.png"alt="render pipeline"><figcaption aria-hidden="true">render pipeline</figcaption></figure></section><section id="templates-vs-render-functions"class="level2"><h2>Templates vs. Render Functions</h2><p>Vue templates are compiled into virtual DOM render functions. Vue also provides APIs that allow us to skip the template compilation step and directly author render functions. Render functions are more flexible than templates when dealing with highly dynamic logic, because you can work with vnodes using the full power of JavaScript.<p>So why does Vue recommend templates by default? There are a number of reasons:<ol><li><p>Templates are closer to actual HTML. This makes it easier to reuse existing HTML snippets, apply accessibility best practices, style with CSS, and for designers to understand and modify.<li><p>Templates are easier to statically analyze due to their more deterministic syntax. This allows Vue's template compiler to apply many compile-time optimizations to improve the performance of the virtual DOM (which we will discuss below).</ol><p>In practice, templates are sufficient for most use cases in applications. Render functions are typically only used in reusable components that need to deal with highly dynamic rendering logic. Render function usage is discussed in more detail in <a href="./render-function">Render Functions &#x26; JSX</a>.</section><section id="compiler-informed-virtual-dom"class="level2"><h2>Compiler-Informed Virtual DOM</h2><p>The virtual DOM implementation in React and most other virtual-DOM implementations are purely runtime: the reconciliation algorithm cannot make any assumptions about the incoming virtual DOM tree, so it has to fully traverse the tree and diff the props of every vnode in order to ensure correctness. In addition, even if a part of the tree never changes, new vnodes are always created for them on each re-render, resulting in unnecessary memory pressure. This is one of the most criticized aspect of virtual DOM: the somewhat brute-force reconciliation process sacrifices efficiency in return for declarativeness and correctness.<p>But it doesn't have to be that way. In Vue, the framework controls both the compiler and the runtime. This allows us to implement many compile-time optimizations that only a tightly-coupled renderer can take advantage of. The compiler can statically analyze the template and leave hints in the generated code so that the runtime can take shortcuts whenever possible. At the same time, we still preserve the capability for the user to drop down to the render function layer for more direct control in edge cases. We call this hybrid approach <strong>Compiler-Informed Virtual DOM</strong>.<p>Below, we will discuss a few major optimizations done by the Vue template compiler to improve the virtual DOM's runtime performance.<section id="static-hoisting"class="level3"><h3>Static Hoisting</h3><p>Quite often there will be parts in a template that do not contain any dynamic bindings:<pre class="language-vue-html{2-3}"><code class="language-vue-html{2-3}">&#x3C;div>
  &#x3C;div>foo&#x3C;/div> &#x3C;!-- hoisted -->
  &#x3C;div>bar&#x3C;/div> &#x3C;!-- hoisted -->
  &#x3C;div>{{ dynamic }}&#x3C;/div>
&#x3C;/div></code></pre><p><a href="https://vue-next-template-explorer.netlify.app/#eyJzcmMiOiI8ZGl2PlxuICA8ZGl2PmZvbzwvZGl2PlxuICA8ZGl2PmJhcjwvZGl2PlxuICA8ZGl2Pnt7IGR5bmFtaWMgfX08L2Rpdj5cbjwvZGl2PiIsInNzciI6ZmFsc2UsIm9wdGlvbnMiOnsiaG9pc3RTdGF0aWMiOnRydWV9fQ==">Inspect in Template Explorer</a><p>The <code>foo</code> and <code>bar</code> divs are static - re-creating vnodes and diffing them on each re-render is unnecessary. The Vue compiler automatically hoists their vnode creation calls out of the render function, and reuses the same vnodes on every render. The renderer is also able to completely skip diffing them when it notices the old vnode and the new vnode are the same one.<p>In addition, when there are enough consecutive static elements, they will be condensed into a single "static vnode" that contains the plain HTML string for all these nodes (<a href="https://vue-next-template-explorer.netlify.app/#eyJzcmMiOiI8ZGl2PlxuICA8ZGl2IGNsYXNzPVwiZm9vXCI+Zm9vPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJmb29cIj5mb288L2Rpdj5cbiAgPGRpdiBjbGFzcz1cImZvb1wiPmZvbzwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiZm9vXCI+Zm9vPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJmb29cIj5mb288L2Rpdj5cbiAgPGRpdj57eyBkeW5hbWljIH19PC9kaXY+XG48L2Rpdj4iLCJzc3IiOmZhbHNlLCJvcHRpb25zIjp7ImhvaXN0U3RhdGljIjp0cnVlfX0=">Example</a>). These static vnodes are mounted by directly setting <code>innerHTML</code>. They also cache their corresponding DOM nodes on initial mount - if the same piece of content is reused elsewhere in the app, new DOM nodes are created using native <code>cloneNode()</code>, which is extremely efficient.</section><section id="patch-flags"class="level3"><h3>Patch Flags</h3><p>For a single element with dynamic bindings, we can also infer a lot of information from it at compile time:<pre class="language-vue-html"><code class="language-vue-html">&#x3C;!-- class binding only -->
&#x3C;div :class="{ active }">&#x3C;/div>

&#x3C;!-- id and value bindings only -->
&#x3C;input :id="id" :value="value">

&#x3C;!-- text children only -->
&#x3C;div>{{ dynamic }}&#x3C;/div></code></pre><p><a href="https://template-explorer.vuejs.org/#eyJzcmMiOiI8ZGl2IDpjbGFzcz1cInsgYWN0aXZlIH1cIj48L2Rpdj5cblxuPGlucHV0IDppZD1cImlkXCIgOnZhbHVlPVwidmFsdWVcIj5cblxuPGRpdj57eyBkeW5hbWljIH19PC9kaXY+Iiwib3B0aW9ucyI6e319">Inspect in Template Explorer</a><p>When generating the render function code for these elements, Vue encodes the type of update each of them needs directly in the vnode creation call:<pre class="language-js{3}"><code class="language-js{3}">createElementVNode("div", {
  class: _normalizeClass({ active: _ctx.active })
}, null, 2 /* CLASS */)</code></pre><p>The last argument, <code>2</code>, is a <a href="https://github.com/vuejs/core/blob/main/packages/shared/src/patchFlags.ts">patch flag</a>. An element can have multiple patch flags, which will be merged into a single number. The runtime renderer can then check against the flags using <a href="https://en.wikipedia.org/wiki/Bitwise_operation">bitwise operations</a> to determine whether it needs to do certain work:<pre class="language-js"><code class="language-js"><span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span><span class="token property-access">patchFlag</span> <span class="token operator">&#x26;</span> <span class="token maybe-class-name">PatchFlags</span><span class="token punctuation">.</span><span class="token constant">CLASS</span> <span class="token comment">/* 2 */</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// update the element's class</span>
<span class="token punctuation">}</span></code></pre><p>Bitwise checks are extremely fast. With the patch flags, Vue is able to do the least amount of work necessary when updating elements with dynamic bindings.<p>Vue also encodes the type of children a vnode has. For example, a template that has multiple root nodes is represented as a fragment. In most cases, we know for sure that the order of these root nodes will never change, so this information can also be provided to the runtime as a patch flag:<pre class="language-js{4}"><code class="language-js{4}">export function render() {
  return (_openBlock(), _createElementBlock(_Fragment, null, [
    /* children */
  ], 64 /* STABLE_FRAGMENT */))
}</code></pre><p>The runtime can thus completely skip child-order reconciliation for the root fragment.</section><section id="tree-flattening"class="level3"><h3>Tree Flattening</h3><p>Taking another look at the generated code from the previous example, you'll notice the root of the returned virtual DOM tree is created using a special <code>createElementBlock()</code> call:<pre class="language-js{2}"><code class="language-js{2}">export function render() {
  return (_openBlock(), _createElementBlock(_Fragment, null, [
    /* children */
  ], 64 /* STABLE_FRAGMENT */))
}</code></pre><p>Conceptually, a "block" is a part of the template that has stable inner structure. In this case, the entire template has a single block because it does not contain any structural directives like <code>v-if</code> and <code>v-for</code>.<p>Each block tracks any descendant nodes (not just direct children) that have patch flags. For example:<pre class="language-vue-html{3,5}"><code class="language-vue-html{3,5}">&#x3C;div> &#x3C;!-- root block -->
  &#x3C;div>...&#x3C;/div>         &#x3C;!-- not tracked -->
  &#x3C;div :id="id">&#x3C;/div>   &#x3C;!-- tracked -->
  &#x3C;div>                  &#x3C;!-- not tracked -->
    &#x3C;div>{{ bar }}&#x3C;/div> &#x3C;!-- tracked -->
  &#x3C;/div>
&#x3C;/div></code></pre><p>The result is a flattened array that contains only the dynamic descendant nodes:<pre class="language-text"><code class="language-text">div (block root)
- div with :id binding
- div with {{ bar }} binding</code></pre><p>When this component needs to re-render, it only needs to traverse the flattened tree instead of the full tree. This is called <strong>Tree Flattening</strong>, and it greatly reduces the number of nodes that need to be traversed during virtual DOM reconciliation. Any static parts of the template are effectively skipped.<p><code>v-if</code> and <code>v-for</code> directives will create new block nodes:<pre class="language-vue-html"><code class="language-vue-html">&#x3C;div> &#x3C;!-- root block -->
  &#x3C;div>
    &#x3C;div v-if> &#x3C;!-- if block -->
      ...
    &#x3C;div>
  &#x3C;/div>
&#x3C;/div></code></pre><p>A child block is tracked inside the parent block's array of dynamic descendants. This retains a stable structure for the parent block.</section><section id="impact-on-ssr-hydration"class="level3"><h3>Impact on SSR Hydration</h3><p>Both patch flags and tree flattening also greatly improve Vue's <a href="/guide/scaling-up/ssr.html#client-hydration">SSR Hydration</a> performance:<ul><li><p>Single element hydration can take fast paths based on the corresponding vnode's patch flag.<li><p>Only block nodes and their dynamic descendants need to be traversed during hydration, effectively achieving partial hydration at the template level. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></ul></section></section></section>