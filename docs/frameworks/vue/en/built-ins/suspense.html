<!doctypehtml><html lang="en"><meta charset="utf-8"><title>Suspense</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta name="outline"content="deep"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="suspense"class="level1"><h1>Suspense</h1><p>:::warning Experimental Feature <code>&#x3C;Suspense></code> is an experimental feature. It is not guaranteed to reach stable status and the API may change before it does. :::<p><code>&#x3C;Suspense></code> is a built-in component for orchestrating async dependencies in a component tree. It can render a loading state while waiting for multiple nested async dependencies down the component tree to be resolved.<section id="async-dependencies"class="level2"><h2>Async Dependencies</h2><p>To explain the problem <code>&#x3C;Suspense></code> is trying to solve and how it interacts with these async dependencies, let's imagine a component hierarchy like the following:<pre class="language-text"><code class="language-text">&#x3C;Suspense>
└─ &#x3C;Dashboard>
   ├─ &#x3C;Profile>
   │  └─ &#x3C;FriendStatus> (component with async setup())
   └─ &#x3C;Content>
      ├─ &#x3C;ActivityFeed> (async component)
      └─ &#x3C;Stats> (async component)</code></pre><p>In the component tree there are multiple nested components whose rendering depends on some async resource to be resolved first. Without <code>&#x3C;Suspense></code>, each of them will need to handle its own loading / error and loaded states. In the worst case scenario, we may see three loading spinners on the page, with content displayed at different times.<p>The <code>&#x3C;Suspense></code> component gives us the ability to display top-level loading / error states while we wait on these nested async dependencies to be resolved.<p>There are two types of async dependencies that <code>&#x3C;Suspense></code> can wait on:<ol><li><p>Components with an async <code>setup()</code> hook. This includes components using <code>&#x3C;script setup></code> with top-level <code>await</code> expressions.<li><p><a href="/guide/components/async.html">Async Components</a>.</ol><section id="async-setup-async-setup"class="level3"><h3><code>async setup()</code> {#async-setup}</h3><p>A Composition API component's <code>setup()</code> hook can be async:<pre class="language-js"><code class="language-js"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>
  <span class="token keyword">async</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token spread operator">...</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> posts <span class="token operator">=</span> <span class="token keyword control-flow">await</span> res<span class="token punctuation">.</span><span class="token method function property-access">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
      posts
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>If using <code>&#x3C;script setup></code>, the presence of top-level <code>await</code> expressions automatically makes the component an async dependency:<pre class="language-vue"><code class="language-vue">&#x3C;script setup>
const res = await fetch(...)
const posts = await res.json()
&#x3C;/script>

&#x3C;template>
  {{ posts }}
&#x3C;/template></code></pre></section><section id="async-components"class="level3"><h3>Async Components</h3><p>Async components are <strong>"suspensible"</strong> by default. This means that if it has a <code>&#x3C;Suspense></code> in the parent chain, it will be treated as an async dependency of that <code>&#x3C;Suspense></code>. In this case, the loading state will be controlled by the <code>&#x3C;Suspense></code>, and the component's own loading, error, delay and timeout options will be ignored.<p>The async component can opt-out of <code>Suspense</code> control and let the component always control its own loading state by specifying <code>suspensible: false</code> in its options.</section></section><section id="loading-state"class="level2"><h2>Loading State</h2><p>The <code>&#x3C;Suspense></code> component has two slots: <code>#default</code> and <code>#fallback</code>. Both slots only allow for <strong>one</strong> immediate child node. The node in the default slot is shown if possible. If not, the node in the fallback slot will be shown instead.<pre class="language-vue-html"><code class="language-vue-html">&#x3C;Suspense>
  &#x3C;!-- component with nested async dependencies -->
  &#x3C;Dashboard />

  &#x3C;!-- loading state via #fallback slot -->
  &#x3C;template #fallback>
    Loading...
  &#x3C;/template>
&#x3C;/Suspense></code></pre><p>On initial render, <code>&#x3C;Suspense></code> will render its default slot content in memory. If any async dependencies are encountered during the process, it will enter a <strong>pending</strong> state. During the pending state, the fallback content will be displayed. When all encountered async dependencies have been resolved, <code>&#x3C;Suspense></code> enters a <strong>resolved</strong> state and the resolved default slot content is displayed.<p>If no async dependencies were encountered during the initial render, <code>&#x3C;Suspense></code> will directly go into a resolved state.<p>Once in a resolved state, <code>&#x3C;Suspense></code> will only revert to a pending state if the root node of the <code>#default</code> slot is replaced. New async dependencies nested deeper in the tree will <strong>not</strong> cause the <code>&#x3C;Suspense></code> to revert to a pending state.<p>When a revert happens, fallback content will not be immediately displayed. Instead, <code>&#x3C;Suspense></code> will display the previous <code>#default</code> content while waiting for the new content and its async dependencies to be resolved. This behavior can be configured with the <code>timeout</code> prop: <code>&#x3C;Suspense></code> will switch to fallback content if it takes longer than <code>timeout</code> to render the new default content. A <code>timeout</code> value of <code>0</code> will cause the fallback content to be displayed immediately when default content is replaced.</section><section id="events"class="level2"><h2>Events</h2><p>The <code>&#x3C;Suspense></code> component emits 3 events: <code>pending</code>, <code>resolve</code> and <code>fallback</code>. The <code>pending</code> event occurs when entering a pending state. The <code>resolve</code> event is emitted when new content has finished resolving in the <code>default</code> slot. The <code>fallback</code> event is fired when the contents of the <code>fallback</code> slot are shown.<p>The events could be used, for example, to show a loading indicator in front of the old DOM while new components are loading.</section><section id="error-handling"class="level2"><h2>Error Handling</h2><p><code>&#x3C;Suspense></code> currently does not provide error handling via the component itself - however, you can use the <a href="/api/options-lifecycle.html#errorcaptured"><code>errorCaptured</code></a> option or the <a href="/api/composition-api-lifecycle.html#onerrorcaptured"><code>onErrorCaptured()</code></a> hook to capture and handle async errors in the parent component of <code>&#x3C;Suspense></code>.</section><section id="combining-with-other-components"class="level2"><h2>Combining with Other Components</h2><p>It is common to want to use <code>&#x3C;Suspense></code> in combination with the <a href="./transition"><code>&#x3C;Transition></code></a> and <a href="./keep-alive"><code>&#x3C;KeepAlive></code></a> components. The nesting order of these components is important to get them all working correctly.<p>In addition, these components are often used in conjunction with the <code>&#x3C;RouterView></code> component from <a href="https://router.vuejs.org/">Vue Router</a>.<p>The following example shows how to nest these components so that they all behave as expected. For simpler combinations you can remove the components that you don't need:<pre class="language-vue-html"><code class="language-vue-html">&#x3C;RouterView v-slot="{ Component }">
  &#x3C;template v-if="Component">
    &#x3C;Transition mode="out-in">
      &#x3C;KeepAlive>
        &#x3C;Suspense>
          &#x3C;!-- main content -->
          &#x3C;component :is="Component">&#x3C;/component>

          &#x3C;!-- loading state -->
          &#x3C;template #fallback>
            Loading...
          &#x3C;/template>
        &#x3C;/Suspense>
      &#x3C;/KeepAlive>
    &#x3C;/Transition>
  &#x3C;/template>
&#x3C;/RouterView></code></pre><p>Vue Router has built-in support for <a href="https://router.vuejs.org/guide/advanced/lazy-loading.html">lazily loading components</a> using dynamic imports. These are distinct from async components and currently they will not trigger <code>&#x3C;Suspense></code>. However, they can still have async components as descendants and those can trigger <code>&#x3C;Suspense></code> in the usual way. <span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>